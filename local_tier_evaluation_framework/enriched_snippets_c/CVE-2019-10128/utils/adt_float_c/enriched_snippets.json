[
  {
    "function_name": "cbrt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3799-3816",
    "snippet": "static double\ncbrt(double x)\n{\n\tint\t\t\tisneg = (x < 0.0);\n\tdouble\t\tabsx = fabs(x);\n\tdouble\t\ttmpres = pow(absx, (double) 1.0 / (double) 3.0);\n\n\t/*\n\t * The result is somewhat inaccurate --- not really pow()'s fault, as the\n\t * exponent it's handed contains roundoff error.  We can improve the\n\t * accuracy by doing one iteration of Newton's formula.  Beware of zero\n\t * input however.\n\t */\n\tif (tmpres > 0.0)\n\t\ttmpres -= (tmpres - absx / (tmpres * tmpres)) / (double) 3.0;\n\n\treturn isneg ? -tmpres : tmpres;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define cbrt my_cbrt"
    ],
    "globals_used": [
      "static double sind_q1(double x);",
      "static double cosd_q1(double x);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "absx",
            "(double) 1.0 / (double) 3.0"
          ],
          "line": 3804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fabs",
          "args": [
            "x"
          ],
          "line": 3803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define cbrt my_cbrt\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\ncbrt(double x)\n{\n\tint\t\t\tisneg = (x < 0.0);\n\tdouble\t\tabsx = fabs(x);\n\tdouble\t\ttmpres = pow(absx, (double) 1.0 / (double) 3.0);\n\n\t/*\n\t * The result is somewhat inaccurate --- not really pow()'s fault, as the\n\t * exponent it's handed contains roundoff error.  We can improve the\n\t * accuracy by doing one iteration of Newton's formula.  Beware of zero\n\t * input however.\n\t */\n\tif (tmpres > 0.0)\n\t\ttmpres -= (tmpres - absx / (tmpres * tmpres)) / (double) 3.0;\n\n\treturn isneg ? -tmpres : tmpres;\n}"
  },
  {
    "function_name": "width_bucket_float8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3731-3793",
    "snippet": "Datum\nwidth_bucket_float8(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\toperand = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tbound1 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tbound2 = PG_GETARG_FLOAT8(2);\n\tint32\t\tcount = PG_GETARG_INT32(3);\n\tint32\t\tresult;\n\n\tif (count <= 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),\n\t\t\t\t errmsg(\"count must be greater than zero\")));\n\n\tif (isnan(operand) || isnan(bound1) || isnan(bound2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),\n\t\t\t\t errmsg(\"operand, lower bound, and upper bound cannot be NaN\")));\n\n\t/* Note that we allow \"operand\" to be infinite */\n\tif (isinf(bound1) || isinf(bound2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),\n\t\t\t\t errmsg(\"lower and upper bounds must be finite\")));\n\n\tif (bound1 < bound2)\n\t{\n\t\tif (operand < bound1)\n\t\t\tresult = 0;\n\t\telse if (operand >= bound2)\n\t\t{\n\t\t\tif (pg_add_s32_overflow(count, 1, &result))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"integer out of range\")));\n\t\t}\n\t\telse\n\t\t\tresult = ((float8) count * (operand - bound1) / (bound2 - bound1)) + 1;\n\t}\n\telse if (bound1 > bound2)\n\t{\n\t\tif (operand > bound1)\n\t\t\tresult = 0;\n\t\telse if (operand <= bound2)\n\t\t{\n\t\t\tif (pg_add_s32_overflow(count, 1, &result))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"integer out of range\")));\n\t\t}\n\t\telse\n\t\t\tresult = ((float8) count * (bound1 - operand) / (bound1 - bound2)) + 1;\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),\n\t\t\t\t errmsg(\"lower bound cannot equal upper bound\")));\n\t\tresult = 0;\t\t\t\t/* keep the compiler quiet */\n\t}\n\n\tPG_RETURN_INT32(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "result"
          ],
          "line": 3792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),\n\t\t\t\t errmsg(\"lower bound cannot equal upper bound\"))"
          ],
          "line": 3786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"lower bound cannot equal upper bound\""
          ],
          "line": 3788
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION"
          ],
          "line": 3787
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"integer out of range\"))"
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_add_s32_overflow",
          "args": [
            "count",
            "1",
            "&result"
          ],
          "line": 3776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"integer out of range\"))"
          ],
          "line": 3763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_add_s32_overflow",
          "args": [
            "count",
            "1",
            "&result"
          ],
          "line": 3762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),\n\t\t\t\t errmsg(\"lower and upper bounds must be finite\"))"
          ],
          "line": 3752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "bound2"
          ],
          "line": 3751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "bound1"
          ],
          "line": 3751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),\n\t\t\t\t errmsg(\"operand, lower bound, and upper bound cannot be NaN\"))"
          ],
          "line": 3746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "bound2"
          ],
          "line": 3745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "bound1"
          ],
          "line": 3745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "operand"
          ],
          "line": 3745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),\n\t\t\t\t errmsg(\"count must be greater than zero\"))"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 3737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "2"
          ],
          "line": 3736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 3735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nwidth_bucket_float8(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\toperand = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tbound1 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tbound2 = PG_GETARG_FLOAT8(2);\n\tint32\t\tcount = PG_GETARG_INT32(3);\n\tint32\t\tresult;\n\n\tif (count <= 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),\n\t\t\t\t errmsg(\"count must be greater than zero\")));\n\n\tif (isnan(operand) || isnan(bound1) || isnan(bound2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),\n\t\t\t\t errmsg(\"operand, lower bound, and upper bound cannot be NaN\")));\n\n\t/* Note that we allow \"operand\" to be infinite */\n\tif (isinf(bound1) || isinf(bound2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),\n\t\t\t\t errmsg(\"lower and upper bounds must be finite\")));\n\n\tif (bound1 < bound2)\n\t{\n\t\tif (operand < bound1)\n\t\t\tresult = 0;\n\t\telse if (operand >= bound2)\n\t\t{\n\t\t\tif (pg_add_s32_overflow(count, 1, &result))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"integer out of range\")));\n\t\t}\n\t\telse\n\t\t\tresult = ((float8) count * (operand - bound1) / (bound2 - bound1)) + 1;\n\t}\n\telse if (bound1 > bound2)\n\t{\n\t\tif (operand > bound1)\n\t\t\tresult = 0;\n\t\telse if (operand <= bound2)\n\t\t{\n\t\t\tif (pg_add_s32_overflow(count, 1, &result))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"integer out of range\")));\n\t\t}\n\t\telse\n\t\t\tresult = ((float8) count * (bound1 - operand) / (bound1 - bound2)) + 1;\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION),\n\t\t\t\t errmsg(\"lower bound cannot equal upper bound\")));\n\t\tresult = 0;\t\t\t\t/* keep the compiler quiet */\n\t}\n\n\tPG_RETURN_INT32(result);\n}"
  },
  {
    "function_name": "float84ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3708-3715",
    "snippet": "Datum\nfloat84ge(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) >= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) >= 0"
          ],
          "line": 3714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 3714
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 3712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 3711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat84ge(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) >= 0);\n}"
  },
  {
    "function_name": "float84gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3699-3706",
    "snippet": "Datum\nfloat84gt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) > 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) > 0"
          ],
          "line": 3705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 3705
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 3703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat84gt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) > 0);\n}"
  },
  {
    "function_name": "float84le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3690-3697",
    "snippet": "Datum\nfloat84le(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) <= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) <= 0"
          ],
          "line": 3696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 3696
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 3694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 3693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat84le(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) <= 0);\n}"
  },
  {
    "function_name": "float84lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3681-3688",
    "snippet": "Datum\nfloat84lt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) < 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) < 0"
          ],
          "line": 3687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 3687
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 3684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat84lt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) < 0);\n}"
  },
  {
    "function_name": "float84ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3672-3679",
    "snippet": "Datum\nfloat84ne(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) != 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) != 0"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 3678
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 3676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 3675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat84ne(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) != 0);\n}"
  },
  {
    "function_name": "float84eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3663-3670",
    "snippet": "Datum\nfloat84eq(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) == 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) == 0"
          ],
          "line": 3669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 3669
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 3667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat84eq(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) == 0);\n}"
  },
  {
    "function_name": "float48ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3651-3658",
    "snippet": "Datum\nfloat48ge(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) >= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) >= 0"
          ],
          "line": 3657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 3657
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 3655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 3654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat48ge(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) >= 0);\n}"
  },
  {
    "function_name": "float48gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3642-3649",
    "snippet": "Datum\nfloat48gt(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) > 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) > 0"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 3648
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 3646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 3645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat48gt(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) > 0);\n}"
  },
  {
    "function_name": "float48le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3633-3640",
    "snippet": "Datum\nfloat48le(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) <= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) <= 0"
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 3639
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 3637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 3636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat48le(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) <= 0);\n}"
  },
  {
    "function_name": "float48lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3624-3631",
    "snippet": "Datum\nfloat48lt(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) < 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) < 0"
          ],
          "line": 3630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 3630
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 3628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat48lt(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) < 0);\n}"
  },
  {
    "function_name": "float48ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3615-3622",
    "snippet": "Datum\nfloat48ne(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) != 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) != 0"
          ],
          "line": 3621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 3621
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 3619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 3618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat48ne(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) != 0);\n}"
  },
  {
    "function_name": "float48eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3606-3613",
    "snippet": "Datum\nfloat48eq(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) == 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) == 0"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 3612
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 3610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 3609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat48eq(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) == 0);\n}"
  },
  {
    "function_name": "float84div",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3579-3595",
    "snippet": "Datum\nfloat84div(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat8\t\tresult;\n\n\tif (arg2 == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = arg1 / arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 3594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "arg1 == 0"
          ],
          "line": 3593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 3593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 3593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\"))"
          ],
          "line": 3587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"division by zero\""
          ],
          "line": 3589
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DIVISION_BY_ZERO"
          ],
          "line": 3588
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 3583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 3582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat84div(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat8\t\tresult;\n\n\tif (arg2 == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = arg1 / arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "float84mul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3565-3577",
    "snippet": "Datum\nfloat84mul(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 * arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2),\n\t\t\t\t  arg1 == 0 || arg2 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 3576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "arg1 == 0 || arg2 == 0"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 3569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 3568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat84mul(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 * arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2),\n\t\t\t\t  arg1 == 0 || arg2 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "float84mi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3552-3563",
    "snippet": "Datum\nfloat84mi(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 - arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "true"
          ],
          "line": 3561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 3561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 3561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 3556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat84mi(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 - arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "float84pl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3539-3550",
    "snippet": "Datum\nfloat84pl(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 + arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 3549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "true"
          ],
          "line": 3548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 3548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 3548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 3543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 3542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat84pl(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 + arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "float48div",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3516-3531",
    "snippet": "Datum\nfloat48div(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tif (arg2 == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = arg1 / arg2;\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 3530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "arg1 == 0"
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\"))"
          ],
          "line": 3524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"division by zero\""
          ],
          "line": 3526
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DIVISION_BY_ZERO"
          ],
          "line": 3525
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 3519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat48div(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tif (arg2 == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = arg1 / arg2;\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "float48mul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3503-3514",
    "snippet": "Datum\nfloat48mul(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 * arg2;\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2),\n\t\t\t\t  arg1 == 0 || arg2 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 3513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "arg1 == 0 || arg2 == 0"
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 3507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 3506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat48mul(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 * arg2;\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2),\n\t\t\t\t  arg1 == 0 || arg2 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "float48mi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3491-3501",
    "snippet": "Datum\nfloat48mi(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 - arg2;\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 3500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "true"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 3495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat48mi(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 - arg2;\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "float48pl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3479-3489",
    "snippet": "Datum\nfloat48pl(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 + arg2;\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "true"
          ],
          "line": 3487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 3487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 3487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 3483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat48pl(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 + arg2;\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "float8_regr_intercept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3431-3464",
    "snippet": "Datum\nfloat8_regr_intercept(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tsumY,\n\t\t\t\tsumXY,\n\t\t\t\tnumeratorX,\n\t\t\t\tnumeratorXXY;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_intercept\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\tsumY = transvalues[3];\n\tsumXY = transvalues[5];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumeratorX = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numeratorX, isinf(sumX2) || isinf(sumX), true);\n\tnumeratorXXY = sumY * sumX2 - sumX * sumXY;\n\tCHECKFLOATVAL(numeratorXXY, isinf(sumY) || isinf(sumX2) ||\n\t\t\t\t  isinf(sumX) || isinf(sumXY), true);\n\tif (numeratorX <= 0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_FLOAT8(numeratorXXY / numeratorX);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "numeratorXXY / numeratorX"
          ],
          "line": 3463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numeratorXXY",
            "isinf(sumY) || isinf(sumX2) ||\n\t\t\t\t  isinf(sumX) || isinf(sumXY)",
            "true"
          ],
          "line": 3458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumXY"
          ],
          "line": 3459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX"
          ],
          "line": 3459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX2"
          ],
          "line": 3458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumY"
          ],
          "line": 3458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numeratorX",
            "isinf(sumX2) || isinf(sumX)",
            "true"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX2"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_regr_intercept\"",
            "6"
          ],
          "line": 3444
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 3434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_regr_intercept(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tsumY,\n\t\t\t\tsumXY,\n\t\t\t\tnumeratorX,\n\t\t\t\tnumeratorXXY;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_intercept\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\tsumY = transvalues[3];\n\tsumXY = transvalues[5];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumeratorX = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numeratorX, isinf(sumX2) || isinf(sumX), true);\n\tnumeratorXXY = sumY * sumX2 - sumX * sumXY;\n\tCHECKFLOATVAL(numeratorXXY, isinf(sumY) || isinf(sumX2) ||\n\t\t\t\t  isinf(sumX) || isinf(sumXY), true);\n\tif (numeratorX <= 0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_FLOAT8(numeratorXXY / numeratorX);\n}"
  },
  {
    "function_name": "float8_regr_slope",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3396-3429",
    "snippet": "Datum\nfloat8_regr_slope(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tsumY,\n\t\t\t\tsumXY,\n\t\t\t\tnumeratorX,\n\t\t\t\tnumeratorXY;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_slope\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\tsumY = transvalues[3];\n\tsumXY = transvalues[5];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumeratorX = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numeratorX, isinf(sumX2) || isinf(sumX), true);\n\tnumeratorXY = N * sumXY - sumX * sumY;\n\tCHECKFLOATVAL(numeratorXY, isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY), true);\n\tif (numeratorX <= 0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_FLOAT8(numeratorXY / numeratorX);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "numeratorXY / numeratorX"
          ],
          "line": 3428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numeratorXY",
            "isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY)",
            "true"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumY"
          ],
          "line": 3424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumXY"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numeratorX",
            "isinf(sumX2) || isinf(sumX)",
            "true"
          ],
          "line": 3421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX"
          ],
          "line": 3421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX2"
          ],
          "line": 3421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_regr_slope\"",
            "6"
          ],
          "line": 3409
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 3399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_regr_slope(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tsumY,\n\t\t\t\tsumXY,\n\t\t\t\tnumeratorX,\n\t\t\t\tnumeratorXY;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_slope\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\tsumY = transvalues[3];\n\tsumXY = transvalues[5];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumeratorX = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numeratorX, isinf(sumX2) || isinf(sumX), true);\n\tnumeratorXY = N * sumXY - sumX * sumY;\n\tCHECKFLOATVAL(numeratorXY, isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY), true);\n\tif (numeratorX <= 0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_FLOAT8(numeratorXY / numeratorX);\n}"
  },
  {
    "function_name": "float8_regr_r2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3352-3394",
    "snippet": "Datum\nfloat8_regr_r2(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tsumY,\n\t\t\t\tsumY2,\n\t\t\t\tsumXY,\n\t\t\t\tnumeratorX,\n\t\t\t\tnumeratorY,\n\t\t\t\tnumeratorXY;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_r2\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\tsumY = transvalues[3];\n\tsumY2 = transvalues[4];\n\tsumXY = transvalues[5];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumeratorX = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numeratorX, isinf(sumX2) || isinf(sumX), true);\n\tnumeratorY = N * sumY2 - sumY * sumY;\n\tCHECKFLOATVAL(numeratorY, isinf(sumY2) || isinf(sumY), true);\n\tnumeratorXY = N * sumXY - sumX * sumY;\n\tCHECKFLOATVAL(numeratorXY, isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY), true);\n\tif (numeratorX <= 0)\n\t\tPG_RETURN_NULL();\n\t/* per spec, horizontal line produces 1.0 */\n\tif (numeratorY <= 0)\n\t\tPG_RETURN_FLOAT8(1.0);\n\n\tPG_RETURN_FLOAT8((numeratorXY * numeratorXY) /\n\t\t\t\t\t (numeratorX * numeratorY));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "(numeratorXY * numeratorXY) /\n\t\t\t\t\t (numeratorX * numeratorY)"
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "1.0"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numeratorXY",
            "isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY)",
            "true"
          ],
          "line": 3384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumY"
          ],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX"
          ],
          "line": 3384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumXY"
          ],
          "line": 3384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numeratorY",
            "isinf(sumY2) || isinf(sumY)",
            "true"
          ],
          "line": 3382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumY"
          ],
          "line": 3382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumY2"
          ],
          "line": 3382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numeratorX",
            "isinf(sumX2) || isinf(sumX)",
            "true"
          ],
          "line": 3380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX"
          ],
          "line": 3380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX2"
          ],
          "line": 3380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_regr_r2\"",
            "6"
          ],
          "line": 3367
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 3355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_regr_r2(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tsumY,\n\t\t\t\tsumY2,\n\t\t\t\tsumXY,\n\t\t\t\tnumeratorX,\n\t\t\t\tnumeratorY,\n\t\t\t\tnumeratorXY;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_r2\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\tsumY = transvalues[3];\n\tsumY2 = transvalues[4];\n\tsumXY = transvalues[5];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumeratorX = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numeratorX, isinf(sumX2) || isinf(sumX), true);\n\tnumeratorY = N * sumY2 - sumY * sumY;\n\tCHECKFLOATVAL(numeratorY, isinf(sumY2) || isinf(sumY), true);\n\tnumeratorXY = N * sumXY - sumX * sumY;\n\tCHECKFLOATVAL(numeratorXY, isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY), true);\n\tif (numeratorX <= 0)\n\t\tPG_RETURN_NULL();\n\t/* per spec, horizontal line produces 1.0 */\n\tif (numeratorY <= 0)\n\t\tPG_RETURN_FLOAT8(1.0);\n\n\tPG_RETURN_FLOAT8((numeratorXY * numeratorXY) /\n\t\t\t\t\t (numeratorX * numeratorY));\n}"
  },
  {
    "function_name": "float8_corr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3312-3350",
    "snippet": "Datum\nfloat8_corr(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tsumY,\n\t\t\t\tsumY2,\n\t\t\t\tsumXY,\n\t\t\t\tnumeratorX,\n\t\t\t\tnumeratorY,\n\t\t\t\tnumeratorXY;\n\n\ttransvalues = check_float8_array(transarray, \"float8_corr\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\tsumY = transvalues[3];\n\tsumY2 = transvalues[4];\n\tsumXY = transvalues[5];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumeratorX = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numeratorX, isinf(sumX2) || isinf(sumX), true);\n\tnumeratorY = N * sumY2 - sumY * sumY;\n\tCHECKFLOATVAL(numeratorY, isinf(sumY2) || isinf(sumY), true);\n\tnumeratorXY = N * sumXY - sumX * sumY;\n\tCHECKFLOATVAL(numeratorXY, isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY), true);\n\tif (numeratorX <= 0 || numeratorY <= 0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_FLOAT8(numeratorXY / sqrt(numeratorX * numeratorY));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "numeratorXY / sqrt(numeratorX * numeratorY)"
          ],
          "line": 3349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqrt",
          "args": [
            "numeratorX * numeratorY"
          ],
          "line": 3349
        },
        "resolved": true,
        "details": {
          "function_name": "dsqrt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1613-1628",
          "snippet": "Datum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numeratorXY",
            "isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY)",
            "true"
          ],
          "line": 3344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumY"
          ],
          "line": 3345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX"
          ],
          "line": 3344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumXY"
          ],
          "line": 3344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numeratorY",
            "isinf(sumY2) || isinf(sumY)",
            "true"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumY"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumY2"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numeratorX",
            "isinf(sumX2) || isinf(sumX)",
            "true"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX2"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_corr\"",
            "6"
          ],
          "line": 3327
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_corr(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tsumY,\n\t\t\t\tsumY2,\n\t\t\t\tsumXY,\n\t\t\t\tnumeratorX,\n\t\t\t\tnumeratorY,\n\t\t\t\tnumeratorXY;\n\n\ttransvalues = check_float8_array(transarray, \"float8_corr\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\tsumY = transvalues[3];\n\tsumY2 = transvalues[4];\n\tsumXY = transvalues[5];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumeratorX = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numeratorX, isinf(sumX2) || isinf(sumX), true);\n\tnumeratorY = N * sumY2 - sumY * sumY;\n\tCHECKFLOATVAL(numeratorY, isinf(sumY2) || isinf(sumY), true);\n\tnumeratorXY = N * sumXY - sumX * sumY;\n\tCHECKFLOATVAL(numeratorXY, isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY), true);\n\tif (numeratorX <= 0 || numeratorY <= 0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_FLOAT8(numeratorXY / sqrt(numeratorX * numeratorY));\n}"
  },
  {
    "function_name": "float8_covar_samp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3284-3310",
    "snippet": "Datum\nfloat8_covar_samp(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumY,\n\t\t\t\tsumXY,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_covar_samp\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumY = transvalues[3];\n\tsumXY = transvalues[5];\n\n\t/* if N is <= 1 we should return NULL */\n\tif (N < 2.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumXY - sumX * sumY;\n\tCHECKFLOATVAL(numerator, isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY), true);\n\n\tPG_RETURN_FLOAT8(numerator / (N * (N - 1.0)));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "numerator / (N * (N - 1.0))"
          ],
          "line": 3309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numerator",
            "isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY)",
            "true"
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumY"
          ],
          "line": 3307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX"
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumXY"
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_covar_samp\"",
            "6"
          ],
          "line": 3295
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 3287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_covar_samp(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumY,\n\t\t\t\tsumXY,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_covar_samp\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumY = transvalues[3];\n\tsumXY = transvalues[5];\n\n\t/* if N is <= 1 we should return NULL */\n\tif (N < 2.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumXY - sumX * sumY;\n\tCHECKFLOATVAL(numerator, isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY), true);\n\n\tPG_RETURN_FLOAT8(numerator / (N * (N - 1.0)));\n}"
  },
  {
    "function_name": "float8_covar_pop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3256-3282",
    "snippet": "Datum\nfloat8_covar_pop(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumY,\n\t\t\t\tsumXY,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_covar_pop\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumY = transvalues[3];\n\tsumXY = transvalues[5];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumXY - sumX * sumY;\n\tCHECKFLOATVAL(numerator, isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY), true);\n\n\tPG_RETURN_FLOAT8(numerator / (N * N));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "numerator / (N * N)"
          ],
          "line": 3281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numerator",
            "isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY)",
            "true"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumY"
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumXY"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_covar_pop\"",
            "6"
          ],
          "line": 3267
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_covar_pop(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumY,\n\t\t\t\tsumXY,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_covar_pop\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumY = transvalues[3];\n\tsumXY = transvalues[5];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumXY - sumX * sumY;\n\tCHECKFLOATVAL(numerator, isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY), true);\n\n\tPG_RETURN_FLOAT8(numerator / (N * N));\n}"
  },
  {
    "function_name": "float8_regr_avgy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3237-3254",
    "snippet": "Datum\nfloat8_regr_avgy(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumY;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_avgy\", 6);\n\tN = transvalues[0];\n\tsumY = transvalues[3];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_FLOAT8(sumY / N);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "sumY / N"
          ],
          "line": 3253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_regr_avgy\"",
            "6"
          ],
          "line": 3245
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 3240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_regr_avgy(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumY;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_avgy\", 6);\n\tN = transvalues[0];\n\tsumY = transvalues[3];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_FLOAT8(sumY / N);\n}"
  },
  {
    "function_name": "float8_regr_avgx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3218-3235",
    "snippet": "Datum\nfloat8_regr_avgx(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_avgx\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_FLOAT8(sumX / N);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "sumX / N"
          ],
          "line": 3234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_regr_avgx\"",
            "6"
          ],
          "line": 3226
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_regr_avgx(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_avgx\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_FLOAT8(sumX / N);\n}"
  },
  {
    "function_name": "float8_regr_sxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3188-3216",
    "snippet": "Datum\nfloat8_regr_sxy(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumY,\n\t\t\t\tsumXY,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_sxy\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumY = transvalues[3];\n\tsumXY = transvalues[5];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumXY - sumX * sumY;\n\tCHECKFLOATVAL(numerator, isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY), true);\n\n\t/* A negative result is valid here */\n\n\tPG_RETURN_FLOAT8(numerator / N);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "numerator / N"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numerator",
            "isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY)",
            "true"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumY"
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumXY"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_regr_sxy\"",
            "6"
          ],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_regr_sxy(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumY,\n\t\t\t\tsumXY,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_sxy\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumY = transvalues[3];\n\tsumXY = transvalues[5];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumXY - sumX * sumY;\n\tCHECKFLOATVAL(numerator, isinf(sumXY) || isinf(sumX) ||\n\t\t\t\t  isinf(sumY), true);\n\n\t/* A negative result is valid here */\n\n\tPG_RETURN_FLOAT8(numerator / N);\n}"
  },
  {
    "function_name": "float8_regr_syy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3159-3186",
    "snippet": "Datum\nfloat8_regr_syy(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumY,\n\t\t\t\tsumY2,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_syy\", 6);\n\tN = transvalues[0];\n\tsumY = transvalues[3];\n\tsumY2 = transvalues[4];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumY2 - sumY * sumY;\n\tCHECKFLOATVAL(numerator, isinf(sumY2) || isinf(sumY), true);\n\n\t/* Watch out for roundoff error producing a negative numerator */\n\tif (numerator <= 0.0)\n\t\tPG_RETURN_FLOAT8(0.0);\n\n\tPG_RETURN_FLOAT8(numerator / N);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "numerator / N"
          ],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "0.0"
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numerator",
            "isinf(sumY2) || isinf(sumY)",
            "true"
          ],
          "line": 3179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumY"
          ],
          "line": 3179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumY2"
          ],
          "line": 3179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_regr_syy\"",
            "6"
          ],
          "line": 3169
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 3162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_regr_syy(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumY,\n\t\t\t\tsumY2,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_syy\", 6);\n\tN = transvalues[0];\n\tsumY = transvalues[3];\n\tsumY2 = transvalues[4];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumY2 - sumY * sumY;\n\tCHECKFLOATVAL(numerator, isinf(sumY2) || isinf(sumY), true);\n\n\t/* Watch out for roundoff error producing a negative numerator */\n\tif (numerator <= 0.0)\n\t\tPG_RETURN_FLOAT8(0.0);\n\n\tPG_RETURN_FLOAT8(numerator / N);\n}"
  },
  {
    "function_name": "float8_regr_sxx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3130-3157",
    "snippet": "Datum\nfloat8_regr_sxx(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_sxx\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numerator, isinf(sumX2) || isinf(sumX), true);\n\n\t/* Watch out for roundoff error producing a negative numerator */\n\tif (numerator <= 0.0)\n\t\tPG_RETURN_FLOAT8(0.0);\n\n\tPG_RETURN_FLOAT8(numerator / N);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "numerator / N"
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "0.0"
          ],
          "line": 3154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numerator",
            "isinf(sumX2) || isinf(sumX)",
            "true"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX2"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_regr_sxx\"",
            "6"
          ],
          "line": 3140
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_regr_sxx(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_sxx\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\n\t/* if N is 0 we should return NULL */\n\tif (N < 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numerator, isinf(sumX2) || isinf(sumX), true);\n\n\t/* Watch out for roundoff error producing a negative numerator */\n\tif (numerator <= 0.0)\n\t\tPG_RETURN_FLOAT8(0.0);\n\n\tPG_RETURN_FLOAT8(numerator / N);\n}"
  },
  {
    "function_name": "float8_regr_combine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "3075-3127",
    "snippet": "Datum\nfloat8_regr_combine(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray1 = PG_GETARG_ARRAYTYPE_P(0);\n\tArrayType  *transarray2 = PG_GETARG_ARRAYTYPE_P(1);\n\tfloat8\t   *transvalues1;\n\tfloat8\t   *transvalues2;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tsumY,\n\t\t\t\tsumY2,\n\t\t\t\tsumXY;\n\n\tif (!AggCheckCallContext(fcinfo, NULL))\n\t\telog(ERROR, \"aggregate function called in non-aggregate context\");\n\n\ttransvalues1 = check_float8_array(transarray1, \"float8_regr_combine\", 6);\n\tN = transvalues1[0];\n\tsumX = transvalues1[1];\n\tsumX2 = transvalues1[2];\n\tsumY = transvalues1[3];\n\tsumY2 = transvalues1[4];\n\tsumXY = transvalues1[5];\n\n\ttransvalues2 = check_float8_array(transarray2, \"float8_regr_combine\", 6);\n\n\tN += transvalues2[0];\n\tsumX += transvalues2[1];\n\tCHECKFLOATVAL(sumX, isinf(transvalues1[1]) || isinf(transvalues2[1]),\n\t\t\t\t  true);\n\tsumX2 += transvalues2[2];\n\tCHECKFLOATVAL(sumX2, isinf(transvalues1[2]) || isinf(transvalues2[2]),\n\t\t\t\t  true);\n\tsumY += transvalues2[3];\n\tCHECKFLOATVAL(sumY, isinf(transvalues1[3]) || isinf(transvalues2[3]),\n\t\t\t\t  true);\n\tsumY2 += transvalues2[4];\n\tCHECKFLOATVAL(sumY2, isinf(transvalues1[4]) || isinf(transvalues2[4]),\n\t\t\t\t  true);\n\tsumXY += transvalues2[5];\n\tCHECKFLOATVAL(sumXY, isinf(transvalues1[5]) || isinf(transvalues2[5]),\n\t\t\t\t  true);\n\n\ttransvalues1[0] = N;\n\ttransvalues1[1] = sumX;\n\ttransvalues1[2] = sumX2;\n\ttransvalues1[3] = sumY;\n\ttransvalues1[4] = sumY2;\n\ttransvalues1[5] = sumXY;\n\n\tPG_RETURN_ARRAYTYPE_P(transarray1);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "transarray1"
          ],
          "line": 3126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "sumXY",
            "isinf(transvalues1[5]) || isinf(transvalues2[5])",
            "true"
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues2[5]"
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues1[5]"
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "sumY2",
            "isinf(transvalues1[4]) || isinf(transvalues2[4])",
            "true"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues2[4]"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues1[4]"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "sumY",
            "isinf(transvalues1[3]) || isinf(transvalues2[3])",
            "true"
          ],
          "line": 3110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues2[3]"
          ],
          "line": 3110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues1[3]"
          ],
          "line": 3110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "sumX2",
            "isinf(transvalues1[2]) || isinf(transvalues2[2])",
            "true"
          ],
          "line": 3107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues2[2]"
          ],
          "line": 3107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues1[2]"
          ],
          "line": 3107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "sumX",
            "isinf(transvalues1[1]) || isinf(transvalues2[1])",
            "true"
          ],
          "line": 3104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues2[1]"
          ],
          "line": 3104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues1[1]"
          ],
          "line": 3104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray2",
            "\"float8_regr_combine\"",
            "6"
          ],
          "line": 3100
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"aggregate function called in non-aggregate context\""
          ],
          "line": 3090
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_regr_combine(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray1 = PG_GETARG_ARRAYTYPE_P(0);\n\tArrayType  *transarray2 = PG_GETARG_ARRAYTYPE_P(1);\n\tfloat8\t   *transvalues1;\n\tfloat8\t   *transvalues2;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tsumY,\n\t\t\t\tsumY2,\n\t\t\t\tsumXY;\n\n\tif (!AggCheckCallContext(fcinfo, NULL))\n\t\telog(ERROR, \"aggregate function called in non-aggregate context\");\n\n\ttransvalues1 = check_float8_array(transarray1, \"float8_regr_combine\", 6);\n\tN = transvalues1[0];\n\tsumX = transvalues1[1];\n\tsumX2 = transvalues1[2];\n\tsumY = transvalues1[3];\n\tsumY2 = transvalues1[4];\n\tsumXY = transvalues1[5];\n\n\ttransvalues2 = check_float8_array(transarray2, \"float8_regr_combine\", 6);\n\n\tN += transvalues2[0];\n\tsumX += transvalues2[1];\n\tCHECKFLOATVAL(sumX, isinf(transvalues1[1]) || isinf(transvalues2[1]),\n\t\t\t\t  true);\n\tsumX2 += transvalues2[2];\n\tCHECKFLOATVAL(sumX2, isinf(transvalues1[2]) || isinf(transvalues2[2]),\n\t\t\t\t  true);\n\tsumY += transvalues2[3];\n\tCHECKFLOATVAL(sumY, isinf(transvalues1[3]) || isinf(transvalues2[3]),\n\t\t\t\t  true);\n\tsumY2 += transvalues2[4];\n\tCHECKFLOATVAL(sumY2, isinf(transvalues1[4]) || isinf(transvalues2[4]),\n\t\t\t\t  true);\n\tsumXY += transvalues2[5];\n\tCHECKFLOATVAL(sumXY, isinf(transvalues1[5]) || isinf(transvalues2[5]),\n\t\t\t\t  true);\n\n\ttransvalues1[0] = N;\n\ttransvalues1[1] = sumX;\n\ttransvalues1[2] = sumX2;\n\ttransvalues1[3] = sumY;\n\ttransvalues1[4] = sumY2;\n\ttransvalues1[5] = sumXY;\n\n\tPG_RETURN_ARRAYTYPE_P(transarray1);\n}"
  },
  {
    "function_name": "float8_regr_accum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2996-3065",
    "snippet": "Datum\nfloat8_regr_accum(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t\tnewvalY = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tnewvalX = PG_GETARG_FLOAT8(2);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tsumY,\n\t\t\t\tsumY2,\n\t\t\t\tsumXY;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_accum\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\tsumY = transvalues[3];\n\tsumY2 = transvalues[4];\n\tsumXY = transvalues[5];\n\n\tN += 1.0;\n\tsumX += newvalX;\n\tCHECKFLOATVAL(sumX, isinf(transvalues[1]) || isinf(newvalX), true);\n\tsumX2 += newvalX * newvalX;\n\tCHECKFLOATVAL(sumX2, isinf(transvalues[2]) || isinf(newvalX), true);\n\tsumY += newvalY;\n\tCHECKFLOATVAL(sumY, isinf(transvalues[3]) || isinf(newvalY), true);\n\tsumY2 += newvalY * newvalY;\n\tCHECKFLOATVAL(sumY2, isinf(transvalues[4]) || isinf(newvalY), true);\n\tsumXY += newvalX * newvalY;\n\tCHECKFLOATVAL(sumXY, isinf(transvalues[5]) || isinf(newvalX) ||\n\t\t\t\t  isinf(newvalY), true);\n\n\t/*\n\t * If we're invoked as an aggregate, we can cheat and modify our first\n\t * parameter in-place to reduce palloc overhead. Otherwise we construct a\n\t * new array with the updated transition data and return it.\n\t */\n\tif (AggCheckCallContext(fcinfo, NULL))\n\t{\n\t\ttransvalues[0] = N;\n\t\ttransvalues[1] = sumX;\n\t\ttransvalues[2] = sumX2;\n\t\ttransvalues[3] = sumY;\n\t\ttransvalues[4] = sumY2;\n\t\ttransvalues[5] = sumXY;\n\n\t\tPG_RETURN_ARRAYTYPE_P(transarray);\n\t}\n\telse\n\t{\n\t\tDatum\t\ttransdatums[6];\n\t\tArrayType  *result;\n\n\t\ttransdatums[0] = Float8GetDatumFast(N);\n\t\ttransdatums[1] = Float8GetDatumFast(sumX);\n\t\ttransdatums[2] = Float8GetDatumFast(sumX2);\n\t\ttransdatums[3] = Float8GetDatumFast(sumY);\n\t\ttransdatums[4] = Float8GetDatumFast(sumY2);\n\t\ttransdatums[5] = Float8GetDatumFast(sumXY);\n\n\t\tresult = construct_array(transdatums, 6,\n\t\t\t\t\t\t\t\t FLOAT8OID,\n\t\t\t\t\t\t\t\t sizeof(float8), FLOAT8PASSBYVAL, 'd');\n\n\t\tPG_RETURN_ARRAYTYPE_P(result);\n\t}\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "result"
          ],
          "line": 3063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_array",
          "args": [
            "transdatums",
            "6",
            "FLOAT8OID",
            "sizeof(float8)",
            "FLOAT8PASSBYVAL",
            "'d'"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "construct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3290-3303",
          "snippet": "ArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Float8GetDatumFast",
          "args": [
            "sumXY"
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Float8GetDatumFast",
          "args": [
            "sumY2"
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Float8GetDatumFast",
          "args": [
            "sumY"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Float8GetDatumFast",
          "args": [
            "sumX2"
          ],
          "line": 3054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Float8GetDatumFast",
          "args": [
            "sumX"
          ],
          "line": 3053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Float8GetDatumFast",
          "args": [
            "N"
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "transarray"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "sumXY",
            "isinf(transvalues[5]) || isinf(newvalX) ||\n\t\t\t\t  isinf(newvalY)",
            "true"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "newvalY"
          ],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "newvalX"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues[5]"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "sumY2",
            "isinf(transvalues[4]) || isinf(newvalY)",
            "true"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "newvalY"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues[4]"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "sumY",
            "isinf(transvalues[3]) || isinf(newvalY)",
            "true"
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "newvalY"
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues[3]"
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "sumX2",
            "isinf(transvalues[2]) || isinf(newvalX)",
            "true"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "newvalX"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues[2]"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "sumX",
            "isinf(transvalues[1]) || isinf(newvalX)",
            "true"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "newvalX"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues[1]"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_regr_accum\"",
            "6"
          ],
          "line": 3010
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "2"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 3000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_regr_accum(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t\tnewvalY = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tnewvalX = PG_GETARG_FLOAT8(2);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tsumY,\n\t\t\t\tsumY2,\n\t\t\t\tsumXY;\n\n\ttransvalues = check_float8_array(transarray, \"float8_regr_accum\", 6);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\tsumY = transvalues[3];\n\tsumY2 = transvalues[4];\n\tsumXY = transvalues[5];\n\n\tN += 1.0;\n\tsumX += newvalX;\n\tCHECKFLOATVAL(sumX, isinf(transvalues[1]) || isinf(newvalX), true);\n\tsumX2 += newvalX * newvalX;\n\tCHECKFLOATVAL(sumX2, isinf(transvalues[2]) || isinf(newvalX), true);\n\tsumY += newvalY;\n\tCHECKFLOATVAL(sumY, isinf(transvalues[3]) || isinf(newvalY), true);\n\tsumY2 += newvalY * newvalY;\n\tCHECKFLOATVAL(sumY2, isinf(transvalues[4]) || isinf(newvalY), true);\n\tsumXY += newvalX * newvalY;\n\tCHECKFLOATVAL(sumXY, isinf(transvalues[5]) || isinf(newvalX) ||\n\t\t\t\t  isinf(newvalY), true);\n\n\t/*\n\t * If we're invoked as an aggregate, we can cheat and modify our first\n\t * parameter in-place to reduce palloc overhead. Otherwise we construct a\n\t * new array with the updated transition data and return it.\n\t */\n\tif (AggCheckCallContext(fcinfo, NULL))\n\t{\n\t\ttransvalues[0] = N;\n\t\ttransvalues[1] = sumX;\n\t\ttransvalues[2] = sumX2;\n\t\ttransvalues[3] = sumY;\n\t\ttransvalues[4] = sumY2;\n\t\ttransvalues[5] = sumXY;\n\n\t\tPG_RETURN_ARRAYTYPE_P(transarray);\n\t}\n\telse\n\t{\n\t\tDatum\t\ttransdatums[6];\n\t\tArrayType  *result;\n\n\t\ttransdatums[0] = Float8GetDatumFast(N);\n\t\ttransdatums[1] = Float8GetDatumFast(sumX);\n\t\ttransdatums[2] = Float8GetDatumFast(sumX2);\n\t\ttransdatums[3] = Float8GetDatumFast(sumY);\n\t\ttransdatums[4] = Float8GetDatumFast(sumY2);\n\t\ttransdatums[5] = Float8GetDatumFast(sumXY);\n\n\t\tresult = construct_array(transdatums, 6,\n\t\t\t\t\t\t\t\t FLOAT8OID,\n\t\t\t\t\t\t\t\t sizeof(float8), FLOAT8PASSBYVAL, 'd');\n\n\t\tPG_RETURN_ARRAYTYPE_P(result);\n\t}\n}"
  },
  {
    "function_name": "float8_stddev_samp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2951-2978",
    "snippet": "Datum\nfloat8_stddev_samp(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_stddev_samp\", 3);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\n\t/* Sample stddev is undefined when N is 0 or 1, so return NULL */\n\tif (N <= 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numerator, isinf(sumX2) || isinf(sumX), true);\n\n\t/* Watch out for roundoff error producing a negative numerator */\n\tif (numerator <= 0.0)\n\t\tPG_RETURN_FLOAT8(0.0);\n\n\tPG_RETURN_FLOAT8(sqrt(numerator / (N * (N - 1.0))));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "sqrt(numerator / (N * (N - 1.0)))"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqrt",
          "args": [
            "numerator / (N * (N - 1.0))"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "dsqrt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1613-1628",
          "snippet": "Datum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "0.0"
          ],
          "line": 2975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numerator",
            "isinf(sumX2) || isinf(sumX)",
            "true"
          ],
          "line": 2971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX"
          ],
          "line": 2971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX2"
          ],
          "line": 2971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_stddev_samp\"",
            "3"
          ],
          "line": 2961
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_stddev_samp(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_stddev_samp\", 3);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\n\t/* Sample stddev is undefined when N is 0 or 1, so return NULL */\n\tif (N <= 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numerator, isinf(sumX2) || isinf(sumX), true);\n\n\t/* Watch out for roundoff error producing a negative numerator */\n\tif (numerator <= 0.0)\n\t\tPG_RETURN_FLOAT8(0.0);\n\n\tPG_RETURN_FLOAT8(sqrt(numerator / (N * (N - 1.0))));\n}"
  },
  {
    "function_name": "float8_stddev_pop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2922-2949",
    "snippet": "Datum\nfloat8_stddev_pop(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_stddev_pop\", 3);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\n\t/* Population stddev is undefined when N is 0, so return NULL */\n\tif (N == 0.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numerator, isinf(sumX2) || isinf(sumX), true);\n\n\t/* Watch out for roundoff error producing a negative numerator */\n\tif (numerator <= 0.0)\n\t\tPG_RETURN_FLOAT8(0.0);\n\n\tPG_RETURN_FLOAT8(sqrt(numerator / (N * N)));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "sqrt(numerator / (N * N))"
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqrt",
          "args": [
            "numerator / (N * N)"
          ],
          "line": 2948
        },
        "resolved": true,
        "details": {
          "function_name": "dsqrt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1613-1628",
          "snippet": "Datum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "0.0"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numerator",
            "isinf(sumX2) || isinf(sumX)",
            "true"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX2"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_stddev_pop\"",
            "3"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_stddev_pop(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_stddev_pop\", 3);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\n\t/* Population stddev is undefined when N is 0, so return NULL */\n\tif (N == 0.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numerator, isinf(sumX2) || isinf(sumX), true);\n\n\t/* Watch out for roundoff error producing a negative numerator */\n\tif (numerator <= 0.0)\n\t\tPG_RETURN_FLOAT8(0.0);\n\n\tPG_RETURN_FLOAT8(sqrt(numerator / (N * N)));\n}"
  },
  {
    "function_name": "float8_var_samp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2893-2920",
    "snippet": "Datum\nfloat8_var_samp(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_var_samp\", 3);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\n\t/* Sample variance is undefined when N is 0 or 1, so return NULL */\n\tif (N <= 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numerator, isinf(sumX2) || isinf(sumX), true);\n\n\t/* Watch out for roundoff error producing a negative numerator */\n\tif (numerator <= 0.0)\n\t\tPG_RETURN_FLOAT8(0.0);\n\n\tPG_RETURN_FLOAT8(numerator / (N * (N - 1.0)));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "numerator / (N * (N - 1.0))"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "0.0"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numerator",
            "isinf(sumX2) || isinf(sumX)",
            "true"
          ],
          "line": 2913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX"
          ],
          "line": 2913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX2"
          ],
          "line": 2913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_var_samp\"",
            "3"
          ],
          "line": 2903
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_var_samp(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_var_samp\", 3);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\n\t/* Sample variance is undefined when N is 0 or 1, so return NULL */\n\tif (N <= 1.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numerator, isinf(sumX2) || isinf(sumX), true);\n\n\t/* Watch out for roundoff error producing a negative numerator */\n\tif (numerator <= 0.0)\n\t\tPG_RETURN_FLOAT8(0.0);\n\n\tPG_RETURN_FLOAT8(numerator / (N * (N - 1.0)));\n}"
  },
  {
    "function_name": "float8_var_pop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2864-2891",
    "snippet": "Datum\nfloat8_var_pop(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_var_pop\", 3);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\n\t/* Population variance is undefined when N is 0, so return NULL */\n\tif (N == 0.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numerator, isinf(sumX2) || isinf(sumX), true);\n\n\t/* Watch out for roundoff error producing a negative numerator */\n\tif (numerator <= 0.0)\n\t\tPG_RETURN_FLOAT8(0.0);\n\n\tPG_RETURN_FLOAT8(numerator / (N * N));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "numerator / (N * N)"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "0.0"
          ],
          "line": 2888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "numerator",
            "isinf(sumX2) || isinf(sumX)",
            "true"
          ],
          "line": 2884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX"
          ],
          "line": 2884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "sumX2"
          ],
          "line": 2884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_var_pop\"",
            "3"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_var_pop(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2,\n\t\t\t\tnumerator;\n\n\ttransvalues = check_float8_array(transarray, \"float8_var_pop\", 3);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\n\t/* Population variance is undefined when N is 0, so return NULL */\n\tif (N == 0.0)\n\t\tPG_RETURN_NULL();\n\n\tnumerator = N * sumX2 - sumX * sumX;\n\tCHECKFLOATVAL(numerator, isinf(sumX2) || isinf(sumX), true);\n\n\t/* Watch out for roundoff error producing a negative numerator */\n\tif (numerator <= 0.0)\n\t\tPG_RETURN_FLOAT8(0.0);\n\n\tPG_RETURN_FLOAT8(numerator / (N * N));\n}"
  },
  {
    "function_name": "float8_avg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2844-2862",
    "snippet": "Datum\nfloat8_avg(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX;\n\n\ttransvalues = check_float8_array(transarray, \"float8_avg\", 3);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\t/* ignore sumX2 */\n\n\t/* SQL defines AVG of no values to be NULL */\n\tif (N == 0.0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_FLOAT8(sumX / N);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "sumX / N"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_avg\"",
            "3"
          ],
          "line": 2852
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_avg(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX;\n\n\ttransvalues = check_float8_array(transarray, \"float8_avg\", 3);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\t/* ignore sumX2 */\n\n\t/* SQL defines AVG of no values to be NULL */\n\tif (N == 0.0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_FLOAT8(sumX / N);\n}"
  },
  {
    "function_name": "float4_accum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2791-2842",
    "snippet": "Datum\nfloat4_accum(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\n\t/* do computations as float8 */\n\tfloat8\t\tnewval = PG_GETARG_FLOAT4(1);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2;\n\n\ttransvalues = check_float8_array(transarray, \"float4_accum\", 3);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\n\tN += 1.0;\n\tsumX += newval;\n\tCHECKFLOATVAL(sumX, isinf(transvalues[1]) || isinf(newval), true);\n\tsumX2 += newval * newval;\n\tCHECKFLOATVAL(sumX2, isinf(transvalues[2]) || isinf(newval), true);\n\n\t/*\n\t * If we're invoked as an aggregate, we can cheat and modify our first\n\t * parameter in-place to reduce palloc overhead. Otherwise we construct a\n\t * new array with the updated transition data and return it.\n\t */\n\tif (AggCheckCallContext(fcinfo, NULL))\n\t{\n\t\ttransvalues[0] = N;\n\t\ttransvalues[1] = sumX;\n\t\ttransvalues[2] = sumX2;\n\n\t\tPG_RETURN_ARRAYTYPE_P(transarray);\n\t}\n\telse\n\t{\n\t\tDatum\t\ttransdatums[3];\n\t\tArrayType  *result;\n\n\t\ttransdatums[0] = Float8GetDatumFast(N);\n\t\ttransdatums[1] = Float8GetDatumFast(sumX);\n\t\ttransdatums[2] = Float8GetDatumFast(sumX2);\n\n\t\tresult = construct_array(transdatums, 3,\n\t\t\t\t\t\t\t\t FLOAT8OID,\n\t\t\t\t\t\t\t\t sizeof(float8), FLOAT8PASSBYVAL, 'd');\n\n\t\tPG_RETURN_ARRAYTYPE_P(result);\n\t}\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "result"
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_array",
          "args": [
            "transdatums",
            "3",
            "FLOAT8OID",
            "sizeof(float8)",
            "FLOAT8PASSBYVAL",
            "'d'"
          ],
          "line": 2836
        },
        "resolved": true,
        "details": {
          "function_name": "construct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3290-3303",
          "snippet": "ArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Float8GetDatumFast",
          "args": [
            "sumX2"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Float8GetDatumFast",
          "args": [
            "sumX"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Float8GetDatumFast",
          "args": [
            "N"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "transarray"
          ],
          "line": 2825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 2819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "sumX2",
            "isinf(transvalues[2]) || isinf(newval)",
            "true"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "newval"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues[2]"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "sumX",
            "isinf(transvalues[1]) || isinf(newval)",
            "true"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "newval"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues[1]"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float4_accum\"",
            "3"
          ],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4_accum(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\n\t/* do computations as float8 */\n\tfloat8\t\tnewval = PG_GETARG_FLOAT4(1);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2;\n\n\ttransvalues = check_float8_array(transarray, \"float4_accum\", 3);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\n\tN += 1.0;\n\tsumX += newval;\n\tCHECKFLOATVAL(sumX, isinf(transvalues[1]) || isinf(newval), true);\n\tsumX2 += newval * newval;\n\tCHECKFLOATVAL(sumX2, isinf(transvalues[2]) || isinf(newval), true);\n\n\t/*\n\t * If we're invoked as an aggregate, we can cheat and modify our first\n\t * parameter in-place to reduce palloc overhead. Otherwise we construct a\n\t * new array with the updated transition data and return it.\n\t */\n\tif (AggCheckCallContext(fcinfo, NULL))\n\t{\n\t\ttransvalues[0] = N;\n\t\ttransvalues[1] = sumX;\n\t\ttransvalues[2] = sumX2;\n\n\t\tPG_RETURN_ARRAYTYPE_P(transarray);\n\t}\n\telse\n\t{\n\t\tDatum\t\ttransdatums[3];\n\t\tArrayType  *result;\n\n\t\ttransdatums[0] = Float8GetDatumFast(N);\n\t\ttransdatums[1] = Float8GetDatumFast(sumX);\n\t\ttransdatums[2] = Float8GetDatumFast(sumX2);\n\n\t\tresult = construct_array(transdatums, 3,\n\t\t\t\t\t\t\t\t FLOAT8OID,\n\t\t\t\t\t\t\t\t sizeof(float8), FLOAT8PASSBYVAL, 'd');\n\n\t\tPG_RETURN_ARRAYTYPE_P(result);\n\t}\n}"
  },
  {
    "function_name": "float8_accum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2740-2789",
    "snippet": "Datum\nfloat8_accum(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t\tnewval = PG_GETARG_FLOAT8(1);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2;\n\n\ttransvalues = check_float8_array(transarray, \"float8_accum\", 3);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\n\tN += 1.0;\n\tsumX += newval;\n\tCHECKFLOATVAL(sumX, isinf(transvalues[1]) || isinf(newval), true);\n\tsumX2 += newval * newval;\n\tCHECKFLOATVAL(sumX2, isinf(transvalues[2]) || isinf(newval), true);\n\n\t/*\n\t * If we're invoked as an aggregate, we can cheat and modify our first\n\t * parameter in-place to reduce palloc overhead. Otherwise we construct a\n\t * new array with the updated transition data and return it.\n\t */\n\tif (AggCheckCallContext(fcinfo, NULL))\n\t{\n\t\ttransvalues[0] = N;\n\t\ttransvalues[1] = sumX;\n\t\ttransvalues[2] = sumX2;\n\n\t\tPG_RETURN_ARRAYTYPE_P(transarray);\n\t}\n\telse\n\t{\n\t\tDatum\t\ttransdatums[3];\n\t\tArrayType  *result;\n\n\t\ttransdatums[0] = Float8GetDatumFast(N);\n\t\ttransdatums[1] = Float8GetDatumFast(sumX);\n\t\ttransdatums[2] = Float8GetDatumFast(sumX2);\n\n\t\tresult = construct_array(transdatums, 3,\n\t\t\t\t\t\t\t\t FLOAT8OID,\n\t\t\t\t\t\t\t\t sizeof(float8), FLOAT8PASSBYVAL, 'd');\n\n\t\tPG_RETURN_ARRAYTYPE_P(result);\n\t}\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "result"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_array",
          "args": [
            "transdatums",
            "3",
            "FLOAT8OID",
            "sizeof(float8)",
            "FLOAT8PASSBYVAL",
            "'d'"
          ],
          "line": 2783
        },
        "resolved": true,
        "details": {
          "function_name": "construct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3290-3303",
          "snippet": "ArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Float8GetDatumFast",
          "args": [
            "sumX2"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Float8GetDatumFast",
          "args": [
            "sumX"
          ],
          "line": 2780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Float8GetDatumFast",
          "args": [
            "N"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "transarray"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 2766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "sumX2",
            "isinf(transvalues[2]) || isinf(newval)",
            "true"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "newval"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues[2]"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "sumX",
            "isinf(transvalues[1]) || isinf(newval)",
            "true"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "newval"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues[1]"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray",
            "\"float8_accum\"",
            "3"
          ],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_accum(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tfloat8\t\tnewval = PG_GETARG_FLOAT8(1);\n\tfloat8\t   *transvalues;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2;\n\n\ttransvalues = check_float8_array(transarray, \"float8_accum\", 3);\n\tN = transvalues[0];\n\tsumX = transvalues[1];\n\tsumX2 = transvalues[2];\n\n\tN += 1.0;\n\tsumX += newval;\n\tCHECKFLOATVAL(sumX, isinf(transvalues[1]) || isinf(newval), true);\n\tsumX2 += newval * newval;\n\tCHECKFLOATVAL(sumX2, isinf(transvalues[2]) || isinf(newval), true);\n\n\t/*\n\t * If we're invoked as an aggregate, we can cheat and modify our first\n\t * parameter in-place to reduce palloc overhead. Otherwise we construct a\n\t * new array with the updated transition data and return it.\n\t */\n\tif (AggCheckCallContext(fcinfo, NULL))\n\t{\n\t\ttransvalues[0] = N;\n\t\ttransvalues[1] = sumX;\n\t\ttransvalues[2] = sumX2;\n\n\t\tPG_RETURN_ARRAYTYPE_P(transarray);\n\t}\n\telse\n\t{\n\t\tDatum\t\ttransdatums[3];\n\t\tArrayType  *result;\n\n\t\ttransdatums[0] = Float8GetDatumFast(N);\n\t\ttransdatums[1] = Float8GetDatumFast(sumX);\n\t\ttransdatums[2] = Float8GetDatumFast(sumX2);\n\n\t\tresult = construct_array(transdatums, 3,\n\t\t\t\t\t\t\t\t FLOAT8OID,\n\t\t\t\t\t\t\t\t sizeof(float8), FLOAT8PASSBYVAL, 'd');\n\n\t\tPG_RETURN_ARRAYTYPE_P(result);\n\t}\n}"
  },
  {
    "function_name": "float8_combine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2704-2738",
    "snippet": "Datum\nfloat8_combine(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray1 = PG_GETARG_ARRAYTYPE_P(0);\n\tArrayType  *transarray2 = PG_GETARG_ARRAYTYPE_P(1);\n\tfloat8\t   *transvalues1;\n\tfloat8\t   *transvalues2;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2;\n\n\tif (!AggCheckCallContext(fcinfo, NULL))\n\t\telog(ERROR, \"aggregate function called in non-aggregate context\");\n\n\ttransvalues1 = check_float8_array(transarray1, \"float8_combine\", 3);\n\tN = transvalues1[0];\n\tsumX = transvalues1[1];\n\tsumX2 = transvalues1[2];\n\n\ttransvalues2 = check_float8_array(transarray2, \"float8_combine\", 3);\n\n\tN += transvalues2[0];\n\tsumX += transvalues2[1];\n\tCHECKFLOATVAL(sumX, isinf(transvalues1[1]) || isinf(transvalues2[1]),\n\t\t\t\t  true);\n\tsumX2 += transvalues2[2];\n\tCHECKFLOATVAL(sumX2, isinf(transvalues1[2]) || isinf(transvalues2[2]),\n\t\t\t\t  true);\n\n\ttransvalues1[0] = N;\n\ttransvalues1[1] = sumX;\n\ttransvalues1[2] = sumX2;\n\n\tPG_RETURN_ARRAYTYPE_P(transarray1);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "transarray1"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "sumX2",
            "isinf(transvalues1[2]) || isinf(transvalues2[2])",
            "true"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues2[2]"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues1[2]"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "sumX",
            "isinf(transvalues1[1]) || isinf(transvalues2[1])",
            "true"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues2[1]"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "transvalues1[1]"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_float8_array",
          "args": [
            "transarray2",
            "\"float8_combine\"",
            "3"
          ],
          "line": 2723
        },
        "resolved": true,
        "details": {
          "function_name": "check_float8_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2680-2694",
          "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"aggregate function called in non-aggregate context\""
          ],
          "line": 2716
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8_combine(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray1 = PG_GETARG_ARRAYTYPE_P(0);\n\tArrayType  *transarray2 = PG_GETARG_ARRAYTYPE_P(1);\n\tfloat8\t   *transvalues1;\n\tfloat8\t   *transvalues2;\n\tfloat8\t\tN,\n\t\t\t\tsumX,\n\t\t\t\tsumX2;\n\n\tif (!AggCheckCallContext(fcinfo, NULL))\n\t\telog(ERROR, \"aggregate function called in non-aggregate context\");\n\n\ttransvalues1 = check_float8_array(transarray1, \"float8_combine\", 3);\n\tN = transvalues1[0];\n\tsumX = transvalues1[1];\n\tsumX2 = transvalues1[2];\n\n\ttransvalues2 = check_float8_array(transarray2, \"float8_combine\", 3);\n\n\tN += transvalues2[0];\n\tsumX += transvalues2[1];\n\tCHECKFLOATVAL(sumX, isinf(transvalues1[1]) || isinf(transvalues2[1]),\n\t\t\t\t  true);\n\tsumX2 += transvalues2[2];\n\tCHECKFLOATVAL(sumX2, isinf(transvalues1[2]) || isinf(transvalues2[2]),\n\t\t\t\t  true);\n\n\ttransvalues1[0] = N;\n\ttransvalues1[1] = sumX;\n\ttransvalues1[2] = sumX2;\n\n\tPG_RETURN_ARRAYTYPE_P(transarray1);\n}"
  },
  {
    "function_name": "check_float8_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2680-2694",
    "snippet": "static float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "transarray"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"%s: expected %d-element float8 array\"",
            "caller",
            "n"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "transarray"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "transarray"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "transarray"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "transarray"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 *\ncheck_float8_array(ArrayType *transarray, const char *caller, int n)\n{\n\t/*\n\t * We expect the input to be an N-element float array; verify that. We\n\t * don't need to use deconstruct_array() since the array data is just\n\t * going to look like a C array of N float8 values.\n\t */\n\tif (ARR_NDIM(transarray) != 1 ||\n\t\tARR_DIMS(transarray)[0] != n ||\n\t\tARR_HASNULL(transarray) ||\n\t\tARR_ELEMTYPE(transarray) != FLOAT8OID)\n\t\telog(ERROR, \"%s: expected %d-element float8 array\", caller, n);\n\treturn (float8 *) ARR_DATA_PTR(transarray);\n}"
  },
  {
    "function_name": "setseed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2641-2654",
    "snippet": "Datum\nsetseed(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tseed = PG_GETARG_FLOAT8(0);\n\tint\t\t\tiseed;\n\n\tif (seed < -1 || seed > 1)\n\t\telog(ERROR, \"setseed parameter %f out of range [-1,1]\", seed);\n\n\tiseed = (int) (seed * MAX_RANDOM_VALUE);\n\tsrandom((unsigned int) iseed);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srandom",
          "args": [
            "(unsigned int) iseed"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"setseed parameter %f out of range [-1,1]\"",
            "seed"
          ],
          "line": 2648
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nsetseed(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tseed = PG_GETARG_FLOAT8(0);\n\tint\t\t\tiseed;\n\n\tif (seed < -1 || seed > 1)\n\t\telog(ERROR, \"setseed parameter %f out of range [-1,1]\", seed);\n\n\tiseed = (int) (seed * MAX_RANDOM_VALUE);\n\tsrandom((unsigned int) iseed);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "drandom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2626-2635",
    "snippet": "Datum\ndrandom(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tresult;\n\n\t/* result [0.0 - 1.0) */\n\tresult = (double) random() / ((double) MAX_RANDOM_VALUE + 1);\n\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "random",
          "args": [],
          "line": 2632
        },
        "resolved": true,
        "details": {
          "function_name": "anl_random_fract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
          "lines": "261-270",
          "snippet": "double\nanl_random_fract(void)\n{\n\t/* initialize if first time through */\n\tif (oldrs.randstate[0] == 0)\n\t\tsampler_random_init_state(random(), oldrs.randstate);\n\n\t/* and compute a random fraction */\n\treturn sampler_random_fract(oldrs.randstate);\n}",
          "includes": [
            "#include \"utils/sampling.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ReservoirStateData oldrs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic ReservoirStateData oldrs;\n\ndouble\nanl_random_fract(void)\n{\n\t/* initialize if first time through */\n\tif (oldrs.randstate[0] == 0)\n\t\tsampler_random_init_state(random(), oldrs.randstate);\n\n\t/* and compute a random fraction */\n\treturn sampler_random_fract(oldrs.randstate);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndrandom(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tresult;\n\n\t/* result [0.0 - 1.0) */\n\tresult = (double) random() / ((double) MAX_RANDOM_VALUE + 1);\n\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "radians",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2610-2620",
    "snippet": "Datum\nradians(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tresult = arg1 * RADIANS_PER_DEGREE;\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RADIANS_PER_DEGREE 0.0174532925199432957692"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1)",
            "arg1 == 0"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define RADIANS_PER_DEGREE 0.0174532925199432957692\n\nDatum\nradians(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tresult = arg1 * RADIANS_PER_DEGREE;\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dpi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2600-2604",
    "snippet": "Datum\ndpi(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(M_PI);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define M_PI 3.14159265358979323846"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "M_PI"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define M_PI 3.14159265358979323846\n\nDatum\ndpi(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(M_PI);\n}"
  },
  {
    "function_name": "degrees",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2584-2594",
    "snippet": "Datum\ndegrees(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tresult = arg1 / RADIANS_PER_DEGREE;\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RADIANS_PER_DEGREE 0.0174532925199432957692"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1)",
            "arg1 == 0"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define RADIANS_PER_DEGREE 0.0174532925199432957692\n\nDatum\ndegrees(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tresult = arg1 / RADIANS_PER_DEGREE;\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dtand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2519-2578",
    "snippet": "Datum\ndtand(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tvolatile float8 tan_arg1;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* tand(-x) = -tand(x) */\n\t\targ1 = -arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* tand(360-x) = -tand(x) */\n\t\targ1 = 360.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* tand(180-x) = -tand(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\ttan_arg1 = sind_q1(arg1) / cosd_q1(arg1);\n\tresult = sign * (tan_arg1 / tan_45);\n\n\t/*\n\t * On some machines we get tand(180) = minus zero, but this isn't always\n\t * true.  For portability, and because the user constituency for this\n\t * function probably doesn't want minus zero, force it to plain zero.\n\t */\n\tif (result == 0.0)\n\t\tresult = 0.0;\n\n\tCHECKFLOATVAL(result, true /* tand(90) == Inf */ , true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static float8 tan_45 = 0;",
      "static double sind_q1(double x);",
      "static double cosd_q1(double x);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "true/* tand(90) == Inf */",
            "true"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cosd_q1",
          "args": [
            "arg1"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "cosd_q1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2328-2341",
          "snippet": "static double\ncosd_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 60]\n\t * and (60, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 60 and 90 degrees.\n\t */\n\tif (x <= 60.0)\n\t\treturn cosd_0_to_60(x);\n\telse\n\t\treturn sind_0_to_30(90.0 - x);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\ncosd_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 60]\n\t * and (60, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 60 and 90 degrees.\n\t */\n\tif (x <= 60.0)\n\t\treturn cosd_0_to_60(x);\n\telse\n\t\treturn sind_0_to_30(90.0 - x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sind_q1",
          "args": [
            "arg1"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "sind_q1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2308-2321",
          "snippet": "static double\nsind_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 30]\n\t * and (30, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 30 and 90 degrees.\n\t */\n\tif (x <= 30.0)\n\t\treturn sind_0_to_30(x);\n\telse\n\t\treturn cosd_0_to_60(90.0 - x);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\nsind_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 30]\n\t * and (30, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 30 and 90 degrees.\n\t */\n\tif (x <= 30.0)\n\t\treturn sind_0_to_30(x);\n\telse\n\t\treturn cosd_0_to_60(90.0 - x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmod",
          "args": [
            "arg1",
            "360.0"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DEGREE_CONSTANTS",
          "args": [],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\"))"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"input is out of range\""
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 tan_45 = 0;\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nDatum\ndtand(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tvolatile float8 tan_arg1;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* tand(-x) = -tand(x) */\n\t\targ1 = -arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* tand(360-x) = -tand(x) */\n\t\targ1 = 360.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* tand(180-x) = -tand(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\ttan_arg1 = sind_q1(arg1) / cosd_q1(arg1);\n\tresult = sign * (tan_arg1 / tan_45);\n\n\t/*\n\t * On some machines we get tand(180) = minus zero, but this isn't always\n\t * true.  For portability, and because the user constituency for this\n\t * function probably doesn't want minus zero, force it to plain zero.\n\t */\n\tif (result == 0.0)\n\t\tresult = 0.0;\n\n\tCHECKFLOATVAL(result, true /* tand(90) == Inf */ , true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dsind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2465-2513",
    "snippet": "Datum\ndsind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* sind(-x) = -sind(x) */\n\t\targ1 = -arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* sind(360-x) = -sind(x) */\n\t\targ1 = 360.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* sind(180-x) = sind(x) */\n\t\targ1 = 180.0 - arg1;\n\t}\n\n\tresult = sign * sind_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double sind_q1(double x);",
      "static double cosd_q1(double x);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "false",
            "true"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sind_q1",
          "args": [
            "arg1"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "sind_q1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2308-2321",
          "snippet": "static double\nsind_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 30]\n\t * and (30, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 30 and 90 degrees.\n\t */\n\tif (x <= 30.0)\n\t\treturn sind_0_to_30(x);\n\telse\n\t\treturn cosd_0_to_60(90.0 - x);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\nsind_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 30]\n\t * and (30, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 30 and 90 degrees.\n\t */\n\tif (x <= 30.0)\n\t\treturn sind_0_to_30(x);\n\telse\n\t\treturn cosd_0_to_60(90.0 - x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmod",
          "args": [
            "arg1",
            "360.0"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DEGREE_CONSTANTS",
          "args": [],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\"))"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"input is out of range\""
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 2477
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nDatum\ndsind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* sind(-x) = -sind(x) */\n\t\targ1 = -arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* sind(360-x) = -sind(x) */\n\t\targ1 = 360.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* sind(180-x) = sind(x) */\n\t\targ1 = 180.0 - arg1;\n\t}\n\n\tresult = sign * sind_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dcotd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2400-2459",
    "snippet": "Datum\ndcotd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tvolatile float8 cot_arg1;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* cotd(-x) = -cotd(x) */\n\t\targ1 = -arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* cotd(360-x) = -cotd(x) */\n\t\targ1 = 360.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* cotd(180-x) = -cotd(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tcot_arg1 = cosd_q1(arg1) / sind_q1(arg1);\n\tresult = sign * (cot_arg1 / cot_45);\n\n\t/*\n\t * On some machines we get cotd(270) = minus zero, but this isn't always\n\t * true.  For portability, and because the user constituency for this\n\t * function probably doesn't want minus zero, force it to plain zero.\n\t */\n\tif (result == 0.0)\n\t\tresult = 0.0;\n\n\tCHECKFLOATVAL(result, true /* cotd(0) == Inf */ , true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static float8 cot_45 = 0;",
      "static double sind_q1(double x);",
      "static double cosd_q1(double x);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "true/* cotd(0) == Inf */",
            "true"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sind_q1",
          "args": [
            "arg1"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "sind_q1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2308-2321",
          "snippet": "static double\nsind_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 30]\n\t * and (30, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 30 and 90 degrees.\n\t */\n\tif (x <= 30.0)\n\t\treturn sind_0_to_30(x);\n\telse\n\t\treturn cosd_0_to_60(90.0 - x);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\nsind_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 30]\n\t * and (30, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 30 and 90 degrees.\n\t */\n\tif (x <= 30.0)\n\t\treturn sind_0_to_30(x);\n\telse\n\t\treturn cosd_0_to_60(90.0 - x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cosd_q1",
          "args": [
            "arg1"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "cosd_q1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2328-2341",
          "snippet": "static double\ncosd_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 60]\n\t * and (60, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 60 and 90 degrees.\n\t */\n\tif (x <= 60.0)\n\t\treturn cosd_0_to_60(x);\n\telse\n\t\treturn sind_0_to_30(90.0 - x);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\ncosd_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 60]\n\t * and (60, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 60 and 90 degrees.\n\t */\n\tif (x <= 60.0)\n\t\treturn cosd_0_to_60(x);\n\telse\n\t\treturn sind_0_to_30(90.0 - x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmod",
          "args": [
            "arg1",
            "360.0"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DEGREE_CONSTANTS",
          "args": [],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\"))"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"input is out of range\""
          ],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 2415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 cot_45 = 0;\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nDatum\ndcotd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tvolatile float8 cot_arg1;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* cotd(-x) = -cotd(x) */\n\t\targ1 = -arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* cotd(360-x) = -cotd(x) */\n\t\targ1 = 360.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* cotd(180-x) = -cotd(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tcot_arg1 = cosd_q1(arg1) / sind_q1(arg1);\n\tresult = sign * (cot_arg1 / cot_45);\n\n\t/*\n\t * On some machines we get cotd(270) = minus zero, but this isn't always\n\t * true.  For portability, and because the user constituency for this\n\t * function probably doesn't want minus zero, force it to plain zero.\n\t */\n\tif (result == 0.0)\n\t\tresult = 0.0;\n\n\tCHECKFLOATVAL(result, true /* cotd(0) == Inf */ , true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dcosd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2347-2394",
    "snippet": "Datum\ndcosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* cosd(-x) = cosd(x) */\n\t\targ1 = -arg1;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* cosd(360-x) = cosd(x) */\n\t\targ1 = 360.0 - arg1;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* cosd(180-x) = -cosd(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tresult = sign * cosd_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double sind_q1(double x);",
      "static double cosd_q1(double x);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "false",
            "true"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cosd_q1",
          "args": [
            "arg1"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "cosd_q1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2328-2341",
          "snippet": "static double\ncosd_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 60]\n\t * and (60, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 60 and 90 degrees.\n\t */\n\tif (x <= 60.0)\n\t\treturn cosd_0_to_60(x);\n\telse\n\t\treturn sind_0_to_30(90.0 - x);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\ncosd_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 60]\n\t * and (60, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 60 and 90 degrees.\n\t */\n\tif (x <= 60.0)\n\t\treturn cosd_0_to_60(x);\n\telse\n\t\treturn sind_0_to_30(90.0 - x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmod",
          "args": [
            "arg1",
            "360.0"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DEGREE_CONSTANTS",
          "args": [],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\"))"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"input is out of range\""
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nDatum\ndcosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* cosd(-x) = cosd(x) */\n\t\targ1 = -arg1;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* cosd(360-x) = cosd(x) */\n\t\targ1 = 360.0 - arg1;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* cosd(180-x) = -cosd(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tresult = sign * cosd_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "cosd_q1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2328-2341",
    "snippet": "static double\ncosd_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 60]\n\t * and (60, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 60 and 90 degrees.\n\t */\n\tif (x <= 60.0)\n\t\treturn cosd_0_to_60(x);\n\telse\n\t\treturn sind_0_to_30(90.0 - x);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double sind_q1(double x);",
      "static double cosd_q1(double x);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sind_0_to_30",
          "args": [
            "90.0 - x"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "sind_0_to_30",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2281-2287",
          "snippet": "static double\nsind_0_to_30(double x)\n{\n\tvolatile float8 sin_x = sin(x * RADIANS_PER_DEGREE);\n\n\treturn (sin_x / sin_30) / 2.0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RADIANS_PER_DEGREE 0.0174532925199432957692"
          ],
          "globals_used": [
            "static float8 sin_30 = 0;",
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define RADIANS_PER_DEGREE 0.0174532925199432957692\n\nstatic float8 sin_30 = 0;\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\nsind_0_to_30(double x)\n{\n\tvolatile float8 sin_x = sin(x * RADIANS_PER_DEGREE);\n\n\treturn (sin_x / sin_30) / 2.0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cosd_0_to_60",
          "args": [
            "x"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "cosd_0_to_60",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2295-2301",
          "snippet": "static double\ncosd_0_to_60(double x)\n{\n\tvolatile float8 one_minus_cos_x = 1.0 - cos(x * RADIANS_PER_DEGREE);\n\n\treturn 1.0 - (one_minus_cos_x / one_minus_cos_60) / 2.0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RADIANS_PER_DEGREE 0.0174532925199432957692"
          ],
          "globals_used": [
            "static float8 one_minus_cos_60 = 0;",
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define RADIANS_PER_DEGREE 0.0174532925199432957692\n\nstatic float8 one_minus_cos_60 = 0;\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\ncosd_0_to_60(double x)\n{\n\tvolatile float8 one_minus_cos_x = 1.0 - cos(x * RADIANS_PER_DEGREE);\n\n\treturn 1.0 - (one_minus_cos_x / one_minus_cos_60) / 2.0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\ncosd_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 60]\n\t * and (60, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 60 and 90 degrees.\n\t */\n\tif (x <= 60.0)\n\t\treturn cosd_0_to_60(x);\n\telse\n\t\treturn sind_0_to_30(90.0 - x);\n}"
  },
  {
    "function_name": "sind_q1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2308-2321",
    "snippet": "static double\nsind_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 30]\n\t * and (30, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 30 and 90 degrees.\n\t */\n\tif (x <= 30.0)\n\t\treturn sind_0_to_30(x);\n\telse\n\t\treturn cosd_0_to_60(90.0 - x);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double sind_q1(double x);",
      "static double cosd_q1(double x);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cosd_0_to_60",
          "args": [
            "90.0 - x"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "cosd_0_to_60",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2295-2301",
          "snippet": "static double\ncosd_0_to_60(double x)\n{\n\tvolatile float8 one_minus_cos_x = 1.0 - cos(x * RADIANS_PER_DEGREE);\n\n\treturn 1.0 - (one_minus_cos_x / one_minus_cos_60) / 2.0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RADIANS_PER_DEGREE 0.0174532925199432957692"
          ],
          "globals_used": [
            "static float8 one_minus_cos_60 = 0;",
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define RADIANS_PER_DEGREE 0.0174532925199432957692\n\nstatic float8 one_minus_cos_60 = 0;\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\ncosd_0_to_60(double x)\n{\n\tvolatile float8 one_minus_cos_x = 1.0 - cos(x * RADIANS_PER_DEGREE);\n\n\treturn 1.0 - (one_minus_cos_x / one_minus_cos_60) / 2.0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sind_0_to_30",
          "args": [
            "x"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "sind_0_to_30",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2281-2287",
          "snippet": "static double\nsind_0_to_30(double x)\n{\n\tvolatile float8 sin_x = sin(x * RADIANS_PER_DEGREE);\n\n\treturn (sin_x / sin_30) / 2.0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RADIANS_PER_DEGREE 0.0174532925199432957692"
          ],
          "globals_used": [
            "static float8 sin_30 = 0;",
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define RADIANS_PER_DEGREE 0.0174532925199432957692\n\nstatic float8 sin_30 = 0;\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\nsind_0_to_30(double x)\n{\n\tvolatile float8 sin_x = sin(x * RADIANS_PER_DEGREE);\n\n\treturn (sin_x / sin_30) / 2.0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\nsind_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 30]\n\t * and (30, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 30 and 90 degrees.\n\t */\n\tif (x <= 30.0)\n\t\treturn sind_0_to_30(x);\n\telse\n\t\treturn cosd_0_to_60(90.0 - x);\n}"
  },
  {
    "function_name": "cosd_0_to_60",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2295-2301",
    "snippet": "static double\ncosd_0_to_60(double x)\n{\n\tvolatile float8 one_minus_cos_x = 1.0 - cos(x * RADIANS_PER_DEGREE);\n\n\treturn 1.0 - (one_minus_cos_x / one_minus_cos_60) / 2.0;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RADIANS_PER_DEGREE 0.0174532925199432957692"
    ],
    "globals_used": [
      "static float8 one_minus_cos_60 = 0;",
      "static double sind_q1(double x);",
      "static double cosd_q1(double x);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cos",
          "args": [
            "x * RADIANS_PER_DEGREE"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "dcosd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2347-2394",
          "snippet": "Datum\ndcosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* cosd(-x) = cosd(x) */\n\t\targ1 = -arg1;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* cosd(360-x) = cosd(x) */\n\t\targ1 = 360.0 - arg1;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* cosd(180-x) = -cosd(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tresult = sign * cosd_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nDatum\ndcosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* cosd(-x) = cosd(x) */\n\t\targ1 = -arg1;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* cosd(360-x) = cosd(x) */\n\t\targ1 = 360.0 - arg1;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* cosd(180-x) = -cosd(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tresult = sign * cosd_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define RADIANS_PER_DEGREE 0.0174532925199432957692\n\nstatic float8 one_minus_cos_60 = 0;\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\ncosd_0_to_60(double x)\n{\n\tvolatile float8 one_minus_cos_x = 1.0 - cos(x * RADIANS_PER_DEGREE);\n\n\treturn 1.0 - (one_minus_cos_x / one_minus_cos_60) / 2.0;\n}"
  },
  {
    "function_name": "sind_0_to_30",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2281-2287",
    "snippet": "static double\nsind_0_to_30(double x)\n{\n\tvolatile float8 sin_x = sin(x * RADIANS_PER_DEGREE);\n\n\treturn (sin_x / sin_30) / 2.0;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RADIANS_PER_DEGREE 0.0174532925199432957692"
    ],
    "globals_used": [
      "static float8 sin_30 = 0;",
      "static double sind_q1(double x);",
      "static double cosd_q1(double x);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sin",
          "args": [
            "x * RADIANS_PER_DEGREE"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "dsind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2465-2513",
          "snippet": "Datum\ndsind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* sind(-x) = -sind(x) */\n\t\targ1 = -arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* sind(360-x) = -sind(x) */\n\t\targ1 = 360.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* sind(180-x) = sind(x) */\n\t\targ1 = 180.0 - arg1;\n\t}\n\n\tresult = sign * sind_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nDatum\ndsind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* sind(-x) = -sind(x) */\n\t\targ1 = -arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* sind(360-x) = -sind(x) */\n\t\targ1 = 360.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* sind(180-x) = sind(x) */\n\t\targ1 = 180.0 - arg1;\n\t}\n\n\tresult = sign * sind_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define RADIANS_PER_DEGREE 0.0174532925199432957692\n\nstatic float8 sin_30 = 0;\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\nsind_0_to_30(double x)\n{\n\tvolatile float8 sin_x = sin(x * RADIANS_PER_DEGREE);\n\n\treturn (sin_x / sin_30) / 2.0;\n}"
  },
  {
    "function_name": "datan2d",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2245-2273",
    "snippet": "Datum\ndatan2d(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\tvolatile float8 atan2_arg1_arg2;\n\n\t/* Per the POSIX spec, return NaN if either input is NaN */\n\tif (isnan(arg1) || isnan(arg2))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * atan2d maps all inputs to values in the range [-180, 180], so the\n\t * result should always be finite, even if the inputs are infinite.\n\t *\n\t * Note: this coding assumes that atan(1.0) is a suitable scaling constant\n\t * to get an exact result from atan2().  This might well fail on us at\n\t * some point, requiring us to decide exactly what inputs we think we're\n\t * going to guarantee an exact result for.\n\t */\n\tatan2_arg1_arg2 = atan2(arg1, arg2);\n\tresult = (atan2_arg1_arg2 / atan_1_0) * 45.0;\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static float8 atan_1_0 = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "false",
            "true"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atan2",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DEGREE_CONSTANTS",
          "args": [],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg2"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 atan_1_0 = 0;\n\nDatum\ndatan2d(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\tvolatile float8 atan2_arg1_arg2;\n\n\t/* Per the POSIX spec, return NaN if either input is NaN */\n\tif (isnan(arg1) || isnan(arg2))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * atan2d maps all inputs to values in the range [-180, 180], so the\n\t * result should always be finite, even if the inputs are infinite.\n\t *\n\t * Note: this coding assumes that atan(1.0) is a suitable scaling constant\n\t * to get an exact result from atan2().  This might well fail on us at\n\t * some point, requiring us to decide exactly what inputs we think we're\n\t * going to guarantee an exact result for.\n\t */\n\tatan2_arg1_arg2 = atan2(arg1, arg2);\n\tresult = (atan2_arg1_arg2 / atan_1_0) * 45.0;\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "datand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2215-2239",
    "snippet": "Datum\ndatand(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tvolatile float8 atan_arg1;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse tangent function maps all inputs to\n\t * values in the range [-90, 90], so the result should always be finite,\n\t * even if the input is infinite.  Additionally, we take care to ensure\n\t * than when arg1 is 1, the result is exactly 45.\n\t */\n\tatan_arg1 = atan(arg1);\n\tresult = (atan_arg1 / atan_1_0) * 45.0;\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static float8 atan_1_0 = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "false",
            "true"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atan",
          "args": [
            "arg1"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "datan2d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2245-2273",
          "snippet": "Datum\ndatan2d(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\tvolatile float8 atan2_arg1_arg2;\n\n\t/* Per the POSIX spec, return NaN if either input is NaN */\n\tif (isnan(arg1) || isnan(arg2))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * atan2d maps all inputs to values in the range [-180, 180], so the\n\t * result should always be finite, even if the inputs are infinite.\n\t *\n\t * Note: this coding assumes that atan(1.0) is a suitable scaling constant\n\t * to get an exact result from atan2().  This might well fail on us at\n\t * some point, requiring us to decide exactly what inputs we think we're\n\t * going to guarantee an exact result for.\n\t */\n\tatan2_arg1_arg2 = atan2(arg1, arg2);\n\tresult = (atan2_arg1_arg2 / atan_1_0) * 45.0;\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float8 atan_1_0 = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 atan_1_0 = 0;\n\nDatum\ndatan2d(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\tvolatile float8 atan2_arg1_arg2;\n\n\t/* Per the POSIX spec, return NaN if either input is NaN */\n\tif (isnan(arg1) || isnan(arg2))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * atan2d maps all inputs to values in the range [-180, 180], so the\n\t * result should always be finite, even if the inputs are infinite.\n\t *\n\t * Note: this coding assumes that atan(1.0) is a suitable scaling constant\n\t * to get an exact result from atan2().  This might well fail on us at\n\t * some point, requiring us to decide exactly what inputs we think we're\n\t * going to guarantee an exact result for.\n\t */\n\tatan2_arg1_arg2 = atan2(arg1, arg2);\n\tresult = (atan2_arg1_arg2 / atan_1_0) * 45.0;\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DEGREE_CONSTANTS",
          "args": [],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 atan_1_0 = 0;\n\nDatum\ndatand(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tvolatile float8 atan_arg1;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse tangent function maps all inputs to\n\t * values in the range [-90, 90], so the result should always be finite,\n\t * even if the input is infinite.  Additionally, we take care to ensure\n\t * than when arg1 is 1, the result is exactly 45.\n\t */\n\tatan_arg1 = atan(arg1);\n\tresult = (atan_arg1 / atan_1_0) * 45.0;\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dasind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2180-2209",
    "snippet": "Datum\ndasind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse sine function maps values in the\n\t * range [-1, 1] to values in the range [-90, 90], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = asind_q1(arg1);\n\telse\n\t\tresult = -asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "false",
            "true"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asind_q1",
          "args": [
            "-arg1"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "asind_q1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2085-2106",
          "snippet": "static double\nasind_q1(double x)\n{\n\t/*\n\t * Stitch together inverse sine and cosine functions for the ranges [0,\n\t * 0.5] and (0.5, 1].  Each expression below is guaranteed to return\n\t * exactly 30 for x=0.5, so the result is a continuous monotonic function\n\t * over the full range.\n\t */\n\tif (x <= 0.5)\n\t{\n\t\tvolatile float8 asin_x = asin(x);\n\n\t\treturn (asin_x / asin_0_5) * 30.0;\n\t}\n\telse\n\t{\n\t\tvolatile float8 acos_x = acos(x);\n\n\t\treturn 90.0 - (acos_x / acos_0_5) * 60.0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float8 asin_0_5 = 0;",
            "static float8 acos_0_5 = 0;",
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 asin_0_5 = 0;\nstatic float8 acos_0_5 = 0;\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\nasind_q1(double x)\n{\n\t/*\n\t * Stitch together inverse sine and cosine functions for the ranges [0,\n\t * 0.5] and (0.5, 1].  Each expression below is guaranteed to return\n\t * exactly 30 for x=0.5, so the result is a continuous monotonic function\n\t * over the full range.\n\t */\n\tif (x <= 0.5)\n\t{\n\t\tvolatile float8 asin_x = asin(x);\n\n\t\treturn (asin_x / asin_0_5) * 30.0;\n\t}\n\telse\n\t{\n\t\tvolatile float8 acos_x = acos(x);\n\n\t\treturn 90.0 - (acos_x / acos_0_5) * 60.0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\"))"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"input is out of range\""
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DEGREE_CONSTANTS",
          "args": [],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndasind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse sine function maps values in the\n\t * range [-1, 1] to values in the range [-90, 90], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = asind_q1(arg1);\n\telse\n\t\tresult = -asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dacosd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2145-2174",
    "snippet": "Datum\ndacosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse cosine function maps values in the\n\t * range [-1, 1] to values in the range [0, 180], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = acosd_q1(arg1);\n\telse\n\t\tresult = 90.0 + asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "false",
            "true"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asind_q1",
          "args": [
            "-arg1"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "asind_q1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2085-2106",
          "snippet": "static double\nasind_q1(double x)\n{\n\t/*\n\t * Stitch together inverse sine and cosine functions for the ranges [0,\n\t * 0.5] and (0.5, 1].  Each expression below is guaranteed to return\n\t * exactly 30 for x=0.5, so the result is a continuous monotonic function\n\t * over the full range.\n\t */\n\tif (x <= 0.5)\n\t{\n\t\tvolatile float8 asin_x = asin(x);\n\n\t\treturn (asin_x / asin_0_5) * 30.0;\n\t}\n\telse\n\t{\n\t\tvolatile float8 acos_x = acos(x);\n\n\t\treturn 90.0 - (acos_x / acos_0_5) * 60.0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float8 asin_0_5 = 0;",
            "static float8 acos_0_5 = 0;",
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 asin_0_5 = 0;\nstatic float8 acos_0_5 = 0;\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\nasind_q1(double x)\n{\n\t/*\n\t * Stitch together inverse sine and cosine functions for the ranges [0,\n\t * 0.5] and (0.5, 1].  Each expression below is guaranteed to return\n\t * exactly 30 for x=0.5, so the result is a continuous monotonic function\n\t * over the full range.\n\t */\n\tif (x <= 0.5)\n\t{\n\t\tvolatile float8 asin_x = asin(x);\n\n\t\treturn (asin_x / asin_0_5) * 30.0;\n\t}\n\telse\n\t{\n\t\tvolatile float8 acos_x = acos(x);\n\n\t\treturn 90.0 - (acos_x / acos_0_5) * 60.0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "acosd_q1",
          "args": [
            "arg1"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "acosd_q1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2118-2139",
          "snippet": "static double\nacosd_q1(double x)\n{\n\t/*\n\t * Stitch together inverse sine and cosine functions for the ranges [0,\n\t * 0.5] and (0.5, 1].  Each expression below is guaranteed to return\n\t * exactly 60 for x=0.5, so the result is a continuous monotonic function\n\t * over the full range.\n\t */\n\tif (x <= 0.5)\n\t{\n\t\tvolatile float8 asin_x = asin(x);\n\n\t\treturn 90.0 - (asin_x / asin_0_5) * 30.0;\n\t}\n\telse\n\t{\n\t\tvolatile float8 acos_x = acos(x);\n\n\t\treturn (acos_x / acos_0_5) * 60.0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float8 asin_0_5 = 0;",
            "static float8 acos_0_5 = 0;",
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 asin_0_5 = 0;\nstatic float8 acos_0_5 = 0;\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\nacosd_q1(double x)\n{\n\t/*\n\t * Stitch together inverse sine and cosine functions for the ranges [0,\n\t * 0.5] and (0.5, 1].  Each expression below is guaranteed to return\n\t * exactly 60 for x=0.5, so the result is a continuous monotonic function\n\t * over the full range.\n\t */\n\tif (x <= 0.5)\n\t{\n\t\tvolatile float8 asin_x = asin(x);\n\n\t\treturn 90.0 - (asin_x / asin_0_5) * 30.0;\n\t}\n\telse\n\t{\n\t\tvolatile float8 acos_x = acos(x);\n\n\t\treturn (acos_x / acos_0_5) * 60.0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\"))"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"input is out of range\""
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DEGREE_CONSTANTS",
          "args": [],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndacosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse cosine function maps values in the\n\t * range [-1, 1] to values in the range [0, 180], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = acosd_q1(arg1);\n\telse\n\t\tresult = 90.0 + asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "acosd_q1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2118-2139",
    "snippet": "static double\nacosd_q1(double x)\n{\n\t/*\n\t * Stitch together inverse sine and cosine functions for the ranges [0,\n\t * 0.5] and (0.5, 1].  Each expression below is guaranteed to return\n\t * exactly 60 for x=0.5, so the result is a continuous monotonic function\n\t * over the full range.\n\t */\n\tif (x <= 0.5)\n\t{\n\t\tvolatile float8 asin_x = asin(x);\n\n\t\treturn 90.0 - (asin_x / asin_0_5) * 30.0;\n\t}\n\telse\n\t{\n\t\tvolatile float8 acos_x = acos(x);\n\n\t\treturn (acos_x / acos_0_5) * 60.0;\n\t}\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static float8 asin_0_5 = 0;",
      "static float8 acos_0_5 = 0;",
      "static double sind_q1(double x);",
      "static double cosd_q1(double x);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "acos",
          "args": [
            "x"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "dacosd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2145-2174",
          "snippet": "Datum\ndacosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse cosine function maps values in the\n\t * range [-1, 1] to values in the range [0, 180], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = acosd_q1(arg1);\n\telse\n\t\tresult = 90.0 + asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndacosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse cosine function maps values in the\n\t * range [-1, 1] to values in the range [0, 180], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = acosd_q1(arg1);\n\telse\n\t\tresult = 90.0 + asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "asin",
          "args": [
            "x"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "dasind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2180-2209",
          "snippet": "Datum\ndasind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse sine function maps values in the\n\t * range [-1, 1] to values in the range [-90, 90], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = asind_q1(arg1);\n\telse\n\t\tresult = -asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndasind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse sine function maps values in the\n\t * range [-1, 1] to values in the range [-90, 90], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = asind_q1(arg1);\n\telse\n\t\tresult = -asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 asin_0_5 = 0;\nstatic float8 acos_0_5 = 0;\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\nacosd_q1(double x)\n{\n\t/*\n\t * Stitch together inverse sine and cosine functions for the ranges [0,\n\t * 0.5] and (0.5, 1].  Each expression below is guaranteed to return\n\t * exactly 60 for x=0.5, so the result is a continuous monotonic function\n\t * over the full range.\n\t */\n\tif (x <= 0.5)\n\t{\n\t\tvolatile float8 asin_x = asin(x);\n\n\t\treturn 90.0 - (asin_x / asin_0_5) * 30.0;\n\t}\n\telse\n\t{\n\t\tvolatile float8 acos_x = acos(x);\n\n\t\treturn (acos_x / acos_0_5) * 60.0;\n\t}\n}"
  },
  {
    "function_name": "asind_q1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2085-2106",
    "snippet": "static double\nasind_q1(double x)\n{\n\t/*\n\t * Stitch together inverse sine and cosine functions for the ranges [0,\n\t * 0.5] and (0.5, 1].  Each expression below is guaranteed to return\n\t * exactly 30 for x=0.5, so the result is a continuous monotonic function\n\t * over the full range.\n\t */\n\tif (x <= 0.5)\n\t{\n\t\tvolatile float8 asin_x = asin(x);\n\n\t\treturn (asin_x / asin_0_5) * 30.0;\n\t}\n\telse\n\t{\n\t\tvolatile float8 acos_x = acos(x);\n\n\t\treturn 90.0 - (acos_x / acos_0_5) * 60.0;\n\t}\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static float8 asin_0_5 = 0;",
      "static float8 acos_0_5 = 0;",
      "static double sind_q1(double x);",
      "static double cosd_q1(double x);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "acos",
          "args": [
            "x"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "dacosd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2145-2174",
          "snippet": "Datum\ndacosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse cosine function maps values in the\n\t * range [-1, 1] to values in the range [0, 180], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = acosd_q1(arg1);\n\telse\n\t\tresult = 90.0 + asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndacosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse cosine function maps values in the\n\t * range [-1, 1] to values in the range [0, 180], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = acosd_q1(arg1);\n\telse\n\t\tresult = 90.0 + asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "asin",
          "args": [
            "x"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "dasind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2180-2209",
          "snippet": "Datum\ndasind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse sine function maps values in the\n\t * range [-1, 1] to values in the range [-90, 90], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = asind_q1(arg1);\n\telse\n\t\tresult = -asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndasind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse sine function maps values in the\n\t * range [-1, 1] to values in the range [-90, 90], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = asind_q1(arg1);\n\telse\n\t\tresult = -asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 asin_0_5 = 0;\nstatic float8 acos_0_5 = 0;\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\nasind_q1(double x)\n{\n\t/*\n\t * Stitch together inverse sine and cosine functions for the ranges [0,\n\t * 0.5] and (0.5, 1].  Each expression below is guaranteed to return\n\t * exactly 30 for x=0.5, so the result is a continuous monotonic function\n\t * over the full range.\n\t */\n\tif (x <= 0.5)\n\t{\n\t\tvolatile float8 asin_x = asin(x);\n\n\t\treturn (asin_x / asin_0_5) * 30.0;\n\t}\n\telse\n\t{\n\t\tvolatile float8 acos_x = acos(x);\n\n\t\treturn 90.0 - (acos_x / acos_0_5) * 60.0;\n\t}\n}"
  },
  {
    "function_name": "init_degree_constants",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2056-2067",
    "snippet": "static void\ninit_degree_constants(void)\n{\n\tsin_30 = sin(degree_c_thirty * RADIANS_PER_DEGREE);\n\tone_minus_cos_60 = 1.0 - cos(degree_c_sixty * RADIANS_PER_DEGREE);\n\tasin_0_5 = asin(degree_c_one_half);\n\tacos_0_5 = acos(degree_c_one_half);\n\tatan_1_0 = atan(degree_c_one);\n\ttan_45 = sind_q1(degree_c_forty_five) / cosd_q1(degree_c_forty_five);\n\tcot_45 = cosd_q1(degree_c_forty_five) / sind_q1(degree_c_forty_five);\n\tdegree_consts_set = true;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RADIANS_PER_DEGREE 0.0174532925199432957692"
    ],
    "globals_used": [
      "static bool degree_consts_set = false;",
      "static float8 sin_30 = 0;",
      "static float8 one_minus_cos_60 = 0;",
      "static float8 asin_0_5 = 0;",
      "static float8 acos_0_5 = 0;",
      "static float8 atan_1_0 = 0;",
      "static float8 tan_45 = 0;",
      "static float8 cot_45 = 0;",
      "float8\t\tdegree_c_thirty = 30.0;",
      "float8\t\tdegree_c_forty_five = 45.0;",
      "float8\t\tdegree_c_sixty = 60.0;",
      "float8\t\tdegree_c_one_half = 0.5;",
      "float8\t\tdegree_c_one = 1.0;",
      "static void init_degree_constants(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sind_q1",
          "args": [
            "degree_c_forty_five"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "sind_q1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2308-2321",
          "snippet": "static double\nsind_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 30]\n\t * and (30, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 30 and 90 degrees.\n\t */\n\tif (x <= 30.0)\n\t\treturn sind_0_to_30(x);\n\telse\n\t\treturn cosd_0_to_60(90.0 - x);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\nsind_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 30]\n\t * and (30, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 30 and 90 degrees.\n\t */\n\tif (x <= 30.0)\n\t\treturn sind_0_to_30(x);\n\telse\n\t\treturn cosd_0_to_60(90.0 - x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cosd_q1",
          "args": [
            "degree_c_forty_five"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "cosd_q1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2328-2341",
          "snippet": "static double\ncosd_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 60]\n\t * and (60, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 60 and 90 degrees.\n\t */\n\tif (x <= 60.0)\n\t\treturn cosd_0_to_60(x);\n\telse\n\t\treturn sind_0_to_30(90.0 - x);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\ncosd_q1(double x)\n{\n\t/*\n\t * Stitch together the sine and cosine functions for the ranges [0, 60]\n\t * and (60, 90].  These guarantee to return exact answers at their\n\t * endpoints, so the overall result is a continuous monotonic function\n\t * that gives exact results when x = 0, 60 and 90 degrees.\n\t */\n\tif (x <= 60.0)\n\t\treturn cosd_0_to_60(x);\n\telse\n\t\treturn sind_0_to_30(90.0 - x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atan",
          "args": [
            "degree_c_one"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "datan2d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2245-2273",
          "snippet": "Datum\ndatan2d(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\tvolatile float8 atan2_arg1_arg2;\n\n\t/* Per the POSIX spec, return NaN if either input is NaN */\n\tif (isnan(arg1) || isnan(arg2))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * atan2d maps all inputs to values in the range [-180, 180], so the\n\t * result should always be finite, even if the inputs are infinite.\n\t *\n\t * Note: this coding assumes that atan(1.0) is a suitable scaling constant\n\t * to get an exact result from atan2().  This might well fail on us at\n\t * some point, requiring us to decide exactly what inputs we think we're\n\t * going to guarantee an exact result for.\n\t */\n\tatan2_arg1_arg2 = atan2(arg1, arg2);\n\tresult = (atan2_arg1_arg2 / atan_1_0) * 45.0;\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float8 atan_1_0 = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 atan_1_0 = 0;\n\nDatum\ndatan2d(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\tvolatile float8 atan2_arg1_arg2;\n\n\t/* Per the POSIX spec, return NaN if either input is NaN */\n\tif (isnan(arg1) || isnan(arg2))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * atan2d maps all inputs to values in the range [-180, 180], so the\n\t * result should always be finite, even if the inputs are infinite.\n\t *\n\t * Note: this coding assumes that atan(1.0) is a suitable scaling constant\n\t * to get an exact result from atan2().  This might well fail on us at\n\t * some point, requiring us to decide exactly what inputs we think we're\n\t * going to guarantee an exact result for.\n\t */\n\tatan2_arg1_arg2 = atan2(arg1, arg2);\n\tresult = (atan2_arg1_arg2 / atan_1_0) * 45.0;\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "acos",
          "args": [
            "degree_c_one_half"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "dacosd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2145-2174",
          "snippet": "Datum\ndacosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse cosine function maps values in the\n\t * range [-1, 1] to values in the range [0, 180], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = acosd_q1(arg1);\n\telse\n\t\tresult = 90.0 + asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndacosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse cosine function maps values in the\n\t * range [-1, 1] to values in the range [0, 180], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = acosd_q1(arg1);\n\telse\n\t\tresult = 90.0 + asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "asin",
          "args": [
            "degree_c_one_half"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "dasind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2180-2209",
          "snippet": "Datum\ndasind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse sine function maps values in the\n\t * range [-1, 1] to values in the range [-90, 90], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = asind_q1(arg1);\n\telse\n\t\tresult = -asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndasind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse sine function maps values in the\n\t * range [-1, 1] to values in the range [-90, 90], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = asind_q1(arg1);\n\telse\n\t\tresult = -asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cos",
          "args": [
            "degree_c_sixty * RADIANS_PER_DEGREE"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "dcosd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2347-2394",
          "snippet": "Datum\ndcosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* cosd(-x) = cosd(x) */\n\t\targ1 = -arg1;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* cosd(360-x) = cosd(x) */\n\t\targ1 = 360.0 - arg1;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* cosd(180-x) = -cosd(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tresult = sign * cosd_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nDatum\ndcosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* cosd(-x) = cosd(x) */\n\t\targ1 = -arg1;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* cosd(360-x) = cosd(x) */\n\t\targ1 = 360.0 - arg1;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* cosd(180-x) = -cosd(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tresult = sign * cosd_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sin",
          "args": [
            "degree_c_thirty * RADIANS_PER_DEGREE"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "dsind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2465-2513",
          "snippet": "Datum\ndsind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* sind(-x) = -sind(x) */\n\t\targ1 = -arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* sind(360-x) = -sind(x) */\n\t\targ1 = 360.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* sind(180-x) = sind(x) */\n\t\targ1 = 180.0 - arg1;\n\t}\n\n\tresult = sign * sind_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nDatum\ndsind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* sind(-x) = -sind(x) */\n\t\targ1 = -arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* sind(360-x) = -sind(x) */\n\t\targ1 = 360.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* sind(180-x) = sind(x) */\n\t\targ1 = 180.0 - arg1;\n\t}\n\n\tresult = sign * sind_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define RADIANS_PER_DEGREE 0.0174532925199432957692\n\nstatic bool degree_consts_set = false;\nstatic float8 sin_30 = 0;\nstatic float8 one_minus_cos_60 = 0;\nstatic float8 asin_0_5 = 0;\nstatic float8 acos_0_5 = 0;\nstatic float8 atan_1_0 = 0;\nstatic float8 tan_45 = 0;\nstatic float8 cot_45 = 0;\nfloat8\t\tdegree_c_thirty = 30.0;\nfloat8\t\tdegree_c_forty_five = 45.0;\nfloat8\t\tdegree_c_sixty = 60.0;\nfloat8\t\tdegree_c_one_half = 0.5;\nfloat8\t\tdegree_c_one = 1.0;\nstatic void init_degree_constants(void);\n\nstatic void\ninit_degree_constants(void)\n{\n\tsin_30 = sin(degree_c_thirty * RADIANS_PER_DEGREE);\n\tone_minus_cos_60 = 1.0 - cos(degree_c_sixty * RADIANS_PER_DEGREE);\n\tasin_0_5 = asin(degree_c_one_half);\n\tacos_0_5 = acos(degree_c_one_half);\n\tatan_1_0 = atan(degree_c_one);\n\ttan_45 = sind_q1(degree_c_forty_five) / cosd_q1(degree_c_forty_five);\n\tcot_45 = cosd_q1(degree_c_forty_five) / sind_q1(degree_c_forty_five);\n\tdegree_consts_set = true;\n}"
  },
  {
    "function_name": "dtan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "2002-2022",
    "snippet": "Datum\ndtan(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\t/* Be sure to throw an error if the input is infinite --- see dcos() */\n\terrno = 0;\n\tresult = tan(arg1);\n\tif (errno != 0 || isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tCHECKFLOATVAL(result, true /* tan(pi/2) == Inf */ , true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "true/* tan(pi/2) == Inf */",
            "true"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\"))"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"input is out of range\""
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tan",
          "args": [
            "arg1"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "dtand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2519-2578",
          "snippet": "Datum\ndtand(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tvolatile float8 tan_arg1;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* tand(-x) = -tand(x) */\n\t\targ1 = -arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* tand(360-x) = -tand(x) */\n\t\targ1 = 360.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* tand(180-x) = -tand(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\ttan_arg1 = sind_q1(arg1) / cosd_q1(arg1);\n\tresult = sign * (tan_arg1 / tan_45);\n\n\t/*\n\t * On some machines we get tand(180) = minus zero, but this isn't always\n\t * true.  For portability, and because the user constituency for this\n\t * function probably doesn't want minus zero, force it to plain zero.\n\t */\n\tif (result == 0.0)\n\t\tresult = 0.0;\n\n\tCHECKFLOATVAL(result, true /* tand(90) == Inf */ , true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float8 tan_45 = 0;",
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 tan_45 = 0;\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nDatum\ndtand(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tvolatile float8 tan_arg1;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* tand(-x) = -tand(x) */\n\t\targ1 = -arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* tand(360-x) = -tand(x) */\n\t\targ1 = 360.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* tand(180-x) = -tand(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\ttan_arg1 = sind_q1(arg1) / cosd_q1(arg1);\n\tresult = sign * (tan_arg1 / tan_45);\n\n\t/*\n\t * On some machines we get tand(180) = minus zero, but this isn't always\n\t * true.  For portability, and because the user constituency for this\n\t * function probably doesn't want minus zero, force it to plain zero.\n\t */\n\tif (result == 0.0)\n\t\tresult = 0.0;\n\n\tCHECKFLOATVAL(result, true /* tand(90) == Inf */ , true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndtan(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\t/* Be sure to throw an error if the input is infinite --- see dcos() */\n\terrno = 0;\n\tresult = tan(arg1);\n\tif (errno != 0 || isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tCHECKFLOATVAL(result, true /* tan(pi/2) == Inf */ , true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dsin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1976-1996",
    "snippet": "Datum\ndsin(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\t/* Be sure to throw an error if the input is infinite --- see dcos() */\n\terrno = 0;\n\tresult = sin(arg1);\n\tif (errno != 0 || isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "false",
            "true"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\"))"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"input is out of range\""
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sin",
          "args": [
            "arg1"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "dsind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2465-2513",
          "snippet": "Datum\ndsind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* sind(-x) = -sind(x) */\n\t\targ1 = -arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* sind(360-x) = -sind(x) */\n\t\targ1 = 360.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* sind(180-x) = sind(x) */\n\t\targ1 = 180.0 - arg1;\n\t}\n\n\tresult = sign * sind_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nDatum\ndsind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* sind(-x) = -sind(x) */\n\t\targ1 = -arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* sind(360-x) = -sind(x) */\n\t\targ1 = 360.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* sind(180-x) = sind(x) */\n\t\targ1 = 180.0 - arg1;\n\t}\n\n\tresult = sign * sind_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndsin(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\t/* Be sure to throw an error if the input is infinite --- see dcos() */\n\terrno = 0;\n\tresult = sin(arg1);\n\tif (errno != 0 || isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dcot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1949-1970",
    "snippet": "Datum\ndcot(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\t/* Be sure to throw an error if the input is infinite --- see dcos() */\n\terrno = 0;\n\tresult = tan(arg1);\n\tif (errno != 0 || isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tresult = 1.0 / result;\n\tCHECKFLOATVAL(result, true /* cot(0) == Inf */ , true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "true/* cot(0) == Inf */",
            "true"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\"))"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"input is out of range\""
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tan",
          "args": [
            "arg1"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "dtand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2519-2578",
          "snippet": "Datum\ndtand(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tvolatile float8 tan_arg1;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* tand(-x) = -tand(x) */\n\t\targ1 = -arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* tand(360-x) = -tand(x) */\n\t\targ1 = 360.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* tand(180-x) = -tand(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\ttan_arg1 = sind_q1(arg1) / cosd_q1(arg1);\n\tresult = sign * (tan_arg1 / tan_45);\n\n\t/*\n\t * On some machines we get tand(180) = minus zero, but this isn't always\n\t * true.  For portability, and because the user constituency for this\n\t * function probably doesn't want minus zero, force it to plain zero.\n\t */\n\tif (result == 0.0)\n\t\tresult = 0.0;\n\n\tCHECKFLOATVAL(result, true /* tand(90) == Inf */ , true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float8 tan_45 = 0;",
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 tan_45 = 0;\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nDatum\ndtand(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tvolatile float8 tan_arg1;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* tand(-x) = -tand(x) */\n\t\targ1 = -arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* tand(360-x) = -tand(x) */\n\t\targ1 = 360.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* tand(180-x) = -tand(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\ttan_arg1 = sind_q1(arg1) / cosd_q1(arg1);\n\tresult = sign * (tan_arg1 / tan_45);\n\n\t/*\n\t * On some machines we get tand(180) = minus zero, but this isn't always\n\t * true.  For portability, and because the user constituency for this\n\t * function probably doesn't want minus zero, force it to plain zero.\n\t */\n\tif (result == 0.0)\n\t\tresult = 0.0;\n\n\tCHECKFLOATVAL(result, true /* tand(90) == Inf */ , true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndcot(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\t/* Be sure to throw an error if the input is infinite --- see dcos() */\n\terrno = 0;\n\tresult = tan(arg1);\n\tif (errno != 0 || isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tresult = 1.0 / result;\n\tCHECKFLOATVAL(result, true /* cot(0) == Inf */ , true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dcos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1909-1943",
    "snippet": "Datum\ndcos(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\t/*\n\t * cos() is periodic and so theoretically can work for all finite inputs,\n\t * but some implementations may choose to throw error if the input is so\n\t * large that there are no significant digits in the result.  So we should\n\t * check for errors.  POSIX allows an error to be reported either via\n\t * errno or via fetestexcept(), but currently we only support checking\n\t * errno.  (fetestexcept() is rumored to report underflow unreasonably\n\t * early on some platforms, so it's not clear that believing it would be a\n\t * net improvement anyway.)\n\t *\n\t * For infinite inputs, POSIX specifies that the trigonometric functions\n\t * should return a domain error; but we won't notice that unless the\n\t * platform reports via errno, so also explicitly test for infinite\n\t * inputs.\n\t */\n\terrno = 0;\n\tresult = cos(arg1);\n\tif (errno != 0 || isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "false",
            "true"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\"))"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"input is out of range\""
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cos",
          "args": [
            "arg1"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "dcosd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2347-2394",
          "snippet": "Datum\ndcosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* cosd(-x) = cosd(x) */\n\t\targ1 = -arg1;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* cosd(360-x) = cosd(x) */\n\t\targ1 = 360.0 - arg1;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* cosd(180-x) = -cosd(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tresult = sign * cosd_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nDatum\ndcosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* cosd(-x) = cosd(x) */\n\t\targ1 = -arg1;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* cosd(360-x) = cosd(x) */\n\t\targ1 = 360.0 - arg1;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* cosd(180-x) = -cosd(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tresult = sign * cosd_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndcos(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\t/*\n\t * cos() is periodic and so theoretically can work for all finite inputs,\n\t * but some implementations may choose to throw error if the input is so\n\t * large that there are no significant digits in the result.  So we should\n\t * check for errors.  POSIX allows an error to be reported either via\n\t * errno or via fetestexcept(), but currently we only support checking\n\t * errno.  (fetestexcept() is rumored to report underflow unreasonably\n\t * early on some platforms, so it's not clear that believing it would be a\n\t * net improvement anyway.)\n\t *\n\t * For infinite inputs, POSIX specifies that the trigonometric functions\n\t * should return a domain error; but we won't notice that unless the\n\t * platform reports via errno, so also explicitly test for infinite\n\t * inputs.\n\t */\n\terrno = 0;\n\tresult = cos(arg1);\n\tif (errno != 0 || isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "datan2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1884-1903",
    "snippet": "Datum\ndatan2(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if either input is NaN */\n\tif (isnan(arg1) || isnan(arg2))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\t/*\n\t * atan2 maps all inputs to values in the range [-Pi, Pi], so the result\n\t * should always be finite, even if the inputs are infinite.\n\t */\n\tresult = atan2(arg1, arg2);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "false",
            "true"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atan2",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg2"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndatan2(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if either input is NaN */\n\tif (isnan(arg1) || isnan(arg2))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\t/*\n\t * atan2 maps all inputs to values in the range [-Pi, Pi], so the result\n\t * should always be finite, even if the inputs are infinite.\n\t */\n\tresult = atan2(arg1, arg2);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "datan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1859-1878",
    "snippet": "Datum\ndatan(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\t/*\n\t * The principal branch of the inverse tangent function maps all inputs to\n\t * values in the range [-Pi/2, Pi/2], so the result should always be\n\t * finite, even if the input is infinite.\n\t */\n\tresult = atan(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "false",
            "true"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atan",
          "args": [
            "arg1"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "datan2d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2245-2273",
          "snippet": "Datum\ndatan2d(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\tvolatile float8 atan2_arg1_arg2;\n\n\t/* Per the POSIX spec, return NaN if either input is NaN */\n\tif (isnan(arg1) || isnan(arg2))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * atan2d maps all inputs to values in the range [-180, 180], so the\n\t * result should always be finite, even if the inputs are infinite.\n\t *\n\t * Note: this coding assumes that atan(1.0) is a suitable scaling constant\n\t * to get an exact result from atan2().  This might well fail on us at\n\t * some point, requiring us to decide exactly what inputs we think we're\n\t * going to guarantee an exact result for.\n\t */\n\tatan2_arg1_arg2 = atan2(arg1, arg2);\n\tresult = (atan2_arg1_arg2 / atan_1_0) * 45.0;\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float8 atan_1_0 = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic float8 atan_1_0 = 0;\n\nDatum\ndatan2d(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\tvolatile float8 atan2_arg1_arg2;\n\n\t/* Per the POSIX spec, return NaN if either input is NaN */\n\tif (isnan(arg1) || isnan(arg2))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * atan2d maps all inputs to values in the range [-180, 180], so the\n\t * result should always be finite, even if the inputs are infinite.\n\t *\n\t * Note: this coding assumes that atan(1.0) is a suitable scaling constant\n\t * to get an exact result from atan2().  This might well fail on us at\n\t * some point, requiring us to decide exactly what inputs we think we're\n\t * going to guarantee an exact result for.\n\t */\n\tatan2_arg1_arg2 = atan2(arg1, arg2);\n\tresult = (atan2_arg1_arg2 / atan_1_0) * 45.0;\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndatan(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\t/*\n\t * The principal branch of the inverse tangent function maps all inputs to\n\t * values in the range [-Pi/2, Pi/2], so the result should always be\n\t * finite, even if the input is infinite.\n\t */\n\tresult = atan(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dasin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1829-1853",
    "snippet": "Datum\ndasin(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\t/*\n\t * The principal branch of the inverse sine function maps values in the\n\t * range [-1, 1] to values in the range [-Pi/2, Pi/2], so we should reject\n\t * any inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tresult = asin(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "false",
            "true"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asin",
          "args": [
            "arg1"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "dasind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2180-2209",
          "snippet": "Datum\ndasind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse sine function maps values in the\n\t * range [-1, 1] to values in the range [-90, 90], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = asind_q1(arg1);\n\telse\n\t\tresult = -asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndasind(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse sine function maps values in the\n\t * range [-1, 1] to values in the range [-90, 90], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = asind_q1(arg1);\n\telse\n\t\tresult = -asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\"))"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"input is out of range\""
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndasin(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\t/*\n\t * The principal branch of the inverse sine function maps values in the\n\t * range [-1, 1] to values in the range [-Pi/2, Pi/2], so we should reject\n\t * any inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tresult = asin(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dacos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1799-1823",
    "snippet": "Datum\ndacos(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\t/*\n\t * The principal branch of the inverse cosine function maps values in the\n\t * range [-1, 1] to values in the range [0, Pi], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tresult = acos(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "false",
            "true"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acos",
          "args": [
            "arg1"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "dacosd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2145-2174",
          "snippet": "Datum\ndacosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse cosine function maps values in the\n\t * range [-1, 1] to values in the range [0, 180], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = acosd_q1(arg1);\n\telse\n\t\tresult = 90.0 + asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndacosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/*\n\t * The principal branch of the inverse cosine function maps values in the\n\t * range [-1, 1] to values in the range [0, 180], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tif (arg1 >= 0.0)\n\t\tresult = acosd_q1(arg1);\n\telse\n\t\tresult = 90.0 + asind_q1(-arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\"))"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"input is out of range\""
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndacos(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/* Per the POSIX spec, return NaN if the input is NaN */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\t/*\n\t * The principal branch of the inverse cosine function maps values in the\n\t * range [-1, 1] to values in the range [0, Pi], so we should reject any\n\t * inputs outside that range and the result will always be finite.\n\t */\n\tif (arg1 < -1.0 || arg1 > 1.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tresult = acos(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dlog10",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1769-1793",
    "snippet": "Datum\ndlog10(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/*\n\t * Emit particular SQLSTATE error codes for log(). The SQL spec doesn't\n\t * define log(), but it does define ln(), so it makes sense to emit the\n\t * same error code for an analogous error condition.\n\t */\n\tif (arg1 == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of zero\")));\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of a negative number\")));\n\n\tresult = log10(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 1);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1)",
            "arg1 == 1"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log10",
          "args": [
            "arg1"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "dlog10",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1769-1793",
          "snippet": "Datum\ndlog10(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/*\n\t * Emit particular SQLSTATE error codes for log(). The SQL spec doesn't\n\t * define log(), but it does define ln(), so it makes sense to emit the\n\t * same error code for an analogous error condition.\n\t */\n\tif (arg1 == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of zero\")));\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of a negative number\")));\n\n\tresult = log10(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 1);\n\tPG_RETURN_FLOAT8(result);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of a negative number\"))"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot take logarithm of a negative number\""
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_ARGUMENT_FOR_LOG"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of zero\"))"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndlog10(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/*\n\t * Emit particular SQLSTATE error codes for log(). The SQL spec doesn't\n\t * define log(), but it does define ln(), so it makes sense to emit the\n\t * same error code for an analogous error condition.\n\t */\n\tif (arg1 == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of zero\")));\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of a negative number\")));\n\n\tresult = log10(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 1);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dlog1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1740-1763",
    "snippet": "Datum\ndlog1(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/*\n\t * Emit particular SQLSTATE error codes for ln(). This is required by the\n\t * SQL standard.\n\t */\n\tif (arg1 == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of zero\")));\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of a negative number\")));\n\n\tresult = log(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 1);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1)",
            "arg1 == 1"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "arg1"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "dlog10",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1769-1793",
          "snippet": "Datum\ndlog10(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/*\n\t * Emit particular SQLSTATE error codes for log(). The SQL spec doesn't\n\t * define log(), but it does define ln(), so it makes sense to emit the\n\t * same error code for an analogous error condition.\n\t */\n\tif (arg1 == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of zero\")));\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of a negative number\")));\n\n\tresult = log10(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 1);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndlog10(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/*\n\t * Emit particular SQLSTATE error codes for log(). The SQL spec doesn't\n\t * define log(), but it does define ln(), so it makes sense to emit the\n\t * same error code for an analogous error condition.\n\t */\n\tif (arg1 == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of zero\")));\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of a negative number\")));\n\n\tresult = log10(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 1);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of a negative number\"))"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot take logarithm of a negative number\""
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_ARGUMENT_FOR_LOG"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of zero\"))"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndlog1(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\t/*\n\t * Emit particular SQLSTATE error codes for ln(). This is required by the\n\t * SQL standard.\n\t */\n\tif (arg1 == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of zero\")));\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_LOG),\n\t\t\t\t errmsg(\"cannot take logarithm of a negative number\")));\n\n\tresult = log(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 1);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dexp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1721-1734",
    "snippet": "Datum\ndexp(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\terrno = 0;\n\tresult = exp(arg1);\n\tif (errno == ERANGE && result != 0 && !isinf(result))\n\t\tresult = get_float8_infinity();\n\n\tCHECKFLOATVAL(result, isinf(arg1), false);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1)",
            "false"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_infinity",
          "args": [],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_infinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "117-132",
          "snippet": "double\nget_float8_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (double) INFINITY;\n#else\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (double) (HUGE_VAL * HUGE_VAL);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ndouble\nget_float8_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (double) INFINITY;\n#else\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (double) (HUGE_VAL * HUGE_VAL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "result"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp",
          "args": [
            "arg1"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "dexp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1721-1734",
          "snippet": "Datum\ndexp(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\terrno = 0;\n\tresult = exp(arg1);\n\tif (errno == ERANGE && result != 0 && !isinf(result))\n\t\tresult = get_float8_infinity();\n\n\tCHECKFLOATVAL(result, isinf(arg1), false);\n\tPG_RETURN_FLOAT8(result);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndexp(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\terrno = 0;\n\tresult = exp(arg1);\n\tif (errno == ERANGE && result != 0 && !isinf(result))\n\t\tresult = get_float8_infinity();\n\n\tCHECKFLOATVAL(result, isinf(arg1), false);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dpow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1649-1715",
    "snippet": "Datum\ndpow(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\t/*\n\t * The POSIX spec says that NaN ^ 0 = 1, and 1 ^ NaN = 1, while all other\n\t * cases with NaN inputs yield NaN (with no error).  Many older platforms\n\t * get one or more of these cases wrong, so deal with them via explicit\n\t * logic rather than trusting pow(3).\n\t */\n\tif (isnan(arg1))\n\t{\n\t\tif (isnan(arg2) || arg2 != 0.0)\n\t\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\t\tPG_RETURN_FLOAT8(1.0);\n\t}\n\tif (isnan(arg2))\n\t{\n\t\tif (arg1 != 1.0)\n\t\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\t\tPG_RETURN_FLOAT8(1.0);\n\t}\n\n\t/*\n\t * The SQL spec requires that we emit a particular SQLSTATE error code for\n\t * certain error conditions.  Specifically, we don't return a\n\t * divide-by-zero error code for 0 ^ -1.\n\t */\n\tif (arg1 == 0 && arg2 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"zero raised to a negative power is undefined\")));\n\tif (arg1 < 0 && floor(arg2) != arg2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"a negative number raised to a non-integer power yields a complex result\")));\n\n\t/*\n\t * pow() sets errno only on some platforms, depending on whether it\n\t * follows _IEEE_, _POSIX_, _XOPEN_, or _SVID_, so we try to avoid using\n\t * errno.  However, some platform/CPU combinations return errno == EDOM\n\t * and result == NaN for negative arg1 and very large arg2 (they must be\n\t * using something different from our floor() test to decide it's\n\t * invalid).  Other platforms (HPPA) return errno == ERANGE and a large\n\t * (HUGE_VAL) but finite result to signal overflow.\n\t */\n\terrno = 0;\n\tresult = pow(arg1, arg2);\n\tif (errno == EDOM && isnan(result))\n\t{\n\t\tif ((fabs(arg1) > 1 && arg2 >= 0) || (fabs(arg1) < 1 && arg2 < 0))\n\t\t\t/* The sign of Inf is not significant in this case. */\n\t\t\tresult = get_float8_infinity();\n\t\telse if (fabs(arg1) != 1)\n\t\t\tresult = 0;\n\t\telse\n\t\t\tresult = 1;\n\t}\n\telse if (errno == ERANGE && result != 0 && !isinf(result))\n\t\tresult = get_float8_infinity();\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "arg1 == 0"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_infinity",
          "args": [],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_infinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "117-132",
          "snippet": "double\nget_float8_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (double) INFINITY;\n#else\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (double) (HUGE_VAL * HUGE_VAL);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ndouble\nget_float8_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (double) INFINITY;\n#else\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (double) (HUGE_VAL * HUGE_VAL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "result"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fabs",
          "args": [
            "arg1"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fabs",
          "args": [
            "arg1"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fabs",
          "args": [
            "arg1"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "result"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"a negative number raised to a non-integer power yields a complex result\"))"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"a negative number raised to a non-integer power yields a complex result\""
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "floor",
          "args": [
            "arg2"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "dfloor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1559-1565",
          "snippet": "Datum\ndfloor(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(floor(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndfloor(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(floor(arg1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"zero raised to a negative power is undefined\"))"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "1.0"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg2"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "1.0"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "get_float8_nan()"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg2"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "arg1"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndpow(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\t/*\n\t * The POSIX spec says that NaN ^ 0 = 1, and 1 ^ NaN = 1, while all other\n\t * cases with NaN inputs yield NaN (with no error).  Many older platforms\n\t * get one or more of these cases wrong, so deal with them via explicit\n\t * logic rather than trusting pow(3).\n\t */\n\tif (isnan(arg1))\n\t{\n\t\tif (isnan(arg2) || arg2 != 0.0)\n\t\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\t\tPG_RETURN_FLOAT8(1.0);\n\t}\n\tif (isnan(arg2))\n\t{\n\t\tif (arg1 != 1.0)\n\t\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\t\tPG_RETURN_FLOAT8(1.0);\n\t}\n\n\t/*\n\t * The SQL spec requires that we emit a particular SQLSTATE error code for\n\t * certain error conditions.  Specifically, we don't return a\n\t * divide-by-zero error code for 0 ^ -1.\n\t */\n\tif (arg1 == 0 && arg2 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"zero raised to a negative power is undefined\")));\n\tif (arg1 < 0 && floor(arg2) != arg2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"a negative number raised to a non-integer power yields a complex result\")));\n\n\t/*\n\t * pow() sets errno only on some platforms, depending on whether it\n\t * follows _IEEE_, _POSIX_, _XOPEN_, or _SVID_, so we try to avoid using\n\t * errno.  However, some platform/CPU combinations return errno == EDOM\n\t * and result == NaN for negative arg1 and very large arg2 (they must be\n\t * using something different from our floor() test to decide it's\n\t * invalid).  Other platforms (HPPA) return errno == ERANGE and a large\n\t * (HUGE_VAL) but finite result to signal overflow.\n\t */\n\terrno = 0;\n\tresult = pow(arg1, arg2);\n\tif (errno == EDOM && isnan(result))\n\t{\n\t\tif ((fabs(arg1) > 1 && arg2 >= 0) || (fabs(arg1) < 1 && arg2 < 0))\n\t\t\t/* The sign of Inf is not significant in this case. */\n\t\t\tresult = get_float8_infinity();\n\t\telse if (fabs(arg1) != 1)\n\t\t\tresult = 0;\n\t\telse\n\t\t\tresult = 1;\n\t}\n\telse if (errno == ERANGE && result != 0 && !isinf(result))\n\t\tresult = get_float8_infinity();\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dcbrt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1634-1643",
    "snippet": "Datum\ndcbrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tresult = cbrt(arg1);\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define cbrt my_cbrt"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1)",
            "arg1 == 0"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbrt",
          "args": [
            "arg1"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "cbrt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "3799-3816",
          "snippet": "static double\ncbrt(double x)\n{\n\tint\t\t\tisneg = (x < 0.0);\n\tdouble\t\tabsx = fabs(x);\n\tdouble\t\ttmpres = pow(absx, (double) 1.0 / (double) 3.0);\n\n\t/*\n\t * The result is somewhat inaccurate --- not really pow()'s fault, as the\n\t * exponent it's handed contains roundoff error.  We can improve the\n\t * accuracy by doing one iteration of Newton's formula.  Beware of zero\n\t * input however.\n\t */\n\tif (tmpres > 0.0)\n\t\ttmpres -= (tmpres - absx / (tmpres * tmpres)) / (double) 3.0;\n\n\treturn isneg ? -tmpres : tmpres;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define cbrt my_cbrt"
          ],
          "globals_used": [
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define cbrt my_cbrt\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic double\ncbrt(double x)\n{\n\tint\t\t\tisneg = (x < 0.0);\n\tdouble\t\tabsx = fabs(x);\n\tdouble\t\ttmpres = pow(absx, (double) 1.0 / (double) 3.0);\n\n\t/*\n\t * The result is somewhat inaccurate --- not really pow()'s fault, as the\n\t * exponent it's handed contains roundoff error.  We can improve the\n\t * accuracy by doing one iteration of Newton's formula.  Beware of zero\n\t * input however.\n\t */\n\tif (tmpres > 0.0)\n\t\ttmpres -= (tmpres - absx / (tmpres * tmpres)) / (double) 3.0;\n\n\treturn isneg ? -tmpres : tmpres;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define cbrt my_cbrt\n\nDatum\ndcbrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tresult = cbrt(arg1);\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dsqrt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1613-1628",
    "snippet": "Datum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1)",
            "arg1 == 0"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqrt",
          "args": [
            "arg1"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "dsqrt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1613-1628",
          "snippet": "Datum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\"))"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot take square root of a negative number\""
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dtrunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1595-1607",
    "snippet": "Datum\ndtrunc(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 >= 0)\n\t\tresult = floor(arg1);\n\telse\n\t\tresult = -floor(-arg1);\n\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "floor",
          "args": [
            "-arg1"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "dfloor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1559-1565",
          "snippet": "Datum\ndfloor(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(floor(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndfloor(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(floor(arg1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndtrunc(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 >= 0)\n\t\tresult = floor(arg1);\n\telse\n\t\tresult = -floor(-arg1);\n\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dsign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1572-1586",
    "snippet": "Datum\ndsign(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 > 0)\n\t\tresult = 1.0;\n\telse if (arg1 < 0)\n\t\tresult = -1.0;\n\telse\n\t\tresult = 0.0;\n\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndsign(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 > 0)\n\t\tresult = 1.0;\n\telse if (arg1 < 0)\n\t\tresult = -1.0;\n\telse\n\t\tresult = 0.0;\n\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dfloor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1559-1565",
    "snippet": "Datum\ndfloor(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(floor(arg1));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "floor(arg1)"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "floor",
          "args": [
            "arg1"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "dfloor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1559-1565",
          "snippet": "Datum\ndfloor(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(floor(arg1));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndfloor(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(floor(arg1));\n}"
  },
  {
    "function_name": "dceil",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1547-1553",
    "snippet": "Datum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "ceil(arg1)"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceil",
          "args": [
            "arg1"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "dceil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1547-1553",
          "snippet": "Datum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}"
  },
  {
    "function_name": "dround",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1535-1541",
    "snippet": "Datum\ndround(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(rint(arg1));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "rint(arg1)"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "arg1"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndround(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(rint(arg1));\n}"
  },
  {
    "function_name": "i2tof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1517-1523",
    "snippet": "Datum\ni2tof(PG_FUNCTION_ARGS)\n{\n\tint16\t\tnum = PG_GETARG_INT16(0);\n\n\tPG_RETURN_FLOAT4((float4) num);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "(float4) num"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT16",
          "args": [
            "0"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ni2tof(PG_FUNCTION_ARGS)\n{\n\tint16\t\tnum = PG_GETARG_INT16(0);\n\n\tPG_RETURN_FLOAT4((float4) num);\n}"
  },
  {
    "function_name": "i4tof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1505-1511",
    "snippet": "Datum\ni4tof(PG_FUNCTION_ARGS)\n{\n\tint32\t\tnum = PG_GETARG_INT32(0);\n\n\tPG_RETURN_FLOAT4((float4) num);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "(float4) num"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ni4tof(PG_FUNCTION_ARGS)\n{\n\tint32\t\tnum = PG_GETARG_INT32(0);\n\n\tPG_RETURN_FLOAT4((float4) num);\n}"
  },
  {
    "function_name": "ftoi2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1473-1499",
    "snippet": "Datum\nftoi2(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\tnum = PG_GETARG_FLOAT4(0);\n\n\t/*\n\t * Get rid of any fractional part in the input.  This is so we don't fail\n\t * on just-out-of-range values that would round into range.  Note\n\t * assumption that rint() will pass through a NaN or Inf unchanged.\n\t */\n\tnum = rint(num);\n\n\t/*\n\t * Range check.  We must be careful here that the boundary values are\n\t * expressed exactly in the float domain.  We expect PG_INT16_MIN to be an\n\t * exact power of 2, so it will be represented exactly; but PG_INT16_MAX\n\t * isn't, and might get rounded off, so avoid using it.\n\t */\n\tif (unlikely(num < (float4) PG_INT16_MIN ||\n\t\t\t\t num >= -((float4) PG_INT16_MIN) ||\n\t\t\t\t isnan(num)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"smallint out of range\")));\n\n\tPG_RETURN_INT16((int16) num);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT16",
          "args": [
            "(int16) num"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"smallint out of range\"))"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"smallint out of range\""
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "num < (float4) PG_INT16_MIN ||\n\t\t\t\t num >= -((float4) PG_INT16_MIN) ||\n\t\t\t\t isnan(num)"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "num"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "num"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nftoi2(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\tnum = PG_GETARG_FLOAT4(0);\n\n\t/*\n\t * Get rid of any fractional part in the input.  This is so we don't fail\n\t * on just-out-of-range values that would round into range.  Note\n\t * assumption that rint() will pass through a NaN or Inf unchanged.\n\t */\n\tnum = rint(num);\n\n\t/*\n\t * Range check.  We must be careful here that the boundary values are\n\t * expressed exactly in the float domain.  We expect PG_INT16_MIN to be an\n\t * exact power of 2, so it will be represented exactly; but PG_INT16_MAX\n\t * isn't, and might get rounded off, so avoid using it.\n\t */\n\tif (unlikely(num < (float4) PG_INT16_MIN ||\n\t\t\t\t num >= -((float4) PG_INT16_MIN) ||\n\t\t\t\t isnan(num)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"smallint out of range\")));\n\n\tPG_RETURN_INT16((int16) num);\n}"
  },
  {
    "function_name": "ftoi4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1441-1467",
    "snippet": "Datum\nftoi4(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\tnum = PG_GETARG_FLOAT4(0);\n\n\t/*\n\t * Get rid of any fractional part in the input.  This is so we don't fail\n\t * on just-out-of-range values that would round into range.  Note\n\t * assumption that rint() will pass through a NaN or Inf unchanged.\n\t */\n\tnum = rint(num);\n\n\t/*\n\t * Range check.  We must be careful here that the boundary values are\n\t * expressed exactly in the float domain.  We expect PG_INT32_MIN to be an\n\t * exact power of 2, so it will be represented exactly; but PG_INT32_MAX\n\t * isn't, and might get rounded off, so avoid using it.\n\t */\n\tif (unlikely(num < (float4) PG_INT32_MIN ||\n\t\t\t\t num >= -((float4) PG_INT32_MIN) ||\n\t\t\t\t isnan(num)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\tPG_RETURN_INT32((int32) num);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "(int32) num"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\"))"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"integer out of range\""
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "num < (float4) PG_INT32_MIN ||\n\t\t\t\t num >= -((float4) PG_INT32_MIN) ||\n\t\t\t\t isnan(num)"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "num"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "num"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nftoi4(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\tnum = PG_GETARG_FLOAT4(0);\n\n\t/*\n\t * Get rid of any fractional part in the input.  This is so we don't fail\n\t * on just-out-of-range values that would round into range.  Note\n\t * assumption that rint() will pass through a NaN or Inf unchanged.\n\t */\n\tnum = rint(num);\n\n\t/*\n\t * Range check.  We must be careful here that the boundary values are\n\t * expressed exactly in the float domain.  We expect PG_INT32_MIN to be an\n\t * exact power of 2, so it will be represented exactly; but PG_INT32_MAX\n\t * isn't, and might get rounded off, so avoid using it.\n\t */\n\tif (unlikely(num < (float4) PG_INT32_MIN ||\n\t\t\t\t num >= -((float4) PG_INT32_MIN) ||\n\t\t\t\t isnan(num)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\tPG_RETURN_INT32((int32) num);\n}"
  },
  {
    "function_name": "i2tod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1429-1435",
    "snippet": "Datum\ni2tod(PG_FUNCTION_ARGS)\n{\n\tint16\t\tnum = PG_GETARG_INT16(0);\n\n\tPG_RETURN_FLOAT8((float8) num);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "(float8) num"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT16",
          "args": [
            "0"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ni2tod(PG_FUNCTION_ARGS)\n{\n\tint16\t\tnum = PG_GETARG_INT16(0);\n\n\tPG_RETURN_FLOAT8((float8) num);\n}"
  },
  {
    "function_name": "i4tod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1417-1423",
    "snippet": "Datum\ni4tod(PG_FUNCTION_ARGS)\n{\n\tint32\t\tnum = PG_GETARG_INT32(0);\n\n\tPG_RETURN_FLOAT8((float8) num);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "(float8) num"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ni4tod(PG_FUNCTION_ARGS)\n{\n\tint32\t\tnum = PG_GETARG_INT32(0);\n\n\tPG_RETURN_FLOAT8((float8) num);\n}"
  },
  {
    "function_name": "dtoi2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1385-1411",
    "snippet": "Datum\ndtoi2(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tnum = PG_GETARG_FLOAT8(0);\n\n\t/*\n\t * Get rid of any fractional part in the input.  This is so we don't fail\n\t * on just-out-of-range values that would round into range.  Note\n\t * assumption that rint() will pass through a NaN or Inf unchanged.\n\t */\n\tnum = rint(num);\n\n\t/*\n\t * Range check.  We must be careful here that the boundary values are\n\t * expressed exactly in the float domain.  We expect PG_INT16_MIN to be an\n\t * exact power of 2, so it will be represented exactly; but PG_INT16_MAX\n\t * isn't, and might get rounded off, so avoid using it.\n\t */\n\tif (unlikely(num < (float8) PG_INT16_MIN ||\n\t\t\t\t num >= -((float8) PG_INT16_MIN) ||\n\t\t\t\t isnan(num)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"smallint out of range\")));\n\n\tPG_RETURN_INT16((int16) num);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT16",
          "args": [
            "(int16) num"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"smallint out of range\"))"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"smallint out of range\""
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "num < (float8) PG_INT16_MIN ||\n\t\t\t\t num >= -((float8) PG_INT16_MIN) ||\n\t\t\t\t isnan(num)"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "num"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "num"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndtoi2(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tnum = PG_GETARG_FLOAT8(0);\n\n\t/*\n\t * Get rid of any fractional part in the input.  This is so we don't fail\n\t * on just-out-of-range values that would round into range.  Note\n\t * assumption that rint() will pass through a NaN or Inf unchanged.\n\t */\n\tnum = rint(num);\n\n\t/*\n\t * Range check.  We must be careful here that the boundary values are\n\t * expressed exactly in the float domain.  We expect PG_INT16_MIN to be an\n\t * exact power of 2, so it will be represented exactly; but PG_INT16_MAX\n\t * isn't, and might get rounded off, so avoid using it.\n\t */\n\tif (unlikely(num < (float8) PG_INT16_MIN ||\n\t\t\t\t num >= -((float8) PG_INT16_MIN) ||\n\t\t\t\t isnan(num)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"smallint out of range\")));\n\n\tPG_RETURN_INT16((int16) num);\n}"
  },
  {
    "function_name": "dtoi4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1353-1379",
    "snippet": "Datum\ndtoi4(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tnum = PG_GETARG_FLOAT8(0);\n\n\t/*\n\t * Get rid of any fractional part in the input.  This is so we don't fail\n\t * on just-out-of-range values that would round into range.  Note\n\t * assumption that rint() will pass through a NaN or Inf unchanged.\n\t */\n\tnum = rint(num);\n\n\t/*\n\t * Range check.  We must be careful here that the boundary values are\n\t * expressed exactly in the float domain.  We expect PG_INT32_MIN to be an\n\t * exact power of 2, so it will be represented exactly; but PG_INT32_MAX\n\t * isn't, and might get rounded off, so avoid using it.\n\t */\n\tif (unlikely(num < (float8) PG_INT32_MIN ||\n\t\t\t\t num >= -((float8) PG_INT32_MIN) ||\n\t\t\t\t isnan(num)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\tPG_RETURN_INT32((int32) num);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "(int32) num"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\"))"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"integer out of range\""
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "num < (float8) PG_INT32_MIN ||\n\t\t\t\t num >= -((float8) PG_INT32_MIN) ||\n\t\t\t\t isnan(num)"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "num"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "num"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndtoi4(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tnum = PG_GETARG_FLOAT8(0);\n\n\t/*\n\t * Get rid of any fractional part in the input.  This is so we don't fail\n\t * on just-out-of-range values that would round into range.  Note\n\t * assumption that rint() will pass through a NaN or Inf unchanged.\n\t */\n\tnum = rint(num);\n\n\t/*\n\t * Range check.  We must be careful here that the boundary values are\n\t * expressed exactly in the float domain.  We expect PG_INT32_MIN to be an\n\t * exact power of 2, so it will be represented exactly; but PG_INT32_MAX\n\t * isn't, and might get rounded off, so avoid using it.\n\t */\n\tif (unlikely(num < (float8) PG_INT32_MIN ||\n\t\t\t\t num >= -((float8) PG_INT32_MIN) ||\n\t\t\t\t isnan(num)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\tPG_RETURN_INT32((int32) num);\n}"
  },
  {
    "function_name": "dtof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1339-1347",
    "snippet": "Datum\ndtof(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tnum = PG_GETARG_FLOAT8(0);\n\n\tCHECKFLOATVAL((float4) num, isinf(num), num == 0);\n\n\tPG_RETURN_FLOAT4((float4) num);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "(float4) num"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "(float4) num",
            "isinf(num)",
            "num == 0"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "num"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndtof(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tnum = PG_GETARG_FLOAT8(0);\n\n\tCHECKFLOATVAL((float4) num, isinf(num), num == 0);\n\n\tPG_RETURN_FLOAT4((float4) num);\n}"
  },
  {
    "function_name": "ftod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1327-1333",
    "snippet": "Datum\nftod(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\tnum = PG_GETARG_FLOAT4(0);\n\n\tPG_RETURN_FLOAT8((float8) num);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "(float8) num"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nftod(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\tnum = PG_GETARG_FLOAT4(0);\n\n\tPG_RETURN_FLOAT8((float8) num);\n}"
  },
  {
    "function_name": "in_range_float4_float8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1254-1315",
    "snippet": "Datum\nin_range_float4_float8(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\tval = PG_GETARG_FLOAT4(0);\n\tfloat4\t\tbase = PG_GETARG_FLOAT4(1);\n\tfloat8\t\toffset = PG_GETARG_FLOAT8(2);\n\tbool\t\tsub = PG_GETARG_BOOL(3);\n\tbool\t\tless = PG_GETARG_BOOL(4);\n\tfloat8\t\tsum;\n\n\t/*\n\t * Reject negative or NaN offset.  Negative is per spec, and NaN is\n\t * because appropriate semantics for that seem non-obvious.\n\t */\n\tif (isnan(offset) || offset < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\")));\n\n\t/*\n\t * Deal with cases where val and/or base is NaN, following the rule that\n\t * NaN sorts after non-NaN (cf float8_cmp_internal).  The offset cannot\n\t * affect the conclusion.\n\t */\n\tif (isnan(val))\n\t{\n\t\tif (isnan(base))\n\t\t\tPG_RETURN_BOOL(true);\t/* NAN = NAN */\n\t\telse\n\t\t\tPG_RETURN_BOOL(!less);\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(base))\n\t{\n\t\tPG_RETURN_BOOL(less);\t/* non-NAN < NAN */\n\t}\n\n\t/*\n\t * Deal with infinite offset (necessarily +inf, at this point).  We must\n\t * special-case this because if base happens to be -inf, their sum would\n\t * be NaN, which is an overflow-ish condition we should avoid.\n\t */\n\tif (isinf(offset))\n\t{\n\t\tPG_RETURN_BOOL(sub ? !less : less);\n\t}\n\n\t/*\n\t * Otherwise it should be safe to compute base +/- offset.  We trust the\n\t * FPU to cope if base is +/-inf or the true sum would overflow, and\n\t * produce a suitably signed infinity, which will compare properly against\n\t * val whether or not that's infinity.\n\t */\n\tif (sub)\n\t\tsum = base - offset;\n\telse\n\t\tsum = base + offset;\n\n\tif (less)\n\t\tPG_RETURN_BOOL(val <= sum);\n\telse\n\t\tPG_RETURN_BOOL(val >= sum);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NAN (*(const double *) nan)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "val >= sum"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "val <= sum"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "sub ? !less : less"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "offset"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "less"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "base"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "!less"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "base"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "val"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\"))"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid preceding or following size in window function\""
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "offset"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "4"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "3"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "2"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nDatum\nin_range_float4_float8(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\tval = PG_GETARG_FLOAT4(0);\n\tfloat4\t\tbase = PG_GETARG_FLOAT4(1);\n\tfloat8\t\toffset = PG_GETARG_FLOAT8(2);\n\tbool\t\tsub = PG_GETARG_BOOL(3);\n\tbool\t\tless = PG_GETARG_BOOL(4);\n\tfloat8\t\tsum;\n\n\t/*\n\t * Reject negative or NaN offset.  Negative is per spec, and NaN is\n\t * because appropriate semantics for that seem non-obvious.\n\t */\n\tif (isnan(offset) || offset < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\")));\n\n\t/*\n\t * Deal with cases where val and/or base is NaN, following the rule that\n\t * NaN sorts after non-NaN (cf float8_cmp_internal).  The offset cannot\n\t * affect the conclusion.\n\t */\n\tif (isnan(val))\n\t{\n\t\tif (isnan(base))\n\t\t\tPG_RETURN_BOOL(true);\t/* NAN = NAN */\n\t\telse\n\t\t\tPG_RETURN_BOOL(!less);\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(base))\n\t{\n\t\tPG_RETURN_BOOL(less);\t/* non-NAN < NAN */\n\t}\n\n\t/*\n\t * Deal with infinite offset (necessarily +inf, at this point).  We must\n\t * special-case this because if base happens to be -inf, their sum would\n\t * be NaN, which is an overflow-ish condition we should avoid.\n\t */\n\tif (isinf(offset))\n\t{\n\t\tPG_RETURN_BOOL(sub ? !less : less);\n\t}\n\n\t/*\n\t * Otherwise it should be safe to compute base +/- offset.  We trust the\n\t * FPU to cope if base is +/-inf or the true sum would overflow, and\n\t * produce a suitably signed infinity, which will compare properly against\n\t * val whether or not that's infinity.\n\t */\n\tif (sub)\n\t\tsum = base - offset;\n\telse\n\t\tsum = base + offset;\n\n\tif (less)\n\t\tPG_RETURN_BOOL(val <= sum);\n\telse\n\t\tPG_RETURN_BOOL(val >= sum);\n}"
  },
  {
    "function_name": "in_range_float8_float8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1185-1246",
    "snippet": "Datum\nin_range_float8_float8(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tval = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tbase = PG_GETARG_FLOAT8(1);\n\tfloat8\t\toffset = PG_GETARG_FLOAT8(2);\n\tbool\t\tsub = PG_GETARG_BOOL(3);\n\tbool\t\tless = PG_GETARG_BOOL(4);\n\tfloat8\t\tsum;\n\n\t/*\n\t * Reject negative or NaN offset.  Negative is per spec, and NaN is\n\t * because appropriate semantics for that seem non-obvious.\n\t */\n\tif (isnan(offset) || offset < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\")));\n\n\t/*\n\t * Deal with cases where val and/or base is NaN, following the rule that\n\t * NaN sorts after non-NaN (cf float8_cmp_internal).  The offset cannot\n\t * affect the conclusion.\n\t */\n\tif (isnan(val))\n\t{\n\t\tif (isnan(base))\n\t\t\tPG_RETURN_BOOL(true);\t/* NAN = NAN */\n\t\telse\n\t\t\tPG_RETURN_BOOL(!less);\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(base))\n\t{\n\t\tPG_RETURN_BOOL(less);\t/* non-NAN < NAN */\n\t}\n\n\t/*\n\t * Deal with infinite offset (necessarily +inf, at this point).  We must\n\t * special-case this because if base happens to be -inf, their sum would\n\t * be NaN, which is an overflow-ish condition we should avoid.\n\t */\n\tif (isinf(offset))\n\t{\n\t\tPG_RETURN_BOOL(sub ? !less : less);\n\t}\n\n\t/*\n\t * Otherwise it should be safe to compute base +/- offset.  We trust the\n\t * FPU to cope if base is +/-inf or the true sum would overflow, and\n\t * produce a suitably signed infinity, which will compare properly against\n\t * val whether or not that's infinity.\n\t */\n\tif (sub)\n\t\tsum = base - offset;\n\telse\n\t\tsum = base + offset;\n\n\tif (less)\n\t\tPG_RETURN_BOOL(val <= sum);\n\telse\n\t\tPG_RETURN_BOOL(val >= sum);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NAN (*(const double *) nan)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "val >= sum"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "val <= sum"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "sub ? !less : less"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "offset"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "less"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "base"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "!less"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "base"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "val"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\"))"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid preceding or following size in window function\""
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "offset"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "4"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "3"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "2"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nDatum\nin_range_float8_float8(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tval = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tbase = PG_GETARG_FLOAT8(1);\n\tfloat8\t\toffset = PG_GETARG_FLOAT8(2);\n\tbool\t\tsub = PG_GETARG_BOOL(3);\n\tbool\t\tless = PG_GETARG_BOOL(4);\n\tfloat8\t\tsum;\n\n\t/*\n\t * Reject negative or NaN offset.  Negative is per spec, and NaN is\n\t * because appropriate semantics for that seem non-obvious.\n\t */\n\tif (isnan(offset) || offset < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\")));\n\n\t/*\n\t * Deal with cases where val and/or base is NaN, following the rule that\n\t * NaN sorts after non-NaN (cf float8_cmp_internal).  The offset cannot\n\t * affect the conclusion.\n\t */\n\tif (isnan(val))\n\t{\n\t\tif (isnan(base))\n\t\t\tPG_RETURN_BOOL(true);\t/* NAN = NAN */\n\t\telse\n\t\t\tPG_RETURN_BOOL(!less);\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(base))\n\t{\n\t\tPG_RETURN_BOOL(less);\t/* non-NAN < NAN */\n\t}\n\n\t/*\n\t * Deal with infinite offset (necessarily +inf, at this point).  We must\n\t * special-case this because if base happens to be -inf, their sum would\n\t * be NaN, which is an overflow-ish condition we should avoid.\n\t */\n\tif (isinf(offset))\n\t{\n\t\tPG_RETURN_BOOL(sub ? !less : less);\n\t}\n\n\t/*\n\t * Otherwise it should be safe to compute base +/- offset.  We trust the\n\t * FPU to cope if base is +/-inf or the true sum would overflow, and\n\t * produce a suitably signed infinity, which will compare properly against\n\t * val whether or not that's infinity.\n\t */\n\tif (sub)\n\t\tsum = base - offset;\n\telse\n\t\tsum = base + offset;\n\n\tif (less)\n\t\tPG_RETURN_BOOL(val <= sum);\n\telse\n\t\tPG_RETURN_BOOL(val >= sum);\n}"
  },
  {
    "function_name": "btfloat84cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1169-1177",
    "snippet": "Datum\nbtfloat84cmp(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\t/* widen float4 to float8 and then compare */\n\tPG_RETURN_INT32(float8_cmp_internal(arg1, arg2));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "float8_cmp_internal(arg1, arg2)"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nbtfloat84cmp(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\t/* widen float4 to float8 and then compare */\n\tPG_RETURN_INT32(float8_cmp_internal(arg1, arg2));\n}"
  },
  {
    "function_name": "btfloat48cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1159-1167",
    "snippet": "Datum\nbtfloat48cmp(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\t/* widen float4 to float8 and then compare */\n\tPG_RETURN_INT32(float8_cmp_internal(arg1, arg2));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "float8_cmp_internal(arg1, arg2)"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nbtfloat48cmp(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\t/* widen float4 to float8 and then compare */\n\tPG_RETURN_INT32(float8_cmp_internal(arg1, arg2));\n}"
  },
  {
    "function_name": "btfloat8sortsupport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1150-1157",
    "snippet": "Datum\nbtfloat8sortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\n\tssup->comparator = btfloat8fastcmp;\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nbtfloat8sortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\n\tssup->comparator = btfloat8fastcmp;\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "btfloat8fastcmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1141-1148",
    "snippet": "static int\nbtfloat8fastcmp(Datum x, Datum y, SortSupport ssup)\n{\n\tfloat8\t\targ1 = DatumGetFloat8(x);\n\tfloat8\t\targ2 = DatumGetFloat8(y);\n\n\treturn float8_cmp_internal(arg1, arg2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double sind_q1(double x);",
      "static double cosd_q1(double x);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "y"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "x"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic int\nbtfloat8fastcmp(Datum x, Datum y, SortSupport ssup)\n{\n\tfloat8\t\targ1 = DatumGetFloat8(x);\n\tfloat8\t\targ2 = DatumGetFloat8(y);\n\n\treturn float8_cmp_internal(arg1, arg2);\n}"
  },
  {
    "function_name": "btfloat8cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1132-1139",
    "snippet": "Datum\nbtfloat8cmp(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_INT32(float8_cmp_internal(arg1, arg2));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "float8_cmp_internal(arg1, arg2)"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nbtfloat8cmp(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_INT32(float8_cmp_internal(arg1, arg2));\n}"
  },
  {
    "function_name": "float8ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1123-1130",
    "snippet": "Datum\nfloat8ge(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) >= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) >= 0"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8ge(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) >= 0);\n}"
  },
  {
    "function_name": "float8gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1114-1121",
    "snippet": "Datum\nfloat8gt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) > 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) > 0"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8gt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) > 0);\n}"
  },
  {
    "function_name": "float8le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1105-1112",
    "snippet": "Datum\nfloat8le(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) <= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) <= 0"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8le(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) <= 0);\n}"
  },
  {
    "function_name": "float8lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1096-1103",
    "snippet": "Datum\nfloat8lt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) < 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) < 0"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8lt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) < 0);\n}"
  },
  {
    "function_name": "float8ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1087-1094",
    "snippet": "Datum\nfloat8ne(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) != 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) != 0"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8ne(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) != 0);\n}"
  },
  {
    "function_name": "float8eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1078-1085",
    "snippet": "Datum\nfloat8eq(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) == 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float8_cmp_internal(arg1, arg2) == 0"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8eq(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_BOOL(float8_cmp_internal(arg1, arg2) == 0);\n}"
  },
  {
    "function_name": "float8_cmp_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1048-1076",
    "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NAN (*(const double *) nan)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "b"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "b"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "a"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "btfloat4sortsupport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1036-1043",
    "snippet": "Datum\nbtfloat4sortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\n\tssup->comparator = btfloat4fastcmp;\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nbtfloat4sortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\n\tssup->comparator = btfloat4fastcmp;\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "btfloat4fastcmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1027-1034",
    "snippet": "static int\nbtfloat4fastcmp(Datum x, Datum y, SortSupport ssup)\n{\n\tfloat4\t\targ1 = DatumGetFloat4(x);\n\tfloat4\t\targ2 = DatumGetFloat4(y);\n\n\treturn float4_cmp_internal(arg1, arg2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double sind_q1(double x);",
      "static double cosd_q1(double x);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "float4_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "float4_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "934-962",
          "snippet": "int\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetFloat4",
          "args": [
            "y"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat4",
          "args": [
            "x"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nstatic int\nbtfloat4fastcmp(Datum x, Datum y, SortSupport ssup)\n{\n\tfloat4\t\targ1 = DatumGetFloat4(x);\n\tfloat4\t\targ2 = DatumGetFloat4(y);\n\n\treturn float4_cmp_internal(arg1, arg2);\n}"
  },
  {
    "function_name": "btfloat4cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1018-1025",
    "snippet": "Datum\nbtfloat4cmp(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_INT32(float4_cmp_internal(arg1, arg2));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "float4_cmp_internal(arg1, arg2)"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float4_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "float4_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "934-962",
          "snippet": "int\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nbtfloat4cmp(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_INT32(float4_cmp_internal(arg1, arg2));\n}"
  },
  {
    "function_name": "float4ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1009-1016",
    "snippet": "Datum\nfloat4ge(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float4_cmp_internal(arg1, arg2) >= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float4_cmp_internal(arg1, arg2) >= 0"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float4_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "float4_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "934-962",
          "snippet": "int\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4ge(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float4_cmp_internal(arg1, arg2) >= 0);\n}"
  },
  {
    "function_name": "float4gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "1000-1007",
    "snippet": "Datum\nfloat4gt(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float4_cmp_internal(arg1, arg2) > 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float4_cmp_internal(arg1, arg2) > 0"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float4_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "float4_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "934-962",
          "snippet": "int\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4gt(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float4_cmp_internal(arg1, arg2) > 0);\n}"
  },
  {
    "function_name": "float4le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "991-998",
    "snippet": "Datum\nfloat4le(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float4_cmp_internal(arg1, arg2) <= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float4_cmp_internal(arg1, arg2) <= 0"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float4_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "float4_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "934-962",
          "snippet": "int\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4le(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float4_cmp_internal(arg1, arg2) <= 0);\n}"
  },
  {
    "function_name": "float4lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "982-989",
    "snippet": "Datum\nfloat4lt(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float4_cmp_internal(arg1, arg2) < 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float4_cmp_internal(arg1, arg2) < 0"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float4_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "float4_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "934-962",
          "snippet": "int\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4lt(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float4_cmp_internal(arg1, arg2) < 0);\n}"
  },
  {
    "function_name": "float4ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "973-980",
    "snippet": "Datum\nfloat4ne(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float4_cmp_internal(arg1, arg2) != 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float4_cmp_internal(arg1, arg2) != 0"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float4_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "float4_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "934-962",
          "snippet": "int\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4ne(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float4_cmp_internal(arg1, arg2) != 0);\n}"
  },
  {
    "function_name": "float4eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "964-971",
    "snippet": "Datum\nfloat4eq(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float4_cmp_internal(arg1, arg2) == 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "float4_cmp_internal(arg1, arg2) == 0"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float4_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "float4_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "934-962",
          "snippet": "int\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4eq(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\n\tPG_RETURN_BOOL(float4_cmp_internal(arg1, arg2) == 0);\n}"
  },
  {
    "function_name": "float4_cmp_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "934-962",
    "snippet": "int\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NAN (*(const double *) nan)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "b"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "b"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "a"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "float8div",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "906-922",
    "snippet": "Datum\nfloat8div(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tif (arg2 == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = arg1 / arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "arg1 == 0"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\"))"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"division by zero\""
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DIVISION_BY_ZERO"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8div(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tif (arg2 == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = arg1 / arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "float8mul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "892-904",
    "snippet": "Datum\nfloat8mul(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 * arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2),\n\t\t\t\t  arg1 == 0 || arg2 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "arg1 == 0 || arg2 == 0"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8mul(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 * arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2),\n\t\t\t\t  arg1 == 0 || arg2 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "float8mi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "879-890",
    "snippet": "Datum\nfloat8mi(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 - arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "true"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8mi(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 - arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "float8pl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "866-877",
    "snippet": "Datum\nfloat8pl(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 + arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), true);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "true"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8pl(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tresult = arg1 + arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), true);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "float4div",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "842-858",
    "snippet": "Datum\nfloat4div(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat4\t\tresult;\n\n\tif (arg2 == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = arg1 / arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), arg1 == 0);\n\tPG_RETURN_FLOAT4(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "result"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "arg1 == 0"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\"))"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"division by zero\""
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DIVISION_BY_ZERO"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4div(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat4\t\tresult;\n\n\tif (arg2 == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = arg1 / arg2;\n\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), arg1 == 0);\n\tPG_RETURN_FLOAT4(result);\n}"
  },
  {
    "function_name": "float4mul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "829-840",
    "snippet": "Datum\nfloat4mul(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat4\t\tresult;\n\n\tresult = arg1 * arg2;\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2),\n\t\t\t\t  arg1 == 0 || arg2 == 0);\n\tPG_RETURN_FLOAT4(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "result"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "arg1 == 0 || arg2 == 0"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4mul(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat4\t\tresult;\n\n\tresult = arg1 * arg2;\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2),\n\t\t\t\t  arg1 == 0 || arg2 == 0);\n\tPG_RETURN_FLOAT4(result);\n}"
  },
  {
    "function_name": "float4mi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "817-827",
    "snippet": "Datum\nfloat4mi(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat4\t\tresult;\n\n\tresult = arg1 - arg2;\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), true);\n\tPG_RETURN_FLOAT4(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "result"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "true"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4mi(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat4\t\tresult;\n\n\tresult = arg1 - arg2;\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), true);\n\tPG_RETURN_FLOAT4(result);\n}"
  },
  {
    "function_name": "float4pl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "797-815",
    "snippet": "Datum\nfloat4pl(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat4\t\tresult;\n\n\tresult = arg1 + arg2;\n\n\t/*\n\t * There isn't any way to check for underflow of addition/subtraction\n\t * because numbers near the underflow value have already been rounded to\n\t * the point where we can't detect that the two values were originally\n\t * different, e.g. on x86, '1e-45'::float4 == '2e-45'::float4 ==\n\t * 1.4013e-45.\n\t */\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), true);\n\tPG_RETURN_FLOAT4(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "result"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "result",
            "isinf(arg1) || isinf(arg2)",
            "true"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg2"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "arg1"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4pl(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat4\t\tresult;\n\n\tresult = arg1 + arg2;\n\n\t/*\n\t * There isn't any way to check for underflow of addition/subtraction\n\t * because numbers near the underflow value have already been rounded to\n\t * the point where we can't detect that the two values were originally\n\t * different, e.g. on x86, '1e-45'::float4 == '2e-45'::float4 ==\n\t * 1.4013e-45.\n\t */\n\tCHECKFLOATVAL(result, isinf(arg1) || isinf(arg2), true);\n\tPG_RETURN_FLOAT4(result);\n}"
  },
  {
    "function_name": "float8smaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "770-782",
    "snippet": "Datum\nfloat8smaller(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tif (float8_cmp_internal(arg1, arg2) < 0)\n\t\tresult = arg1;\n\telse\n\t\tresult = arg2;\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8smaller(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tif (float8_cmp_internal(arg1, arg2) < 0)\n\t\tresult = arg1;\n\telse\n\t\tresult = arg2;\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "float8larger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "756-768",
    "snippet": "Datum\nfloat8larger(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tif (float8_cmp_internal(arg1, arg2) > 0)\n\t\tresult = arg1;\n\telse\n\t\tresult = arg2;\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "float8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1048-1076",
          "snippet": "int\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat8_cmp_internal(float8 a, float8 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8larger(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\targ2 = PG_GETARG_FLOAT8(1);\n\tfloat8\t\tresult;\n\n\tif (float8_cmp_internal(arg1, arg2) > 0)\n\t\tresult = arg1;\n\telse\n\t\tresult = arg2;\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "float8up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "748-754",
    "snippet": "Datum\nfloat8up(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(arg);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "arg"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8up(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(arg);\n}"
  },
  {
    "function_name": "float8um",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "738-746",
    "snippet": "Datum\nfloat8um(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tresult = -arg1;\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8um(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tresult = -arg1;\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "float8abs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "726-732",
    "snippet": "Datum\nfloat8abs(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(fabs(arg1));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "fabs(arg1)"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fabs",
          "args": [
            "arg1"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8abs(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(fabs(arg1));\n}"
  },
  {
    "function_name": "float4smaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "703-715",
    "snippet": "Datum\nfloat4smaller(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat4\t\tresult;\n\n\tif (float4_cmp_internal(arg1, arg2) < 0)\n\t\tresult = arg1;\n\telse\n\t\tresult = arg2;\n\tPG_RETURN_FLOAT4(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "result"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float4_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "float4_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "934-962",
          "snippet": "int\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4smaller(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat4\t\tresult;\n\n\tif (float4_cmp_internal(arg1, arg2) < 0)\n\t\tresult = arg1;\n\telse\n\t\tresult = arg2;\n\tPG_RETURN_FLOAT4(result);\n}"
  },
  {
    "function_name": "float4larger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "689-701",
    "snippet": "Datum\nfloat4larger(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat4\t\tresult;\n\n\tif (float4_cmp_internal(arg1, arg2) > 0)\n\t\tresult = arg1;\n\telse\n\t\tresult = arg2;\n\tPG_RETURN_FLOAT4(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "result"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float4_cmp_internal",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "float4_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "934-962",
          "snippet": "int\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nint\nfloat4_cmp_internal(float4 a, float4 b)\n{\n\t/*\n\t * We consider all NANs to be equal and larger than any non-NAN. This is\n\t * somewhat arbitrary; the important thing is to have a consistent sort\n\t * order.\n\t */\n\tif (isnan(a))\n\t{\n\t\tif (isnan(b))\n\t\t\treturn 0;\t\t\t/* NAN = NAN */\n\t\telse\n\t\t\treturn 1;\t\t\t/* NAN > non-NAN */\n\t}\n\telse if (isnan(b))\n\t{\n\t\treturn -1;\t\t\t\t/* non-NAN < NAN */\n\t}\n\telse\n\t{\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse if (a < b)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4larger(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\targ2 = PG_GETARG_FLOAT4(1);\n\tfloat4\t\tresult;\n\n\tif (float4_cmp_internal(arg1, arg2) > 0)\n\t\tresult = arg1;\n\telse\n\t\tresult = arg2;\n\tPG_RETURN_FLOAT4(result);\n}"
  },
  {
    "function_name": "float4up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "681-687",
    "snippet": "Datum\nfloat4up(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ = PG_GETARG_FLOAT4(0);\n\n\tPG_RETURN_FLOAT4(arg);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "arg"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4up(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ = PG_GETARG_FLOAT4(0);\n\n\tPG_RETURN_FLOAT4(arg);\n}"
  },
  {
    "function_name": "float4um",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "671-679",
    "snippet": "Datum\nfloat4um(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\tresult;\n\n\tresult = -arg1;\n\tPG_RETURN_FLOAT4(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "result"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4um(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\tfloat4\t\tresult;\n\n\tresult = -arg1;\n\tPG_RETURN_FLOAT4(result);\n}"
  },
  {
    "function_name": "float4abs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "660-666",
    "snippet": "Datum\nfloat4abs(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\n\tPG_RETURN_FLOAT4((float4) fabs(arg1));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "(float4) fabs(arg1)"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fabs",
          "args": [
            "arg1"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4abs(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\targ1 = PG_GETARG_FLOAT4(0);\n\n\tPG_RETURN_FLOAT4((float4) fabs(arg1));\n}"
  },
  {
    "function_name": "float8send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "636-645",
    "snippet": "Datum\nfloat8send(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tnum = PG_GETARG_FLOAT8(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendfloat8(&buf, num);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "num"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8send(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tnum = PG_GETARG_FLOAT8(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendfloat8(&buf, num);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "float8recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "625-631",
    "snippet": "Datum\nfloat8recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_FLOAT8(pq_getmsgfloat8(buf));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "pq_getmsgfloat8(buf)"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_FLOAT8(pq_getmsgfloat8(buf));\n}"
  },
  {
    "function_name": "float8out_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "592-620",
    "snippet": "char *\nfloat8out_internal(double num)\n{\n\tchar\t   *ascii;\n\n\tif (isnan(num))\n\t\treturn pstrdup(\"NaN\");\n\n\tswitch (is_infinite(num))\n\t{\n\t\tcase 1:\n\t\t\tascii = pstrdup(\"Infinity\");\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tascii = pstrdup(\"-Infinity\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint\t\t\tndig = DBL_DIG + extra_float_digits;\n\n\t\t\t\tif (ndig < 1)\n\t\t\t\t\tndig = 1;\n\n\t\t\t\tascii = psprintf(\"%.*g\", ndig, num);\n\t\t\t}\n\t}\n\n\treturn ascii;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\textra_float_digits = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%.*g\"",
            "ndig",
            "num"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "\"-Infinity\""
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_infinite",
          "args": [
            "num"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "is_infinite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "195-206",
          "snippet": "int\nis_infinite(double val)\n{\n\tint\t\t\tinf = isinf(val);\n\n\tif (inf == 0)\n\t\treturn 0;\n\telse if (val > 0)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nis_infinite(double val)\n{\n\tint\t\t\tinf = isinf(val);\n\n\tif (inf == 0)\n\t\treturn 0;\n\telse if (val > 0)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "num"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\t\t\textra_float_digits = 0;\n\nchar *\nfloat8out_internal(double num)\n{\n\tchar\t   *ascii;\n\n\tif (isnan(num))\n\t\treturn pstrdup(\"NaN\");\n\n\tswitch (is_infinite(num))\n\t{\n\t\tcase 1:\n\t\t\tascii = pstrdup(\"Infinity\");\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tascii = pstrdup(\"-Infinity\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint\t\t\tndig = DBL_DIG + extra_float_digits;\n\n\t\t\t\tif (ndig < 1)\n\t\t\t\t\tndig = 1;\n\n\t\t\t\tascii = psprintf(\"%.*g\", ndig, num);\n\t\t\t}\n\t}\n\n\treturn ascii;\n}"
  },
  {
    "function_name": "float8out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "577-583",
    "snippet": "Datum\nfloat8out(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tnum = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_CSTRING(float8out_internal(num));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "float8out_internal(num)"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8out_internal",
          "args": [
            "num"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "float8out_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "592-620",
          "snippet": "char *\nfloat8out_internal(double num)\n{\n\tchar\t   *ascii;\n\n\tif (isnan(num))\n\t\treturn pstrdup(\"NaN\");\n\n\tswitch (is_infinite(num))\n\t{\n\t\tcase 1:\n\t\t\tascii = pstrdup(\"Infinity\");\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tascii = pstrdup(\"-Infinity\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint\t\t\tndig = DBL_DIG + extra_float_digits;\n\n\t\t\t\tif (ndig < 1)\n\t\t\t\t\tndig = 1;\n\n\t\t\t\tascii = psprintf(\"%.*g\", ndig, num);\n\t\t\t}\n\t}\n\n\treturn ascii;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\textra_float_digits = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\t\t\textra_float_digits = 0;\n\nchar *\nfloat8out_internal(double num)\n{\n\tchar\t   *ascii;\n\n\tif (isnan(num))\n\t\treturn pstrdup(\"NaN\");\n\n\tswitch (is_infinite(num))\n\t{\n\t\tcase 1:\n\t\t\tascii = pstrdup(\"Infinity\");\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tascii = pstrdup(\"-Infinity\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint\t\t\tndig = DBL_DIG + extra_float_digits;\n\n\t\t\t\tif (ndig < 1)\n\t\t\t\t\tndig = 1;\n\n\t\t\t\tascii = psprintf(\"%.*g\", ndig, num);\n\t\t\t}\n\t}\n\n\treturn ascii;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8out(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tnum = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_CSTRING(float8out_internal(num));\n}"
  },
  {
    "function_name": "float8in_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "440-571",
    "snippet": "double\nfloat8in_internal(char *num, char **endptr_p,\n\t\t\t\t  const char *type_name, const char *orig_string)\n{\n\tdouble\t\tval;\n\tchar\t   *endptr;\n\n\t/* skip leading whitespace */\n\twhile (*num != '\\0' && isspace((unsigned char) *num))\n\t\tnum++;\n\n\t/*\n\t * Check for an empty-string input to begin with, to avoid the vagaries of\n\t * strtod() on different platforms.\n\t */\n\tif (*num == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\terrno = 0;\n\tval = strtod(num, &endptr);\n\n\t/* did we not see anything that looks like a double? */\n\tif (endptr == num || errno != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\t/*\n\t\t * C99 requires that strtod() accept NaN, [+-]Infinity, and [+-]Inf,\n\t\t * but not all platforms support all of these (and some accept them\n\t\t * but set ERANGE anyway...)  Therefore, we check for these inputs\n\t\t * ourselves if strtod() fails.\n\t\t *\n\t\t * Note: C99 also requires hexadecimal input as well as some extended\n\t\t * forms of NaN, but we consider these forms unportable and don't try\n\t\t * to support them.  You can use 'em if your strtod() takes 'em.\n\t\t */\n\t\tif (pg_strncasecmp(num, \"NaN\", 3) == 0)\n\t\t{\n\t\t\tval = get_float8_nan();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"Infinity\", 8) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 8;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = -get_float8_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"inf\", 3) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+inf\", 4) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-inf\", 4) == 0)\n\t\t{\n\t\t\tval = -get_float8_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (save_errno == ERANGE)\n\t\t{\n\t\t\t/*\n\t\t\t * Some platforms return ERANGE for denormalized numbers (those\n\t\t\t * that are not zero, but are too close to zero to have full\n\t\t\t * precision).  We'd prefer not to throw error for that, so try to\n\t\t\t * detect whether it's a \"real\" out-of-range condition by checking\n\t\t\t * to see if the result is zero or huge.\n\t\t\t *\n\t\t\t * On error, we intentionally complain about double precision not\n\t\t\t * the given type name, and we print only the part of the string\n\t\t\t * that is the current number.\n\t\t\t */\n\t\t\tif (val == 0.0 || val >= HUGE_VAL || val <= -HUGE_VAL)\n\t\t\t{\n\t\t\t\tchar\t   *errnumber = pstrdup(num);\n\n\t\t\t\terrnumber[endptr - num] = '\\0';\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"\\\"%s\\\" is out of range for type double precision\",\n\t\t\t\t\t\t\t\terrnumber)));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n#ifdef HAVE_BUGGY_SOLARIS_STRTOD\n\telse\n\t{\n\t\t/*\n\t\t * Many versions of Solaris have a bug wherein strtod sets endptr to\n\t\t * point one byte beyond the end of the string when given \"inf\" or\n\t\t * \"infinity\".\n\t\t */\n\t\tif (endptr != num && endptr[-1] == '\\0')\n\t\t\tendptr--;\n\t}\n#endif\t\t\t\t\t\t\t/* HAVE_BUGGY_SOLARIS_STRTOD */\n\n\t/* skip trailing whitespace */\n\twhile (*endptr != '\\0' && isspace((unsigned char) *endptr))\n\t\tendptr++;\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = endptr;\n\telse if (*endptr != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\treturn val;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string))"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input syntax for type %s: \\\"%s\\\"\"",
            "type_name",
            "orig_string"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *endptr"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string))"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"\\\"%s\\\" is out of range for type double precision\",\n\t\t\t\t\t\t\t\terrnumber))"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "num"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_float8_infinity",
          "args": [],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_infinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "117-132",
          "snippet": "double\nget_float8_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (double) INFINITY;\n#else\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (double) (HUGE_VAL * HUGE_VAL);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ndouble\nget_float8_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (double) INFINITY;\n#else\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (double) (HUGE_VAL * HUGE_VAL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "num",
            "\"-inf\"",
            "4"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "num",
            "\"+inf\"",
            "4"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "num",
            "\"inf\"",
            "3"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "num",
            "\"-Infinity\"",
            "9"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "num",
            "\"+Infinity\"",
            "9"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "num",
            "\"Infinity\"",
            "8"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "num",
            "\"NaN\"",
            "3"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtod",
          "args": [
            "num",
            "&endptr"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string))"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ndouble\nfloat8in_internal(char *num, char **endptr_p,\n\t\t\t\t  const char *type_name, const char *orig_string)\n{\n\tdouble\t\tval;\n\tchar\t   *endptr;\n\n\t/* skip leading whitespace */\n\twhile (*num != '\\0' && isspace((unsigned char) *num))\n\t\tnum++;\n\n\t/*\n\t * Check for an empty-string input to begin with, to avoid the vagaries of\n\t * strtod() on different platforms.\n\t */\n\tif (*num == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\terrno = 0;\n\tval = strtod(num, &endptr);\n\n\t/* did we not see anything that looks like a double? */\n\tif (endptr == num || errno != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\t/*\n\t\t * C99 requires that strtod() accept NaN, [+-]Infinity, and [+-]Inf,\n\t\t * but not all platforms support all of these (and some accept them\n\t\t * but set ERANGE anyway...)  Therefore, we check for these inputs\n\t\t * ourselves if strtod() fails.\n\t\t *\n\t\t * Note: C99 also requires hexadecimal input as well as some extended\n\t\t * forms of NaN, but we consider these forms unportable and don't try\n\t\t * to support them.  You can use 'em if your strtod() takes 'em.\n\t\t */\n\t\tif (pg_strncasecmp(num, \"NaN\", 3) == 0)\n\t\t{\n\t\t\tval = get_float8_nan();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"Infinity\", 8) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 8;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = -get_float8_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"inf\", 3) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+inf\", 4) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-inf\", 4) == 0)\n\t\t{\n\t\t\tval = -get_float8_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (save_errno == ERANGE)\n\t\t{\n\t\t\t/*\n\t\t\t * Some platforms return ERANGE for denormalized numbers (those\n\t\t\t * that are not zero, but are too close to zero to have full\n\t\t\t * precision).  We'd prefer not to throw error for that, so try to\n\t\t\t * detect whether it's a \"real\" out-of-range condition by checking\n\t\t\t * to see if the result is zero or huge.\n\t\t\t *\n\t\t\t * On error, we intentionally complain about double precision not\n\t\t\t * the given type name, and we print only the part of the string\n\t\t\t * that is the current number.\n\t\t\t */\n\t\t\tif (val == 0.0 || val >= HUGE_VAL || val <= -HUGE_VAL)\n\t\t\t{\n\t\t\t\tchar\t   *errnumber = pstrdup(num);\n\n\t\t\t\terrnumber[endptr - num] = '\\0';\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"\\\"%s\\\" is out of range for type double precision\",\n\t\t\t\t\t\t\t\terrnumber)));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n#ifdef HAVE_BUGGY_SOLARIS_STRTOD\n\telse\n\t{\n\t\t/*\n\t\t * Many versions of Solaris have a bug wherein strtod sets endptr to\n\t\t * point one byte beyond the end of the string when given \"inf\" or\n\t\t * \"infinity\".\n\t\t */\n\t\tif (endptr != num && endptr[-1] == '\\0')\n\t\t\tendptr--;\n\t}\n#endif\t\t\t\t\t\t\t/* HAVE_BUGGY_SOLARIS_STRTOD */\n\n\t/* skip trailing whitespace */\n\twhile (*endptr != '\\0' && isspace((unsigned char) *endptr))\n\t\tendptr++;\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = endptr;\n\telse if (*endptr != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\treturn val;\n}"
  },
  {
    "function_name": "float8in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "414-420",
    "snippet": "Datum\nfloat8in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *num = PG_GETARG_CSTRING(0);\n\n\tPG_RETURN_FLOAT8(float8in_internal(num, NULL, \"double precision\", num));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "float8in_internal(num, NULL, \"double precision\", num)"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8in_internal",
          "args": [
            "num",
            "NULL",
            "\"double precision\"",
            "num"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "float8in_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "440-571",
          "snippet": "double\nfloat8in_internal(char *num, char **endptr_p,\n\t\t\t\t  const char *type_name, const char *orig_string)\n{\n\tdouble\t\tval;\n\tchar\t   *endptr;\n\n\t/* skip leading whitespace */\n\twhile (*num != '\\0' && isspace((unsigned char) *num))\n\t\tnum++;\n\n\t/*\n\t * Check for an empty-string input to begin with, to avoid the vagaries of\n\t * strtod() on different platforms.\n\t */\n\tif (*num == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\terrno = 0;\n\tval = strtod(num, &endptr);\n\n\t/* did we not see anything that looks like a double? */\n\tif (endptr == num || errno != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\t/*\n\t\t * C99 requires that strtod() accept NaN, [+-]Infinity, and [+-]Inf,\n\t\t * but not all platforms support all of these (and some accept them\n\t\t * but set ERANGE anyway...)  Therefore, we check for these inputs\n\t\t * ourselves if strtod() fails.\n\t\t *\n\t\t * Note: C99 also requires hexadecimal input as well as some extended\n\t\t * forms of NaN, but we consider these forms unportable and don't try\n\t\t * to support them.  You can use 'em if your strtod() takes 'em.\n\t\t */\n\t\tif (pg_strncasecmp(num, \"NaN\", 3) == 0)\n\t\t{\n\t\t\tval = get_float8_nan();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"Infinity\", 8) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 8;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = -get_float8_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"inf\", 3) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+inf\", 4) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-inf\", 4) == 0)\n\t\t{\n\t\t\tval = -get_float8_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (save_errno == ERANGE)\n\t\t{\n\t\t\t/*\n\t\t\t * Some platforms return ERANGE for denormalized numbers (those\n\t\t\t * that are not zero, but are too close to zero to have full\n\t\t\t * precision).  We'd prefer not to throw error for that, so try to\n\t\t\t * detect whether it's a \"real\" out-of-range condition by checking\n\t\t\t * to see if the result is zero or huge.\n\t\t\t *\n\t\t\t * On error, we intentionally complain about double precision not\n\t\t\t * the given type name, and we print only the part of the string\n\t\t\t * that is the current number.\n\t\t\t */\n\t\t\tif (val == 0.0 || val >= HUGE_VAL || val <= -HUGE_VAL)\n\t\t\t{\n\t\t\t\tchar\t   *errnumber = pstrdup(num);\n\n\t\t\t\terrnumber[endptr - num] = '\\0';\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"\\\"%s\\\" is out of range for type double precision\",\n\t\t\t\t\t\t\t\terrnumber)));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n#ifdef HAVE_BUGGY_SOLARIS_STRTOD\n\telse\n\t{\n\t\t/*\n\t\t * Many versions of Solaris have a bug wherein strtod sets endptr to\n\t\t * point one byte beyond the end of the string when given \"inf\" or\n\t\t * \"infinity\".\n\t\t */\n\t\tif (endptr != num && endptr[-1] == '\\0')\n\t\t\tendptr--;\n\t}\n#endif\t\t\t\t\t\t\t/* HAVE_BUGGY_SOLARIS_STRTOD */\n\n\t/* skip trailing whitespace */\n\twhile (*endptr != '\\0' && isspace((unsigned char) *endptr))\n\t\tendptr++;\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = endptr;\n\telse if (*endptr != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\treturn val;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ndouble\nfloat8in_internal(char *num, char **endptr_p,\n\t\t\t\t  const char *type_name, const char *orig_string)\n{\n\tdouble\t\tval;\n\tchar\t   *endptr;\n\n\t/* skip leading whitespace */\n\twhile (*num != '\\0' && isspace((unsigned char) *num))\n\t\tnum++;\n\n\t/*\n\t * Check for an empty-string input to begin with, to avoid the vagaries of\n\t * strtod() on different platforms.\n\t */\n\tif (*num == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\terrno = 0;\n\tval = strtod(num, &endptr);\n\n\t/* did we not see anything that looks like a double? */\n\tif (endptr == num || errno != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\t/*\n\t\t * C99 requires that strtod() accept NaN, [+-]Infinity, and [+-]Inf,\n\t\t * but not all platforms support all of these (and some accept them\n\t\t * but set ERANGE anyway...)  Therefore, we check for these inputs\n\t\t * ourselves if strtod() fails.\n\t\t *\n\t\t * Note: C99 also requires hexadecimal input as well as some extended\n\t\t * forms of NaN, but we consider these forms unportable and don't try\n\t\t * to support them.  You can use 'em if your strtod() takes 'em.\n\t\t */\n\t\tif (pg_strncasecmp(num, \"NaN\", 3) == 0)\n\t\t{\n\t\t\tval = get_float8_nan();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"Infinity\", 8) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 8;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = -get_float8_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"inf\", 3) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+inf\", 4) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-inf\", 4) == 0)\n\t\t{\n\t\t\tval = -get_float8_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (save_errno == ERANGE)\n\t\t{\n\t\t\t/*\n\t\t\t * Some platforms return ERANGE for denormalized numbers (those\n\t\t\t * that are not zero, but are too close to zero to have full\n\t\t\t * precision).  We'd prefer not to throw error for that, so try to\n\t\t\t * detect whether it's a \"real\" out-of-range condition by checking\n\t\t\t * to see if the result is zero or huge.\n\t\t\t *\n\t\t\t * On error, we intentionally complain about double precision not\n\t\t\t * the given type name, and we print only the part of the string\n\t\t\t * that is the current number.\n\t\t\t */\n\t\t\tif (val == 0.0 || val >= HUGE_VAL || val <= -HUGE_VAL)\n\t\t\t{\n\t\t\t\tchar\t   *errnumber = pstrdup(num);\n\n\t\t\t\terrnumber[endptr - num] = '\\0';\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"\\\"%s\\\" is out of range for type double precision\",\n\t\t\t\t\t\t\t\terrnumber)));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n#ifdef HAVE_BUGGY_SOLARIS_STRTOD\n\telse\n\t{\n\t\t/*\n\t\t * Many versions of Solaris have a bug wherein strtod sets endptr to\n\t\t * point one byte beyond the end of the string when given \"inf\" or\n\t\t * \"infinity\".\n\t\t */\n\t\tif (endptr != num && endptr[-1] == '\\0')\n\t\t\tendptr--;\n\t}\n#endif\t\t\t\t\t\t\t/* HAVE_BUGGY_SOLARIS_STRTOD */\n\n\t/* skip trailing whitespace */\n\twhile (*endptr != '\\0' && isspace((unsigned char) *endptr))\n\t\tendptr++;\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = endptr;\n\telse if (*endptr != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *num = PG_GETARG_CSTRING(0);\n\n\tPG_RETURN_FLOAT8(float8in_internal(num, NULL, \"double precision\", num));\n}"
  },
  {
    "function_name": "float4send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "400-409",
    "snippet": "Datum\nfloat4send(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\tnum = PG_GETARG_FLOAT4(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendfloat4(&buf, num);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat4",
          "args": [
            "&buf",
            "num"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4send(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\tnum = PG_GETARG_FLOAT4(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendfloat4(&buf, num);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "float4recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "389-395",
    "snippet": "Datum\nfloat4recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_FLOAT4(pq_getmsgfloat4(buf));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "pq_getmsgfloat4(buf)"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat4",
          "args": [
            "buf"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_FLOAT4(pq_getmsgfloat4(buf));\n}"
  },
  {
    "function_name": "float4out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "355-384",
    "snippet": "Datum\nfloat4out(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\tnum = PG_GETARG_FLOAT4(0);\n\tchar\t   *ascii;\n\n\tif (isnan(num))\n\t\tPG_RETURN_CSTRING(pstrdup(\"NaN\"));\n\n\tswitch (is_infinite(num))\n\t{\n\t\tcase 1:\n\t\t\tascii = pstrdup(\"Infinity\");\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tascii = pstrdup(\"-Infinity\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint\t\t\tndig = FLT_DIG + extra_float_digits;\n\n\t\t\t\tif (ndig < 1)\n\t\t\t\t\tndig = 1;\n\n\t\t\t\tascii = psprintf(\"%.*g\", ndig, num);\n\t\t\t}\n\t}\n\n\tPG_RETURN_CSTRING(ascii);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\textra_float_digits = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "ascii"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%.*g\"",
            "ndig",
            "num"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "\"-Infinity\""
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_infinite",
          "args": [
            "num"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "is_infinite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "195-206",
          "snippet": "int\nis_infinite(double val)\n{\n\tint\t\t\tinf = isinf(val);\n\n\tif (inf == 0)\n\t\treturn 0;\n\telse if (val > 0)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nis_infinite(double val)\n{\n\tint\t\t\tinf = isinf(val);\n\n\tif (inf == 0)\n\t\treturn 0;\n\telse if (val > 0)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "pstrdup(\"NaN\")"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "num"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\t\t\textra_float_digits = 0;\n\nDatum\nfloat4out(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\tnum = PG_GETARG_FLOAT4(0);\n\tchar\t   *ascii;\n\n\tif (isnan(num))\n\t\tPG_RETURN_CSTRING(pstrdup(\"NaN\"));\n\n\tswitch (is_infinite(num))\n\t{\n\t\tcase 1:\n\t\t\tascii = pstrdup(\"Infinity\");\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tascii = pstrdup(\"-Infinity\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint\t\t\tndig = FLT_DIG + extra_float_digits;\n\n\t\t\t\tif (ndig < 1)\n\t\t\t\t\tndig = 1;\n\n\t\t\t\tascii = psprintf(\"%.*g\", ndig, num);\n\t\t\t}\n\t}\n\n\tPG_RETURN_CSTRING(ascii);\n}"
  },
  {
    "function_name": "float4in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "215-349",
    "snippet": "Datum\nfloat4in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *num = PG_GETARG_CSTRING(0);\n\tchar\t   *orig_num;\n\tdouble\t\tval;\n\tchar\t   *endptr;\n\n\t/*\n\t * endptr points to the first character _after_ the sequence we recognized\n\t * as a valid floating point number. orig_num points to the original input\n\t * string.\n\t */\n\torig_num = num;\n\n\t/* skip leading whitespace */\n\twhile (*num != '\\0' && isspace((unsigned char) *num))\n\t\tnum++;\n\n\t/*\n\t * Check for an empty-string input to begin with, to avoid the vagaries of\n\t * strtod() on different platforms.\n\t */\n\tif (*num == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"real\", orig_num)));\n\n\terrno = 0;\n\tval = strtod(num, &endptr);\n\n\t/* did we not see anything that looks like a double? */\n\tif (endptr == num || errno != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\t/*\n\t\t * C99 requires that strtod() accept NaN, [+-]Infinity, and [+-]Inf,\n\t\t * but not all platforms support all of these (and some accept them\n\t\t * but set ERANGE anyway...)  Therefore, we check for these inputs\n\t\t * ourselves if strtod() fails.\n\t\t *\n\t\t * Note: C99 also requires hexadecimal input as well as some extended\n\t\t * forms of NaN, but we consider these forms unportable and don't try\n\t\t * to support them.  You can use 'em if your strtod() takes 'em.\n\t\t */\n\t\tif (pg_strncasecmp(num, \"NaN\", 3) == 0)\n\t\t{\n\t\t\tval = get_float4_nan();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"Infinity\", 8) == 0)\n\t\t{\n\t\t\tval = get_float4_infinity();\n\t\t\tendptr = num + 8;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = get_float4_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = -get_float4_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"inf\", 3) == 0)\n\t\t{\n\t\t\tval = get_float4_infinity();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+inf\", 4) == 0)\n\t\t{\n\t\t\tval = get_float4_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-inf\", 4) == 0)\n\t\t{\n\t\t\tval = -get_float4_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (save_errno == ERANGE)\n\t\t{\n\t\t\t/*\n\t\t\t * Some platforms return ERANGE for denormalized numbers (those\n\t\t\t * that are not zero, but are too close to zero to have full\n\t\t\t * precision).  We'd prefer not to throw error for that, so try to\n\t\t\t * detect whether it's a \"real\" out-of-range condition by checking\n\t\t\t * to see if the result is zero or huge.\n\t\t\t */\n\t\t\tif (val == 0.0 || val >= HUGE_VAL || val <= -HUGE_VAL)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"\\\"%s\\\" is out of range for type real\",\n\t\t\t\t\t\t\t\torig_num)));\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"real\", orig_num)));\n\t}\n#ifdef HAVE_BUGGY_SOLARIS_STRTOD\n\telse\n\t{\n\t\t/*\n\t\t * Many versions of Solaris have a bug wherein strtod sets endptr to\n\t\t * point one byte beyond the end of the string when given \"inf\" or\n\t\t * \"infinity\".\n\t\t */\n\t\tif (endptr != num && endptr[-1] == '\\0')\n\t\t\tendptr--;\n\t}\n#endif\t\t\t\t\t\t\t/* HAVE_BUGGY_SOLARIS_STRTOD */\n\n\t/* skip trailing whitespace */\n\twhile (*endptr != '\\0' && isspace((unsigned char) *endptr))\n\t\tendptr++;\n\n\t/* if there is any junk left at the end of the string, bail out */\n\tif (*endptr != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"real\", orig_num)));\n\n\t/*\n\t * if we get here, we have a legal double, still need to check to see if\n\t * it's a legal float4\n\t */\n\tCHECKFLOATVAL((float4) val, isinf(val), val == 0);\n\n\tPG_RETURN_FLOAT4((float4) val);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "(float4) val"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECKFLOATVAL",
          "args": [
            "(float4) val",
            "isinf(val)",
            "val == 0"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "val"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"real\", orig_num))"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input syntax for type %s: \\\"%s\\\"\"",
            "\"real\"",
            "orig_num"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *endptr"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"real\", orig_num))"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"\\\"%s\\\" is out of range for type real\",\n\t\t\t\t\t\t\t\torig_num))"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float4_infinity",
          "args": [],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "get_float4_infinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "142-160",
          "snippet": "float\nget_float4_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (float) INFINITY;\n#else\n#if (_MSC_VER >= 1800)\n#pragma warning(default:4756)\n#endif\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (float) (HUGE_VAL * HUGE_VAL);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nfloat\nget_float4_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (float) INFINITY;\n#else\n#if (_MSC_VER >= 1800)\n#pragma warning(default:4756)\n#endif\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (float) (HUGE_VAL * HUGE_VAL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "num",
            "\"-inf\"",
            "4"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "num",
            "\"+inf\"",
            "4"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "num",
            "\"inf\"",
            "3"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "num",
            "\"-Infinity\"",
            "9"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "num",
            "\"+Infinity\"",
            "9"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "num",
            "\"Infinity\"",
            "8"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float4_nan",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "get_float4_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "175-185",
          "snippet": "float\nget_float4_nan(void)\n{\n#ifdef NAN\n\t/* C99 standard way */\n\treturn (float) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (float) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nfloat\nget_float4_nan(void)\n{\n#ifdef NAN\n\t/* C99 standard way */\n\treturn (float) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (float) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "num",
            "\"NaN\"",
            "3"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtod",
          "args": [
            "num",
            "&endptr"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"real\", orig_num))"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat4in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *num = PG_GETARG_CSTRING(0);\n\tchar\t   *orig_num;\n\tdouble\t\tval;\n\tchar\t   *endptr;\n\n\t/*\n\t * endptr points to the first character _after_ the sequence we recognized\n\t * as a valid floating point number. orig_num points to the original input\n\t * string.\n\t */\n\torig_num = num;\n\n\t/* skip leading whitespace */\n\twhile (*num != '\\0' && isspace((unsigned char) *num))\n\t\tnum++;\n\n\t/*\n\t * Check for an empty-string input to begin with, to avoid the vagaries of\n\t * strtod() on different platforms.\n\t */\n\tif (*num == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"real\", orig_num)));\n\n\terrno = 0;\n\tval = strtod(num, &endptr);\n\n\t/* did we not see anything that looks like a double? */\n\tif (endptr == num || errno != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\t/*\n\t\t * C99 requires that strtod() accept NaN, [+-]Infinity, and [+-]Inf,\n\t\t * but not all platforms support all of these (and some accept them\n\t\t * but set ERANGE anyway...)  Therefore, we check for these inputs\n\t\t * ourselves if strtod() fails.\n\t\t *\n\t\t * Note: C99 also requires hexadecimal input as well as some extended\n\t\t * forms of NaN, but we consider these forms unportable and don't try\n\t\t * to support them.  You can use 'em if your strtod() takes 'em.\n\t\t */\n\t\tif (pg_strncasecmp(num, \"NaN\", 3) == 0)\n\t\t{\n\t\t\tval = get_float4_nan();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"Infinity\", 8) == 0)\n\t\t{\n\t\t\tval = get_float4_infinity();\n\t\t\tendptr = num + 8;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = get_float4_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = -get_float4_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"inf\", 3) == 0)\n\t\t{\n\t\t\tval = get_float4_infinity();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+inf\", 4) == 0)\n\t\t{\n\t\t\tval = get_float4_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-inf\", 4) == 0)\n\t\t{\n\t\t\tval = -get_float4_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (save_errno == ERANGE)\n\t\t{\n\t\t\t/*\n\t\t\t * Some platforms return ERANGE for denormalized numbers (those\n\t\t\t * that are not zero, but are too close to zero to have full\n\t\t\t * precision).  We'd prefer not to throw error for that, so try to\n\t\t\t * detect whether it's a \"real\" out-of-range condition by checking\n\t\t\t * to see if the result is zero or huge.\n\t\t\t */\n\t\t\tif (val == 0.0 || val >= HUGE_VAL || val <= -HUGE_VAL)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"\\\"%s\\\" is out of range for type real\",\n\t\t\t\t\t\t\t\torig_num)));\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"real\", orig_num)));\n\t}\n#ifdef HAVE_BUGGY_SOLARIS_STRTOD\n\telse\n\t{\n\t\t/*\n\t\t * Many versions of Solaris have a bug wherein strtod sets endptr to\n\t\t * point one byte beyond the end of the string when given \"inf\" or\n\t\t * \"infinity\".\n\t\t */\n\t\tif (endptr != num && endptr[-1] == '\\0')\n\t\t\tendptr--;\n\t}\n#endif\t\t\t\t\t\t\t/* HAVE_BUGGY_SOLARIS_STRTOD */\n\n\t/* skip trailing whitespace */\n\twhile (*endptr != '\\0' && isspace((unsigned char) *endptr))\n\t\tendptr++;\n\n\t/* if there is any junk left at the end of the string, bail out */\n\tif (*endptr != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"real\", orig_num)));\n\n\t/*\n\t * if we get here, we have a legal double, still need to check to see if\n\t * it's a legal float4\n\t */\n\tCHECKFLOATVAL((float4) val, isinf(val), val == 0);\n\n\tPG_RETURN_FLOAT4((float4) val);\n}"
  },
  {
    "function_name": "is_infinite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "195-206",
    "snippet": "int\nis_infinite(double val)\n{\n\tint\t\t\tinf = isinf(val);\n\n\tif (inf == 0)\n\t\treturn 0;\n\telse if (val > 0)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "val"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nis_infinite(double val)\n{\n\tint\t\t\tinf = isinf(val);\n\n\tif (inf == 0)\n\t\treturn 0;\n\telse if (val > 0)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}"
  },
  {
    "function_name": "get_float4_nan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "175-185",
    "snippet": "float\nget_float4_nan(void)\n{\n#ifdef NAN\n\t/* C99 standard way */\n\treturn (float) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (float) (0.0 / 0.0);\n#endif\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NAN (*(const double *) nan)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\nfloat\nget_float4_nan(void)\n{\n#ifdef NAN\n\t/* C99 standard way */\n\treturn (float) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (float) (0.0 / 0.0);\n#endif\n}"
  },
  {
    "function_name": "get_float8_nan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "162-173",
    "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NAN (*(const double *) nan)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
  },
  {
    "function_name": "get_float4_infinity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "142-160",
    "snippet": "float\nget_float4_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (float) INFINITY;\n#else\n#if (_MSC_VER >= 1800)\n#pragma warning(default:4756)\n#endif\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (float) (HUGE_VAL * HUGE_VAL);\n#endif\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nfloat\nget_float4_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (float) INFINITY;\n#else\n#if (_MSC_VER >= 1800)\n#pragma warning(default:4756)\n#endif\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (float) (HUGE_VAL * HUGE_VAL);\n#endif\n}"
  },
  {
    "function_name": "get_float8_infinity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
    "lines": "117-132",
    "snippet": "double\nget_float8_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (double) INFINITY;\n#else\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (double) (HUGE_VAL * HUGE_VAL);\n#endif\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ndouble\nget_float8_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (double) INFINITY;\n#else\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (double) (HUGE_VAL * HUGE_VAL);\n#endif\n}"
  }
]