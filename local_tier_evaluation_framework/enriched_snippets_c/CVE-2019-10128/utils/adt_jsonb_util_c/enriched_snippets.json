[
  {
    "function_name": "uniqueifyJsonbObject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "1818-1848",
    "snippet": "static void\nuniqueifyJsonbObject(JsonbValue *object)\n{\n\tbool\t\thasNonUniq = false;\n\n\tAssert(object->type == jbvObject);\n\n\tif (object->val.object.nPairs > 1)\n\t\tqsort_arg(object->val.object.pairs, object->val.object.nPairs, sizeof(JsonbPair),\n\t\t\t\t  lengthCompareJsonbPair, &hasNonUniq);\n\n\tif (hasNonUniq)\n\t{\n\t\tJsonbPair  *ptr = object->val.object.pairs + 1,\n\t\t\t\t   *res = object->val.object.pairs;\n\n\t\twhile (ptr - object->val.object.pairs < object->val.object.nPairs)\n\t\t{\n\t\t\t/* Avoid copying over duplicate */\n\t\t\tif (lengthCompareJsonbStringValue(ptr, res) != 0)\n\t\t\t{\n\t\t\t\tres++;\n\t\t\t\tif (ptr != res)\n\t\t\t\t\tmemcpy(res, ptr, sizeof(JsonbPair));\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\n\t\tobject->val.object.nPairs = res + 1 - object->val.object.pairs;\n\t}\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static void uniqueifyJsonbObject(JsonbValue *object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "res",
            "ptr",
            "sizeof(JsonbPair)"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthCompareJsonbStringValue",
          "args": [
            "ptr",
            "res"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "lengthCompareJsonbStringValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1761-1781",
          "snippet": "static int\nlengthCompareJsonbStringValue(const void *a, const void *b)\n{\n\tconst JsonbValue *va = (const JsonbValue *) a;\n\tconst JsonbValue *vb = (const JsonbValue *) b;\n\tint\t\t\tres;\n\n\tAssert(va->type == jbvString);\n\tAssert(vb->type == jbvString);\n\n\tif (va->val.string.len == vb->val.string.len)\n\t{\n\t\tres = memcmp(va->val.string.val, vb->val.string.val, va->val.string.len);\n\t}\n\telse\n\t{\n\t\tres = (va->val.string.len > vb->val.string.len) ? 1 : -1;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static int\tlengthCompareJsonbStringValue(const void *a, const void *b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic int\tlengthCompareJsonbStringValue(const void *a, const void *b);\n\nstatic int\nlengthCompareJsonbStringValue(const void *a, const void *b)\n{\n\tconst JsonbValue *va = (const JsonbValue *) a;\n\tconst JsonbValue *vb = (const JsonbValue *) b;\n\tint\t\t\tres;\n\n\tAssert(va->type == jbvString);\n\tAssert(vb->type == jbvString);\n\n\tif (va->val.string.len == vb->val.string.len)\n\t{\n\t\tres = memcmp(va->val.string.val, vb->val.string.val, va->val.string.len);\n\t}\n\telse\n\t{\n\t\tres = (va->val.string.len > vb->val.string.len) ? 1 : -1;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort_arg",
          "args": [
            "object->val.object.pairs",
            "object->val.object.nPairs",
            "sizeof(JsonbPair)",
            "lengthCompareJsonbPair",
            "&hasNonUniq"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "object->type == jbvObject"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nstatic void\nuniqueifyJsonbObject(JsonbValue *object)\n{\n\tbool\t\thasNonUniq = false;\n\n\tAssert(object->type == jbvObject);\n\n\tif (object->val.object.nPairs > 1)\n\t\tqsort_arg(object->val.object.pairs, object->val.object.nPairs, sizeof(JsonbPair),\n\t\t\t\t  lengthCompareJsonbPair, &hasNonUniq);\n\n\tif (hasNonUniq)\n\t{\n\t\tJsonbPair  *ptr = object->val.object.pairs + 1,\n\t\t\t\t   *res = object->val.object.pairs;\n\n\t\twhile (ptr - object->val.object.pairs < object->val.object.nPairs)\n\t\t{\n\t\t\t/* Avoid copying over duplicate */\n\t\t\tif (lengthCompareJsonbStringValue(ptr, res) != 0)\n\t\t\t{\n\t\t\t\tres++;\n\t\t\t\tif (ptr != res)\n\t\t\t\t\tmemcpy(res, ptr, sizeof(JsonbPair));\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\n\t\tobject->val.object.nPairs = res + 1 - object->val.object.pairs;\n\t}\n}"
  },
  {
    "function_name": "lengthCompareJsonbPair",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "1794-1813",
    "snippet": "static int\nlengthCompareJsonbPair(const void *a, const void *b, void *binequal)\n{\n\tconst JsonbPair *pa = (const JsonbPair *) a;\n\tconst JsonbPair *pb = (const JsonbPair *) b;\n\tint\t\t\tres;\n\n\tres = lengthCompareJsonbStringValue(&pa->key, &pb->key);\n\tif (res == 0 && binequal)\n\t\t*((bool *) binequal) = true;\n\n\t/*\n\t * Guarantee keeping order of equal pair.  Unique algorithm will prefer\n\t * first element as value.\n\t */\n\tif (res == 0)\n\t\tres = (pa->order > pb->order) ? -1 : 1;\n\n\treturn res;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
      "static int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
      "static int\tlengthCompareJsonbStringValue(const void *a, const void *b);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lengthCompareJsonbStringValue",
          "args": [
            "&pa->key",
            "&pb->key"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "lengthCompareJsonbStringValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1761-1781",
          "snippet": "static int\nlengthCompareJsonbStringValue(const void *a, const void *b)\n{\n\tconst JsonbValue *va = (const JsonbValue *) a;\n\tconst JsonbValue *vb = (const JsonbValue *) b;\n\tint\t\t\tres;\n\n\tAssert(va->type == jbvString);\n\tAssert(vb->type == jbvString);\n\n\tif (va->val.string.len == vb->val.string.len)\n\t{\n\t\tres = memcmp(va->val.string.val, vb->val.string.val, va->val.string.len);\n\t}\n\telse\n\t{\n\t\tres = (va->val.string.len > vb->val.string.len) ? 1 : -1;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static int\tlengthCompareJsonbStringValue(const void *a, const void *b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic int\tlengthCompareJsonbStringValue(const void *a, const void *b);\n\nstatic int\nlengthCompareJsonbStringValue(const void *a, const void *b)\n{\n\tconst JsonbValue *va = (const JsonbValue *) a;\n\tconst JsonbValue *vb = (const JsonbValue *) b;\n\tint\t\t\tres;\n\n\tAssert(va->type == jbvString);\n\tAssert(vb->type == jbvString);\n\n\tif (va->val.string.len == vb->val.string.len)\n\t{\n\t\tres = memcmp(va->val.string.val, vb->val.string.val, va->val.string.len);\n\t}\n\telse\n\t{\n\t\tres = (va->val.string.len > vb->val.string.len) ? 1 : -1;\n\t}\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic int\tlengthCompareJsonbStringValue(const void *a, const void *b);\n\nstatic int\nlengthCompareJsonbPair(const void *a, const void *b, void *binequal)\n{\n\tconst JsonbPair *pa = (const JsonbPair *) a;\n\tconst JsonbPair *pb = (const JsonbPair *) b;\n\tint\t\t\tres;\n\n\tres = lengthCompareJsonbStringValue(&pa->key, &pb->key);\n\tif (res == 0 && binequal)\n\t\t*((bool *) binequal) = true;\n\n\t/*\n\t * Guarantee keeping order of equal pair.  Unique algorithm will prefer\n\t * first element as value.\n\t */\n\tif (res == 0)\n\t\tres = (pa->order > pb->order) ? -1 : 1;\n\n\treturn res;\n}"
  },
  {
    "function_name": "lengthCompareJsonbStringValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "1761-1781",
    "snippet": "static int\nlengthCompareJsonbStringValue(const void *a, const void *b)\n{\n\tconst JsonbValue *va = (const JsonbValue *) a;\n\tconst JsonbValue *vb = (const JsonbValue *) b;\n\tint\t\t\tres;\n\n\tAssert(va->type == jbvString);\n\tAssert(vb->type == jbvString);\n\n\tif (va->val.string.len == vb->val.string.len)\n\t{\n\t\tres = memcmp(va->val.string.val, vb->val.string.val, va->val.string.len);\n\t}\n\telse\n\t{\n\t\tres = (va->val.string.len > vb->val.string.len) ? 1 : -1;\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
      "static int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static int\treserveFromBuffer(StringInfo buffer, int len);",
      "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
      "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
      "static int\tlengthCompareJsonbStringValue(const void *a, const void *b);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "va->val.string.val",
            "vb->val.string.val",
            "va->val.string.len"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "vb->type == jbvString"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "va->type == jbvString"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic int\tlengthCompareJsonbStringValue(const void *a, const void *b);\n\nstatic int\nlengthCompareJsonbStringValue(const void *a, const void *b)\n{\n\tconst JsonbValue *va = (const JsonbValue *) a;\n\tconst JsonbValue *vb = (const JsonbValue *) b;\n\tint\t\t\tres;\n\n\tAssert(va->type == jbvString);\n\tAssert(vb->type == jbvString);\n\n\tif (va->val.string.len == vb->val.string.len)\n\t{\n\t\tres = memcmp(va->val.string.val, vb->val.string.val, va->val.string.len);\n\t}\n\telse\n\t{\n\t\tres = (va->val.string.len > vb->val.string.len) ? 1 : -1;\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "convertJsonbScalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "1712-1747",
    "snippet": "static void\nconvertJsonbScalar(StringInfo buffer, JEntry *jentry, JsonbValue *scalarVal)\n{\n\tint\t\t\tnumlen;\n\tshort\t\tpadlen;\n\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\t*jentry = JENTRY_ISNULL;\n\t\t\tbreak;\n\n\t\tcase jbvString:\n\t\t\tappendToBuffer(buffer, scalarVal->val.string.val, scalarVal->val.string.len);\n\n\t\t\t*jentry = scalarVal->val.string.len;\n\t\t\tbreak;\n\n\t\tcase jbvNumeric:\n\t\t\tnumlen = VARSIZE_ANY(scalarVal->val.numeric);\n\t\t\tpadlen = padBufferToInt(buffer);\n\n\t\t\tappendToBuffer(buffer, (char *) scalarVal->val.numeric, numlen);\n\n\t\t\t*jentry = JENTRY_ISNUMERIC | (padlen + numlen);\n\t\t\tbreak;\n\n\t\tcase jbvBool:\n\t\t\t*jentry = (scalarVal->val.boolean) ?\n\t\t\t\tJENTRY_ISBOOL_TRUE : JENTRY_ISBOOL_FALSE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t}\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
      "static int\treserveFromBuffer(StringInfo buffer, int len);",
      "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
      "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
      "static short padBufferToInt(StringInfo buffer);",
      "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid jsonb scalar type\""
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendToBuffer",
          "args": [
            "buffer",
            "(char *) scalarVal->val.numeric",
            "numlen"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "appendToBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1410-1417",
          "snippet": "static void\nappendToBuffer(StringInfo buffer, const char *data, int len)\n{\n\tint\t\t\toffset;\n\n\toffset = reserveFromBuffer(buffer, len);\n\tcopyToBuffer(buffer, offset, data, len);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\n\nstatic void\nappendToBuffer(StringInfo buffer, const char *data, int len)\n{\n\tint\t\t\toffset;\n\n\toffset = reserveFromBuffer(buffer, len);\n\tcopyToBuffer(buffer, offset, data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padBufferToInt",
          "args": [
            "buffer"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "padBufferToInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1424-1440",
          "snippet": "static short\npadBufferToInt(StringInfo buffer)\n{\n\tint\t\t\tpadlen,\n\t\t\t\tp,\n\t\t\t\toffset;\n\n\tpadlen = INTALIGN(buffer->len) - buffer->len;\n\n\toffset = reserveFromBuffer(buffer, padlen);\n\n\t/* padlen must be small, so this is probably faster than a memset */\n\tfor (p = 0; p < padlen; p++)\n\t\tbuffer->data[offset + p] = '\\0';\n\n\treturn padlen;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\n\nstatic short\npadBufferToInt(StringInfo buffer)\n{\n\tint\t\t\tpadlen,\n\t\t\t\tp,\n\t\t\t\toffset;\n\n\tpadlen = INTALIGN(buffer->len) - buffer->len;\n\n\toffset = reserveFromBuffer(buffer, padlen);\n\n\t/* padlen must be small, so this is probably faster than a memset */\n\tfor (p = 0; p < padlen; p++)\n\t\tbuffer->data[offset + p] = '\\0';\n\n\treturn padlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY",
          "args": [
            "scalarVal->val.numeric"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic void\nconvertJsonbScalar(StringInfo buffer, JEntry *jentry, JsonbValue *scalarVal)\n{\n\tint\t\t\tnumlen;\n\tshort\t\tpadlen;\n\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\t*jentry = JENTRY_ISNULL;\n\t\t\tbreak;\n\n\t\tcase jbvString:\n\t\t\tappendToBuffer(buffer, scalarVal->val.string.val, scalarVal->val.string.len);\n\n\t\t\t*jentry = scalarVal->val.string.len;\n\t\t\tbreak;\n\n\t\tcase jbvNumeric:\n\t\t\tnumlen = VARSIZE_ANY(scalarVal->val.numeric);\n\t\t\tpadlen = padBufferToInt(buffer);\n\n\t\t\tappendToBuffer(buffer, (char *) scalarVal->val.numeric, numlen);\n\n\t\t\t*jentry = JENTRY_ISNUMERIC | (padlen + numlen);\n\t\t\tbreak;\n\n\t\tcase jbvBool:\n\t\t\t*jentry = (scalarVal->val.boolean) ?\n\t\t\t\tJENTRY_ISBOOL_TRUE : JENTRY_ISBOOL_FALSE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t}\n}"
  },
  {
    "function_name": "convertJsonbObject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "1596-1710",
    "snippet": "static void\nconvertJsonbObject(StringInfo buffer, JEntry *pheader, JsonbValue *val, int level)\n{\n\tint\t\t\tbase_offset;\n\tint\t\t\tjentry_offset;\n\tint\t\t\ti;\n\tint\t\t\ttotallen;\n\tuint32\t\theader;\n\tint\t\t\tnPairs = val->val.object.nPairs;\n\n\t/* Remember where in the buffer this object starts. */\n\tbase_offset = buffer->len;\n\n\t/* Align to 4-byte boundary (any padding counts as part of my data) */\n\tpadBufferToInt(buffer);\n\n\t/*\n\t * Construct the header Jentry and store it in the beginning of the\n\t * variable-length payload.\n\t */\n\theader = nPairs | JB_FOBJECT;\n\tappendToBuffer(buffer, (char *) &header, sizeof(uint32));\n\n\t/* Reserve space for the JEntries of the keys and values. */\n\tjentry_offset = reserveFromBuffer(buffer, sizeof(JEntry) * nPairs * 2);\n\n\t/*\n\t * Iterate over the keys, then over the values, since that is the ordering\n\t * we want in the on-disk representation.\n\t */\n\ttotallen = 0;\n\tfor (i = 0; i < nPairs; i++)\n\t{\n\t\tJsonbPair  *pair = &val->val.object.pairs[i];\n\t\tint\t\t\tlen;\n\t\tJEntry\t\tmeta;\n\n\t\t/*\n\t\t * Convert key, producing a JEntry and appending its variable-length\n\t\t * data to buffer\n\t\t */\n\t\tconvertJsonbScalar(buffer, &meta, &pair->key);\n\n\t\tlen = JBE_OFFLENFLD(meta);\n\t\ttotallen += len;\n\n\t\t/*\n\t\t * Bail out if total variable-length data exceeds what will fit in a\n\t\t * JEntry length field.  We check this in each iteration, not just\n\t\t * once at the end, to forestall possible integer overflow.\n\t\t */\n\t\tif (totallen > JENTRY_OFFLENMASK)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"total size of jsonb object elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t\t/*\n\t\t * Convert each JB_OFFSET_STRIDE'th length to an offset.\n\t\t */\n\t\tif ((i % JB_OFFSET_STRIDE) == 0)\n\t\t\tmeta = (meta & JENTRY_TYPEMASK) | totallen | JENTRY_HAS_OFF;\n\n\t\tcopyToBuffer(buffer, jentry_offset, (char *) &meta, sizeof(JEntry));\n\t\tjentry_offset += sizeof(JEntry);\n\t}\n\tfor (i = 0; i < nPairs; i++)\n\t{\n\t\tJsonbPair  *pair = &val->val.object.pairs[i];\n\t\tint\t\t\tlen;\n\t\tJEntry\t\tmeta;\n\n\t\t/*\n\t\t * Convert value, producing a JEntry and appending its variable-length\n\t\t * data to buffer\n\t\t */\n\t\tconvertJsonbValue(buffer, &meta, &pair->value, level + 1);\n\n\t\tlen = JBE_OFFLENFLD(meta);\n\t\ttotallen += len;\n\n\t\t/*\n\t\t * Bail out if total variable-length data exceeds what will fit in a\n\t\t * JEntry length field.  We check this in each iteration, not just\n\t\t * once at the end, to forestall possible integer overflow.\n\t\t */\n\t\tif (totallen > JENTRY_OFFLENMASK)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"total size of jsonb object elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t\t/*\n\t\t * Convert each JB_OFFSET_STRIDE'th length to an offset.\n\t\t */\n\t\tif (((i + nPairs) % JB_OFFSET_STRIDE) == 0)\n\t\t\tmeta = (meta & JENTRY_TYPEMASK) | totallen | JENTRY_HAS_OFF;\n\n\t\tcopyToBuffer(buffer, jentry_offset, (char *) &meta, sizeof(JEntry));\n\t\tjentry_offset += sizeof(JEntry);\n\t}\n\n\t/* Total data size is everything we've appended to buffer */\n\ttotallen = buffer->len - base_offset;\n\n\t/* Check length again, since we didn't include the metadata above */\n\tif (totallen > JENTRY_OFFLENMASK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"total size of jsonb object elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t/* Initialize the header of this node in the container's JEntry array */\n\t*pheader = JENTRY_ISCONTAINER | totallen;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
      "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
      "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
      "static int\treserveFromBuffer(StringInfo buffer, int len);",
      "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
      "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
      "static short padBufferToInt(StringInfo buffer);",
      "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
      "static void uniqueifyJsonbObject(JsonbValue *object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"total size of jsonb object elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\tJENTRY_OFFLENMASK))"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"total size of jsonb object elements exceeds the maximum of %u bytes\"",
            "JENTRY_OFFLENMASK"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyToBuffer",
          "args": [
            "buffer",
            "jentry_offset",
            "(char *) &meta",
            "sizeof(JEntry)"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "copyToBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1401-1405",
          "snippet": "static void\ncopyToBuffer(StringInfo buffer, int offset, const char *data, int len)\n{\n\tmemcpy(buffer->data + offset, data, len);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\n\nstatic void\ncopyToBuffer(StringInfo buffer, int offset, const char *data, int len)\n{\n\tmemcpy(buffer->data + offset, data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"total size of jsonb object elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\t\tJENTRY_OFFLENMASK))"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBE_OFFLENFLD",
          "args": [
            "meta"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convertJsonbValue",
          "args": [
            "buffer",
            "&meta",
            "&pair->value",
            "level + 1"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "convertJsonbValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1487-1510",
          "snippet": "static void\nconvertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level)\n{\n\tcheck_stack_depth();\n\n\tif (!val)\n\t\treturn;\n\n\t/*\n\t * A JsonbValue passed as val should never have a type of jbvBinary, and\n\t * neither should any of its sub-components. Those values will be produced\n\t * by convertJsonbArray and convertJsonbObject, the results of which will\n\t * not be passed back to this function as an argument.\n\t */\n\n\tif (IsAJsonbScalar(val))\n\t\tconvertJsonbScalar(buffer, header, val);\n\telse if (val->type == jbvArray)\n\t\tconvertJsonbArray(buffer, header, val, level);\n\telse if (val->type == jbvObject)\n\t\tconvertJsonbObject(buffer, header, val, level);\n\telse\n\t\telog(ERROR, \"unknown type of jsonb container to convert\");\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static short padBufferToInt(StringInfo buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic short padBufferToInt(StringInfo buffer);\n\nstatic void\nconvertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level)\n{\n\tcheck_stack_depth();\n\n\tif (!val)\n\t\treturn;\n\n\t/*\n\t * A JsonbValue passed as val should never have a type of jbvBinary, and\n\t * neither should any of its sub-components. Those values will be produced\n\t * by convertJsonbArray and convertJsonbObject, the results of which will\n\t * not be passed back to this function as an argument.\n\t */\n\n\tif (IsAJsonbScalar(val))\n\t\tconvertJsonbScalar(buffer, header, val);\n\telse if (val->type == jbvArray)\n\t\tconvertJsonbArray(buffer, header, val, level);\n\telse if (val->type == jbvObject)\n\t\tconvertJsonbObject(buffer, header, val, level);\n\telse\n\t\telog(ERROR, \"unknown type of jsonb container to convert\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"total size of jsonb object elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\t\tJENTRY_OFFLENMASK))"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBE_OFFLENFLD",
          "args": [
            "meta"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convertJsonbScalar",
          "args": [
            "buffer",
            "&meta",
            "&pair->key"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "convertJsonbScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1712-1747",
          "snippet": "static void\nconvertJsonbScalar(StringInfo buffer, JEntry *jentry, JsonbValue *scalarVal)\n{\n\tint\t\t\tnumlen;\n\tshort\t\tpadlen;\n\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\t*jentry = JENTRY_ISNULL;\n\t\t\tbreak;\n\n\t\tcase jbvString:\n\t\t\tappendToBuffer(buffer, scalarVal->val.string.val, scalarVal->val.string.len);\n\n\t\t\t*jentry = scalarVal->val.string.len;\n\t\t\tbreak;\n\n\t\tcase jbvNumeric:\n\t\t\tnumlen = VARSIZE_ANY(scalarVal->val.numeric);\n\t\t\tpadlen = padBufferToInt(buffer);\n\n\t\t\tappendToBuffer(buffer, (char *) scalarVal->val.numeric, numlen);\n\n\t\t\t*jentry = JENTRY_ISNUMERIC | (padlen + numlen);\n\t\t\tbreak;\n\n\t\tcase jbvBool:\n\t\t\t*jentry = (scalarVal->val.boolean) ?\n\t\t\t\tJENTRY_ISBOOL_TRUE : JENTRY_ISBOOL_FALSE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic void\nconvertJsonbScalar(StringInfo buffer, JEntry *jentry, JsonbValue *scalarVal)\n{\n\tint\t\t\tnumlen;\n\tshort\t\tpadlen;\n\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\t*jentry = JENTRY_ISNULL;\n\t\t\tbreak;\n\n\t\tcase jbvString:\n\t\t\tappendToBuffer(buffer, scalarVal->val.string.val, scalarVal->val.string.len);\n\n\t\t\t*jentry = scalarVal->val.string.len;\n\t\t\tbreak;\n\n\t\tcase jbvNumeric:\n\t\t\tnumlen = VARSIZE_ANY(scalarVal->val.numeric);\n\t\t\tpadlen = padBufferToInt(buffer);\n\n\t\t\tappendToBuffer(buffer, (char *) scalarVal->val.numeric, numlen);\n\n\t\t\t*jentry = JENTRY_ISNUMERIC | (padlen + numlen);\n\t\t\tbreak;\n\n\t\tcase jbvBool:\n\t\t\t*jentry = (scalarVal->val.boolean) ?\n\t\t\t\tJENTRY_ISBOOL_TRUE : JENTRY_ISBOOL_FALSE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reserveFromBuffer",
          "args": [
            "buffer",
            "sizeof(JEntry) * nPairs * 2"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "reserveFromBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1375-1396",
          "snippet": "static int\nreserveFromBuffer(StringInfo buffer, int len)\n{\n\tint\t\t\toffset;\n\n\t/* Make more room if needed */\n\tenlargeStringInfo(buffer, len);\n\n\t/* remember current offset */\n\toffset = buffer->len;\n\n\t/* reserve the space */\n\tbuffer->len += len;\n\n\t/*\n\t * Keep a trailing null in place, even though it's not useful for us; it\n\t * seems best to preserve the invariants of StringInfos.\n\t */\n\tbuffer->data[buffer->len] = '\\0';\n\n\treturn offset;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nstatic int\nreserveFromBuffer(StringInfo buffer, int len)\n{\n\tint\t\t\toffset;\n\n\t/* Make more room if needed */\n\tenlargeStringInfo(buffer, len);\n\n\t/* remember current offset */\n\toffset = buffer->len;\n\n\t/* reserve the space */\n\tbuffer->len += len;\n\n\t/*\n\t * Keep a trailing null in place, even though it's not useful for us; it\n\t * seems best to preserve the invariants of StringInfos.\n\t */\n\tbuffer->data[buffer->len] = '\\0';\n\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendToBuffer",
          "args": [
            "buffer",
            "(char *) &header",
            "sizeof(uint32)"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "appendToBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1410-1417",
          "snippet": "static void\nappendToBuffer(StringInfo buffer, const char *data, int len)\n{\n\tint\t\t\toffset;\n\n\toffset = reserveFromBuffer(buffer, len);\n\tcopyToBuffer(buffer, offset, data, len);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\n\nstatic void\nappendToBuffer(StringInfo buffer, const char *data, int len)\n{\n\tint\t\t\toffset;\n\n\toffset = reserveFromBuffer(buffer, len);\n\tcopyToBuffer(buffer, offset, data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padBufferToInt",
          "args": [
            "buffer"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "padBufferToInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1424-1440",
          "snippet": "static short\npadBufferToInt(StringInfo buffer)\n{\n\tint\t\t\tpadlen,\n\t\t\t\tp,\n\t\t\t\toffset;\n\n\tpadlen = INTALIGN(buffer->len) - buffer->len;\n\n\toffset = reserveFromBuffer(buffer, padlen);\n\n\t/* padlen must be small, so this is probably faster than a memset */\n\tfor (p = 0; p < padlen; p++)\n\t\tbuffer->data[offset + p] = '\\0';\n\n\treturn padlen;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\n\nstatic short\npadBufferToInt(StringInfo buffer)\n{\n\tint\t\t\tpadlen,\n\t\t\t\tp,\n\t\t\t\toffset;\n\n\tpadlen = INTALIGN(buffer->len) - buffer->len;\n\n\toffset = reserveFromBuffer(buffer, padlen);\n\n\t/* padlen must be small, so this is probably faster than a memset */\n\tfor (p = 0; p < padlen; p++)\n\t\tbuffer->data[offset + p] = '\\0';\n\n\treturn padlen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nstatic void\nconvertJsonbObject(StringInfo buffer, JEntry *pheader, JsonbValue *val, int level)\n{\n\tint\t\t\tbase_offset;\n\tint\t\t\tjentry_offset;\n\tint\t\t\ti;\n\tint\t\t\ttotallen;\n\tuint32\t\theader;\n\tint\t\t\tnPairs = val->val.object.nPairs;\n\n\t/* Remember where in the buffer this object starts. */\n\tbase_offset = buffer->len;\n\n\t/* Align to 4-byte boundary (any padding counts as part of my data) */\n\tpadBufferToInt(buffer);\n\n\t/*\n\t * Construct the header Jentry and store it in the beginning of the\n\t * variable-length payload.\n\t */\n\theader = nPairs | JB_FOBJECT;\n\tappendToBuffer(buffer, (char *) &header, sizeof(uint32));\n\n\t/* Reserve space for the JEntries of the keys and values. */\n\tjentry_offset = reserveFromBuffer(buffer, sizeof(JEntry) * nPairs * 2);\n\n\t/*\n\t * Iterate over the keys, then over the values, since that is the ordering\n\t * we want in the on-disk representation.\n\t */\n\ttotallen = 0;\n\tfor (i = 0; i < nPairs; i++)\n\t{\n\t\tJsonbPair  *pair = &val->val.object.pairs[i];\n\t\tint\t\t\tlen;\n\t\tJEntry\t\tmeta;\n\n\t\t/*\n\t\t * Convert key, producing a JEntry and appending its variable-length\n\t\t * data to buffer\n\t\t */\n\t\tconvertJsonbScalar(buffer, &meta, &pair->key);\n\n\t\tlen = JBE_OFFLENFLD(meta);\n\t\ttotallen += len;\n\n\t\t/*\n\t\t * Bail out if total variable-length data exceeds what will fit in a\n\t\t * JEntry length field.  We check this in each iteration, not just\n\t\t * once at the end, to forestall possible integer overflow.\n\t\t */\n\t\tif (totallen > JENTRY_OFFLENMASK)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"total size of jsonb object elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t\t/*\n\t\t * Convert each JB_OFFSET_STRIDE'th length to an offset.\n\t\t */\n\t\tif ((i % JB_OFFSET_STRIDE) == 0)\n\t\t\tmeta = (meta & JENTRY_TYPEMASK) | totallen | JENTRY_HAS_OFF;\n\n\t\tcopyToBuffer(buffer, jentry_offset, (char *) &meta, sizeof(JEntry));\n\t\tjentry_offset += sizeof(JEntry);\n\t}\n\tfor (i = 0; i < nPairs; i++)\n\t{\n\t\tJsonbPair  *pair = &val->val.object.pairs[i];\n\t\tint\t\t\tlen;\n\t\tJEntry\t\tmeta;\n\n\t\t/*\n\t\t * Convert value, producing a JEntry and appending its variable-length\n\t\t * data to buffer\n\t\t */\n\t\tconvertJsonbValue(buffer, &meta, &pair->value, level + 1);\n\n\t\tlen = JBE_OFFLENFLD(meta);\n\t\ttotallen += len;\n\n\t\t/*\n\t\t * Bail out if total variable-length data exceeds what will fit in a\n\t\t * JEntry length field.  We check this in each iteration, not just\n\t\t * once at the end, to forestall possible integer overflow.\n\t\t */\n\t\tif (totallen > JENTRY_OFFLENMASK)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"total size of jsonb object elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t\t/*\n\t\t * Convert each JB_OFFSET_STRIDE'th length to an offset.\n\t\t */\n\t\tif (((i + nPairs) % JB_OFFSET_STRIDE) == 0)\n\t\t\tmeta = (meta & JENTRY_TYPEMASK) | totallen | JENTRY_HAS_OFF;\n\n\t\tcopyToBuffer(buffer, jentry_offset, (char *) &meta, sizeof(JEntry));\n\t\tjentry_offset += sizeof(JEntry);\n\t}\n\n\t/* Total data size is everything we've appended to buffer */\n\ttotallen = buffer->len - base_offset;\n\n\t/* Check length again, since we didn't include the metadata above */\n\tif (totallen > JENTRY_OFFLENMASK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"total size of jsonb object elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t/* Initialize the header of this node in the container's JEntry array */\n\t*pheader = JENTRY_ISCONTAINER | totallen;\n}"
  },
  {
    "function_name": "convertJsonbArray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "1512-1594",
    "snippet": "static void\nconvertJsonbArray(StringInfo buffer, JEntry *pheader, JsonbValue *val, int level)\n{\n\tint\t\t\tbase_offset;\n\tint\t\t\tjentry_offset;\n\tint\t\t\ti;\n\tint\t\t\ttotallen;\n\tuint32\t\theader;\n\tint\t\t\tnElems = val->val.array.nElems;\n\n\t/* Remember where in the buffer this array starts. */\n\tbase_offset = buffer->len;\n\n\t/* Align to 4-byte boundary (any padding counts as part of my data) */\n\tpadBufferToInt(buffer);\n\n\t/*\n\t * Construct the header Jentry and store it in the beginning of the\n\t * variable-length payload.\n\t */\n\theader = nElems | JB_FARRAY;\n\tif (val->val.array.rawScalar)\n\t{\n\t\tAssert(nElems == 1);\n\t\tAssert(level == 0);\n\t\theader |= JB_FSCALAR;\n\t}\n\n\tappendToBuffer(buffer, (char *) &header, sizeof(uint32));\n\n\t/* Reserve space for the JEntries of the elements. */\n\tjentry_offset = reserveFromBuffer(buffer, sizeof(JEntry) * nElems);\n\n\ttotallen = 0;\n\tfor (i = 0; i < nElems; i++)\n\t{\n\t\tJsonbValue *elem = &val->val.array.elems[i];\n\t\tint\t\t\tlen;\n\t\tJEntry\t\tmeta;\n\n\t\t/*\n\t\t * Convert element, producing a JEntry and appending its\n\t\t * variable-length data to buffer\n\t\t */\n\t\tconvertJsonbValue(buffer, &meta, elem, level + 1);\n\n\t\tlen = JBE_OFFLENFLD(meta);\n\t\ttotallen += len;\n\n\t\t/*\n\t\t * Bail out if total variable-length data exceeds what will fit in a\n\t\t * JEntry length field.  We check this in each iteration, not just\n\t\t * once at the end, to forestall possible integer overflow.\n\t\t */\n\t\tif (totallen > JENTRY_OFFLENMASK)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"total size of jsonb array elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t\t/*\n\t\t * Convert each JB_OFFSET_STRIDE'th length to an offset.\n\t\t */\n\t\tif ((i % JB_OFFSET_STRIDE) == 0)\n\t\t\tmeta = (meta & JENTRY_TYPEMASK) | totallen | JENTRY_HAS_OFF;\n\n\t\tcopyToBuffer(buffer, jentry_offset, (char *) &meta, sizeof(JEntry));\n\t\tjentry_offset += sizeof(JEntry);\n\t}\n\n\t/* Total data size is everything we've appended to buffer */\n\ttotallen = buffer->len - base_offset;\n\n\t/* Check length again, since we didn't include the metadata above */\n\tif (totallen > JENTRY_OFFLENMASK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"total size of jsonb array elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t/* Initialize the header of this node in the container's JEntry array */\n\t*pheader = JENTRY_ISCONTAINER | totallen;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
      "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
      "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
      "static int\treserveFromBuffer(StringInfo buffer, int len);",
      "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
      "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
      "static short padBufferToInt(StringInfo buffer);",
      "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"total size of jsonb array elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\tJENTRY_OFFLENMASK))"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"total size of jsonb array elements exceeds the maximum of %u bytes\"",
            "JENTRY_OFFLENMASK"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyToBuffer",
          "args": [
            "buffer",
            "jentry_offset",
            "(char *) &meta",
            "sizeof(JEntry)"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "copyToBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1401-1405",
          "snippet": "static void\ncopyToBuffer(StringInfo buffer, int offset, const char *data, int len)\n{\n\tmemcpy(buffer->data + offset, data, len);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\n\nstatic void\ncopyToBuffer(StringInfo buffer, int offset, const char *data, int len)\n{\n\tmemcpy(buffer->data + offset, data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"total size of jsonb array elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\t\tJENTRY_OFFLENMASK))"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBE_OFFLENFLD",
          "args": [
            "meta"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convertJsonbValue",
          "args": [
            "buffer",
            "&meta",
            "elem",
            "level + 1"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "convertJsonbValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1487-1510",
          "snippet": "static void\nconvertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level)\n{\n\tcheck_stack_depth();\n\n\tif (!val)\n\t\treturn;\n\n\t/*\n\t * A JsonbValue passed as val should never have a type of jbvBinary, and\n\t * neither should any of its sub-components. Those values will be produced\n\t * by convertJsonbArray and convertJsonbObject, the results of which will\n\t * not be passed back to this function as an argument.\n\t */\n\n\tif (IsAJsonbScalar(val))\n\t\tconvertJsonbScalar(buffer, header, val);\n\telse if (val->type == jbvArray)\n\t\tconvertJsonbArray(buffer, header, val, level);\n\telse if (val->type == jbvObject)\n\t\tconvertJsonbObject(buffer, header, val, level);\n\telse\n\t\telog(ERROR, \"unknown type of jsonb container to convert\");\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static short padBufferToInt(StringInfo buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic short padBufferToInt(StringInfo buffer);\n\nstatic void\nconvertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level)\n{\n\tcheck_stack_depth();\n\n\tif (!val)\n\t\treturn;\n\n\t/*\n\t * A JsonbValue passed as val should never have a type of jbvBinary, and\n\t * neither should any of its sub-components. Those values will be produced\n\t * by convertJsonbArray and convertJsonbObject, the results of which will\n\t * not be passed back to this function as an argument.\n\t */\n\n\tif (IsAJsonbScalar(val))\n\t\tconvertJsonbScalar(buffer, header, val);\n\telse if (val->type == jbvArray)\n\t\tconvertJsonbArray(buffer, header, val, level);\n\telse if (val->type == jbvObject)\n\t\tconvertJsonbObject(buffer, header, val, level);\n\telse\n\t\telog(ERROR, \"unknown type of jsonb container to convert\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "reserveFromBuffer",
          "args": [
            "buffer",
            "sizeof(JEntry) * nElems"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "reserveFromBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1375-1396",
          "snippet": "static int\nreserveFromBuffer(StringInfo buffer, int len)\n{\n\tint\t\t\toffset;\n\n\t/* Make more room if needed */\n\tenlargeStringInfo(buffer, len);\n\n\t/* remember current offset */\n\toffset = buffer->len;\n\n\t/* reserve the space */\n\tbuffer->len += len;\n\n\t/*\n\t * Keep a trailing null in place, even though it's not useful for us; it\n\t * seems best to preserve the invariants of StringInfos.\n\t */\n\tbuffer->data[buffer->len] = '\\0';\n\n\treturn offset;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nstatic int\nreserveFromBuffer(StringInfo buffer, int len)\n{\n\tint\t\t\toffset;\n\n\t/* Make more room if needed */\n\tenlargeStringInfo(buffer, len);\n\n\t/* remember current offset */\n\toffset = buffer->len;\n\n\t/* reserve the space */\n\tbuffer->len += len;\n\n\t/*\n\t * Keep a trailing null in place, even though it's not useful for us; it\n\t * seems best to preserve the invariants of StringInfos.\n\t */\n\tbuffer->data[buffer->len] = '\\0';\n\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendToBuffer",
          "args": [
            "buffer",
            "(char *) &header",
            "sizeof(uint32)"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "appendToBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1410-1417",
          "snippet": "static void\nappendToBuffer(StringInfo buffer, const char *data, int len)\n{\n\tint\t\t\toffset;\n\n\toffset = reserveFromBuffer(buffer, len);\n\tcopyToBuffer(buffer, offset, data, len);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\n\nstatic void\nappendToBuffer(StringInfo buffer, const char *data, int len)\n{\n\tint\t\t\toffset;\n\n\toffset = reserveFromBuffer(buffer, len);\n\tcopyToBuffer(buffer, offset, data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "level == 0"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nElems == 1"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padBufferToInt",
          "args": [
            "buffer"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "padBufferToInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1424-1440",
          "snippet": "static short\npadBufferToInt(StringInfo buffer)\n{\n\tint\t\t\tpadlen,\n\t\t\t\tp,\n\t\t\t\toffset;\n\n\tpadlen = INTALIGN(buffer->len) - buffer->len;\n\n\toffset = reserveFromBuffer(buffer, padlen);\n\n\t/* padlen must be small, so this is probably faster than a memset */\n\tfor (p = 0; p < padlen; p++)\n\t\tbuffer->data[offset + p] = '\\0';\n\n\treturn padlen;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\n\nstatic short\npadBufferToInt(StringInfo buffer)\n{\n\tint\t\t\tpadlen,\n\t\t\t\tp,\n\t\t\t\toffset;\n\n\tpadlen = INTALIGN(buffer->len) - buffer->len;\n\n\toffset = reserveFromBuffer(buffer, padlen);\n\n\t/* padlen must be small, so this is probably faster than a memset */\n\tfor (p = 0; p < padlen; p++)\n\t\tbuffer->data[offset + p] = '\\0';\n\n\treturn padlen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nstatic void\nconvertJsonbArray(StringInfo buffer, JEntry *pheader, JsonbValue *val, int level)\n{\n\tint\t\t\tbase_offset;\n\tint\t\t\tjentry_offset;\n\tint\t\t\ti;\n\tint\t\t\ttotallen;\n\tuint32\t\theader;\n\tint\t\t\tnElems = val->val.array.nElems;\n\n\t/* Remember where in the buffer this array starts. */\n\tbase_offset = buffer->len;\n\n\t/* Align to 4-byte boundary (any padding counts as part of my data) */\n\tpadBufferToInt(buffer);\n\n\t/*\n\t * Construct the header Jentry and store it in the beginning of the\n\t * variable-length payload.\n\t */\n\theader = nElems | JB_FARRAY;\n\tif (val->val.array.rawScalar)\n\t{\n\t\tAssert(nElems == 1);\n\t\tAssert(level == 0);\n\t\theader |= JB_FSCALAR;\n\t}\n\n\tappendToBuffer(buffer, (char *) &header, sizeof(uint32));\n\n\t/* Reserve space for the JEntries of the elements. */\n\tjentry_offset = reserveFromBuffer(buffer, sizeof(JEntry) * nElems);\n\n\ttotallen = 0;\n\tfor (i = 0; i < nElems; i++)\n\t{\n\t\tJsonbValue *elem = &val->val.array.elems[i];\n\t\tint\t\t\tlen;\n\t\tJEntry\t\tmeta;\n\n\t\t/*\n\t\t * Convert element, producing a JEntry and appending its\n\t\t * variable-length data to buffer\n\t\t */\n\t\tconvertJsonbValue(buffer, &meta, elem, level + 1);\n\n\t\tlen = JBE_OFFLENFLD(meta);\n\t\ttotallen += len;\n\n\t\t/*\n\t\t * Bail out if total variable-length data exceeds what will fit in a\n\t\t * JEntry length field.  We check this in each iteration, not just\n\t\t * once at the end, to forestall possible integer overflow.\n\t\t */\n\t\tif (totallen > JENTRY_OFFLENMASK)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"total size of jsonb array elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t\t/*\n\t\t * Convert each JB_OFFSET_STRIDE'th length to an offset.\n\t\t */\n\t\tif ((i % JB_OFFSET_STRIDE) == 0)\n\t\t\tmeta = (meta & JENTRY_TYPEMASK) | totallen | JENTRY_HAS_OFF;\n\n\t\tcopyToBuffer(buffer, jentry_offset, (char *) &meta, sizeof(JEntry));\n\t\tjentry_offset += sizeof(JEntry);\n\t}\n\n\t/* Total data size is everything we've appended to buffer */\n\ttotallen = buffer->len - base_offset;\n\n\t/* Check length again, since we didn't include the metadata above */\n\tif (totallen > JENTRY_OFFLENMASK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"total size of jsonb array elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t/* Initialize the header of this node in the container's JEntry array */\n\t*pheader = JENTRY_ISCONTAINER | totallen;\n}"
  },
  {
    "function_name": "convertJsonbValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "1487-1510",
    "snippet": "static void\nconvertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level)\n{\n\tcheck_stack_depth();\n\n\tif (!val)\n\t\treturn;\n\n\t/*\n\t * A JsonbValue passed as val should never have a type of jbvBinary, and\n\t * neither should any of its sub-components. Those values will be produced\n\t * by convertJsonbArray and convertJsonbObject, the results of which will\n\t * not be passed back to this function as an argument.\n\t */\n\n\tif (IsAJsonbScalar(val))\n\t\tconvertJsonbScalar(buffer, header, val);\n\telse if (val->type == jbvArray)\n\t\tconvertJsonbArray(buffer, header, val, level);\n\telse if (val->type == jbvObject)\n\t\tconvertJsonbObject(buffer, header, val, level);\n\telse\n\t\telog(ERROR, \"unknown type of jsonb container to convert\");\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
      "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
      "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
      "static short padBufferToInt(StringInfo buffer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unknown type of jsonb container to convert\""
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convertJsonbObject",
          "args": [
            "buffer",
            "header",
            "val",
            "level"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "convertJsonbObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1596-1710",
          "snippet": "static void\nconvertJsonbObject(StringInfo buffer, JEntry *pheader, JsonbValue *val, int level)\n{\n\tint\t\t\tbase_offset;\n\tint\t\t\tjentry_offset;\n\tint\t\t\ti;\n\tint\t\t\ttotallen;\n\tuint32\t\theader;\n\tint\t\t\tnPairs = val->val.object.nPairs;\n\n\t/* Remember where in the buffer this object starts. */\n\tbase_offset = buffer->len;\n\n\t/* Align to 4-byte boundary (any padding counts as part of my data) */\n\tpadBufferToInt(buffer);\n\n\t/*\n\t * Construct the header Jentry and store it in the beginning of the\n\t * variable-length payload.\n\t */\n\theader = nPairs | JB_FOBJECT;\n\tappendToBuffer(buffer, (char *) &header, sizeof(uint32));\n\n\t/* Reserve space for the JEntries of the keys and values. */\n\tjentry_offset = reserveFromBuffer(buffer, sizeof(JEntry) * nPairs * 2);\n\n\t/*\n\t * Iterate over the keys, then over the values, since that is the ordering\n\t * we want in the on-disk representation.\n\t */\n\ttotallen = 0;\n\tfor (i = 0; i < nPairs; i++)\n\t{\n\t\tJsonbPair  *pair = &val->val.object.pairs[i];\n\t\tint\t\t\tlen;\n\t\tJEntry\t\tmeta;\n\n\t\t/*\n\t\t * Convert key, producing a JEntry and appending its variable-length\n\t\t * data to buffer\n\t\t */\n\t\tconvertJsonbScalar(buffer, &meta, &pair->key);\n\n\t\tlen = JBE_OFFLENFLD(meta);\n\t\ttotallen += len;\n\n\t\t/*\n\t\t * Bail out if total variable-length data exceeds what will fit in a\n\t\t * JEntry length field.  We check this in each iteration, not just\n\t\t * once at the end, to forestall possible integer overflow.\n\t\t */\n\t\tif (totallen > JENTRY_OFFLENMASK)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"total size of jsonb object elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t\t/*\n\t\t * Convert each JB_OFFSET_STRIDE'th length to an offset.\n\t\t */\n\t\tif ((i % JB_OFFSET_STRIDE) == 0)\n\t\t\tmeta = (meta & JENTRY_TYPEMASK) | totallen | JENTRY_HAS_OFF;\n\n\t\tcopyToBuffer(buffer, jentry_offset, (char *) &meta, sizeof(JEntry));\n\t\tjentry_offset += sizeof(JEntry);\n\t}\n\tfor (i = 0; i < nPairs; i++)\n\t{\n\t\tJsonbPair  *pair = &val->val.object.pairs[i];\n\t\tint\t\t\tlen;\n\t\tJEntry\t\tmeta;\n\n\t\t/*\n\t\t * Convert value, producing a JEntry and appending its variable-length\n\t\t * data to buffer\n\t\t */\n\t\tconvertJsonbValue(buffer, &meta, &pair->value, level + 1);\n\n\t\tlen = JBE_OFFLENFLD(meta);\n\t\ttotallen += len;\n\n\t\t/*\n\t\t * Bail out if total variable-length data exceeds what will fit in a\n\t\t * JEntry length field.  We check this in each iteration, not just\n\t\t * once at the end, to forestall possible integer overflow.\n\t\t */\n\t\tif (totallen > JENTRY_OFFLENMASK)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"total size of jsonb object elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t\t/*\n\t\t * Convert each JB_OFFSET_STRIDE'th length to an offset.\n\t\t */\n\t\tif (((i + nPairs) % JB_OFFSET_STRIDE) == 0)\n\t\t\tmeta = (meta & JENTRY_TYPEMASK) | totallen | JENTRY_HAS_OFF;\n\n\t\tcopyToBuffer(buffer, jentry_offset, (char *) &meta, sizeof(JEntry));\n\t\tjentry_offset += sizeof(JEntry);\n\t}\n\n\t/* Total data size is everything we've appended to buffer */\n\ttotallen = buffer->len - base_offset;\n\n\t/* Check length again, since we didn't include the metadata above */\n\tif (totallen > JENTRY_OFFLENMASK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"total size of jsonb object elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t/* Initialize the header of this node in the container's JEntry array */\n\t*pheader = JENTRY_ISCONTAINER | totallen;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nstatic void\nconvertJsonbObject(StringInfo buffer, JEntry *pheader, JsonbValue *val, int level)\n{\n\tint\t\t\tbase_offset;\n\tint\t\t\tjentry_offset;\n\tint\t\t\ti;\n\tint\t\t\ttotallen;\n\tuint32\t\theader;\n\tint\t\t\tnPairs = val->val.object.nPairs;\n\n\t/* Remember where in the buffer this object starts. */\n\tbase_offset = buffer->len;\n\n\t/* Align to 4-byte boundary (any padding counts as part of my data) */\n\tpadBufferToInt(buffer);\n\n\t/*\n\t * Construct the header Jentry and store it in the beginning of the\n\t * variable-length payload.\n\t */\n\theader = nPairs | JB_FOBJECT;\n\tappendToBuffer(buffer, (char *) &header, sizeof(uint32));\n\n\t/* Reserve space for the JEntries of the keys and values. */\n\tjentry_offset = reserveFromBuffer(buffer, sizeof(JEntry) * nPairs * 2);\n\n\t/*\n\t * Iterate over the keys, then over the values, since that is the ordering\n\t * we want in the on-disk representation.\n\t */\n\ttotallen = 0;\n\tfor (i = 0; i < nPairs; i++)\n\t{\n\t\tJsonbPair  *pair = &val->val.object.pairs[i];\n\t\tint\t\t\tlen;\n\t\tJEntry\t\tmeta;\n\n\t\t/*\n\t\t * Convert key, producing a JEntry and appending its variable-length\n\t\t * data to buffer\n\t\t */\n\t\tconvertJsonbScalar(buffer, &meta, &pair->key);\n\n\t\tlen = JBE_OFFLENFLD(meta);\n\t\ttotallen += len;\n\n\t\t/*\n\t\t * Bail out if total variable-length data exceeds what will fit in a\n\t\t * JEntry length field.  We check this in each iteration, not just\n\t\t * once at the end, to forestall possible integer overflow.\n\t\t */\n\t\tif (totallen > JENTRY_OFFLENMASK)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"total size of jsonb object elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t\t/*\n\t\t * Convert each JB_OFFSET_STRIDE'th length to an offset.\n\t\t */\n\t\tif ((i % JB_OFFSET_STRIDE) == 0)\n\t\t\tmeta = (meta & JENTRY_TYPEMASK) | totallen | JENTRY_HAS_OFF;\n\n\t\tcopyToBuffer(buffer, jentry_offset, (char *) &meta, sizeof(JEntry));\n\t\tjentry_offset += sizeof(JEntry);\n\t}\n\tfor (i = 0; i < nPairs; i++)\n\t{\n\t\tJsonbPair  *pair = &val->val.object.pairs[i];\n\t\tint\t\t\tlen;\n\t\tJEntry\t\tmeta;\n\n\t\t/*\n\t\t * Convert value, producing a JEntry and appending its variable-length\n\t\t * data to buffer\n\t\t */\n\t\tconvertJsonbValue(buffer, &meta, &pair->value, level + 1);\n\n\t\tlen = JBE_OFFLENFLD(meta);\n\t\ttotallen += len;\n\n\t\t/*\n\t\t * Bail out if total variable-length data exceeds what will fit in a\n\t\t * JEntry length field.  We check this in each iteration, not just\n\t\t * once at the end, to forestall possible integer overflow.\n\t\t */\n\t\tif (totallen > JENTRY_OFFLENMASK)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"total size of jsonb object elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t\t/*\n\t\t * Convert each JB_OFFSET_STRIDE'th length to an offset.\n\t\t */\n\t\tif (((i + nPairs) % JB_OFFSET_STRIDE) == 0)\n\t\t\tmeta = (meta & JENTRY_TYPEMASK) | totallen | JENTRY_HAS_OFF;\n\n\t\tcopyToBuffer(buffer, jentry_offset, (char *) &meta, sizeof(JEntry));\n\t\tjentry_offset += sizeof(JEntry);\n\t}\n\n\t/* Total data size is everything we've appended to buffer */\n\ttotallen = buffer->len - base_offset;\n\n\t/* Check length again, since we didn't include the metadata above */\n\tif (totallen > JENTRY_OFFLENMASK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"total size of jsonb object elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t/* Initialize the header of this node in the container's JEntry array */\n\t*pheader = JENTRY_ISCONTAINER | totallen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convertJsonbArray",
          "args": [
            "buffer",
            "header",
            "val",
            "level"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "convertJsonbArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1512-1594",
          "snippet": "static void\nconvertJsonbArray(StringInfo buffer, JEntry *pheader, JsonbValue *val, int level)\n{\n\tint\t\t\tbase_offset;\n\tint\t\t\tjentry_offset;\n\tint\t\t\ti;\n\tint\t\t\ttotallen;\n\tuint32\t\theader;\n\tint\t\t\tnElems = val->val.array.nElems;\n\n\t/* Remember where in the buffer this array starts. */\n\tbase_offset = buffer->len;\n\n\t/* Align to 4-byte boundary (any padding counts as part of my data) */\n\tpadBufferToInt(buffer);\n\n\t/*\n\t * Construct the header Jentry and store it in the beginning of the\n\t * variable-length payload.\n\t */\n\theader = nElems | JB_FARRAY;\n\tif (val->val.array.rawScalar)\n\t{\n\t\tAssert(nElems == 1);\n\t\tAssert(level == 0);\n\t\theader |= JB_FSCALAR;\n\t}\n\n\tappendToBuffer(buffer, (char *) &header, sizeof(uint32));\n\n\t/* Reserve space for the JEntries of the elements. */\n\tjentry_offset = reserveFromBuffer(buffer, sizeof(JEntry) * nElems);\n\n\ttotallen = 0;\n\tfor (i = 0; i < nElems; i++)\n\t{\n\t\tJsonbValue *elem = &val->val.array.elems[i];\n\t\tint\t\t\tlen;\n\t\tJEntry\t\tmeta;\n\n\t\t/*\n\t\t * Convert element, producing a JEntry and appending its\n\t\t * variable-length data to buffer\n\t\t */\n\t\tconvertJsonbValue(buffer, &meta, elem, level + 1);\n\n\t\tlen = JBE_OFFLENFLD(meta);\n\t\ttotallen += len;\n\n\t\t/*\n\t\t * Bail out if total variable-length data exceeds what will fit in a\n\t\t * JEntry length field.  We check this in each iteration, not just\n\t\t * once at the end, to forestall possible integer overflow.\n\t\t */\n\t\tif (totallen > JENTRY_OFFLENMASK)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"total size of jsonb array elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t\t/*\n\t\t * Convert each JB_OFFSET_STRIDE'th length to an offset.\n\t\t */\n\t\tif ((i % JB_OFFSET_STRIDE) == 0)\n\t\t\tmeta = (meta & JENTRY_TYPEMASK) | totallen | JENTRY_HAS_OFF;\n\n\t\tcopyToBuffer(buffer, jentry_offset, (char *) &meta, sizeof(JEntry));\n\t\tjentry_offset += sizeof(JEntry);\n\t}\n\n\t/* Total data size is everything we've appended to buffer */\n\ttotallen = buffer->len - base_offset;\n\n\t/* Check length again, since we didn't include the metadata above */\n\tif (totallen > JENTRY_OFFLENMASK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"total size of jsonb array elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t/* Initialize the header of this node in the container's JEntry array */\n\t*pheader = JENTRY_ISCONTAINER | totallen;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nstatic void\nconvertJsonbArray(StringInfo buffer, JEntry *pheader, JsonbValue *val, int level)\n{\n\tint\t\t\tbase_offset;\n\tint\t\t\tjentry_offset;\n\tint\t\t\ti;\n\tint\t\t\ttotallen;\n\tuint32\t\theader;\n\tint\t\t\tnElems = val->val.array.nElems;\n\n\t/* Remember where in the buffer this array starts. */\n\tbase_offset = buffer->len;\n\n\t/* Align to 4-byte boundary (any padding counts as part of my data) */\n\tpadBufferToInt(buffer);\n\n\t/*\n\t * Construct the header Jentry and store it in the beginning of the\n\t * variable-length payload.\n\t */\n\theader = nElems | JB_FARRAY;\n\tif (val->val.array.rawScalar)\n\t{\n\t\tAssert(nElems == 1);\n\t\tAssert(level == 0);\n\t\theader |= JB_FSCALAR;\n\t}\n\n\tappendToBuffer(buffer, (char *) &header, sizeof(uint32));\n\n\t/* Reserve space for the JEntries of the elements. */\n\tjentry_offset = reserveFromBuffer(buffer, sizeof(JEntry) * nElems);\n\n\ttotallen = 0;\n\tfor (i = 0; i < nElems; i++)\n\t{\n\t\tJsonbValue *elem = &val->val.array.elems[i];\n\t\tint\t\t\tlen;\n\t\tJEntry\t\tmeta;\n\n\t\t/*\n\t\t * Convert element, producing a JEntry and appending its\n\t\t * variable-length data to buffer\n\t\t */\n\t\tconvertJsonbValue(buffer, &meta, elem, level + 1);\n\n\t\tlen = JBE_OFFLENFLD(meta);\n\t\ttotallen += len;\n\n\t\t/*\n\t\t * Bail out if total variable-length data exceeds what will fit in a\n\t\t * JEntry length field.  We check this in each iteration, not just\n\t\t * once at the end, to forestall possible integer overflow.\n\t\t */\n\t\tif (totallen > JENTRY_OFFLENMASK)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"total size of jsonb array elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t\t/*\n\t\t * Convert each JB_OFFSET_STRIDE'th length to an offset.\n\t\t */\n\t\tif ((i % JB_OFFSET_STRIDE) == 0)\n\t\t\tmeta = (meta & JENTRY_TYPEMASK) | totallen | JENTRY_HAS_OFF;\n\n\t\tcopyToBuffer(buffer, jentry_offset, (char *) &meta, sizeof(JEntry));\n\t\tjentry_offset += sizeof(JEntry);\n\t}\n\n\t/* Total data size is everything we've appended to buffer */\n\ttotallen = buffer->len - base_offset;\n\n\t/* Check length again, since we didn't include the metadata above */\n\tif (totallen > JENTRY_OFFLENMASK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"total size of jsonb array elements exceeds the maximum of %u bytes\",\n\t\t\t\t\t\tJENTRY_OFFLENMASK)));\n\n\t/* Initialize the header of this node in the container's JEntry array */\n\t*pheader = JENTRY_ISCONTAINER | totallen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convertJsonbScalar",
          "args": [
            "buffer",
            "header",
            "val"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "convertJsonbScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1712-1747",
          "snippet": "static void\nconvertJsonbScalar(StringInfo buffer, JEntry *jentry, JsonbValue *scalarVal)\n{\n\tint\t\t\tnumlen;\n\tshort\t\tpadlen;\n\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\t*jentry = JENTRY_ISNULL;\n\t\t\tbreak;\n\n\t\tcase jbvString:\n\t\t\tappendToBuffer(buffer, scalarVal->val.string.val, scalarVal->val.string.len);\n\n\t\t\t*jentry = scalarVal->val.string.len;\n\t\t\tbreak;\n\n\t\tcase jbvNumeric:\n\t\t\tnumlen = VARSIZE_ANY(scalarVal->val.numeric);\n\t\t\tpadlen = padBufferToInt(buffer);\n\n\t\t\tappendToBuffer(buffer, (char *) scalarVal->val.numeric, numlen);\n\n\t\t\t*jentry = JENTRY_ISNUMERIC | (padlen + numlen);\n\t\t\tbreak;\n\n\t\tcase jbvBool:\n\t\t\t*jentry = (scalarVal->val.boolean) ?\n\t\t\t\tJENTRY_ISBOOL_TRUE : JENTRY_ISBOOL_FALSE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic void\nconvertJsonbScalar(StringInfo buffer, JEntry *jentry, JsonbValue *scalarVal)\n{\n\tint\t\t\tnumlen;\n\tshort\t\tpadlen;\n\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\t*jentry = JENTRY_ISNULL;\n\t\t\tbreak;\n\n\t\tcase jbvString:\n\t\t\tappendToBuffer(buffer, scalarVal->val.string.val, scalarVal->val.string.len);\n\n\t\t\t*jentry = scalarVal->val.string.len;\n\t\t\tbreak;\n\n\t\tcase jbvNumeric:\n\t\t\tnumlen = VARSIZE_ANY(scalarVal->val.numeric);\n\t\t\tpadlen = padBufferToInt(buffer);\n\n\t\t\tappendToBuffer(buffer, (char *) scalarVal->val.numeric, numlen);\n\n\t\t\t*jentry = JENTRY_ISNUMERIC | (padlen + numlen);\n\t\t\tbreak;\n\n\t\tcase jbvBool:\n\t\t\t*jentry = (scalarVal->val.boolean) ?\n\t\t\t\tJENTRY_ISBOOL_TRUE : JENTRY_ISBOOL_FALSE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsAJsonbScalar",
          "args": [
            "val"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic short padBufferToInt(StringInfo buffer);\n\nstatic void\nconvertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level)\n{\n\tcheck_stack_depth();\n\n\tif (!val)\n\t\treturn;\n\n\t/*\n\t * A JsonbValue passed as val should never have a type of jbvBinary, and\n\t * neither should any of its sub-components. Those values will be produced\n\t * by convertJsonbArray and convertJsonbObject, the results of which will\n\t * not be passed back to this function as an argument.\n\t */\n\n\tif (IsAJsonbScalar(val))\n\t\tconvertJsonbScalar(buffer, header, val);\n\telse if (val->type == jbvArray)\n\t\tconvertJsonbArray(buffer, header, val, level);\n\telse if (val->type == jbvObject)\n\t\tconvertJsonbObject(buffer, header, val, level);\n\telse\n\t\telog(ERROR, \"unknown type of jsonb container to convert\");\n}"
  },
  {
    "function_name": "convertToJsonb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "1445-1474",
    "snippet": "static Jsonb *\nconvertToJsonb(JsonbValue *val)\n{\n\tStringInfoData buffer;\n\tJEntry\t\tjentry;\n\tJsonb\t   *res;\n\n\t/* Should not already have binary representation */\n\tAssert(val->type != jbvBinary);\n\n\t/* Allocate an output buffer. It will be enlarged as needed */\n\tinitStringInfo(&buffer);\n\n\t/* Make room for the varlena header */\n\treserveFromBuffer(&buffer, VARHDRSZ);\n\n\tconvertJsonbValue(&buffer, &jentry, val, 0);\n\n\t/*\n\t * Note: the JEntry of the root is discarded. Therefore the root\n\t * JsonbContainer struct must contain enough information to tell what kind\n\t * of value it is.\n\t */\n\n\tres = (Jsonb *) buffer.data;\n\n\tSET_VARSIZE(res, buffer.len);\n\n\treturn res;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static int\treserveFromBuffer(StringInfo buffer, int len);",
      "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
      "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
      "static short padBufferToInt(StringInfo buffer);",
      "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "res",
            "buffer.len"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convertJsonbValue",
          "args": [
            "&buffer",
            "&jentry",
            "val",
            "0"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "convertJsonbValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1487-1510",
          "snippet": "static void\nconvertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level)\n{\n\tcheck_stack_depth();\n\n\tif (!val)\n\t\treturn;\n\n\t/*\n\t * A JsonbValue passed as val should never have a type of jbvBinary, and\n\t * neither should any of its sub-components. Those values will be produced\n\t * by convertJsonbArray and convertJsonbObject, the results of which will\n\t * not be passed back to this function as an argument.\n\t */\n\n\tif (IsAJsonbScalar(val))\n\t\tconvertJsonbScalar(buffer, header, val);\n\telse if (val->type == jbvArray)\n\t\tconvertJsonbArray(buffer, header, val, level);\n\telse if (val->type == jbvObject)\n\t\tconvertJsonbObject(buffer, header, val, level);\n\telse\n\t\telog(ERROR, \"unknown type of jsonb container to convert\");\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static short padBufferToInt(StringInfo buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic short padBufferToInt(StringInfo buffer);\n\nstatic void\nconvertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level)\n{\n\tcheck_stack_depth();\n\n\tif (!val)\n\t\treturn;\n\n\t/*\n\t * A JsonbValue passed as val should never have a type of jbvBinary, and\n\t * neither should any of its sub-components. Those values will be produced\n\t * by convertJsonbArray and convertJsonbObject, the results of which will\n\t * not be passed back to this function as an argument.\n\t */\n\n\tif (IsAJsonbScalar(val))\n\t\tconvertJsonbScalar(buffer, header, val);\n\telse if (val->type == jbvArray)\n\t\tconvertJsonbArray(buffer, header, val, level);\n\telse if (val->type == jbvObject)\n\t\tconvertJsonbObject(buffer, header, val, level);\n\telse\n\t\telog(ERROR, \"unknown type of jsonb container to convert\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "reserveFromBuffer",
          "args": [
            "&buffer",
            "VARHDRSZ"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "reserveFromBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1375-1396",
          "snippet": "static int\nreserveFromBuffer(StringInfo buffer, int len)\n{\n\tint\t\t\toffset;\n\n\t/* Make more room if needed */\n\tenlargeStringInfo(buffer, len);\n\n\t/* remember current offset */\n\toffset = buffer->len;\n\n\t/* reserve the space */\n\tbuffer->len += len;\n\n\t/*\n\t * Keep a trailing null in place, even though it's not useful for us; it\n\t * seems best to preserve the invariants of StringInfos.\n\t */\n\tbuffer->data[buffer->len] = '\\0';\n\n\treturn offset;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nstatic int\nreserveFromBuffer(StringInfo buffer, int len)\n{\n\tint\t\t\toffset;\n\n\t/* Make more room if needed */\n\tenlargeStringInfo(buffer, len);\n\n\t/* remember current offset */\n\toffset = buffer->len;\n\n\t/* reserve the space */\n\tbuffer->len += len;\n\n\t/*\n\t * Keep a trailing null in place, even though it's not useful for us; it\n\t * seems best to preserve the invariants of StringInfos.\n\t */\n\tbuffer->data[buffer->len] = '\\0';\n\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buffer"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "val->type != jbvBinary"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nstatic Jsonb *\nconvertToJsonb(JsonbValue *val)\n{\n\tStringInfoData buffer;\n\tJEntry\t\tjentry;\n\tJsonb\t   *res;\n\n\t/* Should not already have binary representation */\n\tAssert(val->type != jbvBinary);\n\n\t/* Allocate an output buffer. It will be enlarged as needed */\n\tinitStringInfo(&buffer);\n\n\t/* Make room for the varlena header */\n\treserveFromBuffer(&buffer, VARHDRSZ);\n\n\tconvertJsonbValue(&buffer, &jentry, val, 0);\n\n\t/*\n\t * Note: the JEntry of the root is discarded. Therefore the root\n\t * JsonbContainer struct must contain enough information to tell what kind\n\t * of value it is.\n\t */\n\n\tres = (Jsonb *) buffer.data;\n\n\tSET_VARSIZE(res, buffer.len);\n\n\treturn res;\n}"
  },
  {
    "function_name": "padBufferToInt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "1424-1440",
    "snippet": "static short\npadBufferToInt(StringInfo buffer)\n{\n\tint\t\t\tpadlen,\n\t\t\t\tp,\n\t\t\t\toffset;\n\n\tpadlen = INTALIGN(buffer->len) - buffer->len;\n\n\toffset = reserveFromBuffer(buffer, padlen);\n\n\t/* padlen must be small, so this is probably faster than a memset */\n\tfor (p = 0; p < padlen; p++)\n\t\tbuffer->data[offset + p] = '\\0';\n\n\treturn padlen;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\treserveFromBuffer(StringInfo buffer, int len);",
      "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
      "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
      "static short padBufferToInt(StringInfo buffer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reserveFromBuffer",
          "args": [
            "buffer",
            "padlen"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "reserveFromBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1375-1396",
          "snippet": "static int\nreserveFromBuffer(StringInfo buffer, int len)\n{\n\tint\t\t\toffset;\n\n\t/* Make more room if needed */\n\tenlargeStringInfo(buffer, len);\n\n\t/* remember current offset */\n\toffset = buffer->len;\n\n\t/* reserve the space */\n\tbuffer->len += len;\n\n\t/*\n\t * Keep a trailing null in place, even though it's not useful for us; it\n\t * seems best to preserve the invariants of StringInfos.\n\t */\n\tbuffer->data[buffer->len] = '\\0';\n\n\treturn offset;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nstatic int\nreserveFromBuffer(StringInfo buffer, int len)\n{\n\tint\t\t\toffset;\n\n\t/* Make more room if needed */\n\tenlargeStringInfo(buffer, len);\n\n\t/* remember current offset */\n\toffset = buffer->len;\n\n\t/* reserve the space */\n\tbuffer->len += len;\n\n\t/*\n\t * Keep a trailing null in place, even though it's not useful for us; it\n\t * seems best to preserve the invariants of StringInfos.\n\t */\n\tbuffer->data[buffer->len] = '\\0';\n\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INTALIGN",
          "args": [
            "buffer->len"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\n\nstatic short\npadBufferToInt(StringInfo buffer)\n{\n\tint\t\t\tpadlen,\n\t\t\t\tp,\n\t\t\t\toffset;\n\n\tpadlen = INTALIGN(buffer->len) - buffer->len;\n\n\toffset = reserveFromBuffer(buffer, padlen);\n\n\t/* padlen must be small, so this is probably faster than a memset */\n\tfor (p = 0; p < padlen; p++)\n\t\tbuffer->data[offset + p] = '\\0';\n\n\treturn padlen;\n}"
  },
  {
    "function_name": "appendToBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "1410-1417",
    "snippet": "static void\nappendToBuffer(StringInfo buffer, const char *data, int len)\n{\n\tint\t\t\toffset;\n\n\toffset = reserveFromBuffer(buffer, len);\n\tcopyToBuffer(buffer, offset, data, len);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\treserveFromBuffer(StringInfo buffer, int len);",
      "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
      "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
      "static short padBufferToInt(StringInfo buffer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copyToBuffer",
          "args": [
            "buffer",
            "offset",
            "data",
            "len"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "copyToBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1401-1405",
          "snippet": "static void\ncopyToBuffer(StringInfo buffer, int offset, const char *data, int len)\n{\n\tmemcpy(buffer->data + offset, data, len);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\n\nstatic void\ncopyToBuffer(StringInfo buffer, int offset, const char *data, int len)\n{\n\tmemcpy(buffer->data + offset, data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reserveFromBuffer",
          "args": [
            "buffer",
            "len"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "reserveFromBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1375-1396",
          "snippet": "static int\nreserveFromBuffer(StringInfo buffer, int len)\n{\n\tint\t\t\toffset;\n\n\t/* Make more room if needed */\n\tenlargeStringInfo(buffer, len);\n\n\t/* remember current offset */\n\toffset = buffer->len;\n\n\t/* reserve the space */\n\tbuffer->len += len;\n\n\t/*\n\t * Keep a trailing null in place, even though it's not useful for us; it\n\t * seems best to preserve the invariants of StringInfos.\n\t */\n\tbuffer->data[buffer->len] = '\\0';\n\n\treturn offset;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nstatic int\nreserveFromBuffer(StringInfo buffer, int len)\n{\n\tint\t\t\toffset;\n\n\t/* Make more room if needed */\n\tenlargeStringInfo(buffer, len);\n\n\t/* remember current offset */\n\toffset = buffer->len;\n\n\t/* reserve the space */\n\tbuffer->len += len;\n\n\t/*\n\t * Keep a trailing null in place, even though it's not useful for us; it\n\t * seems best to preserve the invariants of StringInfos.\n\t */\n\tbuffer->data[buffer->len] = '\\0';\n\n\treturn offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\n\nstatic void\nappendToBuffer(StringInfo buffer, const char *data, int len)\n{\n\tint\t\t\toffset;\n\n\toffset = reserveFromBuffer(buffer, len);\n\tcopyToBuffer(buffer, offset, data, len);\n}"
  },
  {
    "function_name": "copyToBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "1401-1405",
    "snippet": "static void\ncopyToBuffer(StringInfo buffer, int offset, const char *data, int len)\n{\n\tmemcpy(buffer->data + offset, data, len);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\treserveFromBuffer(StringInfo buffer, int len);",
      "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
      "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
      "static short padBufferToInt(StringInfo buffer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer->data + offset",
            "data",
            "len"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\n\nstatic void\ncopyToBuffer(StringInfo buffer, int offset, const char *data, int len)\n{\n\tmemcpy(buffer->data + offset, data, len);\n}"
  },
  {
    "function_name": "reserveFromBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "1375-1396",
    "snippet": "static int\nreserveFromBuffer(StringInfo buffer, int len)\n{\n\tint\t\t\toffset;\n\n\t/* Make more room if needed */\n\tenlargeStringInfo(buffer, len);\n\n\t/* remember current offset */\n\toffset = buffer->len;\n\n\t/* reserve the space */\n\tbuffer->len += len;\n\n\t/*\n\t * Keep a trailing null in place, even though it's not useful for us; it\n\t * seems best to preserve the invariants of StringInfos.\n\t */\n\tbuffer->data[buffer->len] = '\\0';\n\n\treturn offset;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\treserveFromBuffer(StringInfo buffer, int len);",
      "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
      "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
      "static short padBufferToInt(StringInfo buffer);",
      "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enlargeStringInfo",
          "args": [
            "buffer",
            "len"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nstatic int\nreserveFromBuffer(StringInfo buffer, int len)\n{\n\tint\t\t\toffset;\n\n\t/* Make more room if needed */\n\tenlargeStringInfo(buffer, len);\n\n\t/* remember current offset */\n\toffset = buffer->len;\n\n\t/* reserve the space */\n\tbuffer->len += len;\n\n\t/*\n\t * Keep a trailing null in place, even though it's not useful for us; it\n\t * seems best to preserve the invariants of StringInfos.\n\t */\n\tbuffer->data[buffer->len] = '\\0';\n\n\treturn offset;\n}"
  },
  {
    "function_name": "compareJsonbScalarValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "1330-1362",
    "snippet": "static int\ncompareJsonbScalarValue(JsonbValue *aScalar, JsonbValue *bScalar)\n{\n\tif (aScalar->type == bScalar->type)\n\t{\n\t\tswitch (aScalar->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\treturn 0;\n\t\t\tcase jbvString:\n\t\t\t\treturn varstr_cmp(aScalar->val.string.val,\n\t\t\t\t\t\t\t\t  aScalar->val.string.len,\n\t\t\t\t\t\t\t\t  bScalar->val.string.val,\n\t\t\t\t\t\t\t\t  bScalar->val.string.len,\n\t\t\t\t\t\t\t\t  DEFAULT_COLLATION_OID);\n\t\t\tcase jbvNumeric:\n\t\t\t\treturn DatumGetInt32(DirectFunctionCall2(numeric_cmp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(bScalar->val.numeric)));\n\t\t\tcase jbvBool:\n\t\t\t\tif (aScalar->val.boolean == bScalar->val.boolean)\n\t\t\t\t\treturn 0;\n\t\t\t\telse if (aScalar->val.boolean > bScalar->val.boolean)\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t}\n\t}\n\telog(ERROR, \"jsonb scalar type mismatch\");\n\treturn -1;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static int\treserveFromBuffer(StringInfo buffer, int len);",
      "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
      "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"jsonb scalar type mismatch\""
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "DirectFunctionCall2(numeric_cmp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(bScalar->val.numeric))"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_cmp",
            "PointerGetDatum(aScalar->val.numeric)",
            "PointerGetDatum(bScalar->val.numeric)"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "bScalar->val.numeric"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "aScalar->val.numeric"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varstr_cmp",
          "args": [
            "aScalar->val.string.val",
            "aScalar->val.string.len",
            "bScalar->val.string.val",
            "bScalar->val.string.len",
            "DEFAULT_COLLATION_OID"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "varstr_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1380-1609",
          "snippet": "int\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXTBUFLEN\t\t1024"
          ],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nint\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\n\nstatic int\ncompareJsonbScalarValue(JsonbValue *aScalar, JsonbValue *bScalar)\n{\n\tif (aScalar->type == bScalar->type)\n\t{\n\t\tswitch (aScalar->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\treturn 0;\n\t\t\tcase jbvString:\n\t\t\t\treturn varstr_cmp(aScalar->val.string.val,\n\t\t\t\t\t\t\t\t  aScalar->val.string.len,\n\t\t\t\t\t\t\t\t  bScalar->val.string.val,\n\t\t\t\t\t\t\t\t  bScalar->val.string.len,\n\t\t\t\t\t\t\t\t  DEFAULT_COLLATION_OID);\n\t\t\tcase jbvNumeric:\n\t\t\t\treturn DatumGetInt32(DirectFunctionCall2(numeric_cmp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(bScalar->val.numeric)));\n\t\t\tcase jbvBool:\n\t\t\t\tif (aScalar->val.boolean == bScalar->val.boolean)\n\t\t\t\t\treturn 0;\n\t\t\t\telse if (aScalar->val.boolean > bScalar->val.boolean)\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t}\n\t}\n\telog(ERROR, \"jsonb scalar type mismatch\");\n\treturn -1;\n}"
  },
  {
    "function_name": "equalsJsonbScalarValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "1298-1322",
    "snippet": "static bool\nequalsJsonbScalarValue(JsonbValue *aScalar, JsonbValue *bScalar)\n{\n\tif (aScalar->type == bScalar->type)\n\t{\n\t\tswitch (aScalar->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\treturn true;\n\t\t\tcase jbvString:\n\t\t\t\treturn lengthCompareJsonbStringValue(aScalar, bScalar) == 0;\n\t\t\tcase jbvNumeric:\n\t\t\t\treturn DatumGetBool(DirectFunctionCall2(numeric_eq,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(bScalar->val.numeric)));\n\t\t\tcase jbvBool:\n\t\t\t\treturn aScalar->val.boolean == bScalar->val.boolean;\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t}\n\t}\n\telog(ERROR, \"jsonb scalar type mismatch\");\n\treturn -1;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"jsonb scalar type mismatch\""
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(numeric_eq,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(bScalar->val.numeric))"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_eq",
            "PointerGetDatum(aScalar->val.numeric)",
            "PointerGetDatum(bScalar->val.numeric)"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "bScalar->val.numeric"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "aScalar->val.numeric"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthCompareJsonbStringValue",
          "args": [
            "aScalar",
            "bScalar"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "lengthCompareJsonbStringValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1761-1781",
          "snippet": "static int\nlengthCompareJsonbStringValue(const void *a, const void *b)\n{\n\tconst JsonbValue *va = (const JsonbValue *) a;\n\tconst JsonbValue *vb = (const JsonbValue *) b;\n\tint\t\t\tres;\n\n\tAssert(va->type == jbvString);\n\tAssert(vb->type == jbvString);\n\n\tif (va->val.string.len == vb->val.string.len)\n\t{\n\t\tres = memcmp(va->val.string.val, vb->val.string.val, va->val.string.len);\n\t}\n\telse\n\t{\n\t\tres = (va->val.string.len > vb->val.string.len) ? 1 : -1;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static int\tlengthCompareJsonbStringValue(const void *a, const void *b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic int\tlengthCompareJsonbStringValue(const void *a, const void *b);\n\nstatic int\nlengthCompareJsonbStringValue(const void *a, const void *b)\n{\n\tconst JsonbValue *va = (const JsonbValue *) a;\n\tconst JsonbValue *vb = (const JsonbValue *) b;\n\tint\t\t\tres;\n\n\tAssert(va->type == jbvString);\n\tAssert(vb->type == jbvString);\n\n\tif (va->val.string.len == vb->val.string.len)\n\t{\n\t\tres = memcmp(va->val.string.val, vb->val.string.val, va->val.string.len);\n\t}\n\telse\n\t{\n\t\tres = (va->val.string.len > vb->val.string.len) ? 1 : -1;\n\t}\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\n\nstatic bool\nequalsJsonbScalarValue(JsonbValue *aScalar, JsonbValue *bScalar)\n{\n\tif (aScalar->type == bScalar->type)\n\t{\n\t\tswitch (aScalar->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\treturn true;\n\t\t\tcase jbvString:\n\t\t\t\treturn lengthCompareJsonbStringValue(aScalar, bScalar) == 0;\n\t\t\tcase jbvNumeric:\n\t\t\t\treturn DatumGetBool(DirectFunctionCall2(numeric_eq,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(bScalar->val.numeric)));\n\t\t\tcase jbvBool:\n\t\t\t\treturn aScalar->val.boolean == bScalar->val.boolean;\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t}\n\t}\n\telog(ERROR, \"jsonb scalar type mismatch\");\n\treturn -1;\n}"
  },
  {
    "function_name": "JsonbHashScalarValueExtended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "1256-1293",
    "snippet": "void\nJsonbHashScalarValueExtended(const JsonbValue *scalarVal, uint64 *hash,\n\t\t\t\t\t\t\t uint64 seed)\n{\n\tuint64\t\ttmp;\n\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\ttmp = seed + 0x01;\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\ttmp = DatumGetUInt64(hash_any_extended((const unsigned char *) scalarVal->val.string.val,\n\t\t\t\t\t\t\t\t\t\t\t\t   scalarVal->val.string.len,\n\t\t\t\t\t\t\t\t\t\t\t\t   seed));\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\ttmp = DatumGetUInt64(DirectFunctionCall2(hash_numeric_extended,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NumericGetDatum(scalarVal->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t UInt64GetDatum(seed)));\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\tif (seed)\n\t\t\t\ttmp = DatumGetUInt64(DirectFunctionCall2(hashcharextended,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t BoolGetDatum(scalarVal->val.boolean),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t UInt64GetDatum(seed)));\n\t\t\telse\n\t\t\t\ttmp = scalarVal->val.boolean ? 0x02 : 0x04;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t\tbreak;\n\t}\n\n\t*hash = ROTATE_HIGH_AND_LOW_32BITS(*hash);\n\t*hash ^= tmp;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
      "static int\treserveFromBuffer(StringInfo buffer, int len);",
      "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
      "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
      "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ROTATE_HIGH_AND_LOW_32BITS",
          "args": [
            "*hash"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid jsonb scalar type\""
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetUInt64",
          "args": [
            "DirectFunctionCall2(hashcharextended,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t BoolGetDatum(scalarVal->val.boolean),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t UInt64GetDatum(seed))"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "hashcharextended",
            "BoolGetDatum(scalarVal->val.boolean)",
            "UInt64GetDatum(seed)"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UInt64GetDatum",
          "args": [
            "seed"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "scalarVal->val.boolean"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt64",
          "args": [
            "DirectFunctionCall2(hash_numeric_extended,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NumericGetDatum(scalarVal->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t UInt64GetDatum(seed))"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "hash_numeric_extended",
            "NumericGetDatum(scalarVal->val.numeric)",
            "UInt64GetDatum(seed)"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UInt64GetDatum",
          "args": [
            "seed"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "scalarVal->val.numeric"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt64",
          "args": [
            "hash_any_extended((const unsigned char *) scalarVal->val.string.val,\n\t\t\t\t\t\t\t\t\t\t\t\t   scalarVal->val.string.len,\n\t\t\t\t\t\t\t\t\t\t\t\t   seed)"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_any_extended",
          "args": [
            "(const unsigned char *) scalarVal->val.string.val",
            "scalarVal->val.string.len",
            "seed"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nvoid\nJsonbHashScalarValueExtended(const JsonbValue *scalarVal, uint64 *hash,\n\t\t\t\t\t\t\t uint64 seed)\n{\n\tuint64\t\ttmp;\n\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\ttmp = seed + 0x01;\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\ttmp = DatumGetUInt64(hash_any_extended((const unsigned char *) scalarVal->val.string.val,\n\t\t\t\t\t\t\t\t\t\t\t\t   scalarVal->val.string.len,\n\t\t\t\t\t\t\t\t\t\t\t\t   seed));\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\ttmp = DatumGetUInt64(DirectFunctionCall2(hash_numeric_extended,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NumericGetDatum(scalarVal->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t UInt64GetDatum(seed)));\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\tif (seed)\n\t\t\t\ttmp = DatumGetUInt64(DirectFunctionCall2(hashcharextended,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t BoolGetDatum(scalarVal->val.boolean),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t UInt64GetDatum(seed)));\n\t\t\telse\n\t\t\t\ttmp = scalarVal->val.boolean ? 0x02 : 0x04;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t\tbreak;\n\t}\n\n\t*hash = ROTATE_HIGH_AND_LOW_32BITS(*hash);\n\t*hash ^= tmp;\n}"
  },
  {
    "function_name": "JsonbHashScalarValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "1213-1250",
    "snippet": "void\nJsonbHashScalarValue(const JsonbValue *scalarVal, uint32 *hash)\n{\n\tuint32\t\ttmp;\n\n\t/* Compute hash value for scalarVal */\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\ttmp = 0x01;\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\ttmp = DatumGetUInt32(hash_any((const unsigned char *) scalarVal->val.string.val,\n\t\t\t\t\t\t\t\t\t\t  scalarVal->val.string.len));\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\t/* Must hash equal numerics to equal hash codes */\n\t\t\ttmp = DatumGetUInt32(DirectFunctionCall1(hash_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NumericGetDatum(scalarVal->val.numeric)));\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\ttmp = scalarVal->val.boolean ? 0x02 : 0x04;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t\ttmp = 0;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Combine hash values of successive keys, values and elements by rotating\n\t * the previous value left 1 bit, then XOR'ing in the new\n\t * key/value/element's hash value.\n\t */\n\t*hash = (*hash << 1) | (*hash >> 31);\n\t*hash ^= tmp;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
      "static int\treserveFromBuffer(StringInfo buffer, int len);",
      "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
      "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
      "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid jsonb scalar type\""
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetUInt32",
          "args": [
            "DirectFunctionCall1(hash_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NumericGetDatum(scalarVal->val.numeric))"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "hash_numeric",
            "NumericGetDatum(scalarVal->val.numeric)"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "scalarVal->val.numeric"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt32",
          "args": [
            "hash_any((const unsigned char *) scalarVal->val.string.val,\n\t\t\t\t\t\t\t\t\t\t  scalarVal->val.string.len)"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_any",
          "args": [
            "(const unsigned char *) scalarVal->val.string.val",
            "scalarVal->val.string.len"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nvoid\nJsonbHashScalarValue(const JsonbValue *scalarVal, uint32 *hash)\n{\n\tuint32\t\ttmp;\n\n\t/* Compute hash value for scalarVal */\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\ttmp = 0x01;\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\ttmp = DatumGetUInt32(hash_any((const unsigned char *) scalarVal->val.string.val,\n\t\t\t\t\t\t\t\t\t\t  scalarVal->val.string.len));\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\t/* Must hash equal numerics to equal hash codes */\n\t\t\ttmp = DatumGetUInt32(DirectFunctionCall1(hash_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NumericGetDatum(scalarVal->val.numeric)));\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\ttmp = scalarVal->val.boolean ? 0x02 : 0x04;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t\ttmp = 0;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Combine hash values of successive keys, values and elements by rotating\n\t * the previous value left 1 bit, then XOR'ing in the new\n\t * key/value/element's hash value.\n\t */\n\t*hash = (*hash << 1) | (*hash >> 31);\n\t*hash ^= tmp;\n}"
  },
  {
    "function_name": "JsonbDeepContains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "962-1204",
    "snippet": "bool\nJsonbDeepContains(JsonbIterator **val, JsonbIterator **mContained)\n{\n\tJsonbValue\tvval,\n\t\t\t\tvcontained;\n\tJsonbIteratorToken rval,\n\t\t\t\trcont;\n\n\t/*\n\t * Guard against stack overflow due to overly complex Jsonb.\n\t *\n\t * Functions called here independently take this precaution, but that\n\t * might not be sufficient since this is also a recursive function.\n\t */\n\tcheck_stack_depth();\n\n\trval = JsonbIteratorNext(val, &vval, false);\n\trcont = JsonbIteratorNext(mContained, &vcontained, false);\n\n\tif (rval != rcont)\n\t{\n\t\t/*\n\t\t * The differing return values can immediately be taken as indicating\n\t\t * two differing container types at this nesting level, which is\n\t\t * sufficient reason to give up entirely (but it should be the case\n\t\t * that they're both some container type).\n\t\t */\n\t\tAssert(rval == WJB_BEGIN_OBJECT || rval == WJB_BEGIN_ARRAY);\n\t\tAssert(rcont == WJB_BEGIN_OBJECT || rcont == WJB_BEGIN_ARRAY);\n\t\treturn false;\n\t}\n\telse if (rcont == WJB_BEGIN_OBJECT)\n\t{\n\t\tAssert(vval.type == jbvObject);\n\t\tAssert(vcontained.type == jbvObject);\n\n\t\t/*\n\t\t * If the lhs has fewer pairs than the rhs, it can't possibly contain\n\t\t * the rhs.  (This conclusion is safe only because we de-duplicate\n\t\t * keys in all Jsonb objects; thus there can be no corresponding\n\t\t * optimization in the array case.)  The case probably won't arise\n\t\t * often, but since it's such a cheap check we may as well make it.\n\t\t */\n\t\tif (vval.val.object.nPairs < vcontained.val.object.nPairs)\n\t\t\treturn false;\n\n\t\t/* Work through rhs \"is it contained within?\" object */\n\t\tfor (;;)\n\t\t{\n\t\t\tJsonbValue *lhsVal; /* lhsVal is from pair in lhs object */\n\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, false);\n\n\t\t\t/*\n\t\t\t * When we get through caller's rhs \"is it contained within?\"\n\t\t\t * object without failing to find one of its values, it's\n\t\t\t * contained.\n\t\t\t */\n\t\t\tif (rcont == WJB_END_OBJECT)\n\t\t\t\treturn true;\n\n\t\t\tAssert(rcont == WJB_KEY);\n\n\t\t\t/* First, find value by key... */\n\t\t\tlhsVal = findJsonbValueFromContainer((*val)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t &vcontained);\n\n\t\t\tif (!lhsVal)\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * ...at this stage it is apparent that there is at least a key\n\t\t\t * match for this rhs pair.\n\t\t\t */\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, true);\n\n\t\t\tAssert(rcont == WJB_VALUE);\n\n\t\t\t/*\n\t\t\t * Compare rhs pair's value with lhs pair's value just found using\n\t\t\t * key\n\t\t\t */\n\t\t\tif (lhsVal->type != vcontained.type)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (IsAJsonbScalar(lhsVal))\n\t\t\t{\n\t\t\t\tif (!equalsJsonbScalarValue(lhsVal, &vcontained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Nested container value (object or array) */\n\t\t\t\tJsonbIterator *nestval,\n\t\t\t\t\t\t   *nestContained;\n\n\t\t\t\tAssert(lhsVal->type == jbvBinary);\n\t\t\t\tAssert(vcontained.type == jbvBinary);\n\n\t\t\t\tnestval = JsonbIteratorInit(lhsVal->val.binary.data);\n\t\t\t\tnestContained = JsonbIteratorInit(vcontained.val.binary.data);\n\n\t\t\t\t/*\n\t\t\t\t * Match \"value\" side of rhs datum object's pair recursively.\n\t\t\t\t * It's a nested structure.\n\t\t\t\t *\n\t\t\t\t * Note that nesting still has to \"match up\" at the right\n\t\t\t\t * nesting sub-levels.  However, there need only be zero or\n\t\t\t\t * more matching pairs (or elements) at each nesting level\n\t\t\t\t * (provided the *rhs* pairs/elements *all* match on each\n\t\t\t\t * level), which enables searching nested structures for a\n\t\t\t\t * single String or other primitive type sub-datum quite\n\t\t\t\t * effectively (provided the user constructed the rhs nested\n\t\t\t\t * structure such that we \"know where to look\").\n\t\t\t\t *\n\t\t\t\t * In other words, the mapping of container nodes in the rhs\n\t\t\t\t * \"vcontained\" Jsonb to internal nodes on the lhs is\n\t\t\t\t * injective, and parent-child edges on the rhs must be mapped\n\t\t\t\t * to parent-child edges on the lhs to satisfy the condition\n\t\t\t\t * of containment (plus of course the mapped nodes must be\n\t\t\t\t * equal).\n\t\t\t\t */\n\t\t\t\tif (!JsonbDeepContains(&nestval, &nestContained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse if (rcont == WJB_BEGIN_ARRAY)\n\t{\n\t\tJsonbValue *lhsConts = NULL;\n\t\tuint32\t\tnLhsElems = vval.val.array.nElems;\n\n\t\tAssert(vval.type == jbvArray);\n\t\tAssert(vcontained.type == jbvArray);\n\n\t\t/*\n\t\t * Handle distinction between \"raw scalar\" pseudo arrays, and real\n\t\t * arrays.\n\t\t *\n\t\t * A raw scalar may contain another raw scalar, and an array may\n\t\t * contain a raw scalar, but a raw scalar may not contain an array. We\n\t\t * don't do something like this for the object case, since objects can\n\t\t * only contain pairs, never raw scalars (a pair is represented by an\n\t\t * rhs object argument with a single contained pair).\n\t\t */\n\t\tif (vval.val.array.rawScalar && !vcontained.val.array.rawScalar)\n\t\t\treturn false;\n\n\t\t/* Work through rhs \"is it contained within?\" array */\n\t\tfor (;;)\n\t\t{\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, true);\n\n\t\t\t/*\n\t\t\t * When we get through caller's rhs \"is it contained within?\"\n\t\t\t * array without failing to find one of its values, it's\n\t\t\t * contained.\n\t\t\t */\n\t\t\tif (rcont == WJB_END_ARRAY)\n\t\t\t\treturn true;\n\n\t\t\tAssert(rcont == WJB_ELEM);\n\n\t\t\tif (IsAJsonbScalar(&vcontained))\n\t\t\t{\n\t\t\t\tif (!findJsonbValueFromContainer((*val)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t JB_FARRAY,\n\t\t\t\t\t\t\t\t\t\t\t\t &vcontained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuint32\t\ti;\n\n\t\t\t\t/*\n\t\t\t\t * If this is first container found in rhs array (at this\n\t\t\t\t * depth), initialize temp lhs array of containers\n\t\t\t\t */\n\t\t\t\tif (lhsConts == NULL)\n\t\t\t\t{\n\t\t\t\t\tuint32\t\tj = 0;\n\n\t\t\t\t\t/* Make room for all possible values */\n\t\t\t\t\tlhsConts = palloc(sizeof(JsonbValue) * nLhsElems);\n\n\t\t\t\t\tfor (i = 0; i < nLhsElems; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Store all lhs elements in temp array */\n\t\t\t\t\t\trcont = JsonbIteratorNext(val, &vval, true);\n\t\t\t\t\t\tAssert(rcont == WJB_ELEM);\n\n\t\t\t\t\t\tif (vval.type == jbvBinary)\n\t\t\t\t\t\t\tlhsConts[j++] = vval;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* No container elements in temp array, so give up now */\n\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t/* We may have only partially filled array */\n\t\t\t\t\tnLhsElems = j;\n\t\t\t\t}\n\n\t\t\t\t/* XXX: Nested array containment is O(N^2) */\n\t\t\t\tfor (i = 0; i < nLhsElems; i++)\n\t\t\t\t{\n\t\t\t\t\t/* Nested container value (object or array) */\n\t\t\t\t\tJsonbIterator *nestval,\n\t\t\t\t\t\t\t   *nestContained;\n\t\t\t\t\tbool\t\tcontains;\n\n\t\t\t\t\tnestval = JsonbIteratorInit(lhsConts[i].val.binary.data);\n\t\t\t\t\tnestContained = JsonbIteratorInit(vcontained.val.binary.data);\n\n\t\t\t\t\tcontains = JsonbDeepContains(&nestval, &nestContained);\n\n\t\t\t\t\tif (nestval)\n\t\t\t\t\t\tpfree(nestval);\n\t\t\t\t\tif (nestContained)\n\t\t\t\t\t\tpfree(nestContained);\n\t\t\t\t\tif (contains)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Report rhs container value is not contained if couldn't\n\t\t\t\t * match rhs container to *some* lhs cont\n\t\t\t\t */\n\t\t\t\tif (i == nLhsElems)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"invalid jsonb container type\");\n\t}\n\n\telog(ERROR, \"unexpectedly fell off end of jsonb container\");\n\treturn false;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
      "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
      "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
      "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
      "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
      "static void uniqueifyJsonbObject(JsonbValue *object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpectedly fell off end of jsonb container\""
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "nestContained"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbDeepContains",
          "args": [
            "&nestval",
            "&nestContained"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbDeepContains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "962-1204",
          "snippet": "bool\nJsonbDeepContains(JsonbIterator **val, JsonbIterator **mContained)\n{\n\tJsonbValue\tvval,\n\t\t\t\tvcontained;\n\tJsonbIteratorToken rval,\n\t\t\t\trcont;\n\n\t/*\n\t * Guard against stack overflow due to overly complex Jsonb.\n\t *\n\t * Functions called here independently take this precaution, but that\n\t * might not be sufficient since this is also a recursive function.\n\t */\n\tcheck_stack_depth();\n\n\trval = JsonbIteratorNext(val, &vval, false);\n\trcont = JsonbIteratorNext(mContained, &vcontained, false);\n\n\tif (rval != rcont)\n\t{\n\t\t/*\n\t\t * The differing return values can immediately be taken as indicating\n\t\t * two differing container types at this nesting level, which is\n\t\t * sufficient reason to give up entirely (but it should be the case\n\t\t * that they're both some container type).\n\t\t */\n\t\tAssert(rval == WJB_BEGIN_OBJECT || rval == WJB_BEGIN_ARRAY);\n\t\tAssert(rcont == WJB_BEGIN_OBJECT || rcont == WJB_BEGIN_ARRAY);\n\t\treturn false;\n\t}\n\telse if (rcont == WJB_BEGIN_OBJECT)\n\t{\n\t\tAssert(vval.type == jbvObject);\n\t\tAssert(vcontained.type == jbvObject);\n\n\t\t/*\n\t\t * If the lhs has fewer pairs than the rhs, it can't possibly contain\n\t\t * the rhs.  (This conclusion is safe only because we de-duplicate\n\t\t * keys in all Jsonb objects; thus there can be no corresponding\n\t\t * optimization in the array case.)  The case probably won't arise\n\t\t * often, but since it's such a cheap check we may as well make it.\n\t\t */\n\t\tif (vval.val.object.nPairs < vcontained.val.object.nPairs)\n\t\t\treturn false;\n\n\t\t/* Work through rhs \"is it contained within?\" object */\n\t\tfor (;;)\n\t\t{\n\t\t\tJsonbValue *lhsVal; /* lhsVal is from pair in lhs object */\n\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, false);\n\n\t\t\t/*\n\t\t\t * When we get through caller's rhs \"is it contained within?\"\n\t\t\t * object without failing to find one of its values, it's\n\t\t\t * contained.\n\t\t\t */\n\t\t\tif (rcont == WJB_END_OBJECT)\n\t\t\t\treturn true;\n\n\t\t\tAssert(rcont == WJB_KEY);\n\n\t\t\t/* First, find value by key... */\n\t\t\tlhsVal = findJsonbValueFromContainer((*val)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t &vcontained);\n\n\t\t\tif (!lhsVal)\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * ...at this stage it is apparent that there is at least a key\n\t\t\t * match for this rhs pair.\n\t\t\t */\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, true);\n\n\t\t\tAssert(rcont == WJB_VALUE);\n\n\t\t\t/*\n\t\t\t * Compare rhs pair's value with lhs pair's value just found using\n\t\t\t * key\n\t\t\t */\n\t\t\tif (lhsVal->type != vcontained.type)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (IsAJsonbScalar(lhsVal))\n\t\t\t{\n\t\t\t\tif (!equalsJsonbScalarValue(lhsVal, &vcontained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Nested container value (object or array) */\n\t\t\t\tJsonbIterator *nestval,\n\t\t\t\t\t\t   *nestContained;\n\n\t\t\t\tAssert(lhsVal->type == jbvBinary);\n\t\t\t\tAssert(vcontained.type == jbvBinary);\n\n\t\t\t\tnestval = JsonbIteratorInit(lhsVal->val.binary.data);\n\t\t\t\tnestContained = JsonbIteratorInit(vcontained.val.binary.data);\n\n\t\t\t\t/*\n\t\t\t\t * Match \"value\" side of rhs datum object's pair recursively.\n\t\t\t\t * It's a nested structure.\n\t\t\t\t *\n\t\t\t\t * Note that nesting still has to \"match up\" at the right\n\t\t\t\t * nesting sub-levels.  However, there need only be zero or\n\t\t\t\t * more matching pairs (or elements) at each nesting level\n\t\t\t\t * (provided the *rhs* pairs/elements *all* match on each\n\t\t\t\t * level), which enables searching nested structures for a\n\t\t\t\t * single String or other primitive type sub-datum quite\n\t\t\t\t * effectively (provided the user constructed the rhs nested\n\t\t\t\t * structure such that we \"know where to look\").\n\t\t\t\t *\n\t\t\t\t * In other words, the mapping of container nodes in the rhs\n\t\t\t\t * \"vcontained\" Jsonb to internal nodes on the lhs is\n\t\t\t\t * injective, and parent-child edges on the rhs must be mapped\n\t\t\t\t * to parent-child edges on the lhs to satisfy the condition\n\t\t\t\t * of containment (plus of course the mapped nodes must be\n\t\t\t\t * equal).\n\t\t\t\t */\n\t\t\t\tif (!JsonbDeepContains(&nestval, &nestContained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse if (rcont == WJB_BEGIN_ARRAY)\n\t{\n\t\tJsonbValue *lhsConts = NULL;\n\t\tuint32\t\tnLhsElems = vval.val.array.nElems;\n\n\t\tAssert(vval.type == jbvArray);\n\t\tAssert(vcontained.type == jbvArray);\n\n\t\t/*\n\t\t * Handle distinction between \"raw scalar\" pseudo arrays, and real\n\t\t * arrays.\n\t\t *\n\t\t * A raw scalar may contain another raw scalar, and an array may\n\t\t * contain a raw scalar, but a raw scalar may not contain an array. We\n\t\t * don't do something like this for the object case, since objects can\n\t\t * only contain pairs, never raw scalars (a pair is represented by an\n\t\t * rhs object argument with a single contained pair).\n\t\t */\n\t\tif (vval.val.array.rawScalar && !vcontained.val.array.rawScalar)\n\t\t\treturn false;\n\n\t\t/* Work through rhs \"is it contained within?\" array */\n\t\tfor (;;)\n\t\t{\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, true);\n\n\t\t\t/*\n\t\t\t * When we get through caller's rhs \"is it contained within?\"\n\t\t\t * array without failing to find one of its values, it's\n\t\t\t * contained.\n\t\t\t */\n\t\t\tif (rcont == WJB_END_ARRAY)\n\t\t\t\treturn true;\n\n\t\t\tAssert(rcont == WJB_ELEM);\n\n\t\t\tif (IsAJsonbScalar(&vcontained))\n\t\t\t{\n\t\t\t\tif (!findJsonbValueFromContainer((*val)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t JB_FARRAY,\n\t\t\t\t\t\t\t\t\t\t\t\t &vcontained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuint32\t\ti;\n\n\t\t\t\t/*\n\t\t\t\t * If this is first container found in rhs array (at this\n\t\t\t\t * depth), initialize temp lhs array of containers\n\t\t\t\t */\n\t\t\t\tif (lhsConts == NULL)\n\t\t\t\t{\n\t\t\t\t\tuint32\t\tj = 0;\n\n\t\t\t\t\t/* Make room for all possible values */\n\t\t\t\t\tlhsConts = palloc(sizeof(JsonbValue) * nLhsElems);\n\n\t\t\t\t\tfor (i = 0; i < nLhsElems; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Store all lhs elements in temp array */\n\t\t\t\t\t\trcont = JsonbIteratorNext(val, &vval, true);\n\t\t\t\t\t\tAssert(rcont == WJB_ELEM);\n\n\t\t\t\t\t\tif (vval.type == jbvBinary)\n\t\t\t\t\t\t\tlhsConts[j++] = vval;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* No container elements in temp array, so give up now */\n\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t/* We may have only partially filled array */\n\t\t\t\t\tnLhsElems = j;\n\t\t\t\t}\n\n\t\t\t\t/* XXX: Nested array containment is O(N^2) */\n\t\t\t\tfor (i = 0; i < nLhsElems; i++)\n\t\t\t\t{\n\t\t\t\t\t/* Nested container value (object or array) */\n\t\t\t\t\tJsonbIterator *nestval,\n\t\t\t\t\t\t\t   *nestContained;\n\t\t\t\t\tbool\t\tcontains;\n\n\t\t\t\t\tnestval = JsonbIteratorInit(lhsConts[i].val.binary.data);\n\t\t\t\t\tnestContained = JsonbIteratorInit(vcontained.val.binary.data);\n\n\t\t\t\t\tcontains = JsonbDeepContains(&nestval, &nestContained);\n\n\t\t\t\t\tif (nestval)\n\t\t\t\t\t\tpfree(nestval);\n\t\t\t\t\tif (nestContained)\n\t\t\t\t\t\tpfree(nestContained);\n\t\t\t\t\tif (contains)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Report rhs container value is not contained if couldn't\n\t\t\t\t * match rhs container to *some* lhs cont\n\t\t\t\t */\n\t\t\t\tif (i == nLhsElems)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"invalid jsonb container type\");\n\t}\n\n\telog(ERROR, \"unexpectedly fell off end of jsonb container\");\n\treturn false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "vcontained.val.binary.data"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rcont == WJB_ELEM"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "val",
            "&vval",
            "true"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(JsonbValue) * nLhsElems"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "findJsonbValueFromContainer",
          "args": [
            "(*val)->container",
            "JB_FARRAY",
            "&vcontained"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "findJsonbValueFromContainer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "326-411",
          "snippet": "JsonbValue *\nfindJsonbValueFromContainer(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\tJsonbValue *key)\n{\n\tJEntry\t   *children = container->children;\n\tint\t\t\tcount = JsonContainerSize(container);\n\tJsonbValue *result;\n\n\tAssert((flags & ~(JB_FARRAY | JB_FOBJECT)) == 0);\n\n\t/* Quick out without a palloc cycle if object/array is empty */\n\tif (count <= 0)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tif ((flags & JB_FARRAY) && JsonContainerIsArray(container))\n\t{\n\t\tchar\t   *base_addr = (char *) (children + count);\n\t\tuint32\t\toffset = 0;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tfillJsonbValue(container, i, base_addr, offset, result);\n\n\t\t\tif (key->type == result->type)\n\t\t\t{\n\t\t\t\tif (equalsJsonbScalarValue(key, result))\n\t\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tJBE_ADVANCE_OFFSET(offset, children[i]);\n\t\t}\n\t}\n\telse if ((flags & JB_FOBJECT) && JsonContainerIsObject(container))\n\t{\n\t\t/* Since this is an object, account for *Pairs* of Jentrys */\n\t\tchar\t   *base_addr = (char *) (children + count * 2);\n\t\tuint32\t\tstopLow = 0,\n\t\t\t\t\tstopHigh = count;\n\n\t\t/* Object key passed by caller must be a string */\n\t\tAssert(key->type == jbvString);\n\n\t\t/* Binary search on object/pair keys *only* */\n\t\twhile (stopLow < stopHigh)\n\t\t{\n\t\t\tuint32\t\tstopMiddle;\n\t\t\tint\t\t\tdifference;\n\t\t\tJsonbValue\tcandidate;\n\n\t\t\tstopMiddle = stopLow + (stopHigh - stopLow) / 2;\n\n\t\t\tcandidate.type = jbvString;\n\t\t\tcandidate.val.string.val =\n\t\t\t\tbase_addr + getJsonbOffset(container, stopMiddle);\n\t\t\tcandidate.val.string.len = getJsonbLength(container, stopMiddle);\n\n\t\t\tdifference = lengthCompareJsonbStringValue(&candidate, key);\n\n\t\t\tif (difference == 0)\n\t\t\t{\n\t\t\t\t/* Found our key, return corresponding value */\n\t\t\t\tint\t\t\tindex = stopMiddle + count;\n\n\t\t\t\tfillJsonbValue(container, index, base_addr,\n\t\t\t\t\t\t\t   getJsonbOffset(container, index),\n\t\t\t\t\t\t\t   result);\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (difference < 0)\n\t\t\t\t\tstopLow = stopMiddle + 1;\n\t\t\t\telse\n\t\t\t\t\tstopHigh = stopMiddle;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Not found */\n\tpfree(result);\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbValue *\nfindJsonbValueFromContainer(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\tJsonbValue *key)\n{\n\tJEntry\t   *children = container->children;\n\tint\t\t\tcount = JsonContainerSize(container);\n\tJsonbValue *result;\n\n\tAssert((flags & ~(JB_FARRAY | JB_FOBJECT)) == 0);\n\n\t/* Quick out without a palloc cycle if object/array is empty */\n\tif (count <= 0)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tif ((flags & JB_FARRAY) && JsonContainerIsArray(container))\n\t{\n\t\tchar\t   *base_addr = (char *) (children + count);\n\t\tuint32\t\toffset = 0;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tfillJsonbValue(container, i, base_addr, offset, result);\n\n\t\t\tif (key->type == result->type)\n\t\t\t{\n\t\t\t\tif (equalsJsonbScalarValue(key, result))\n\t\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tJBE_ADVANCE_OFFSET(offset, children[i]);\n\t\t}\n\t}\n\telse if ((flags & JB_FOBJECT) && JsonContainerIsObject(container))\n\t{\n\t\t/* Since this is an object, account for *Pairs* of Jentrys */\n\t\tchar\t   *base_addr = (char *) (children + count * 2);\n\t\tuint32\t\tstopLow = 0,\n\t\t\t\t\tstopHigh = count;\n\n\t\t/* Object key passed by caller must be a string */\n\t\tAssert(key->type == jbvString);\n\n\t\t/* Binary search on object/pair keys *only* */\n\t\twhile (stopLow < stopHigh)\n\t\t{\n\t\t\tuint32\t\tstopMiddle;\n\t\t\tint\t\t\tdifference;\n\t\t\tJsonbValue\tcandidate;\n\n\t\t\tstopMiddle = stopLow + (stopHigh - stopLow) / 2;\n\n\t\t\tcandidate.type = jbvString;\n\t\t\tcandidate.val.string.val =\n\t\t\t\tbase_addr + getJsonbOffset(container, stopMiddle);\n\t\t\tcandidate.val.string.len = getJsonbLength(container, stopMiddle);\n\n\t\t\tdifference = lengthCompareJsonbStringValue(&candidate, key);\n\n\t\t\tif (difference == 0)\n\t\t\t{\n\t\t\t\t/* Found our key, return corresponding value */\n\t\t\t\tint\t\t\tindex = stopMiddle + count;\n\n\t\t\t\tfillJsonbValue(container, index, base_addr,\n\t\t\t\t\t\t\t   getJsonbOffset(container, index),\n\t\t\t\t\t\t\t   result);\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (difference < 0)\n\t\t\t\t\tstopLow = stopMiddle + 1;\n\t\t\t\telse\n\t\t\t\t\tstopHigh = stopMiddle;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Not found */\n\tpfree(result);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsAJsonbScalar",
          "args": [
            "&vcontained"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rcont == WJB_ELEM"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "vcontained.type == jbvArray"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "vval.type == jbvArray"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "vcontained.type == jbvBinary"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lhsVal->type == jbvBinary"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equalsJsonbScalarValue",
          "args": [
            "lhsVal",
            "&vcontained"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "equalsJsonbScalarValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1298-1322",
          "snippet": "static bool\nequalsJsonbScalarValue(JsonbValue *aScalar, JsonbValue *bScalar)\n{\n\tif (aScalar->type == bScalar->type)\n\t{\n\t\tswitch (aScalar->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\treturn true;\n\t\t\tcase jbvString:\n\t\t\t\treturn lengthCompareJsonbStringValue(aScalar, bScalar) == 0;\n\t\t\tcase jbvNumeric:\n\t\t\t\treturn DatumGetBool(DirectFunctionCall2(numeric_eq,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(bScalar->val.numeric)));\n\t\t\tcase jbvBool:\n\t\t\t\treturn aScalar->val.boolean == bScalar->val.boolean;\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t}\n\t}\n\telog(ERROR, \"jsonb scalar type mismatch\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\n\nstatic bool\nequalsJsonbScalarValue(JsonbValue *aScalar, JsonbValue *bScalar)\n{\n\tif (aScalar->type == bScalar->type)\n\t{\n\t\tswitch (aScalar->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\treturn true;\n\t\t\tcase jbvString:\n\t\t\t\treturn lengthCompareJsonbStringValue(aScalar, bScalar) == 0;\n\t\t\tcase jbvNumeric:\n\t\t\t\treturn DatumGetBool(DirectFunctionCall2(numeric_eq,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(bScalar->val.numeric)));\n\t\t\tcase jbvBool:\n\t\t\t\treturn aScalar->val.boolean == bScalar->val.boolean;\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t}\n\t}\n\telog(ERROR, \"jsonb scalar type mismatch\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsAJsonbScalar",
          "args": [
            "lhsVal"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rcont == WJB_VALUE"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rcont == WJB_KEY"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "vcontained.type == jbvObject"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "vval.type == jbvObject"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rcont == WJB_BEGIN_OBJECT || rcont == WJB_BEGIN_ARRAY"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rval == WJB_BEGIN_OBJECT || rval == WJB_BEGIN_ARRAY"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nbool\nJsonbDeepContains(JsonbIterator **val, JsonbIterator **mContained)\n{\n\tJsonbValue\tvval,\n\t\t\t\tvcontained;\n\tJsonbIteratorToken rval,\n\t\t\t\trcont;\n\n\t/*\n\t * Guard against stack overflow due to overly complex Jsonb.\n\t *\n\t * Functions called here independently take this precaution, but that\n\t * might not be sufficient since this is also a recursive function.\n\t */\n\tcheck_stack_depth();\n\n\trval = JsonbIteratorNext(val, &vval, false);\n\trcont = JsonbIteratorNext(mContained, &vcontained, false);\n\n\tif (rval != rcont)\n\t{\n\t\t/*\n\t\t * The differing return values can immediately be taken as indicating\n\t\t * two differing container types at this nesting level, which is\n\t\t * sufficient reason to give up entirely (but it should be the case\n\t\t * that they're both some container type).\n\t\t */\n\t\tAssert(rval == WJB_BEGIN_OBJECT || rval == WJB_BEGIN_ARRAY);\n\t\tAssert(rcont == WJB_BEGIN_OBJECT || rcont == WJB_BEGIN_ARRAY);\n\t\treturn false;\n\t}\n\telse if (rcont == WJB_BEGIN_OBJECT)\n\t{\n\t\tAssert(vval.type == jbvObject);\n\t\tAssert(vcontained.type == jbvObject);\n\n\t\t/*\n\t\t * If the lhs has fewer pairs than the rhs, it can't possibly contain\n\t\t * the rhs.  (This conclusion is safe only because we de-duplicate\n\t\t * keys in all Jsonb objects; thus there can be no corresponding\n\t\t * optimization in the array case.)  The case probably won't arise\n\t\t * often, but since it's such a cheap check we may as well make it.\n\t\t */\n\t\tif (vval.val.object.nPairs < vcontained.val.object.nPairs)\n\t\t\treturn false;\n\n\t\t/* Work through rhs \"is it contained within?\" object */\n\t\tfor (;;)\n\t\t{\n\t\t\tJsonbValue *lhsVal; /* lhsVal is from pair in lhs object */\n\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, false);\n\n\t\t\t/*\n\t\t\t * When we get through caller's rhs \"is it contained within?\"\n\t\t\t * object without failing to find one of its values, it's\n\t\t\t * contained.\n\t\t\t */\n\t\t\tif (rcont == WJB_END_OBJECT)\n\t\t\t\treturn true;\n\n\t\t\tAssert(rcont == WJB_KEY);\n\n\t\t\t/* First, find value by key... */\n\t\t\tlhsVal = findJsonbValueFromContainer((*val)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t &vcontained);\n\n\t\t\tif (!lhsVal)\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * ...at this stage it is apparent that there is at least a key\n\t\t\t * match for this rhs pair.\n\t\t\t */\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, true);\n\n\t\t\tAssert(rcont == WJB_VALUE);\n\n\t\t\t/*\n\t\t\t * Compare rhs pair's value with lhs pair's value just found using\n\t\t\t * key\n\t\t\t */\n\t\t\tif (lhsVal->type != vcontained.type)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (IsAJsonbScalar(lhsVal))\n\t\t\t{\n\t\t\t\tif (!equalsJsonbScalarValue(lhsVal, &vcontained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Nested container value (object or array) */\n\t\t\t\tJsonbIterator *nestval,\n\t\t\t\t\t\t   *nestContained;\n\n\t\t\t\tAssert(lhsVal->type == jbvBinary);\n\t\t\t\tAssert(vcontained.type == jbvBinary);\n\n\t\t\t\tnestval = JsonbIteratorInit(lhsVal->val.binary.data);\n\t\t\t\tnestContained = JsonbIteratorInit(vcontained.val.binary.data);\n\n\t\t\t\t/*\n\t\t\t\t * Match \"value\" side of rhs datum object's pair recursively.\n\t\t\t\t * It's a nested structure.\n\t\t\t\t *\n\t\t\t\t * Note that nesting still has to \"match up\" at the right\n\t\t\t\t * nesting sub-levels.  However, there need only be zero or\n\t\t\t\t * more matching pairs (or elements) at each nesting level\n\t\t\t\t * (provided the *rhs* pairs/elements *all* match on each\n\t\t\t\t * level), which enables searching nested structures for a\n\t\t\t\t * single String or other primitive type sub-datum quite\n\t\t\t\t * effectively (provided the user constructed the rhs nested\n\t\t\t\t * structure such that we \"know where to look\").\n\t\t\t\t *\n\t\t\t\t * In other words, the mapping of container nodes in the rhs\n\t\t\t\t * \"vcontained\" Jsonb to internal nodes on the lhs is\n\t\t\t\t * injective, and parent-child edges on the rhs must be mapped\n\t\t\t\t * to parent-child edges on the lhs to satisfy the condition\n\t\t\t\t * of containment (plus of course the mapped nodes must be\n\t\t\t\t * equal).\n\t\t\t\t */\n\t\t\t\tif (!JsonbDeepContains(&nestval, &nestContained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse if (rcont == WJB_BEGIN_ARRAY)\n\t{\n\t\tJsonbValue *lhsConts = NULL;\n\t\tuint32\t\tnLhsElems = vval.val.array.nElems;\n\n\t\tAssert(vval.type == jbvArray);\n\t\tAssert(vcontained.type == jbvArray);\n\n\t\t/*\n\t\t * Handle distinction between \"raw scalar\" pseudo arrays, and real\n\t\t * arrays.\n\t\t *\n\t\t * A raw scalar may contain another raw scalar, and an array may\n\t\t * contain a raw scalar, but a raw scalar may not contain an array. We\n\t\t * don't do something like this for the object case, since objects can\n\t\t * only contain pairs, never raw scalars (a pair is represented by an\n\t\t * rhs object argument with a single contained pair).\n\t\t */\n\t\tif (vval.val.array.rawScalar && !vcontained.val.array.rawScalar)\n\t\t\treturn false;\n\n\t\t/* Work through rhs \"is it contained within?\" array */\n\t\tfor (;;)\n\t\t{\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, true);\n\n\t\t\t/*\n\t\t\t * When we get through caller's rhs \"is it contained within?\"\n\t\t\t * array without failing to find one of its values, it's\n\t\t\t * contained.\n\t\t\t */\n\t\t\tif (rcont == WJB_END_ARRAY)\n\t\t\t\treturn true;\n\n\t\t\tAssert(rcont == WJB_ELEM);\n\n\t\t\tif (IsAJsonbScalar(&vcontained))\n\t\t\t{\n\t\t\t\tif (!findJsonbValueFromContainer((*val)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t JB_FARRAY,\n\t\t\t\t\t\t\t\t\t\t\t\t &vcontained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuint32\t\ti;\n\n\t\t\t\t/*\n\t\t\t\t * If this is first container found in rhs array (at this\n\t\t\t\t * depth), initialize temp lhs array of containers\n\t\t\t\t */\n\t\t\t\tif (lhsConts == NULL)\n\t\t\t\t{\n\t\t\t\t\tuint32\t\tj = 0;\n\n\t\t\t\t\t/* Make room for all possible values */\n\t\t\t\t\tlhsConts = palloc(sizeof(JsonbValue) * nLhsElems);\n\n\t\t\t\t\tfor (i = 0; i < nLhsElems; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Store all lhs elements in temp array */\n\t\t\t\t\t\trcont = JsonbIteratorNext(val, &vval, true);\n\t\t\t\t\t\tAssert(rcont == WJB_ELEM);\n\n\t\t\t\t\t\tif (vval.type == jbvBinary)\n\t\t\t\t\t\t\tlhsConts[j++] = vval;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* No container elements in temp array, so give up now */\n\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t/* We may have only partially filled array */\n\t\t\t\t\tnLhsElems = j;\n\t\t\t\t}\n\n\t\t\t\t/* XXX: Nested array containment is O(N^2) */\n\t\t\t\tfor (i = 0; i < nLhsElems; i++)\n\t\t\t\t{\n\t\t\t\t\t/* Nested container value (object or array) */\n\t\t\t\t\tJsonbIterator *nestval,\n\t\t\t\t\t\t\t   *nestContained;\n\t\t\t\t\tbool\t\tcontains;\n\n\t\t\t\t\tnestval = JsonbIteratorInit(lhsConts[i].val.binary.data);\n\t\t\t\t\tnestContained = JsonbIteratorInit(vcontained.val.binary.data);\n\n\t\t\t\t\tcontains = JsonbDeepContains(&nestval, &nestContained);\n\n\t\t\t\t\tif (nestval)\n\t\t\t\t\t\tpfree(nestval);\n\t\t\t\t\tif (nestContained)\n\t\t\t\t\t\tpfree(nestContained);\n\t\t\t\t\tif (contains)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Report rhs container value is not contained if couldn't\n\t\t\t\t * match rhs container to *some* lhs cont\n\t\t\t\t */\n\t\t\t\tif (i == nLhsElems)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"invalid jsonb container type\");\n\t}\n\n\telog(ERROR, \"unexpectedly fell off end of jsonb container\");\n\treturn false;\n}"
  },
  {
    "function_name": "freeAndGetParent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "941-948",
    "snippet": "static JsonbIterator *\nfreeAndGetParent(JsonbIterator *it)\n{\n\tJsonbIterator *v = it->parent;\n\n\tpfree(it);\n\treturn v;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
      "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "it"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nstatic JsonbIterator *\nfreeAndGetParent(JsonbIterator *it)\n{\n\tJsonbIterator *v = it->parent;\n\n\tpfree(it);\n\treturn v;\n}"
  },
  {
    "function_name": "iteratorFromContainer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "899-935",
    "snippet": "static JsonbIterator *\niteratorFromContainer(JsonbContainer *container, JsonbIterator *parent)\n{\n\tJsonbIterator *it;\n\n\tit = palloc0(sizeof(JsonbIterator));\n\tit->container = container;\n\tit->parent = parent;\n\tit->nElems = JsonContainerSize(container);\n\n\t/* Array starts just after header */\n\tit->children = container->children;\n\n\tswitch (container->header & (JB_FARRAY | JB_FOBJECT))\n\t{\n\t\tcase JB_FARRAY:\n\t\t\tit->dataProper =\n\t\t\t\t(char *) it->children + it->nElems * sizeof(JEntry);\n\t\t\tit->isScalar = JsonContainerIsScalar(container);\n\t\t\t/* This is either a \"raw scalar\", or an array */\n\t\t\tAssert(!it->isScalar || it->nElems == 1);\n\n\t\t\tit->state = JBI_ARRAY_START;\n\t\t\tbreak;\n\n\t\tcase JB_FOBJECT:\n\t\t\tit->dataProper =\n\t\t\t\t(char *) it->children + it->nElems * sizeof(JEntry) * 2;\n\t\t\tit->state = JBI_OBJECT_START;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown type of jsonb container\");\n\t}\n\n\treturn it;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
      "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unknown type of jsonb container\""
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!it->isScalar || it->nElems == 1"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonContainerIsScalar",
          "args": [
            "container"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonContainerSize",
          "args": [
            "container"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(JsonbIterator)"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nstatic JsonbIterator *\niteratorFromContainer(JsonbContainer *container, JsonbIterator *parent)\n{\n\tJsonbIterator *it;\n\n\tit = palloc0(sizeof(JsonbIterator));\n\tit->container = container;\n\tit->parent = parent;\n\tit->nElems = JsonContainerSize(container);\n\n\t/* Array starts just after header */\n\tit->children = container->children;\n\n\tswitch (container->header & (JB_FARRAY | JB_FOBJECT))\n\t{\n\t\tcase JB_FARRAY:\n\t\t\tit->dataProper =\n\t\t\t\t(char *) it->children + it->nElems * sizeof(JEntry);\n\t\t\tit->isScalar = JsonContainerIsScalar(container);\n\t\t\t/* This is either a \"raw scalar\", or an array */\n\t\t\tAssert(!it->isScalar || it->nElems == 1);\n\n\t\t\tit->state = JBI_ARRAY_START;\n\t\t\tbreak;\n\n\t\tcase JB_FOBJECT:\n\t\t\tit->dataProper =\n\t\t\t\t(char *) it->children + it->nElems * sizeof(JEntry) * 2;\n\t\t\tit->state = JBI_OBJECT_START;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown type of jsonb container\");\n\t}\n\n\treturn it;\n}"
  },
  {
    "function_name": "JsonbIteratorNext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "753-894",
    "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
      "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
      "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
      "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
      "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
      "static void uniqueifyJsonbObject(JsonbValue *object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid iterator state\""
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iteratorFromContainer",
          "args": [
            "val->val.binary.data",
            "*it"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "iteratorFromContainer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "899-935",
          "snippet": "static JsonbIterator *\niteratorFromContainer(JsonbContainer *container, JsonbIterator *parent)\n{\n\tJsonbIterator *it;\n\n\tit = palloc0(sizeof(JsonbIterator));\n\tit->container = container;\n\tit->parent = parent;\n\tit->nElems = JsonContainerSize(container);\n\n\t/* Array starts just after header */\n\tit->children = container->children;\n\n\tswitch (container->header & (JB_FARRAY | JB_FOBJECT))\n\t{\n\t\tcase JB_FARRAY:\n\t\t\tit->dataProper =\n\t\t\t\t(char *) it->children + it->nElems * sizeof(JEntry);\n\t\t\tit->isScalar = JsonContainerIsScalar(container);\n\t\t\t/* This is either a \"raw scalar\", or an array */\n\t\t\tAssert(!it->isScalar || it->nElems == 1);\n\n\t\t\tit->state = JBI_ARRAY_START;\n\t\t\tbreak;\n\n\t\tcase JB_FOBJECT:\n\t\t\tit->dataProper =\n\t\t\t\t(char *) it->children + it->nElems * sizeof(JEntry) * 2;\n\t\t\tit->state = JBI_OBJECT_START;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown type of jsonb container\");\n\t}\n\n\treturn it;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nstatic JsonbIterator *\niteratorFromContainer(JsonbContainer *container, JsonbIterator *parent)\n{\n\tJsonbIterator *it;\n\n\tit = palloc0(sizeof(JsonbIterator));\n\tit->container = container;\n\tit->parent = parent;\n\tit->nElems = JsonContainerSize(container);\n\n\t/* Array starts just after header */\n\tit->children = container->children;\n\n\tswitch (container->header & (JB_FARRAY | JB_FOBJECT))\n\t{\n\t\tcase JB_FARRAY:\n\t\t\tit->dataProper =\n\t\t\t\t(char *) it->children + it->nElems * sizeof(JEntry);\n\t\t\tit->isScalar = JsonContainerIsScalar(container);\n\t\t\t/* This is either a \"raw scalar\", or an array */\n\t\t\tAssert(!it->isScalar || it->nElems == 1);\n\n\t\t\tit->state = JBI_ARRAY_START;\n\t\t\tbreak;\n\n\t\tcase JB_FOBJECT:\n\t\t\tit->dataProper =\n\t\t\t\t(char *) it->children + it->nElems * sizeof(JEntry) * 2;\n\t\t\tit->state = JBI_OBJECT_START;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown type of jsonb container\");\n\t}\n\n\treturn it;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsAJsonbScalar",
          "args": [
            "val"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBE_ADVANCE_OFFSET",
          "args": [
            "(*it)->curValueOffset",
            "(*it)->children[(*it)->curIndex + (*it)->nElems]"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBE_ADVANCE_OFFSET",
          "args": [
            "(*it)->curDataOffset",
            "(*it)->children[(*it)->curIndex]"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fillJsonbValue",
          "args": [
            "(*it)->container",
            "(*it)->curIndex + (*it)->nElems",
            "(*it)->dataProper",
            "(*it)->curValueOffset",
            "val"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "fillJsonbValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "455-497",
          "snippet": "static void\nfillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result)\n{\n\tJEntry\t\tentry = container->children[index];\n\n\tif (JBE_ISNULL(entry))\n\t{\n\t\tresult->type = jbvNull;\n\t}\n\telse if (JBE_ISSTRING(entry))\n\t{\n\t\tresult->type = jbvString;\n\t\tresult->val.string.val = base_addr + offset;\n\t\tresult->val.string.len = getJsonbLength(container, index);\n\t\tAssert(result->val.string.len >= 0);\n\t}\n\telse if (JBE_ISNUMERIC(entry))\n\t{\n\t\tresult->type = jbvNumeric;\n\t\tresult->val.numeric = (Numeric) (base_addr + INTALIGN(offset));\n\t}\n\telse if (JBE_ISBOOL_TRUE(entry))\n\t{\n\t\tresult->type = jbvBool;\n\t\tresult->val.boolean = true;\n\t}\n\telse if (JBE_ISBOOL_FALSE(entry))\n\t{\n\t\tresult->type = jbvBool;\n\t\tresult->val.boolean = false;\n\t}\n\telse\n\t{\n\t\tAssert(JBE_ISCONTAINER(entry));\n\t\tresult->type = jbvBinary;\n\t\t/* Remove alignment padding from data pointer and length */\n\t\tresult->val.binary.data = (JsonbContainer *) (base_addr + INTALIGN(offset));\n\t\tresult->val.binary.len = getJsonbLength(container, index) -\n\t\t\t(INTALIGN(offset) - offset);\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\n\nstatic void\nfillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result)\n{\n\tJEntry\t\tentry = container->children[index];\n\n\tif (JBE_ISNULL(entry))\n\t{\n\t\tresult->type = jbvNull;\n\t}\n\telse if (JBE_ISSTRING(entry))\n\t{\n\t\tresult->type = jbvString;\n\t\tresult->val.string.val = base_addr + offset;\n\t\tresult->val.string.len = getJsonbLength(container, index);\n\t\tAssert(result->val.string.len >= 0);\n\t}\n\telse if (JBE_ISNUMERIC(entry))\n\t{\n\t\tresult->type = jbvNumeric;\n\t\tresult->val.numeric = (Numeric) (base_addr + INTALIGN(offset));\n\t}\n\telse if (JBE_ISBOOL_TRUE(entry))\n\t{\n\t\tresult->type = jbvBool;\n\t\tresult->val.boolean = true;\n\t}\n\telse if (JBE_ISBOOL_FALSE(entry))\n\t{\n\t\tresult->type = jbvBool;\n\t\tresult->val.boolean = false;\n\t}\n\telse\n\t{\n\t\tAssert(JBE_ISCONTAINER(entry));\n\t\tresult->type = jbvBinary;\n\t\t/* Remove alignment padding from data pointer and length */\n\t\tresult->val.binary.data = (JsonbContainer *) (base_addr + INTALIGN(offset));\n\t\tresult->val.binary.len = getJsonbLength(container, index) -\n\t\t\t(INTALIGN(offset) - offset);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeAndGetParent",
          "args": [
            "*it"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "freeAndGetParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "941-948",
          "snippet": "static JsonbIterator *\nfreeAndGetParent(JsonbIterator *it)\n{\n\tJsonbIterator *v = it->parent;\n\n\tpfree(it);\n\treturn v;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nstatic JsonbIterator *\nfreeAndGetParent(JsonbIterator *it)\n{\n\tJsonbIterator *v = it->parent;\n\n\tpfree(it);\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getJsonbOffset",
          "args": [
            "(*it)->container",
            "(*it)->nElems"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "getJsonbOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "120-139",
          "snippet": "uint32\ngetJsonbOffset(const JsonbContainer *jc, int index)\n{\n\tuint32\t\toffset = 0;\n\tint\t\t\ti;\n\n\t/*\n\t * Start offset of this entry is equal to the end offset of the previous\n\t * entry.  Walk backwards to the most recent entry stored as an end\n\t * offset, returning that offset plus any lengths in between.\n\t */\n\tfor (i = index - 1; i >= 0; i--)\n\t{\n\t\toffset += JBE_OFFLENFLD(jc->children[i]);\n\t\tif (JBE_HAS_OFF(jc->children[i]))\n\t\t\tbreak;\n\t}\n\n\treturn offset;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nuint32\ngetJsonbOffset(const JsonbContainer *jc, int index)\n{\n\tuint32\t\toffset = 0;\n\tint\t\t\ti;\n\n\t/*\n\t * Start offset of this entry is equal to the end offset of the previous\n\t * entry.  Walk backwards to the most recent entry stored as an end\n\t * offset, returning that offset plus any lengths in between.\n\t */\n\tfor (i = index - 1; i >= 0; i--)\n\t{\n\t\toffset += JBE_OFFLENFLD(jc->children[i]);\n\t\tif (JBE_HAS_OFF(jc->children[i]))\n\t\t\tbreak;\n\t}\n\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsAJsonbScalar",
          "args": [
            "val"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBE_ADVANCE_OFFSET",
          "args": [
            "(*it)->curDataOffset",
            "(*it)->children[(*it)->curIndex]"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
  },
  {
    "function_name": "JsonbIteratorInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "717-721",
    "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iteratorFromContainer",
          "args": [
            "container",
            "NULL"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "iteratorFromContainer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "899-935",
          "snippet": "static JsonbIterator *\niteratorFromContainer(JsonbContainer *container, JsonbIterator *parent)\n{\n\tJsonbIterator *it;\n\n\tit = palloc0(sizeof(JsonbIterator));\n\tit->container = container;\n\tit->parent = parent;\n\tit->nElems = JsonContainerSize(container);\n\n\t/* Array starts just after header */\n\tit->children = container->children;\n\n\tswitch (container->header & (JB_FARRAY | JB_FOBJECT))\n\t{\n\t\tcase JB_FARRAY:\n\t\t\tit->dataProper =\n\t\t\t\t(char *) it->children + it->nElems * sizeof(JEntry);\n\t\t\tit->isScalar = JsonContainerIsScalar(container);\n\t\t\t/* This is either a \"raw scalar\", or an array */\n\t\t\tAssert(!it->isScalar || it->nElems == 1);\n\n\t\t\tit->state = JBI_ARRAY_START;\n\t\t\tbreak;\n\n\t\tcase JB_FOBJECT:\n\t\t\tit->dataProper =\n\t\t\t\t(char *) it->children + it->nElems * sizeof(JEntry) * 2;\n\t\t\tit->state = JBI_OBJECT_START;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown type of jsonb container\");\n\t}\n\n\treturn it;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nstatic JsonbIterator *\niteratorFromContainer(JsonbContainer *container, JsonbIterator *parent)\n{\n\tJsonbIterator *it;\n\n\tit = palloc0(sizeof(JsonbIterator));\n\tit->container = container;\n\tit->parent = parent;\n\tit->nElems = JsonContainerSize(container);\n\n\t/* Array starts just after header */\n\tit->children = container->children;\n\n\tswitch (container->header & (JB_FARRAY | JB_FOBJECT))\n\t{\n\t\tcase JB_FARRAY:\n\t\t\tit->dataProper =\n\t\t\t\t(char *) it->children + it->nElems * sizeof(JEntry);\n\t\t\tit->isScalar = JsonContainerIsScalar(container);\n\t\t\t/* This is either a \"raw scalar\", or an array */\n\t\t\tAssert(!it->isScalar || it->nElems == 1);\n\n\t\t\tit->state = JBI_ARRAY_START;\n\t\t\tbreak;\n\n\t\tcase JB_FOBJECT:\n\t\t\tit->dataProper =\n\t\t\t\t(char *) it->children + it->nElems * sizeof(JEntry) * 2;\n\t\t\tit->state = JBI_OBJECT_START;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown type of jsonb container\");\n\t}\n\n\treturn it;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
  },
  {
    "function_name": "appendElement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "688-709",
    "snippet": "static void\nappendElement(JsonbParseState *pstate, JsonbValue *scalarVal)\n{\n\tJsonbValue *array = &pstate->contVal;\n\n\tAssert(array->type == jbvArray);\n\n\tif (array->val.array.nElems >= JSONB_MAX_ELEMS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of jsonb array elements exceeds the maximum allowed (%zu)\",\n\t\t\t\t\t\tJSONB_MAX_ELEMS)));\n\n\tif (array->val.array.nElems >= pstate->size)\n\t{\n\t\tpstate->size *= 2;\n\t\tarray->val.array.elems = repalloc(array->val.array.elems,\n\t\t\t\t\t\t\t\t\t\t  sizeof(JsonbValue) * pstate->size);\n\t}\n\n\tarray->val.array.elems[array->val.array.nElems++] = *scalarVal;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define JSONB_MAX_ELEMS (Min(MaxAllocSize / sizeof(JsonbValue), JB_CMASK))"
    ],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
      "static JsonbParseState *pushState(JsonbParseState **pstate);",
      "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "array->val.array.elems",
            "sizeof(JsonbValue) * pstate->size"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of jsonb array elements exceeds the maximum allowed (%zu)\",\n\t\t\t\t\t\tJSONB_MAX_ELEMS))"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"number of jsonb array elements exceeds the maximum allowed (%zu)\"",
            "JSONB_MAX_ELEMS"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "array->type == jbvArray"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define JSONB_MAX_ELEMS (Min(MaxAllocSize / sizeof(JsonbValue), JB_CMASK))\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic void\nappendElement(JsonbParseState *pstate, JsonbValue *scalarVal)\n{\n\tJsonbValue *array = &pstate->contVal;\n\n\tAssert(array->type == jbvArray);\n\n\tif (array->val.array.nElems >= JSONB_MAX_ELEMS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of jsonb array elements exceeds the maximum allowed (%zu)\",\n\t\t\t\t\t\tJSONB_MAX_ELEMS)));\n\n\tif (array->val.array.nElems >= pstate->size)\n\t{\n\t\tpstate->size *= 2;\n\t\tarray->val.array.elems = repalloc(array->val.array.elems,\n\t\t\t\t\t\t\t\t\t\t  sizeof(JsonbValue) * pstate->size);\n\t}\n\n\tarray->val.array.elems[array->val.array.nElems++] = *scalarVal;\n}"
  },
  {
    "function_name": "appendValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "675-683",
    "snippet": "static void\nappendValue(JsonbParseState *pstate, JsonbValue *scalarVal)\n{\n\tJsonbValue *object = &pstate->contVal;\n\n\tAssert(object->type == jbvObject);\n\n\tobject->val.object.pairs[object->val.object.nPairs++].value = *scalarVal;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
      "static JsonbParseState *pushState(JsonbParseState **pstate);",
      "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static void uniqueifyJsonbObject(JsonbValue *object);",
      "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "object->type == jbvObject"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic void\nappendValue(JsonbParseState *pstate, JsonbValue *scalarVal)\n{\n\tJsonbValue *object = &pstate->contVal;\n\n\tAssert(object->type == jbvObject);\n\n\tobject->val.object.pairs[object->val.object.nPairs++].value = *scalarVal;\n}"
  },
  {
    "function_name": "appendKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "646-669",
    "snippet": "static void\nappendKey(JsonbParseState *pstate, JsonbValue *string)\n{\n\tJsonbValue *object = &pstate->contVal;\n\n\tAssert(object->type == jbvObject);\n\tAssert(string->type == jbvString);\n\n\tif (object->val.object.nPairs >= JSONB_MAX_PAIRS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of jsonb object pairs exceeds the maximum allowed (%zu)\",\n\t\t\t\t\t\tJSONB_MAX_PAIRS)));\n\n\tif (object->val.object.nPairs >= pstate->size)\n\t{\n\t\tpstate->size *= 2;\n\t\tobject->val.object.pairs = repalloc(object->val.object.pairs,\n\t\t\t\t\t\t\t\t\t\t\tsizeof(JsonbPair) * pstate->size);\n\t}\n\n\tobject->val.object.pairs[object->val.object.nPairs].key = *string;\n\tobject->val.object.pairs[object->val.object.nPairs].order = object->val.object.nPairs;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define JSONB_MAX_PAIRS (Min(MaxAllocSize / sizeof(JsonbPair), JB_CMASK))"
    ],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static JsonbParseState *pushState(JsonbParseState **pstate);",
      "static void uniqueifyJsonbObject(JsonbValue *object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "object->val.object.pairs",
            "sizeof(JsonbPair) * pstate->size"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of jsonb object pairs exceeds the maximum allowed (%zu)\",\n\t\t\t\t\t\tJSONB_MAX_PAIRS))"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"number of jsonb object pairs exceeds the maximum allowed (%zu)\"",
            "JSONB_MAX_PAIRS"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "string->type == jbvString"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "object->type == jbvObject"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define JSONB_MAX_PAIRS (Min(MaxAllocSize / sizeof(JsonbPair), JB_CMASK))\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nstatic void\nappendKey(JsonbParseState *pstate, JsonbValue *string)\n{\n\tJsonbValue *object = &pstate->contVal;\n\n\tAssert(object->type == jbvObject);\n\tAssert(string->type == jbvString);\n\n\tif (object->val.object.nPairs >= JSONB_MAX_PAIRS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of jsonb object pairs exceeds the maximum allowed (%zu)\",\n\t\t\t\t\t\tJSONB_MAX_PAIRS)));\n\n\tif (object->val.object.nPairs >= pstate->size)\n\t{\n\t\tpstate->size *= 2;\n\t\tobject->val.object.pairs = repalloc(object->val.object.pairs,\n\t\t\t\t\t\t\t\t\t\t\tsizeof(JsonbPair) * pstate->size);\n\t}\n\n\tobject->val.object.pairs[object->val.object.nPairs].key = *string;\n\tobject->val.object.pairs[object->val.object.nPairs].order = object->val.object.nPairs;\n}"
  },
  {
    "function_name": "pushState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "634-641",
    "snippet": "static JsonbParseState *\npushState(JsonbParseState **pstate)\n{\n\tJsonbParseState *ns = palloc(sizeof(JsonbParseState));\n\n\tns->next = *pstate;\n\treturn ns;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static JsonbParseState *pushState(JsonbParseState **pstate);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(JsonbParseState)"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nstatic JsonbParseState *\npushState(JsonbParseState **pstate)\n{\n\tJsonbParseState *ns = palloc(sizeof(JsonbParseState));\n\n\tns->next = *pstate;\n\treturn ns;\n}"
  },
  {
    "function_name": "pushJsonbValueScalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "545-629",
    "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
      "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
      "static JsonbParseState *pushState(JsonbParseState **pstate);",
      "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
      "static void uniqueifyJsonbObject(JsonbValue *object);",
      "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized jsonb sequential processing token\""
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendValue",
          "args": [
            "*pstate",
            "result"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "appendValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "675-683",
          "snippet": "static void\nappendValue(JsonbParseState *pstate, JsonbValue *scalarVal)\n{\n\tJsonbValue *object = &pstate->contVal;\n\n\tAssert(object->type == jbvObject);\n\n\tobject->val.object.pairs[object->val.object.nPairs++].value = *scalarVal;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic void\nappendValue(JsonbParseState *pstate, JsonbValue *scalarVal)\n{\n\tJsonbValue *object = &pstate->contVal;\n\n\tAssert(object->type == jbvObject);\n\n\tobject->val.object.pairs[object->val.object.nPairs++].value = *scalarVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendElement",
          "args": [
            "*pstate",
            "result"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "appendElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "688-709",
          "snippet": "static void\nappendElement(JsonbParseState *pstate, JsonbValue *scalarVal)\n{\n\tJsonbValue *array = &pstate->contVal;\n\n\tAssert(array->type == jbvArray);\n\n\tif (array->val.array.nElems >= JSONB_MAX_ELEMS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of jsonb array elements exceeds the maximum allowed (%zu)\",\n\t\t\t\t\t\tJSONB_MAX_ELEMS)));\n\n\tif (array->val.array.nElems >= pstate->size)\n\t{\n\t\tpstate->size *= 2;\n\t\tarray->val.array.elems = repalloc(array->val.array.elems,\n\t\t\t\t\t\t\t\t\t\t  sizeof(JsonbValue) * pstate->size);\n\t}\n\n\tarray->val.array.elems[array->val.array.nElems++] = *scalarVal;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define JSONB_MAX_ELEMS (Min(MaxAllocSize / sizeof(JsonbValue), JB_CMASK))"
          ],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define JSONB_MAX_ELEMS (Min(MaxAllocSize / sizeof(JsonbValue), JB_CMASK))\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic void\nappendElement(JsonbParseState *pstate, JsonbValue *scalarVal)\n{\n\tJsonbValue *array = &pstate->contVal;\n\n\tAssert(array->type == jbvArray);\n\n\tif (array->val.array.nElems >= JSONB_MAX_ELEMS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of jsonb array elements exceeds the maximum allowed (%zu)\",\n\t\t\t\t\t\tJSONB_MAX_ELEMS)));\n\n\tif (array->val.array.nElems >= pstate->size)\n\t{\n\t\tpstate->size *= 2;\n\t\tarray->val.array.elems = repalloc(array->val.array.elems,\n\t\t\t\t\t\t\t\t\t\t  sizeof(JsonbValue) * pstate->size);\n\t}\n\n\tarray->val.array.elems[array->val.array.nElems++] = *scalarVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!scalarVal"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uniqueifyJsonbObject",
          "args": [
            "&(*pstate)->contVal"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "uniqueifyJsonbObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1818-1848",
          "snippet": "static void\nuniqueifyJsonbObject(JsonbValue *object)\n{\n\tbool\t\thasNonUniq = false;\n\n\tAssert(object->type == jbvObject);\n\n\tif (object->val.object.nPairs > 1)\n\t\tqsort_arg(object->val.object.pairs, object->val.object.nPairs, sizeof(JsonbPair),\n\t\t\t\t  lengthCompareJsonbPair, &hasNonUniq);\n\n\tif (hasNonUniq)\n\t{\n\t\tJsonbPair  *ptr = object->val.object.pairs + 1,\n\t\t\t\t   *res = object->val.object.pairs;\n\n\t\twhile (ptr - object->val.object.pairs < object->val.object.nPairs)\n\t\t{\n\t\t\t/* Avoid copying over duplicate */\n\t\t\tif (lengthCompareJsonbStringValue(ptr, res) != 0)\n\t\t\t{\n\t\t\t\tres++;\n\t\t\t\tif (ptr != res)\n\t\t\t\t\tmemcpy(res, ptr, sizeof(JsonbPair));\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\n\t\tobject->val.object.nPairs = res + 1 - object->val.object.pairs;\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nstatic void\nuniqueifyJsonbObject(JsonbValue *object)\n{\n\tbool\t\thasNonUniq = false;\n\n\tAssert(object->type == jbvObject);\n\n\tif (object->val.object.nPairs > 1)\n\t\tqsort_arg(object->val.object.pairs, object->val.object.nPairs, sizeof(JsonbPair),\n\t\t\t\t  lengthCompareJsonbPair, &hasNonUniq);\n\n\tif (hasNonUniq)\n\t{\n\t\tJsonbPair  *ptr = object->val.object.pairs + 1,\n\t\t\t\t   *res = object->val.object.pairs;\n\n\t\twhile (ptr - object->val.object.pairs < object->val.object.nPairs)\n\t\t{\n\t\t\t/* Avoid copying over duplicate */\n\t\t\tif (lengthCompareJsonbStringValue(ptr, res) != 0)\n\t\t\t{\n\t\t\t\tres++;\n\t\t\t\tif (ptr != res)\n\t\t\t\t\tmemcpy(res, ptr, sizeof(JsonbPair));\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\n\t\tobject->val.object.nPairs = res + 1 - object->val.object.pairs;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "IsAJsonbScalar(scalarVal)"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAJsonbScalar",
          "args": [
            "scalarVal"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "IsAJsonbScalar(scalarVal)"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAJsonbScalar",
          "args": [
            "scalarVal"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendKey",
          "args": [
            "*pstate",
            "scalarVal"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "appendKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "646-669",
          "snippet": "static void\nappendKey(JsonbParseState *pstate, JsonbValue *string)\n{\n\tJsonbValue *object = &pstate->contVal;\n\n\tAssert(object->type == jbvObject);\n\tAssert(string->type == jbvString);\n\n\tif (object->val.object.nPairs >= JSONB_MAX_PAIRS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of jsonb object pairs exceeds the maximum allowed (%zu)\",\n\t\t\t\t\t\tJSONB_MAX_PAIRS)));\n\n\tif (object->val.object.nPairs >= pstate->size)\n\t{\n\t\tpstate->size *= 2;\n\t\tobject->val.object.pairs = repalloc(object->val.object.pairs,\n\t\t\t\t\t\t\t\t\t\t\tsizeof(JsonbPair) * pstate->size);\n\t}\n\n\tobject->val.object.pairs[object->val.object.nPairs].key = *string;\n\tobject->val.object.pairs[object->val.object.nPairs].order = object->val.object.nPairs;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define JSONB_MAX_PAIRS (Min(MaxAllocSize / sizeof(JsonbPair), JB_CMASK))"
          ],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define JSONB_MAX_PAIRS (Min(MaxAllocSize / sizeof(JsonbPair), JB_CMASK))\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nstatic void\nappendKey(JsonbParseState *pstate, JsonbValue *string)\n{\n\tJsonbValue *object = &pstate->contVal;\n\n\tAssert(object->type == jbvObject);\n\tAssert(string->type == jbvString);\n\n\tif (object->val.object.nPairs >= JSONB_MAX_PAIRS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of jsonb object pairs exceeds the maximum allowed (%zu)\",\n\t\t\t\t\t\tJSONB_MAX_PAIRS)));\n\n\tif (object->val.object.nPairs >= pstate->size)\n\t{\n\t\tpstate->size *= 2;\n\t\tobject->val.object.pairs = repalloc(object->val.object.pairs,\n\t\t\t\t\t\t\t\t\t\t\tsizeof(JsonbPair) * pstate->size);\n\t}\n\n\tobject->val.object.pairs[object->val.object.nPairs].key = *string;\n\tobject->val.object.pairs[object->val.object.nPairs].order = object->val.object.nPairs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "scalarVal->type == jbvString"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushState",
          "args": [
            "pstate"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "pushState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "634-641",
          "snippet": "static JsonbParseState *\npushState(JsonbParseState **pstate)\n{\n\tJsonbParseState *ns = palloc(sizeof(JsonbParseState));\n\n\tns->next = *pstate;\n\treturn ns;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nstatic JsonbParseState *\npushState(JsonbParseState **pstate)\n{\n\tJsonbParseState *ns = palloc(sizeof(JsonbParseState));\n\n\tns->next = *pstate;\n\treturn ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!scalarVal"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "scalarVal->type == jbvArray"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!scalarVal || scalarVal->val.array.rawScalar"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "pushJsonbValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "516-539",
    "snippet": "JsonbValue *\npushJsonbValue(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t   JsonbValue *jbval)\n{\n\tJsonbIterator *it;\n\tJsonbValue *res = NULL;\n\tJsonbValue\tv;\n\tJsonbIteratorToken tok;\n\n\tif (!jbval || (seq != WJB_ELEM && seq != WJB_VALUE) ||\n\t\tjbval->type != jbvBinary)\n\t{\n\t\t/* drop through */\n\t\treturn pushJsonbValueScalar(pstate, seq, jbval);\n\t}\n\n\t/* unpack the binary and add each piece to the pstate */\n\tit = JsonbIteratorInit(jbval->val.binary.data);\n\twhile ((tok = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t\tres = pushJsonbValueScalar(pstate, tok,\n\t\t\t\t\t\t\t\t   tok < WJB_BEGIN_ARRAY ? &v : NULL);\n\n\treturn res;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
      "static JsonbParseState *pushState(JsonbParseState **pstate);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pushJsonbValueScalar",
          "args": [
            "pstate",
            "tok",
            "tok < WJB_BEGIN_ARRAY ? &v : NULL"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "false"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "jbval->val.binary.data"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonbValue *\npushJsonbValue(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t   JsonbValue *jbval)\n{\n\tJsonbIterator *it;\n\tJsonbValue *res = NULL;\n\tJsonbValue\tv;\n\tJsonbIteratorToken tok;\n\n\tif (!jbval || (seq != WJB_ELEM && seq != WJB_VALUE) ||\n\t\tjbval->type != jbvBinary)\n\t{\n\t\t/* drop through */\n\t\treturn pushJsonbValueScalar(pstate, seq, jbval);\n\t}\n\n\t/* unpack the binary and add each piece to the pstate */\n\tit = JsonbIteratorInit(jbval->val.binary.data);\n\twhile ((tok = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t\tres = pushJsonbValueScalar(pstate, tok,\n\t\t\t\t\t\t\t\t   tok < WJB_BEGIN_ARRAY ? &v : NULL);\n\n\treturn res;\n}"
  },
  {
    "function_name": "fillJsonbValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "455-497",
    "snippet": "static void\nfillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result)\n{\n\tJEntry\t\tentry = container->children[index];\n\n\tif (JBE_ISNULL(entry))\n\t{\n\t\tresult->type = jbvNull;\n\t}\n\telse if (JBE_ISSTRING(entry))\n\t{\n\t\tresult->type = jbvString;\n\t\tresult->val.string.val = base_addr + offset;\n\t\tresult->val.string.len = getJsonbLength(container, index);\n\t\tAssert(result->val.string.len >= 0);\n\t}\n\telse if (JBE_ISNUMERIC(entry))\n\t{\n\t\tresult->type = jbvNumeric;\n\t\tresult->val.numeric = (Numeric) (base_addr + INTALIGN(offset));\n\t}\n\telse if (JBE_ISBOOL_TRUE(entry))\n\t{\n\t\tresult->type = jbvBool;\n\t\tresult->val.boolean = true;\n\t}\n\telse if (JBE_ISBOOL_FALSE(entry))\n\t{\n\t\tresult->type = jbvBool;\n\t\tresult->val.boolean = false;\n\t}\n\telse\n\t{\n\t\tAssert(JBE_ISCONTAINER(entry));\n\t\tresult->type = jbvBinary;\n\t\t/* Remove alignment padding from data pointer and length */\n\t\tresult->val.binary.data = (JsonbContainer *) (base_addr + INTALIGN(offset));\n\t\tresult->val.binary.len = getJsonbLength(container, index) -\n\t\t\t(INTALIGN(offset) - offset);\n\t}\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static int\treserveFromBuffer(StringInfo buffer, int len);",
      "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
      "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INTALIGN",
          "args": [
            "offset"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getJsonbLength",
          "args": [
            "container",
            "index"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "getJsonbLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "145-165",
          "snippet": "uint32\ngetJsonbLength(const JsonbContainer *jc, int index)\n{\n\tuint32\t\toff;\n\tuint32\t\tlen;\n\n\t/*\n\t * If the length is stored directly in the JEntry, just return it.\n\t * Otherwise, get the begin offset of the entry, and subtract that from\n\t * the stored end+1 offset.\n\t */\n\tif (JBE_HAS_OFF(jc->children[index]))\n\t{\n\t\toff = getJsonbOffset(jc, index);\n\t\tlen = JBE_OFFLENFLD(jc->children[index]) - off;\n\t}\n\telse\n\t\tlen = JBE_OFFLENFLD(jc->children[index]);\n\n\treturn len;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nuint32\ngetJsonbLength(const JsonbContainer *jc, int index)\n{\n\tuint32\t\toff;\n\tuint32\t\tlen;\n\n\t/*\n\t * If the length is stored directly in the JEntry, just return it.\n\t * Otherwise, get the begin offset of the entry, and subtract that from\n\t * the stored end+1 offset.\n\t */\n\tif (JBE_HAS_OFF(jc->children[index]))\n\t{\n\t\toff = getJsonbOffset(jc, index);\n\t\tlen = JBE_OFFLENFLD(jc->children[index]) - off;\n\t}\n\telse\n\t\tlen = JBE_OFFLENFLD(jc->children[index]);\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INTALIGN",
          "args": [
            "offset"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "JBE_ISCONTAINER(entry)"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBE_ISCONTAINER",
          "args": [
            "entry"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBE_ISBOOL_FALSE",
          "args": [
            "entry"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBE_ISBOOL_TRUE",
          "args": [
            "entry"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "base_addr + INTALIGN(offset)"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTALIGN",
          "args": [
            "offset"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBE_ISNUMERIC",
          "args": [
            "entry"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "result->val.string.len >= 0"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBE_ISSTRING",
          "args": [
            "entry"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBE_ISNULL",
          "args": [
            "entry"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\n\nstatic void\nfillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result)\n{\n\tJEntry\t\tentry = container->children[index];\n\n\tif (JBE_ISNULL(entry))\n\t{\n\t\tresult->type = jbvNull;\n\t}\n\telse if (JBE_ISSTRING(entry))\n\t{\n\t\tresult->type = jbvString;\n\t\tresult->val.string.val = base_addr + offset;\n\t\tresult->val.string.len = getJsonbLength(container, index);\n\t\tAssert(result->val.string.len >= 0);\n\t}\n\telse if (JBE_ISNUMERIC(entry))\n\t{\n\t\tresult->type = jbvNumeric;\n\t\tresult->val.numeric = (Numeric) (base_addr + INTALIGN(offset));\n\t}\n\telse if (JBE_ISBOOL_TRUE(entry))\n\t{\n\t\tresult->type = jbvBool;\n\t\tresult->val.boolean = true;\n\t}\n\telse if (JBE_ISBOOL_FALSE(entry))\n\t{\n\t\tresult->type = jbvBool;\n\t\tresult->val.boolean = false;\n\t}\n\telse\n\t{\n\t\tAssert(JBE_ISCONTAINER(entry));\n\t\tresult->type = jbvBinary;\n\t\t/* Remove alignment padding from data pointer and length */\n\t\tresult->val.binary.data = (JsonbContainer *) (base_addr + INTALIGN(offset));\n\t\tresult->val.binary.len = getJsonbLength(container, index) -\n\t\t\t(INTALIGN(offset) - offset);\n\t}\n}"
  },
  {
    "function_name": "getIthJsonbValueFromContainer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "418-441",
    "snippet": "JsonbValue *\ngetIthJsonbValueFromContainer(JsonbContainer *container, uint32 i)\n{\n\tJsonbValue *result;\n\tchar\t   *base_addr;\n\tuint32\t\tnelements;\n\n\tif (!JsonContainerIsArray(container))\n\t\telog(ERROR, \"not a jsonb array\");\n\n\tnelements = JsonContainerSize(container);\n\tbase_addr = (char *) &container->children[nelements];\n\n\tif (i >= nelements)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tfillJsonbValue(container, i, base_addr,\n\t\t\t\t   getJsonbOffset(container, i),\n\t\t\t\t   result);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fillJsonbValue",
          "args": [
            "container",
            "i",
            "base_addr",
            "getJsonbOffset(container, i)",
            "result"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "fillJsonbValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "455-497",
          "snippet": "static void\nfillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result)\n{\n\tJEntry\t\tentry = container->children[index];\n\n\tif (JBE_ISNULL(entry))\n\t{\n\t\tresult->type = jbvNull;\n\t}\n\telse if (JBE_ISSTRING(entry))\n\t{\n\t\tresult->type = jbvString;\n\t\tresult->val.string.val = base_addr + offset;\n\t\tresult->val.string.len = getJsonbLength(container, index);\n\t\tAssert(result->val.string.len >= 0);\n\t}\n\telse if (JBE_ISNUMERIC(entry))\n\t{\n\t\tresult->type = jbvNumeric;\n\t\tresult->val.numeric = (Numeric) (base_addr + INTALIGN(offset));\n\t}\n\telse if (JBE_ISBOOL_TRUE(entry))\n\t{\n\t\tresult->type = jbvBool;\n\t\tresult->val.boolean = true;\n\t}\n\telse if (JBE_ISBOOL_FALSE(entry))\n\t{\n\t\tresult->type = jbvBool;\n\t\tresult->val.boolean = false;\n\t}\n\telse\n\t{\n\t\tAssert(JBE_ISCONTAINER(entry));\n\t\tresult->type = jbvBinary;\n\t\t/* Remove alignment padding from data pointer and length */\n\t\tresult->val.binary.data = (JsonbContainer *) (base_addr + INTALIGN(offset));\n\t\tresult->val.binary.len = getJsonbLength(container, index) -\n\t\t\t(INTALIGN(offset) - offset);\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\n\nstatic void\nfillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result)\n{\n\tJEntry\t\tentry = container->children[index];\n\n\tif (JBE_ISNULL(entry))\n\t{\n\t\tresult->type = jbvNull;\n\t}\n\telse if (JBE_ISSTRING(entry))\n\t{\n\t\tresult->type = jbvString;\n\t\tresult->val.string.val = base_addr + offset;\n\t\tresult->val.string.len = getJsonbLength(container, index);\n\t\tAssert(result->val.string.len >= 0);\n\t}\n\telse if (JBE_ISNUMERIC(entry))\n\t{\n\t\tresult->type = jbvNumeric;\n\t\tresult->val.numeric = (Numeric) (base_addr + INTALIGN(offset));\n\t}\n\telse if (JBE_ISBOOL_TRUE(entry))\n\t{\n\t\tresult->type = jbvBool;\n\t\tresult->val.boolean = true;\n\t}\n\telse if (JBE_ISBOOL_FALSE(entry))\n\t{\n\t\tresult->type = jbvBool;\n\t\tresult->val.boolean = false;\n\t}\n\telse\n\t{\n\t\tAssert(JBE_ISCONTAINER(entry));\n\t\tresult->type = jbvBinary;\n\t\t/* Remove alignment padding from data pointer and length */\n\t\tresult->val.binary.data = (JsonbContainer *) (base_addr + INTALIGN(offset));\n\t\tresult->val.binary.len = getJsonbLength(container, index) -\n\t\t\t(INTALIGN(offset) - offset);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getJsonbOffset",
          "args": [
            "container",
            "i"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "getJsonbOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "120-139",
          "snippet": "uint32\ngetJsonbOffset(const JsonbContainer *jc, int index)\n{\n\tuint32\t\toffset = 0;\n\tint\t\t\ti;\n\n\t/*\n\t * Start offset of this entry is equal to the end offset of the previous\n\t * entry.  Walk backwards to the most recent entry stored as an end\n\t * offset, returning that offset plus any lengths in between.\n\t */\n\tfor (i = index - 1; i >= 0; i--)\n\t{\n\t\toffset += JBE_OFFLENFLD(jc->children[i]);\n\t\tif (JBE_HAS_OFF(jc->children[i]))\n\t\t\tbreak;\n\t}\n\n\treturn offset;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nuint32\ngetJsonbOffset(const JsonbContainer *jc, int index)\n{\n\tuint32\t\toffset = 0;\n\tint\t\t\ti;\n\n\t/*\n\t * Start offset of this entry is equal to the end offset of the previous\n\t * entry.  Walk backwards to the most recent entry stored as an end\n\t * offset, returning that offset plus any lengths in between.\n\t */\n\tfor (i = index - 1; i >= 0; i--)\n\t{\n\t\toffset += JBE_OFFLENFLD(jc->children[i]);\n\t\tif (JBE_HAS_OFF(jc->children[i]))\n\t\t\tbreak;\n\t}\n\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(JsonbValue)"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonContainerSize",
          "args": [
            "container"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"not a jsonb array\""
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonContainerIsArray",
          "args": [
            "container"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\n\nJsonbValue *\ngetIthJsonbValueFromContainer(JsonbContainer *container, uint32 i)\n{\n\tJsonbValue *result;\n\tchar\t   *base_addr;\n\tuint32\t\tnelements;\n\n\tif (!JsonContainerIsArray(container))\n\t\telog(ERROR, \"not a jsonb array\");\n\n\tnelements = JsonContainerSize(container);\n\tbase_addr = (char *) &container->children[nelements];\n\n\tif (i >= nelements)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tfillJsonbValue(container, i, base_addr,\n\t\t\t\t   getJsonbOffset(container, i),\n\t\t\t\t   result);\n\n\treturn result;\n}"
  },
  {
    "function_name": "findJsonbValueFromContainer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "326-411",
    "snippet": "JsonbValue *\nfindJsonbValueFromContainer(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\tJsonbValue *key)\n{\n\tJEntry\t   *children = container->children;\n\tint\t\t\tcount = JsonContainerSize(container);\n\tJsonbValue *result;\n\n\tAssert((flags & ~(JB_FARRAY | JB_FOBJECT)) == 0);\n\n\t/* Quick out without a palloc cycle if object/array is empty */\n\tif (count <= 0)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tif ((flags & JB_FARRAY) && JsonContainerIsArray(container))\n\t{\n\t\tchar\t   *base_addr = (char *) (children + count);\n\t\tuint32\t\toffset = 0;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tfillJsonbValue(container, i, base_addr, offset, result);\n\n\t\t\tif (key->type == result->type)\n\t\t\t{\n\t\t\t\tif (equalsJsonbScalarValue(key, result))\n\t\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tJBE_ADVANCE_OFFSET(offset, children[i]);\n\t\t}\n\t}\n\telse if ((flags & JB_FOBJECT) && JsonContainerIsObject(container))\n\t{\n\t\t/* Since this is an object, account for *Pairs* of Jentrys */\n\t\tchar\t   *base_addr = (char *) (children + count * 2);\n\t\tuint32\t\tstopLow = 0,\n\t\t\t\t\tstopHigh = count;\n\n\t\t/* Object key passed by caller must be a string */\n\t\tAssert(key->type == jbvString);\n\n\t\t/* Binary search on object/pair keys *only* */\n\t\twhile (stopLow < stopHigh)\n\t\t{\n\t\t\tuint32\t\tstopMiddle;\n\t\t\tint\t\t\tdifference;\n\t\t\tJsonbValue\tcandidate;\n\n\t\t\tstopMiddle = stopLow + (stopHigh - stopLow) / 2;\n\n\t\t\tcandidate.type = jbvString;\n\t\t\tcandidate.val.string.val =\n\t\t\t\tbase_addr + getJsonbOffset(container, stopMiddle);\n\t\t\tcandidate.val.string.len = getJsonbLength(container, stopMiddle);\n\n\t\t\tdifference = lengthCompareJsonbStringValue(&candidate, key);\n\n\t\t\tif (difference == 0)\n\t\t\t{\n\t\t\t\t/* Found our key, return corresponding value */\n\t\t\t\tint\t\t\tindex = stopMiddle + count;\n\n\t\t\t\tfillJsonbValue(container, index, base_addr,\n\t\t\t\t\t\t\t   getJsonbOffset(container, index),\n\t\t\t\t\t\t\t   result);\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (difference < 0)\n\t\t\t\t\tstopLow = stopMiddle + 1;\n\t\t\t\telse\n\t\t\t\t\tstopHigh = stopMiddle;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Not found */\n\tpfree(result);\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static int\treserveFromBuffer(StringInfo buffer, int len);",
      "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
      "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
      "static void uniqueifyJsonbObject(JsonbValue *object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "result"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fillJsonbValue",
          "args": [
            "container",
            "index",
            "base_addr",
            "getJsonbOffset(container, index)",
            "result"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "fillJsonbValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "455-497",
          "snippet": "static void\nfillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result)\n{\n\tJEntry\t\tentry = container->children[index];\n\n\tif (JBE_ISNULL(entry))\n\t{\n\t\tresult->type = jbvNull;\n\t}\n\telse if (JBE_ISSTRING(entry))\n\t{\n\t\tresult->type = jbvString;\n\t\tresult->val.string.val = base_addr + offset;\n\t\tresult->val.string.len = getJsonbLength(container, index);\n\t\tAssert(result->val.string.len >= 0);\n\t}\n\telse if (JBE_ISNUMERIC(entry))\n\t{\n\t\tresult->type = jbvNumeric;\n\t\tresult->val.numeric = (Numeric) (base_addr + INTALIGN(offset));\n\t}\n\telse if (JBE_ISBOOL_TRUE(entry))\n\t{\n\t\tresult->type = jbvBool;\n\t\tresult->val.boolean = true;\n\t}\n\telse if (JBE_ISBOOL_FALSE(entry))\n\t{\n\t\tresult->type = jbvBool;\n\t\tresult->val.boolean = false;\n\t}\n\telse\n\t{\n\t\tAssert(JBE_ISCONTAINER(entry));\n\t\tresult->type = jbvBinary;\n\t\t/* Remove alignment padding from data pointer and length */\n\t\tresult->val.binary.data = (JsonbContainer *) (base_addr + INTALIGN(offset));\n\t\tresult->val.binary.len = getJsonbLength(container, index) -\n\t\t\t(INTALIGN(offset) - offset);\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\n\nstatic void\nfillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result)\n{\n\tJEntry\t\tentry = container->children[index];\n\n\tif (JBE_ISNULL(entry))\n\t{\n\t\tresult->type = jbvNull;\n\t}\n\telse if (JBE_ISSTRING(entry))\n\t{\n\t\tresult->type = jbvString;\n\t\tresult->val.string.val = base_addr + offset;\n\t\tresult->val.string.len = getJsonbLength(container, index);\n\t\tAssert(result->val.string.len >= 0);\n\t}\n\telse if (JBE_ISNUMERIC(entry))\n\t{\n\t\tresult->type = jbvNumeric;\n\t\tresult->val.numeric = (Numeric) (base_addr + INTALIGN(offset));\n\t}\n\telse if (JBE_ISBOOL_TRUE(entry))\n\t{\n\t\tresult->type = jbvBool;\n\t\tresult->val.boolean = true;\n\t}\n\telse if (JBE_ISBOOL_FALSE(entry))\n\t{\n\t\tresult->type = jbvBool;\n\t\tresult->val.boolean = false;\n\t}\n\telse\n\t{\n\t\tAssert(JBE_ISCONTAINER(entry));\n\t\tresult->type = jbvBinary;\n\t\t/* Remove alignment padding from data pointer and length */\n\t\tresult->val.binary.data = (JsonbContainer *) (base_addr + INTALIGN(offset));\n\t\tresult->val.binary.len = getJsonbLength(container, index) -\n\t\t\t(INTALIGN(offset) - offset);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getJsonbOffset",
          "args": [
            "container",
            "index"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "getJsonbOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "120-139",
          "snippet": "uint32\ngetJsonbOffset(const JsonbContainer *jc, int index)\n{\n\tuint32\t\toffset = 0;\n\tint\t\t\ti;\n\n\t/*\n\t * Start offset of this entry is equal to the end offset of the previous\n\t * entry.  Walk backwards to the most recent entry stored as an end\n\t * offset, returning that offset plus any lengths in between.\n\t */\n\tfor (i = index - 1; i >= 0; i--)\n\t{\n\t\toffset += JBE_OFFLENFLD(jc->children[i]);\n\t\tif (JBE_HAS_OFF(jc->children[i]))\n\t\t\tbreak;\n\t}\n\n\treturn offset;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nuint32\ngetJsonbOffset(const JsonbContainer *jc, int index)\n{\n\tuint32\t\toffset = 0;\n\tint\t\t\ti;\n\n\t/*\n\t * Start offset of this entry is equal to the end offset of the previous\n\t * entry.  Walk backwards to the most recent entry stored as an end\n\t * offset, returning that offset plus any lengths in between.\n\t */\n\tfor (i = index - 1; i >= 0; i--)\n\t{\n\t\toffset += JBE_OFFLENFLD(jc->children[i]);\n\t\tif (JBE_HAS_OFF(jc->children[i]))\n\t\t\tbreak;\n\t}\n\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthCompareJsonbStringValue",
          "args": [
            "&candidate",
            "key"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "lengthCompareJsonbStringValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1761-1781",
          "snippet": "static int\nlengthCompareJsonbStringValue(const void *a, const void *b)\n{\n\tconst JsonbValue *va = (const JsonbValue *) a;\n\tconst JsonbValue *vb = (const JsonbValue *) b;\n\tint\t\t\tres;\n\n\tAssert(va->type == jbvString);\n\tAssert(vb->type == jbvString);\n\n\tif (va->val.string.len == vb->val.string.len)\n\t{\n\t\tres = memcmp(va->val.string.val, vb->val.string.val, va->val.string.len);\n\t}\n\telse\n\t{\n\t\tres = (va->val.string.len > vb->val.string.len) ? 1 : -1;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static int\tlengthCompareJsonbStringValue(const void *a, const void *b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic int\tlengthCompareJsonbStringValue(const void *a, const void *b);\n\nstatic int\nlengthCompareJsonbStringValue(const void *a, const void *b)\n{\n\tconst JsonbValue *va = (const JsonbValue *) a;\n\tconst JsonbValue *vb = (const JsonbValue *) b;\n\tint\t\t\tres;\n\n\tAssert(va->type == jbvString);\n\tAssert(vb->type == jbvString);\n\n\tif (va->val.string.len == vb->val.string.len)\n\t{\n\t\tres = memcmp(va->val.string.val, vb->val.string.val, va->val.string.len);\n\t}\n\telse\n\t{\n\t\tres = (va->val.string.len > vb->val.string.len) ? 1 : -1;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getJsonbLength",
          "args": [
            "container",
            "stopMiddle"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "getJsonbLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "145-165",
          "snippet": "uint32\ngetJsonbLength(const JsonbContainer *jc, int index)\n{\n\tuint32\t\toff;\n\tuint32\t\tlen;\n\n\t/*\n\t * If the length is stored directly in the JEntry, just return it.\n\t * Otherwise, get the begin offset of the entry, and subtract that from\n\t * the stored end+1 offset.\n\t */\n\tif (JBE_HAS_OFF(jc->children[index]))\n\t{\n\t\toff = getJsonbOffset(jc, index);\n\t\tlen = JBE_OFFLENFLD(jc->children[index]) - off;\n\t}\n\telse\n\t\tlen = JBE_OFFLENFLD(jc->children[index]);\n\n\treturn len;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nuint32\ngetJsonbLength(const JsonbContainer *jc, int index)\n{\n\tuint32\t\toff;\n\tuint32\t\tlen;\n\n\t/*\n\t * If the length is stored directly in the JEntry, just return it.\n\t * Otherwise, get the begin offset of the entry, and subtract that from\n\t * the stored end+1 offset.\n\t */\n\tif (JBE_HAS_OFF(jc->children[index]))\n\t{\n\t\toff = getJsonbOffset(jc, index);\n\t\tlen = JBE_OFFLENFLD(jc->children[index]) - off;\n\t}\n\telse\n\t\tlen = JBE_OFFLENFLD(jc->children[index]);\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "key->type == jbvString"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonContainerIsObject",
          "args": [
            "container"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBE_ADVANCE_OFFSET",
          "args": [
            "offset",
            "children[i]"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equalsJsonbScalarValue",
          "args": [
            "key",
            "result"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "equalsJsonbScalarValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1298-1322",
          "snippet": "static bool\nequalsJsonbScalarValue(JsonbValue *aScalar, JsonbValue *bScalar)\n{\n\tif (aScalar->type == bScalar->type)\n\t{\n\t\tswitch (aScalar->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\treturn true;\n\t\t\tcase jbvString:\n\t\t\t\treturn lengthCompareJsonbStringValue(aScalar, bScalar) == 0;\n\t\t\tcase jbvNumeric:\n\t\t\t\treturn DatumGetBool(DirectFunctionCall2(numeric_eq,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(bScalar->val.numeric)));\n\t\t\tcase jbvBool:\n\t\t\t\treturn aScalar->val.boolean == bScalar->val.boolean;\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t}\n\t}\n\telog(ERROR, \"jsonb scalar type mismatch\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\n\nstatic bool\nequalsJsonbScalarValue(JsonbValue *aScalar, JsonbValue *bScalar)\n{\n\tif (aScalar->type == bScalar->type)\n\t{\n\t\tswitch (aScalar->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\treturn true;\n\t\t\tcase jbvString:\n\t\t\t\treturn lengthCompareJsonbStringValue(aScalar, bScalar) == 0;\n\t\t\tcase jbvNumeric:\n\t\t\t\treturn DatumGetBool(DirectFunctionCall2(numeric_eq,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(bScalar->val.numeric)));\n\t\t\tcase jbvBool:\n\t\t\t\treturn aScalar->val.boolean == bScalar->val.boolean;\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t}\n\t}\n\telog(ERROR, \"jsonb scalar type mismatch\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonContainerIsArray",
          "args": [
            "container"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(JsonbValue)"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "(flags & ~(JB_FARRAY | JB_FOBJECT)) == 0"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonContainerSize",
          "args": [
            "container"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbValue *\nfindJsonbValueFromContainer(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\tJsonbValue *key)\n{\n\tJEntry\t   *children = container->children;\n\tint\t\t\tcount = JsonContainerSize(container);\n\tJsonbValue *result;\n\n\tAssert((flags & ~(JB_FARRAY | JB_FOBJECT)) == 0);\n\n\t/* Quick out without a palloc cycle if object/array is empty */\n\tif (count <= 0)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tif ((flags & JB_FARRAY) && JsonContainerIsArray(container))\n\t{\n\t\tchar\t   *base_addr = (char *) (children + count);\n\t\tuint32\t\toffset = 0;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tfillJsonbValue(container, i, base_addr, offset, result);\n\n\t\t\tif (key->type == result->type)\n\t\t\t{\n\t\t\t\tif (equalsJsonbScalarValue(key, result))\n\t\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tJBE_ADVANCE_OFFSET(offset, children[i]);\n\t\t}\n\t}\n\telse if ((flags & JB_FOBJECT) && JsonContainerIsObject(container))\n\t{\n\t\t/* Since this is an object, account for *Pairs* of Jentrys */\n\t\tchar\t   *base_addr = (char *) (children + count * 2);\n\t\tuint32\t\tstopLow = 0,\n\t\t\t\t\tstopHigh = count;\n\n\t\t/* Object key passed by caller must be a string */\n\t\tAssert(key->type == jbvString);\n\n\t\t/* Binary search on object/pair keys *only* */\n\t\twhile (stopLow < stopHigh)\n\t\t{\n\t\t\tuint32\t\tstopMiddle;\n\t\t\tint\t\t\tdifference;\n\t\t\tJsonbValue\tcandidate;\n\n\t\t\tstopMiddle = stopLow + (stopHigh - stopLow) / 2;\n\n\t\t\tcandidate.type = jbvString;\n\t\t\tcandidate.val.string.val =\n\t\t\t\tbase_addr + getJsonbOffset(container, stopMiddle);\n\t\t\tcandidate.val.string.len = getJsonbLength(container, stopMiddle);\n\n\t\t\tdifference = lengthCompareJsonbStringValue(&candidate, key);\n\n\t\t\tif (difference == 0)\n\t\t\t{\n\t\t\t\t/* Found our key, return corresponding value */\n\t\t\t\tint\t\t\tindex = stopMiddle + count;\n\n\t\t\t\tfillJsonbValue(container, index, base_addr,\n\t\t\t\t\t\t\t   getJsonbOffset(container, index),\n\t\t\t\t\t\t\t   result);\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (difference < 0)\n\t\t\t\t\tstopLow = stopMiddle + 1;\n\t\t\t\telse\n\t\t\t\t\tstopHigh = stopMiddle;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Not found */\n\tpfree(result);\n\treturn NULL;\n}"
  },
  {
    "function_name": "compareJsonbContainers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "177-298",
    "snippet": "int\ncompareJsonbContainers(JsonbContainer *a, JsonbContainer *b)\n{\n\tJsonbIterator *ita,\n\t\t\t   *itb;\n\tint\t\t\tres = 0;\n\n\tita = JsonbIteratorInit(a);\n\titb = JsonbIteratorInit(b);\n\n\tdo\n\t{\n\t\tJsonbValue\tva,\n\t\t\t\t\tvb;\n\t\tJsonbIteratorToken ra,\n\t\t\t\t\trb;\n\n\t\tra = JsonbIteratorNext(&ita, &va, false);\n\t\trb = JsonbIteratorNext(&itb, &vb, false);\n\n\t\tif (ra == rb)\n\t\t{\n\t\t\tif (ra == WJB_DONE)\n\t\t\t{\n\t\t\t\t/* Decisively equal */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * There is no array or object to compare at this stage of\n\t\t\t\t * processing.  jbvArray/jbvObject values are compared\n\t\t\t\t * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT\n\t\t\t\t * tokens.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (va.type == vb.type)\n\t\t\t{\n\t\t\t\tswitch (va.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvString:\n\t\t\t\t\tcase jbvNull:\n\t\t\t\t\tcase jbvNumeric:\n\t\t\t\t\tcase jbvBool:\n\t\t\t\t\t\tres = compareJsonbScalarValue(&va, &vb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvArray:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This could be a \"raw scalar\" pseudo array.  That's\n\t\t\t\t\t\t * a special case here though, since we still want the\n\t\t\t\t\t\t * general type-based comparisons to apply, and as far\n\t\t\t\t\t\t * as we're concerned a pseudo array is just a scalar.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (va.val.array.rawScalar != vb.val.array.rawScalar)\n\t\t\t\t\t\t\tres = (va.val.array.rawScalar) ? -1 : 1;\n\t\t\t\t\t\tif (va.val.array.nElems != vb.val.array.nElems)\n\t\t\t\t\t\t\tres = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tif (va.val.object.nPairs != vb.val.object.nPairs)\n\t\t\t\t\t\t\tres = (va.val.object.nPairs > vb.val.object.nPairs) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvBinary:\n\t\t\t\t\t\telog(ERROR, \"unexpected jbvBinary value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Type-defined order */\n\t\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It's safe to assume that the types differed, and that the va\n\t\t\t * and vb values passed were set.\n\t\t\t *\n\t\t\t * If the two values were of the same container type, then there'd\n\t\t\t * have been a chance to observe the variation in the number of\n\t\t\t * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're\n\t\t\t * either two heterogeneously-typed containers, or a container and\n\t\t\t * some scalar type.\n\t\t\t *\n\t\t\t * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT\n\t\t\t * cases here, because we would have seen the corresponding\n\t\t\t * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and\n\t\t\t * concluded that they don't match.\n\t\t\t */\n\t\t\tAssert(ra != WJB_END_ARRAY && ra != WJB_END_OBJECT);\n\t\t\tAssert(rb != WJB_END_ARRAY && rb != WJB_END_OBJECT);\n\n\t\t\tAssert(va.type != vb.type);\n\t\t\tAssert(va.type != jbvBinary);\n\t\t\tAssert(vb.type != jbvBinary);\n\t\t\t/* Type-defined order */\n\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t}\n\t}\n\twhile (res == 0);\n\n\twhile (ita != NULL)\n\t{\n\t\tJsonbIterator *i = ita->parent;\n\n\t\tpfree(ita);\n\t\tita = i;\n\t}\n\twhile (itb != NULL)\n\t{\n\t\tJsonbIterator *i = itb->parent;\n\n\t\tpfree(itb);\n\t\titb = i;\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
      "static int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
      "static int\tlengthCompareJsonbStringValue(const void *a, const void *b);",
      "static void uniqueifyJsonbObject(JsonbValue *object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "itb"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "vb.type != jbvBinary"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "va.type != jbvBinary"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "va.type != vb.type"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rb != WJB_END_ARRAY && rb != WJB_END_OBJECT"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ra != WJB_END_ARRAY && ra != WJB_END_OBJECT"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected jbvBinary value\""
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compareJsonbScalarValue",
          "args": [
            "&va",
            "&vb"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "compareJsonbScalarValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1330-1362",
          "snippet": "static int\ncompareJsonbScalarValue(JsonbValue *aScalar, JsonbValue *bScalar)\n{\n\tif (aScalar->type == bScalar->type)\n\t{\n\t\tswitch (aScalar->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\treturn 0;\n\t\t\tcase jbvString:\n\t\t\t\treturn varstr_cmp(aScalar->val.string.val,\n\t\t\t\t\t\t\t\t  aScalar->val.string.len,\n\t\t\t\t\t\t\t\t  bScalar->val.string.val,\n\t\t\t\t\t\t\t\t  bScalar->val.string.len,\n\t\t\t\t\t\t\t\t  DEFAULT_COLLATION_OID);\n\t\t\tcase jbvNumeric:\n\t\t\t\treturn DatumGetInt32(DirectFunctionCall2(numeric_cmp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(bScalar->val.numeric)));\n\t\t\tcase jbvBool:\n\t\t\t\tif (aScalar->val.boolean == bScalar->val.boolean)\n\t\t\t\t\treturn 0;\n\t\t\t\telse if (aScalar->val.boolean > bScalar->val.boolean)\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t}\n\t}\n\telog(ERROR, \"jsonb scalar type mismatch\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\n\nstatic int\ncompareJsonbScalarValue(JsonbValue *aScalar, JsonbValue *bScalar)\n{\n\tif (aScalar->type == bScalar->type)\n\t{\n\t\tswitch (aScalar->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\treturn 0;\n\t\t\tcase jbvString:\n\t\t\t\treturn varstr_cmp(aScalar->val.string.val,\n\t\t\t\t\t\t\t\t  aScalar->val.string.len,\n\t\t\t\t\t\t\t\t  bScalar->val.string.val,\n\t\t\t\t\t\t\t\t  bScalar->val.string.len,\n\t\t\t\t\t\t\t\t  DEFAULT_COLLATION_OID);\n\t\t\tcase jbvNumeric:\n\t\t\t\treturn DatumGetInt32(DirectFunctionCall2(numeric_cmp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(bScalar->val.numeric)));\n\t\t\tcase jbvBool:\n\t\t\t\tif (aScalar->val.boolean == bScalar->val.boolean)\n\t\t\t\t\treturn 0;\n\t\t\t\telse if (aScalar->val.boolean > bScalar->val.boolean)\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t}\n\t}\n\telog(ERROR, \"jsonb scalar type mismatch\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&itb",
            "&vb",
            "false"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "b"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic int\tlengthCompareJsonbStringValue(const void *a, const void *b);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nint\ncompareJsonbContainers(JsonbContainer *a, JsonbContainer *b)\n{\n\tJsonbIterator *ita,\n\t\t\t   *itb;\n\tint\t\t\tres = 0;\n\n\tita = JsonbIteratorInit(a);\n\titb = JsonbIteratorInit(b);\n\n\tdo\n\t{\n\t\tJsonbValue\tva,\n\t\t\t\t\tvb;\n\t\tJsonbIteratorToken ra,\n\t\t\t\t\trb;\n\n\t\tra = JsonbIteratorNext(&ita, &va, false);\n\t\trb = JsonbIteratorNext(&itb, &vb, false);\n\n\t\tif (ra == rb)\n\t\t{\n\t\t\tif (ra == WJB_DONE)\n\t\t\t{\n\t\t\t\t/* Decisively equal */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * There is no array or object to compare at this stage of\n\t\t\t\t * processing.  jbvArray/jbvObject values are compared\n\t\t\t\t * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT\n\t\t\t\t * tokens.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (va.type == vb.type)\n\t\t\t{\n\t\t\t\tswitch (va.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvString:\n\t\t\t\t\tcase jbvNull:\n\t\t\t\t\tcase jbvNumeric:\n\t\t\t\t\tcase jbvBool:\n\t\t\t\t\t\tres = compareJsonbScalarValue(&va, &vb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvArray:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This could be a \"raw scalar\" pseudo array.  That's\n\t\t\t\t\t\t * a special case here though, since we still want the\n\t\t\t\t\t\t * general type-based comparisons to apply, and as far\n\t\t\t\t\t\t * as we're concerned a pseudo array is just a scalar.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (va.val.array.rawScalar != vb.val.array.rawScalar)\n\t\t\t\t\t\t\tres = (va.val.array.rawScalar) ? -1 : 1;\n\t\t\t\t\t\tif (va.val.array.nElems != vb.val.array.nElems)\n\t\t\t\t\t\t\tres = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tif (va.val.object.nPairs != vb.val.object.nPairs)\n\t\t\t\t\t\t\tres = (va.val.object.nPairs > vb.val.object.nPairs) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvBinary:\n\t\t\t\t\t\telog(ERROR, \"unexpected jbvBinary value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Type-defined order */\n\t\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It's safe to assume that the types differed, and that the va\n\t\t\t * and vb values passed were set.\n\t\t\t *\n\t\t\t * If the two values were of the same container type, then there'd\n\t\t\t * have been a chance to observe the variation in the number of\n\t\t\t * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're\n\t\t\t * either two heterogeneously-typed containers, or a container and\n\t\t\t * some scalar type.\n\t\t\t *\n\t\t\t * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT\n\t\t\t * cases here, because we would have seen the corresponding\n\t\t\t * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and\n\t\t\t * concluded that they don't match.\n\t\t\t */\n\t\t\tAssert(ra != WJB_END_ARRAY && ra != WJB_END_OBJECT);\n\t\t\tAssert(rb != WJB_END_ARRAY && rb != WJB_END_OBJECT);\n\n\t\t\tAssert(va.type != vb.type);\n\t\t\tAssert(va.type != jbvBinary);\n\t\t\tAssert(vb.type != jbvBinary);\n\t\t\t/* Type-defined order */\n\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t}\n\t}\n\twhile (res == 0);\n\n\twhile (ita != NULL)\n\t{\n\t\tJsonbIterator *i = ita->parent;\n\n\t\tpfree(ita);\n\t\tita = i;\n\t}\n\twhile (itb != NULL)\n\t{\n\t\tJsonbIterator *i = itb->parent;\n\n\t\tpfree(itb);\n\t\titb = i;\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "getJsonbLength",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "145-165",
    "snippet": "uint32\ngetJsonbLength(const JsonbContainer *jc, int index)\n{\n\tuint32\t\toff;\n\tuint32\t\tlen;\n\n\t/*\n\t * If the length is stored directly in the JEntry, just return it.\n\t * Otherwise, get the begin offset of the entry, and subtract that from\n\t * the stored end+1 offset.\n\t */\n\tif (JBE_HAS_OFF(jc->children[index]))\n\t{\n\t\toff = getJsonbOffset(jc, index);\n\t\tlen = JBE_OFFLENFLD(jc->children[index]) - off;\n\t}\n\telse\n\t\tlen = JBE_OFFLENFLD(jc->children[index]);\n\n\treturn len;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\treserveFromBuffer(StringInfo buffer, int len);",
      "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
      "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
      "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "JBE_OFFLENFLD",
          "args": [
            "jc->children[index]"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBE_OFFLENFLD",
          "args": [
            "jc->children[index]"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getJsonbOffset",
          "args": [
            "jc",
            "index"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "getJsonbOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "120-139",
          "snippet": "uint32\ngetJsonbOffset(const JsonbContainer *jc, int index)\n{\n\tuint32\t\toffset = 0;\n\tint\t\t\ti;\n\n\t/*\n\t * Start offset of this entry is equal to the end offset of the previous\n\t * entry.  Walk backwards to the most recent entry stored as an end\n\t * offset, returning that offset plus any lengths in between.\n\t */\n\tfor (i = index - 1; i >= 0; i--)\n\t{\n\t\toffset += JBE_OFFLENFLD(jc->children[i]);\n\t\tif (JBE_HAS_OFF(jc->children[i]))\n\t\t\tbreak;\n\t}\n\n\treturn offset;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nuint32\ngetJsonbOffset(const JsonbContainer *jc, int index)\n{\n\tuint32\t\toffset = 0;\n\tint\t\t\ti;\n\n\t/*\n\t * Start offset of this entry is equal to the end offset of the previous\n\t * entry.  Walk backwards to the most recent entry stored as an end\n\t * offset, returning that offset plus any lengths in between.\n\t */\n\tfor (i = index - 1; i >= 0; i--)\n\t{\n\t\toffset += JBE_OFFLENFLD(jc->children[i]);\n\t\tif (JBE_HAS_OFF(jc->children[i]))\n\t\t\tbreak;\n\t}\n\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBE_HAS_OFF",
          "args": [
            "jc->children[index]"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nuint32\ngetJsonbLength(const JsonbContainer *jc, int index)\n{\n\tuint32\t\toff;\n\tuint32\t\tlen;\n\n\t/*\n\t * If the length is stored directly in the JEntry, just return it.\n\t * Otherwise, get the begin offset of the entry, and subtract that from\n\t * the stored end+1 offset.\n\t */\n\tif (JBE_HAS_OFF(jc->children[index]))\n\t{\n\t\toff = getJsonbOffset(jc, index);\n\t\tlen = JBE_OFFLENFLD(jc->children[index]) - off;\n\t}\n\telse\n\t\tlen = JBE_OFFLENFLD(jc->children[index]);\n\n\treturn len;\n}"
  },
  {
    "function_name": "getJsonbOffset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "120-139",
    "snippet": "uint32\ngetJsonbOffset(const JsonbContainer *jc, int index)\n{\n\tuint32\t\toffset = 0;\n\tint\t\t\ti;\n\n\t/*\n\t * Start offset of this entry is equal to the end offset of the previous\n\t * entry.  Walk backwards to the most recent entry stored as an end\n\t * offset, returning that offset plus any lengths in between.\n\t */\n\tfor (i = index - 1; i >= 0; i--)\n\t{\n\t\toffset += JBE_OFFLENFLD(jc->children[i]);\n\t\tif (JBE_HAS_OFF(jc->children[i]))\n\t\t\tbreak;\n\t}\n\n\treturn offset;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "JBE_HAS_OFF",
          "args": [
            "jc->children[i]"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBE_OFFLENFLD",
          "args": [
            "jc->children[i]"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nuint32\ngetJsonbOffset(const JsonbContainer *jc, int index)\n{\n\tuint32\t\toffset = 0;\n\tint\t\t\ti;\n\n\t/*\n\t * Start offset of this entry is equal to the end offset of the previous\n\t * entry.  Walk backwards to the most recent entry stored as an end\n\t * offset, returning that offset plus any lengths in between.\n\t */\n\tfor (i = index - 1; i >= 0; i--)\n\t{\n\t\toffset += JBE_OFFLENFLD(jc->children[i]);\n\t\tif (JBE_HAS_OFF(jc->children[i]))\n\t\t\tbreak;\n\t}\n\n\treturn offset;\n}"
  },
  {
    "function_name": "JsonbValueToJsonb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
    "lines": "78-113",
    "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Jsonb *convertToJsonb(JsonbValue *val);",
      "static int\treserveFromBuffer(StringInfo buffer, int len);",
      "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
      "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
      "static JsonbParseState *pushState(JsonbParseState **pstate);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARDATA(out)",
            "val->val.binary.data",
            "val->val.binary.len"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "out"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "out",
            "VARHDRSZ + val->val.binary.len"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "VARHDRSZ + val->val.binary.len"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "val->type == jbvBinary"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convertToJsonb",
          "args": [
            "val"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "convertToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1445-1474",
          "snippet": "static Jsonb *\nconvertToJsonb(JsonbValue *val)\n{\n\tStringInfoData buffer;\n\tJEntry\t\tjentry;\n\tJsonb\t   *res;\n\n\t/* Should not already have binary representation */\n\tAssert(val->type != jbvBinary);\n\n\t/* Allocate an output buffer. It will be enlarged as needed */\n\tinitStringInfo(&buffer);\n\n\t/* Make room for the varlena header */\n\treserveFromBuffer(&buffer, VARHDRSZ);\n\n\tconvertJsonbValue(&buffer, &jentry, val, 0);\n\n\t/*\n\t * Note: the JEntry of the root is discarded. Therefore the root\n\t * JsonbContainer struct must contain enough information to tell what kind\n\t * of value it is.\n\t */\n\n\tres = (Jsonb *) buffer.data;\n\n\tSET_VARSIZE(res, buffer.len);\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static short padBufferToInt(StringInfo buffer);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic short padBufferToInt(StringInfo buffer);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\n\nstatic Jsonb *\nconvertToJsonb(JsonbValue *val)\n{\n\tStringInfoData buffer;\n\tJEntry\t\tjentry;\n\tJsonb\t   *res;\n\n\t/* Should not already have binary representation */\n\tAssert(val->type != jbvBinary);\n\n\t/* Allocate an output buffer. It will be enlarged as needed */\n\tinitStringInfo(&buffer);\n\n\t/* Make room for the varlena header */\n\treserveFromBuffer(&buffer, VARHDRSZ);\n\n\tconvertJsonbValue(&buffer, &jentry, val, 0);\n\n\t/*\n\t * Note: the JEntry of the root is discarded. Therefore the root\n\t * JsonbContainer struct must contain enough information to tell what kind\n\t * of value it is.\n\t */\n\n\tres = (Jsonb *) buffer.data;\n\n\tSET_VARSIZE(res, buffer.len);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&pstate",
            "WJB_END_ARRAY",
            "NULL"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsAJsonbScalar",
          "args": [
            "val"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
  }
]