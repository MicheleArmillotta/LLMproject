[
  {
    "function_name": "inet_cidr_pton_ipv6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_net_pton.c",
    "lines": "438-564",
    "snippet": "static int\ninet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size)\n{\n\tstatic const char xdigits_l[] = \"0123456789abcdef\",\n\t\t\t\txdigits_u[] = \"0123456789ABCDEF\";\n\tu_char\t\ttmp[NS_IN6ADDRSZ],\n\t\t\t   *tp,\n\t\t\t   *endp,\n\t\t\t   *colonp;\n\tconst char *xdigits,\n\t\t\t   *curtok;\n\tint\t\t\tch,\n\t\t\t\tsaw_xdigit;\n\tu_int\t\tval;\n\tint\t\t\tdigits;\n\tint\t\t\tbits;\n\n\tif (size < NS_IN6ADDRSZ)\n\t\tgoto emsgsize;\n\n\tmemset((tp = tmp), '\\0', NS_IN6ADDRSZ);\n\tendp = tp + NS_IN6ADDRSZ;\n\tcolonp = NULL;\n\t/* Leading :: requires some special handling. */\n\tif (*src == ':')\n\t\tif (*++src != ':')\n\t\t\tgoto enoent;\n\tcurtok = src;\n\tsaw_xdigit = 0;\n\tval = 0;\n\tdigits = 0;\n\tbits = -1;\n\twhile ((ch = *src++) != '\\0')\n\t{\n\t\tconst char *pch;\n\n\t\tif ((pch = strchr((xdigits = xdigits_l), ch)) == NULL)\n\t\t\tpch = strchr((xdigits = xdigits_u), ch);\n\t\tif (pch != NULL)\n\t\t{\n\t\t\tval <<= 4;\n\t\t\tval |= (pch - xdigits);\n\t\t\tif (++digits > 4)\n\t\t\t\tgoto enoent;\n\t\t\tsaw_xdigit = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == ':')\n\t\t{\n\t\t\tcurtok = src;\n\t\t\tif (!saw_xdigit)\n\t\t\t{\n\t\t\t\tif (colonp)\n\t\t\t\t\tgoto enoent;\n\t\t\t\tcolonp = tp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (*src == '\\0')\n\t\t\t\tgoto enoent;\n\t\t\tif (tp + NS_INT16SZ > endp)\n\t\t\t\tgoto enoent;\n\t\t\t*tp++ = (u_char) (val >> 8) & 0xff;\n\t\t\t*tp++ = (u_char) val & 0xff;\n\t\t\tsaw_xdigit = 0;\n\t\t\tdigits = 0;\n\t\t\tval = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&\n\t\t\tgetv4(curtok, tp, &bits) > 0)\n\t\t{\n\t\t\ttp += NS_INADDRSZ;\n\t\t\tsaw_xdigit = 0;\n\t\t\tbreak;\t\t\t\t/* '\\0' was seen by inet_pton4(). */\n\t\t}\n\t\tif (ch == '/' && getbits(src, &bits) > 0)\n\t\t\tbreak;\n\t\tgoto enoent;\n\t}\n\tif (saw_xdigit)\n\t{\n\t\tif (tp + NS_INT16SZ > endp)\n\t\t\tgoto enoent;\n\t\t*tp++ = (u_char) (val >> 8) & 0xff;\n\t\t*tp++ = (u_char) val & 0xff;\n\t}\n\tif (bits == -1)\n\t\tbits = 128;\n\n\tendp = tmp + 16;\n\n\tif (colonp != NULL)\n\t{\n\t\t/*\n\t\t * Since some memmove()'s erroneously fail to handle overlapping\n\t\t * regions, we'll do the shift by hand.\n\t\t */\n\t\tconst int\tn = tp - colonp;\n\t\tint\t\t\ti;\n\n\t\tif (tp == endp)\n\t\t\tgoto enoent;\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tendp[-i] = colonp[n - i];\n\t\t\tcolonp[n - i] = 0;\n\t\t}\n\t\ttp = endp;\n\t}\n\tif (tp != endp)\n\t\tgoto enoent;\n\n\t/*\n\t * Copy out the result.\n\t */\n\tmemcpy(dst, tmp, NS_IN6ADDRSZ);\n\n\treturn bits;\n\nenoent:\n\terrno = ENOENT;\n\treturn -1;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn -1;\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NS_INADDRSZ 4",
      "#define NS_INT16SZ 2",
      "#define NS_IN6ADDRSZ 16"
    ],
    "globals_used": [
      "static int\tinet_net_pton_ipv4(const char *src, u_char *dst);",
      "static int\tinet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size);",
      "static int\tinet_net_pton_ipv6(const char *src, u_char *dst);",
      "static int\tinet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "tmp",
            "NS_IN6ADDRSZ"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "val >> 8"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getbits",
          "args": [
            "src",
            "&bits"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "getbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_net_pton.c",
          "lines": "348-379",
          "snippet": "static int\ngetbits(const char *src, int *bitsp)\n{\n\tstatic const char digits[] = \"0123456789\";\n\tint\t\t\tn;\n\tint\t\t\tval;\n\tchar\t\tch;\n\n\tval = 0;\n\tn = 0;\n\twhile ((ch = *src++) != '\\0')\n\t{\n\t\tconst char *pch;\n\n\t\tpch = strchr(digits, ch);\n\t\tif (pch != NULL)\n\t\t{\n\t\t\tif (n++ != 0 && val == 0)\t/* no leading zeros */\n\t\t\t\treturn 0;\n\t\t\tval *= 10;\n\t\t\tval += (pch - digits);\n\t\t\tif (val > 128)\t\t/* range */\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (n == 0)\n\t\treturn 0;\n\t*bitsp = val;\n\treturn 1;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */\n#include <ctype.h>\n#include <assert.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\ngetbits(const char *src, int *bitsp)\n{\n\tstatic const char digits[] = \"0123456789\";\n\tint\t\t\tn;\n\tint\t\t\tval;\n\tchar\t\tch;\n\n\tval = 0;\n\tn = 0;\n\twhile ((ch = *src++) != '\\0')\n\t{\n\t\tconst char *pch;\n\n\t\tpch = strchr(digits, ch);\n\t\tif (pch != NULL)\n\t\t{\n\t\t\tif (n++ != 0 && val == 0)\t/* no leading zeros */\n\t\t\t\treturn 0;\n\t\t\tval *= 10;\n\t\t\tval += (pch - digits);\n\t\t\tif (val > 128)\t\t/* range */\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (n == 0)\n\t\treturn 0;\n\t*bitsp = val;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getv4",
          "args": [
            "curtok",
            "tp",
            "&bits"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "getv4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_net_pton.c",
          "lines": "381-426",
          "snippet": "static int\ngetv4(const char *src, u_char *dst, int *bitsp)\n{\n\tstatic const char digits[] = \"0123456789\";\n\tu_char\t   *odst = dst;\n\tint\t\t\tn;\n\tu_int\t\tval;\n\tchar\t\tch;\n\n\tval = 0;\n\tn = 0;\n\twhile ((ch = *src++) != '\\0')\n\t{\n\t\tconst char *pch;\n\n\t\tpch = strchr(digits, ch);\n\t\tif (pch != NULL)\n\t\t{\n\t\t\tif (n++ != 0 && val == 0)\t/* no leading zeros */\n\t\t\t\treturn 0;\n\t\t\tval *= 10;\n\t\t\tval += (pch - digits);\n\t\t\tif (val > 255)\t\t/* range */\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '.' || ch == '/')\n\t\t{\n\t\t\tif (dst - odst > 3) /* too many octets? */\n\t\t\t\treturn 0;\n\t\t\t*dst++ = val;\n\t\t\tif (ch == '/')\n\t\t\t\treturn getbits(src, bitsp);\n\t\t\tval = 0;\n\t\t\tn = 0;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (n == 0)\n\t\treturn 0;\n\tif (dst - odst > 3)\t\t\t/* too many octets? */\n\t\treturn 0;\n\t*dst++ = val;\n\treturn 1;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tinet_net_pton_ipv4(const char *src, u_char *dst);",
            "static int\tinet_net_pton_ipv6(const char *src, u_char *dst);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */\n#include <ctype.h>\n#include <assert.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_net_pton_ipv4(const char *src, u_char *dst);\nstatic int\tinet_net_pton_ipv6(const char *src, u_char *dst);\n\nstatic int\ngetv4(const char *src, u_char *dst, int *bitsp)\n{\n\tstatic const char digits[] = \"0123456789\";\n\tu_char\t   *odst = dst;\n\tint\t\t\tn;\n\tu_int\t\tval;\n\tchar\t\tch;\n\n\tval = 0;\n\tn = 0;\n\twhile ((ch = *src++) != '\\0')\n\t{\n\t\tconst char *pch;\n\n\t\tpch = strchr(digits, ch);\n\t\tif (pch != NULL)\n\t\t{\n\t\t\tif (n++ != 0 && val == 0)\t/* no leading zeros */\n\t\t\t\treturn 0;\n\t\t\tval *= 10;\n\t\t\tval += (pch - digits);\n\t\t\tif (val > 255)\t\t/* range */\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '.' || ch == '/')\n\t\t{\n\t\t\tif (dst - odst > 3) /* too many octets? */\n\t\t\t\treturn 0;\n\t\t\t*dst++ = val;\n\t\t\tif (ch == '/')\n\t\t\t\treturn getbits(src, bitsp);\n\t\t\tval = 0;\n\t\t\tn = 0;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (n == 0)\n\t\treturn 0;\n\tif (dst - odst > 3)\t\t\t/* too many octets? */\n\t\treturn 0;\n\t*dst++ = val;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "val >> 8"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "(xdigits = xdigits_u)",
            "ch"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "(xdigits = xdigits_l)",
            "ch"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(tp = tmp)",
            "'\\0'",
            "NS_IN6ADDRSZ"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */\n#include <ctype.h>\n#include <assert.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\n#define NS_INADDRSZ 4\n#define NS_INT16SZ 2\n#define NS_IN6ADDRSZ 16\n\nstatic int\tinet_net_pton_ipv4(const char *src, u_char *dst);\nstatic int\tinet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size);\nstatic int\tinet_net_pton_ipv6(const char *src, u_char *dst);\nstatic int\tinet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size);\n\nstatic int\ninet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size)\n{\n\tstatic const char xdigits_l[] = \"0123456789abcdef\",\n\t\t\t\txdigits_u[] = \"0123456789ABCDEF\";\n\tu_char\t\ttmp[NS_IN6ADDRSZ],\n\t\t\t   *tp,\n\t\t\t   *endp,\n\t\t\t   *colonp;\n\tconst char *xdigits,\n\t\t\t   *curtok;\n\tint\t\t\tch,\n\t\t\t\tsaw_xdigit;\n\tu_int\t\tval;\n\tint\t\t\tdigits;\n\tint\t\t\tbits;\n\n\tif (size < NS_IN6ADDRSZ)\n\t\tgoto emsgsize;\n\n\tmemset((tp = tmp), '\\0', NS_IN6ADDRSZ);\n\tendp = tp + NS_IN6ADDRSZ;\n\tcolonp = NULL;\n\t/* Leading :: requires some special handling. */\n\tif (*src == ':')\n\t\tif (*++src != ':')\n\t\t\tgoto enoent;\n\tcurtok = src;\n\tsaw_xdigit = 0;\n\tval = 0;\n\tdigits = 0;\n\tbits = -1;\n\twhile ((ch = *src++) != '\\0')\n\t{\n\t\tconst char *pch;\n\n\t\tif ((pch = strchr((xdigits = xdigits_l), ch)) == NULL)\n\t\t\tpch = strchr((xdigits = xdigits_u), ch);\n\t\tif (pch != NULL)\n\t\t{\n\t\t\tval <<= 4;\n\t\t\tval |= (pch - xdigits);\n\t\t\tif (++digits > 4)\n\t\t\t\tgoto enoent;\n\t\t\tsaw_xdigit = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == ':')\n\t\t{\n\t\t\tcurtok = src;\n\t\t\tif (!saw_xdigit)\n\t\t\t{\n\t\t\t\tif (colonp)\n\t\t\t\t\tgoto enoent;\n\t\t\t\tcolonp = tp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (*src == '\\0')\n\t\t\t\tgoto enoent;\n\t\t\tif (tp + NS_INT16SZ > endp)\n\t\t\t\tgoto enoent;\n\t\t\t*tp++ = (u_char) (val >> 8) & 0xff;\n\t\t\t*tp++ = (u_char) val & 0xff;\n\t\t\tsaw_xdigit = 0;\n\t\t\tdigits = 0;\n\t\t\tval = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&\n\t\t\tgetv4(curtok, tp, &bits) > 0)\n\t\t{\n\t\t\ttp += NS_INADDRSZ;\n\t\t\tsaw_xdigit = 0;\n\t\t\tbreak;\t\t\t\t/* '\\0' was seen by inet_pton4(). */\n\t\t}\n\t\tif (ch == '/' && getbits(src, &bits) > 0)\n\t\t\tbreak;\n\t\tgoto enoent;\n\t}\n\tif (saw_xdigit)\n\t{\n\t\tif (tp + NS_INT16SZ > endp)\n\t\t\tgoto enoent;\n\t\t*tp++ = (u_char) (val >> 8) & 0xff;\n\t\t*tp++ = (u_char) val & 0xff;\n\t}\n\tif (bits == -1)\n\t\tbits = 128;\n\n\tendp = tmp + 16;\n\n\tif (colonp != NULL)\n\t{\n\t\t/*\n\t\t * Since some memmove()'s erroneously fail to handle overlapping\n\t\t * regions, we'll do the shift by hand.\n\t\t */\n\t\tconst int\tn = tp - colonp;\n\t\tint\t\t\ti;\n\n\t\tif (tp == endp)\n\t\t\tgoto enoent;\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tendp[-i] = colonp[n - i];\n\t\t\tcolonp[n - i] = 0;\n\t\t}\n\t\ttp = endp;\n\t}\n\tif (tp != endp)\n\t\tgoto enoent;\n\n\t/*\n\t * Copy out the result.\n\t */\n\tmemcpy(dst, tmp, NS_IN6ADDRSZ);\n\n\treturn bits;\n\nenoent:\n\terrno = ENOENT;\n\treturn -1;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn -1;\n}"
  },
  {
    "function_name": "inet_net_pton_ipv6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_net_pton.c",
    "lines": "428-432",
    "snippet": "static int\ninet_net_pton_ipv6(const char *src, u_char *dst)\n{\n\treturn inet_cidr_pton_ipv6(src, dst, 16);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tinet_net_pton_ipv4(const char *src, u_char *dst);",
      "static int\tinet_net_pton_ipv6(const char *src, u_char *dst);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inet_cidr_pton_ipv6",
          "args": [
            "src",
            "dst",
            "16"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "inet_cidr_pton_ipv6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_net_pton.c",
          "lines": "438-564",
          "snippet": "static int\ninet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size)\n{\n\tstatic const char xdigits_l[] = \"0123456789abcdef\",\n\t\t\t\txdigits_u[] = \"0123456789ABCDEF\";\n\tu_char\t\ttmp[NS_IN6ADDRSZ],\n\t\t\t   *tp,\n\t\t\t   *endp,\n\t\t\t   *colonp;\n\tconst char *xdigits,\n\t\t\t   *curtok;\n\tint\t\t\tch,\n\t\t\t\tsaw_xdigit;\n\tu_int\t\tval;\n\tint\t\t\tdigits;\n\tint\t\t\tbits;\n\n\tif (size < NS_IN6ADDRSZ)\n\t\tgoto emsgsize;\n\n\tmemset((tp = tmp), '\\0', NS_IN6ADDRSZ);\n\tendp = tp + NS_IN6ADDRSZ;\n\tcolonp = NULL;\n\t/* Leading :: requires some special handling. */\n\tif (*src == ':')\n\t\tif (*++src != ':')\n\t\t\tgoto enoent;\n\tcurtok = src;\n\tsaw_xdigit = 0;\n\tval = 0;\n\tdigits = 0;\n\tbits = -1;\n\twhile ((ch = *src++) != '\\0')\n\t{\n\t\tconst char *pch;\n\n\t\tif ((pch = strchr((xdigits = xdigits_l), ch)) == NULL)\n\t\t\tpch = strchr((xdigits = xdigits_u), ch);\n\t\tif (pch != NULL)\n\t\t{\n\t\t\tval <<= 4;\n\t\t\tval |= (pch - xdigits);\n\t\t\tif (++digits > 4)\n\t\t\t\tgoto enoent;\n\t\t\tsaw_xdigit = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == ':')\n\t\t{\n\t\t\tcurtok = src;\n\t\t\tif (!saw_xdigit)\n\t\t\t{\n\t\t\t\tif (colonp)\n\t\t\t\t\tgoto enoent;\n\t\t\t\tcolonp = tp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (*src == '\\0')\n\t\t\t\tgoto enoent;\n\t\t\tif (tp + NS_INT16SZ > endp)\n\t\t\t\tgoto enoent;\n\t\t\t*tp++ = (u_char) (val >> 8) & 0xff;\n\t\t\t*tp++ = (u_char) val & 0xff;\n\t\t\tsaw_xdigit = 0;\n\t\t\tdigits = 0;\n\t\t\tval = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&\n\t\t\tgetv4(curtok, tp, &bits) > 0)\n\t\t{\n\t\t\ttp += NS_INADDRSZ;\n\t\t\tsaw_xdigit = 0;\n\t\t\tbreak;\t\t\t\t/* '\\0' was seen by inet_pton4(). */\n\t\t}\n\t\tif (ch == '/' && getbits(src, &bits) > 0)\n\t\t\tbreak;\n\t\tgoto enoent;\n\t}\n\tif (saw_xdigit)\n\t{\n\t\tif (tp + NS_INT16SZ > endp)\n\t\t\tgoto enoent;\n\t\t*tp++ = (u_char) (val >> 8) & 0xff;\n\t\t*tp++ = (u_char) val & 0xff;\n\t}\n\tif (bits == -1)\n\t\tbits = 128;\n\n\tendp = tmp + 16;\n\n\tif (colonp != NULL)\n\t{\n\t\t/*\n\t\t * Since some memmove()'s erroneously fail to handle overlapping\n\t\t * regions, we'll do the shift by hand.\n\t\t */\n\t\tconst int\tn = tp - colonp;\n\t\tint\t\t\ti;\n\n\t\tif (tp == endp)\n\t\t\tgoto enoent;\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tendp[-i] = colonp[n - i];\n\t\t\tcolonp[n - i] = 0;\n\t\t}\n\t\ttp = endp;\n\t}\n\tif (tp != endp)\n\t\tgoto enoent;\n\n\t/*\n\t * Copy out the result.\n\t */\n\tmemcpy(dst, tmp, NS_IN6ADDRSZ);\n\n\treturn bits;\n\nenoent:\n\terrno = ENOENT;\n\treturn -1;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NS_INADDRSZ 4",
            "#define NS_INT16SZ 2",
            "#define NS_IN6ADDRSZ 16"
          ],
          "globals_used": [
            "static int\tinet_net_pton_ipv4(const char *src, u_char *dst);",
            "static int\tinet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size);",
            "static int\tinet_net_pton_ipv6(const char *src, u_char *dst);",
            "static int\tinet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */\n#include <ctype.h>\n#include <assert.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\n#define NS_INADDRSZ 4\n#define NS_INT16SZ 2\n#define NS_IN6ADDRSZ 16\n\nstatic int\tinet_net_pton_ipv4(const char *src, u_char *dst);\nstatic int\tinet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size);\nstatic int\tinet_net_pton_ipv6(const char *src, u_char *dst);\nstatic int\tinet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size);\n\nstatic int\ninet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size)\n{\n\tstatic const char xdigits_l[] = \"0123456789abcdef\",\n\t\t\t\txdigits_u[] = \"0123456789ABCDEF\";\n\tu_char\t\ttmp[NS_IN6ADDRSZ],\n\t\t\t   *tp,\n\t\t\t   *endp,\n\t\t\t   *colonp;\n\tconst char *xdigits,\n\t\t\t   *curtok;\n\tint\t\t\tch,\n\t\t\t\tsaw_xdigit;\n\tu_int\t\tval;\n\tint\t\t\tdigits;\n\tint\t\t\tbits;\n\n\tif (size < NS_IN6ADDRSZ)\n\t\tgoto emsgsize;\n\n\tmemset((tp = tmp), '\\0', NS_IN6ADDRSZ);\n\tendp = tp + NS_IN6ADDRSZ;\n\tcolonp = NULL;\n\t/* Leading :: requires some special handling. */\n\tif (*src == ':')\n\t\tif (*++src != ':')\n\t\t\tgoto enoent;\n\tcurtok = src;\n\tsaw_xdigit = 0;\n\tval = 0;\n\tdigits = 0;\n\tbits = -1;\n\twhile ((ch = *src++) != '\\0')\n\t{\n\t\tconst char *pch;\n\n\t\tif ((pch = strchr((xdigits = xdigits_l), ch)) == NULL)\n\t\t\tpch = strchr((xdigits = xdigits_u), ch);\n\t\tif (pch != NULL)\n\t\t{\n\t\t\tval <<= 4;\n\t\t\tval |= (pch - xdigits);\n\t\t\tif (++digits > 4)\n\t\t\t\tgoto enoent;\n\t\t\tsaw_xdigit = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == ':')\n\t\t{\n\t\t\tcurtok = src;\n\t\t\tif (!saw_xdigit)\n\t\t\t{\n\t\t\t\tif (colonp)\n\t\t\t\t\tgoto enoent;\n\t\t\t\tcolonp = tp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (*src == '\\0')\n\t\t\t\tgoto enoent;\n\t\t\tif (tp + NS_INT16SZ > endp)\n\t\t\t\tgoto enoent;\n\t\t\t*tp++ = (u_char) (val >> 8) & 0xff;\n\t\t\t*tp++ = (u_char) val & 0xff;\n\t\t\tsaw_xdigit = 0;\n\t\t\tdigits = 0;\n\t\t\tval = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&\n\t\t\tgetv4(curtok, tp, &bits) > 0)\n\t\t{\n\t\t\ttp += NS_INADDRSZ;\n\t\t\tsaw_xdigit = 0;\n\t\t\tbreak;\t\t\t\t/* '\\0' was seen by inet_pton4(). */\n\t\t}\n\t\tif (ch == '/' && getbits(src, &bits) > 0)\n\t\t\tbreak;\n\t\tgoto enoent;\n\t}\n\tif (saw_xdigit)\n\t{\n\t\tif (tp + NS_INT16SZ > endp)\n\t\t\tgoto enoent;\n\t\t*tp++ = (u_char) (val >> 8) & 0xff;\n\t\t*tp++ = (u_char) val & 0xff;\n\t}\n\tif (bits == -1)\n\t\tbits = 128;\n\n\tendp = tmp + 16;\n\n\tif (colonp != NULL)\n\t{\n\t\t/*\n\t\t * Since some memmove()'s erroneously fail to handle overlapping\n\t\t * regions, we'll do the shift by hand.\n\t\t */\n\t\tconst int\tn = tp - colonp;\n\t\tint\t\t\ti;\n\n\t\tif (tp == endp)\n\t\t\tgoto enoent;\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tendp[-i] = colonp[n - i];\n\t\t\tcolonp[n - i] = 0;\n\t\t}\n\t\ttp = endp;\n\t}\n\tif (tp != endp)\n\t\tgoto enoent;\n\n\t/*\n\t * Copy out the result.\n\t */\n\tmemcpy(dst, tmp, NS_IN6ADDRSZ);\n\n\treturn bits;\n\nenoent:\n\terrno = ENOENT;\n\treturn -1;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */\n#include <ctype.h>\n#include <assert.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_net_pton_ipv4(const char *src, u_char *dst);\nstatic int\tinet_net_pton_ipv6(const char *src, u_char *dst);\n\nstatic int\ninet_net_pton_ipv6(const char *src, u_char *dst)\n{\n\treturn inet_cidr_pton_ipv6(src, dst, 16);\n}"
  },
  {
    "function_name": "getv4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_net_pton.c",
    "lines": "381-426",
    "snippet": "static int\ngetv4(const char *src, u_char *dst, int *bitsp)\n{\n\tstatic const char digits[] = \"0123456789\";\n\tu_char\t   *odst = dst;\n\tint\t\t\tn;\n\tu_int\t\tval;\n\tchar\t\tch;\n\n\tval = 0;\n\tn = 0;\n\twhile ((ch = *src++) != '\\0')\n\t{\n\t\tconst char *pch;\n\n\t\tpch = strchr(digits, ch);\n\t\tif (pch != NULL)\n\t\t{\n\t\t\tif (n++ != 0 && val == 0)\t/* no leading zeros */\n\t\t\t\treturn 0;\n\t\t\tval *= 10;\n\t\t\tval += (pch - digits);\n\t\t\tif (val > 255)\t\t/* range */\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '.' || ch == '/')\n\t\t{\n\t\t\tif (dst - odst > 3) /* too many octets? */\n\t\t\t\treturn 0;\n\t\t\t*dst++ = val;\n\t\t\tif (ch == '/')\n\t\t\t\treturn getbits(src, bitsp);\n\t\t\tval = 0;\n\t\t\tn = 0;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (n == 0)\n\t\treturn 0;\n\tif (dst - odst > 3)\t\t\t/* too many octets? */\n\t\treturn 0;\n\t*dst++ = val;\n\treturn 1;\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tinet_net_pton_ipv4(const char *src, u_char *dst);",
      "static int\tinet_net_pton_ipv6(const char *src, u_char *dst);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "getbits",
          "args": [
            "src",
            "bitsp"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "getbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_net_pton.c",
          "lines": "348-379",
          "snippet": "static int\ngetbits(const char *src, int *bitsp)\n{\n\tstatic const char digits[] = \"0123456789\";\n\tint\t\t\tn;\n\tint\t\t\tval;\n\tchar\t\tch;\n\n\tval = 0;\n\tn = 0;\n\twhile ((ch = *src++) != '\\0')\n\t{\n\t\tconst char *pch;\n\n\t\tpch = strchr(digits, ch);\n\t\tif (pch != NULL)\n\t\t{\n\t\t\tif (n++ != 0 && val == 0)\t/* no leading zeros */\n\t\t\t\treturn 0;\n\t\t\tval *= 10;\n\t\t\tval += (pch - digits);\n\t\t\tif (val > 128)\t\t/* range */\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (n == 0)\n\t\treturn 0;\n\t*bitsp = val;\n\treturn 1;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */\n#include <ctype.h>\n#include <assert.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\ngetbits(const char *src, int *bitsp)\n{\n\tstatic const char digits[] = \"0123456789\";\n\tint\t\t\tn;\n\tint\t\t\tval;\n\tchar\t\tch;\n\n\tval = 0;\n\tn = 0;\n\twhile ((ch = *src++) != '\\0')\n\t{\n\t\tconst char *pch;\n\n\t\tpch = strchr(digits, ch);\n\t\tif (pch != NULL)\n\t\t{\n\t\t\tif (n++ != 0 && val == 0)\t/* no leading zeros */\n\t\t\t\treturn 0;\n\t\t\tval *= 10;\n\t\t\tval += (pch - digits);\n\t\t\tif (val > 128)\t\t/* range */\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (n == 0)\n\t\treturn 0;\n\t*bitsp = val;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "digits",
            "ch"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */\n#include <ctype.h>\n#include <assert.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_net_pton_ipv4(const char *src, u_char *dst);\nstatic int\tinet_net_pton_ipv6(const char *src, u_char *dst);\n\nstatic int\ngetv4(const char *src, u_char *dst, int *bitsp)\n{\n\tstatic const char digits[] = \"0123456789\";\n\tu_char\t   *odst = dst;\n\tint\t\t\tn;\n\tu_int\t\tval;\n\tchar\t\tch;\n\n\tval = 0;\n\tn = 0;\n\twhile ((ch = *src++) != '\\0')\n\t{\n\t\tconst char *pch;\n\n\t\tpch = strchr(digits, ch);\n\t\tif (pch != NULL)\n\t\t{\n\t\t\tif (n++ != 0 && val == 0)\t/* no leading zeros */\n\t\t\t\treturn 0;\n\t\t\tval *= 10;\n\t\t\tval += (pch - digits);\n\t\t\tif (val > 255)\t\t/* range */\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '.' || ch == '/')\n\t\t{\n\t\t\tif (dst - odst > 3) /* too many octets? */\n\t\t\t\treturn 0;\n\t\t\t*dst++ = val;\n\t\t\tif (ch == '/')\n\t\t\t\treturn getbits(src, bitsp);\n\t\t\tval = 0;\n\t\t\tn = 0;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (n == 0)\n\t\treturn 0;\n\tif (dst - odst > 3)\t\t\t/* too many octets? */\n\t\treturn 0;\n\t*dst++ = val;\n\treturn 1;\n}"
  },
  {
    "function_name": "getbits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_net_pton.c",
    "lines": "348-379",
    "snippet": "static int\ngetbits(const char *src, int *bitsp)\n{\n\tstatic const char digits[] = \"0123456789\";\n\tint\t\t\tn;\n\tint\t\t\tval;\n\tchar\t\tch;\n\n\tval = 0;\n\tn = 0;\n\twhile ((ch = *src++) != '\\0')\n\t{\n\t\tconst char *pch;\n\n\t\tpch = strchr(digits, ch);\n\t\tif (pch != NULL)\n\t\t{\n\t\t\tif (n++ != 0 && val == 0)\t/* no leading zeros */\n\t\t\t\treturn 0;\n\t\t\tval *= 10;\n\t\t\tval += (pch - digits);\n\t\t\tif (val > 128)\t\t/* range */\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (n == 0)\n\t\treturn 0;\n\t*bitsp = val;\n\treturn 1;\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "digits",
            "ch"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */\n#include <ctype.h>\n#include <assert.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\ngetbits(const char *src, int *bitsp)\n{\n\tstatic const char digits[] = \"0123456789\";\n\tint\t\t\tn;\n\tint\t\t\tval;\n\tchar\t\tch;\n\n\tval = 0;\n\tn = 0;\n\twhile ((ch = *src++) != '\\0')\n\t{\n\t\tconst char *pch;\n\n\t\tpch = strchr(digits, ch);\n\t\tif (pch != NULL)\n\t\t{\n\t\t\tif (n++ != 0 && val == 0)\t/* no leading zeros */\n\t\t\t\treturn 0;\n\t\t\tval *= 10;\n\t\t\tval += (pch - digits);\n\t\t\tif (val > 128)\t\t/* range */\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (n == 0)\n\t\treturn 0;\n\t*bitsp = val;\n\treturn 1;\n}"
  },
  {
    "function_name": "inet_net_pton_ipv4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_net_pton.c",
    "lines": "259-346",
    "snippet": "static int\ninet_net_pton_ipv4(const char *src, u_char *dst)\n{\n\tstatic const char digits[] = \"0123456789\";\n\tconst u_char *odst = dst;\n\tint\t\t\tn,\n\t\t\t\tch,\n\t\t\t\ttmp,\n\t\t\t\tbits;\n\tsize_t\t\tsize = 4;\n\n\t/* Get the mantissa. */\n\twhile (ch = *src++, isdigit((unsigned char) ch))\n\t{\n\t\ttmp = 0;\n\t\tdo\n\t\t{\n\t\t\tn = strchr(digits, ch) - digits;\n\t\t\tassert(n >= 0 && n <= 9);\n\t\t\ttmp *= 10;\n\t\t\ttmp += n;\n\t\t\tif (tmp > 255)\n\t\t\t\tgoto enoent;\n\t\t} while ((ch = *src++) != '\\0' && isdigit((unsigned char) ch));\n\t\tif (size-- == 0)\n\t\t\tgoto emsgsize;\n\t\t*dst++ = (u_char) tmp;\n\t\tif (ch == '\\0' || ch == '/')\n\t\t\tbreak;\n\t\tif (ch != '.')\n\t\t\tgoto enoent;\n\t}\n\n\t/* Get the prefix length if any. */\n\tbits = -1;\n\tif (ch == '/' && isdigit((unsigned char) src[0]) && dst > odst)\n\t{\n\t\t/* CIDR width specifier.  Nothing can follow it. */\n\t\tch = *src++;\t\t\t/* Skip over the /. */\n\t\tbits = 0;\n\t\tdo\n\t\t{\n\t\t\tn = strchr(digits, ch) - digits;\n\t\t\tassert(n >= 0 && n <= 9);\n\t\t\tbits *= 10;\n\t\t\tbits += n;\n\t\t} while ((ch = *src++) != '\\0' && isdigit((unsigned char) ch));\n\t\tif (ch != '\\0')\n\t\t\tgoto enoent;\n\t\tif (bits > 32)\n\t\t\tgoto emsgsize;\n\t}\n\n\t/* Firey death and destruction unless we prefetched EOS. */\n\tif (ch != '\\0')\n\t\tgoto enoent;\n\n\t/* Prefix length can default to /32 only if all four octets spec'd. */\n\tif (bits == -1)\n\t{\n\t\tif (dst - odst == 4)\n\t\t\tbits = 32;\n\t\telse\n\t\t\tgoto enoent;\n\t}\n\n\t/* If nothing was written to the destination, we found no address. */\n\tif (dst == odst)\n\t\tgoto enoent;\n\n\t/* If prefix length overspecifies mantissa, life is bad. */\n\tif ((bits / 8) > (dst - odst))\n\t\tgoto enoent;\n\n\t/* Extend address to four octets. */\n\twhile (size-- > 0)\n\t\t*dst++ = 0;\n\n\treturn bits;\n\nenoent:\n\terrno = ENOENT;\n\treturn -1;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn -1;\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tinet_net_pton_ipv4(const char *src, u_char *dst);",
      "static int\tinet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size);",
      "static int\tinet_net_pton_ipv6(const char *src, u_char *dst);",
      "static int\tinet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) ch"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "n >= 0 && n <= 9"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "digits",
            "ch"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) src[0]"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) ch"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "n >= 0 && n <= 9"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "digits",
            "ch"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) ch"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */\n#include <ctype.h>\n#include <assert.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_net_pton_ipv4(const char *src, u_char *dst);\nstatic int\tinet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size);\nstatic int\tinet_net_pton_ipv6(const char *src, u_char *dst);\nstatic int\tinet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size);\n\nstatic int\ninet_net_pton_ipv4(const char *src, u_char *dst)\n{\n\tstatic const char digits[] = \"0123456789\";\n\tconst u_char *odst = dst;\n\tint\t\t\tn,\n\t\t\t\tch,\n\t\t\t\ttmp,\n\t\t\t\tbits;\n\tsize_t\t\tsize = 4;\n\n\t/* Get the mantissa. */\n\twhile (ch = *src++, isdigit((unsigned char) ch))\n\t{\n\t\ttmp = 0;\n\t\tdo\n\t\t{\n\t\t\tn = strchr(digits, ch) - digits;\n\t\t\tassert(n >= 0 && n <= 9);\n\t\t\ttmp *= 10;\n\t\t\ttmp += n;\n\t\t\tif (tmp > 255)\n\t\t\t\tgoto enoent;\n\t\t} while ((ch = *src++) != '\\0' && isdigit((unsigned char) ch));\n\t\tif (size-- == 0)\n\t\t\tgoto emsgsize;\n\t\t*dst++ = (u_char) tmp;\n\t\tif (ch == '\\0' || ch == '/')\n\t\t\tbreak;\n\t\tif (ch != '.')\n\t\t\tgoto enoent;\n\t}\n\n\t/* Get the prefix length if any. */\n\tbits = -1;\n\tif (ch == '/' && isdigit((unsigned char) src[0]) && dst > odst)\n\t{\n\t\t/* CIDR width specifier.  Nothing can follow it. */\n\t\tch = *src++;\t\t\t/* Skip over the /. */\n\t\tbits = 0;\n\t\tdo\n\t\t{\n\t\t\tn = strchr(digits, ch) - digits;\n\t\t\tassert(n >= 0 && n <= 9);\n\t\t\tbits *= 10;\n\t\t\tbits += n;\n\t\t} while ((ch = *src++) != '\\0' && isdigit((unsigned char) ch));\n\t\tif (ch != '\\0')\n\t\t\tgoto enoent;\n\t\tif (bits > 32)\n\t\t\tgoto emsgsize;\n\t}\n\n\t/* Firey death and destruction unless we prefetched EOS. */\n\tif (ch != '\\0')\n\t\tgoto enoent;\n\n\t/* Prefix length can default to /32 only if all four octets spec'd. */\n\tif (bits == -1)\n\t{\n\t\tif (dst - odst == 4)\n\t\t\tbits = 32;\n\t\telse\n\t\t\tgoto enoent;\n\t}\n\n\t/* If nothing was written to the destination, we found no address. */\n\tif (dst == odst)\n\t\tgoto enoent;\n\n\t/* If prefix length overspecifies mantissa, life is bad. */\n\tif ((bits / 8) > (dst - odst))\n\t\tgoto enoent;\n\n\t/* Extend address to four octets. */\n\twhile (size-- > 0)\n\t\t*dst++ = 0;\n\n\treturn bits;\n\nenoent:\n\terrno = ENOENT;\n\treturn -1;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn -1;\n}"
  },
  {
    "function_name": "inet_cidr_pton_ipv4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_net_pton.c",
    "lines": "96-240",
    "snippet": "static int\ninet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size)\n{\n\tstatic const char xdigits[] = \"0123456789abcdef\";\n\tstatic const char digits[] = \"0123456789\";\n\tint\t\t\tn,\n\t\t\t\tch,\n\t\t\t\ttmp = 0,\n\t\t\t\tdirty,\n\t\t\t\tbits;\n\tconst u_char *odst = dst;\n\n\tch = *src++;\n\tif (ch == '0' && (src[0] == 'x' || src[0] == 'X')\n\t\t&& isxdigit((unsigned char) src[1]))\n\t{\n\t\t/* Hexadecimal: Eat nybble string. */\n\t\tif (size <= 0U)\n\t\t\tgoto emsgsize;\n\t\tdirty = 0;\n\t\tsrc++;\t\t\t\t\t/* skip x or X. */\n\t\twhile ((ch = *src++) != '\\0' && isxdigit((unsigned char) ch))\n\t\t{\n\t\t\tif (isupper((unsigned char) ch))\n\t\t\t\tch = tolower((unsigned char) ch);\n\t\t\tn = strchr(xdigits, ch) - xdigits;\n\t\t\tassert(n >= 0 && n <= 15);\n\t\t\tif (dirty == 0)\n\t\t\t\ttmp = n;\n\t\t\telse\n\t\t\t\ttmp = (tmp << 4) | n;\n\t\t\tif (++dirty == 2)\n\t\t\t{\n\t\t\t\tif (size-- <= 0U)\n\t\t\t\t\tgoto emsgsize;\n\t\t\t\t*dst++ = (u_char) tmp;\n\t\t\t\tdirty = 0;\n\t\t\t}\n\t\t}\n\t\tif (dirty)\n\t\t{\t\t\t\t\t\t/* Odd trailing nybble? */\n\t\t\tif (size-- <= 0U)\n\t\t\t\tgoto emsgsize;\n\t\t\t*dst++ = (u_char) (tmp << 4);\n\t\t}\n\t}\n\telse if (isdigit((unsigned char) ch))\n\t{\n\t\t/* Decimal: eat dotted digit string. */\n\t\tfor (;;)\n\t\t{\n\t\t\ttmp = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tn = strchr(digits, ch) - digits;\n\t\t\t\tassert(n >= 0 && n <= 9);\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += n;\n\t\t\t\tif (tmp > 255)\n\t\t\t\t\tgoto enoent;\n\t\t\t} while ((ch = *src++) != '\\0' &&\n\t\t\t\t\t isdigit((unsigned char) ch));\n\t\t\tif (size-- <= 0U)\n\t\t\t\tgoto emsgsize;\n\t\t\t*dst++ = (u_char) tmp;\n\t\t\tif (ch == '\\0' || ch == '/')\n\t\t\t\tbreak;\n\t\t\tif (ch != '.')\n\t\t\t\tgoto enoent;\n\t\t\tch = *src++;\n\t\t\tif (!isdigit((unsigned char) ch))\n\t\t\t\tgoto enoent;\n\t\t}\n\t}\n\telse\n\t\tgoto enoent;\n\n\tbits = -1;\n\tif (ch == '/' && isdigit((unsigned char) src[0]) && dst > odst)\n\t{\n\t\t/* CIDR width specifier.  Nothing can follow it. */\n\t\tch = *src++;\t\t\t/* Skip over the /. */\n\t\tbits = 0;\n\t\tdo\n\t\t{\n\t\t\tn = strchr(digits, ch) - digits;\n\t\t\tassert(n >= 0 && n <= 9);\n\t\t\tbits *= 10;\n\t\t\tbits += n;\n\t\t} while ((ch = *src++) != '\\0' && isdigit((unsigned char) ch));\n\t\tif (ch != '\\0')\n\t\t\tgoto enoent;\n\t\tif (bits > 32)\n\t\t\tgoto emsgsize;\n\t}\n\n\t/* Firey death and destruction unless we prefetched EOS. */\n\tif (ch != '\\0')\n\t\tgoto enoent;\n\n\t/* If nothing was written to the destination, we found no address. */\n\tif (dst == odst)\n\t\tgoto enoent;\n\t/* If no CIDR spec was given, infer width from net class. */\n\tif (bits == -1)\n\t{\n\t\tif (*odst >= 240)\t\t/* Class E */\n\t\t\tbits = 32;\n\t\telse if (*odst >= 224)\t/* Class D */\n\t\t\tbits = 8;\n\t\telse if (*odst >= 192)\t/* Class C */\n\t\t\tbits = 24;\n\t\telse if (*odst >= 128)\t/* Class B */\n\t\t\tbits = 16;\n\t\telse\n\t\t\t/* Class A */\n\t\t\tbits = 8;\n\t\t/* If imputed mask is narrower than specified octets, widen. */\n\t\tif (bits < ((dst - odst) * 8))\n\t\t\tbits = (dst - odst) * 8;\n\n\t\t/*\n\t\t * If there are no additional bits specified for a class D address\n\t\t * adjust bits to 4.\n\t\t */\n\t\tif (bits == 8 && *odst == 224)\n\t\t\tbits = 4;\n\t}\n\t/* Extend network to cover the actual mask. */\n\twhile (bits > ((dst - odst) * 8))\n\t{\n\t\tif (size-- <= 0U)\n\t\t\tgoto emsgsize;\n\t\t*dst++ = '\\0';\n\t}\n\treturn bits;\n\nenoent:\n\terrno = ENOENT;\n\treturn -1;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn -1;\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tinet_net_pton_ipv4(const char *src, u_char *dst);",
      "static int\tinet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size);",
      "static int\tinet_net_pton_ipv6(const char *src, u_char *dst);",
      "static int\tinet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) ch"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "n >= 0 && n <= 9"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "digits",
            "ch"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) src[0]"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) ch"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) ch"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "n >= 0 && n <= 9"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "digits",
            "ch"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) ch"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tmp << 4"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "n >= 0 && n <= 15"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "xdigits",
            "ch"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "(unsigned char) ch"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "asc_tolower_z",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1994-1998",
          "snippet": "static char *\nasc_tolower_z(const char *buff)\n{\n\treturn asc_tolower(buff, strlen(buff));\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *\nasc_tolower_z(const char *buff)\n{\n\treturn asc_tolower(buff, strlen(buff));\n}"
        }
      },
      {
        "call_info": {
          "callee": "isupper",
          "args": [
            "(unsigned char) ch"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "(unsigned char) ch"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "(unsigned char) src[1]"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */\n#include <ctype.h>\n#include <assert.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_net_pton_ipv4(const char *src, u_char *dst);\nstatic int\tinet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size);\nstatic int\tinet_net_pton_ipv6(const char *src, u_char *dst);\nstatic int\tinet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size);\n\nstatic int\ninet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size)\n{\n\tstatic const char xdigits[] = \"0123456789abcdef\";\n\tstatic const char digits[] = \"0123456789\";\n\tint\t\t\tn,\n\t\t\t\tch,\n\t\t\t\ttmp = 0,\n\t\t\t\tdirty,\n\t\t\t\tbits;\n\tconst u_char *odst = dst;\n\n\tch = *src++;\n\tif (ch == '0' && (src[0] == 'x' || src[0] == 'X')\n\t\t&& isxdigit((unsigned char) src[1]))\n\t{\n\t\t/* Hexadecimal: Eat nybble string. */\n\t\tif (size <= 0U)\n\t\t\tgoto emsgsize;\n\t\tdirty = 0;\n\t\tsrc++;\t\t\t\t\t/* skip x or X. */\n\t\twhile ((ch = *src++) != '\\0' && isxdigit((unsigned char) ch))\n\t\t{\n\t\t\tif (isupper((unsigned char) ch))\n\t\t\t\tch = tolower((unsigned char) ch);\n\t\t\tn = strchr(xdigits, ch) - xdigits;\n\t\t\tassert(n >= 0 && n <= 15);\n\t\t\tif (dirty == 0)\n\t\t\t\ttmp = n;\n\t\t\telse\n\t\t\t\ttmp = (tmp << 4) | n;\n\t\t\tif (++dirty == 2)\n\t\t\t{\n\t\t\t\tif (size-- <= 0U)\n\t\t\t\t\tgoto emsgsize;\n\t\t\t\t*dst++ = (u_char) tmp;\n\t\t\t\tdirty = 0;\n\t\t\t}\n\t\t}\n\t\tif (dirty)\n\t\t{\t\t\t\t\t\t/* Odd trailing nybble? */\n\t\t\tif (size-- <= 0U)\n\t\t\t\tgoto emsgsize;\n\t\t\t*dst++ = (u_char) (tmp << 4);\n\t\t}\n\t}\n\telse if (isdigit((unsigned char) ch))\n\t{\n\t\t/* Decimal: eat dotted digit string. */\n\t\tfor (;;)\n\t\t{\n\t\t\ttmp = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tn = strchr(digits, ch) - digits;\n\t\t\t\tassert(n >= 0 && n <= 9);\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += n;\n\t\t\t\tif (tmp > 255)\n\t\t\t\t\tgoto enoent;\n\t\t\t} while ((ch = *src++) != '\\0' &&\n\t\t\t\t\t isdigit((unsigned char) ch));\n\t\t\tif (size-- <= 0U)\n\t\t\t\tgoto emsgsize;\n\t\t\t*dst++ = (u_char) tmp;\n\t\t\tif (ch == '\\0' || ch == '/')\n\t\t\t\tbreak;\n\t\t\tif (ch != '.')\n\t\t\t\tgoto enoent;\n\t\t\tch = *src++;\n\t\t\tif (!isdigit((unsigned char) ch))\n\t\t\t\tgoto enoent;\n\t\t}\n\t}\n\telse\n\t\tgoto enoent;\n\n\tbits = -1;\n\tif (ch == '/' && isdigit((unsigned char) src[0]) && dst > odst)\n\t{\n\t\t/* CIDR width specifier.  Nothing can follow it. */\n\t\tch = *src++;\t\t\t/* Skip over the /. */\n\t\tbits = 0;\n\t\tdo\n\t\t{\n\t\t\tn = strchr(digits, ch) - digits;\n\t\t\tassert(n >= 0 && n <= 9);\n\t\t\tbits *= 10;\n\t\t\tbits += n;\n\t\t} while ((ch = *src++) != '\\0' && isdigit((unsigned char) ch));\n\t\tif (ch != '\\0')\n\t\t\tgoto enoent;\n\t\tif (bits > 32)\n\t\t\tgoto emsgsize;\n\t}\n\n\t/* Firey death and destruction unless we prefetched EOS. */\n\tif (ch != '\\0')\n\t\tgoto enoent;\n\n\t/* If nothing was written to the destination, we found no address. */\n\tif (dst == odst)\n\t\tgoto enoent;\n\t/* If no CIDR spec was given, infer width from net class. */\n\tif (bits == -1)\n\t{\n\t\tif (*odst >= 240)\t\t/* Class E */\n\t\t\tbits = 32;\n\t\telse if (*odst >= 224)\t/* Class D */\n\t\t\tbits = 8;\n\t\telse if (*odst >= 192)\t/* Class C */\n\t\t\tbits = 24;\n\t\telse if (*odst >= 128)\t/* Class B */\n\t\t\tbits = 16;\n\t\telse\n\t\t\t/* Class A */\n\t\t\tbits = 8;\n\t\t/* If imputed mask is narrower than specified octets, widen. */\n\t\tif (bits < ((dst - odst) * 8))\n\t\t\tbits = (dst - odst) * 8;\n\n\t\t/*\n\t\t * If there are no additional bits specified for a class D address\n\t\t * adjust bits to 4.\n\t\t */\n\t\tif (bits == 8 && *odst == 224)\n\t\t\tbits = 4;\n\t}\n\t/* Extend network to cover the actual mask. */\n\twhile (bits > ((dst - odst) * 8))\n\t{\n\t\tif (size-- <= 0U)\n\t\t\tgoto emsgsize;\n\t\t*dst++ = '\\0';\n\t}\n\treturn bits;\n\nenoent:\n\terrno = ENOENT;\n\treturn -1;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn -1;\n}"
  },
  {
    "function_name": "inet_net_pton",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_net_pton.c",
    "lines": "61-78",
    "snippet": "int\ninet_net_pton(int af, const char *src, void *dst, size_t size)\n{\n\tswitch (af)\n\t{\n\t\tcase PGSQL_AF_INET:\n\t\t\treturn size == -1 ?\n\t\t\t\tinet_net_pton_ipv4(src, dst) :\n\t\t\t\tinet_cidr_pton_ipv4(src, dst, size);\n\t\tcase PGSQL_AF_INET6:\n\t\t\treturn size == -1 ?\n\t\t\t\tinet_net_pton_ipv6(src, dst) :\n\t\t\t\tinet_cidr_pton_ipv6(src, dst, size);\n\t\tdefault:\n\t\t\terrno = EAFNOSUPPORT;\n\t\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tinet_net_pton_ipv4(const char *src, u_char *dst);",
      "static int\tinet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size);",
      "static int\tinet_net_pton_ipv6(const char *src, u_char *dst);",
      "static int\tinet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inet_cidr_pton_ipv6",
          "args": [
            "src",
            "dst",
            "size"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "inet_cidr_pton_ipv6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_net_pton.c",
          "lines": "438-564",
          "snippet": "static int\ninet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size)\n{\n\tstatic const char xdigits_l[] = \"0123456789abcdef\",\n\t\t\t\txdigits_u[] = \"0123456789ABCDEF\";\n\tu_char\t\ttmp[NS_IN6ADDRSZ],\n\t\t\t   *tp,\n\t\t\t   *endp,\n\t\t\t   *colonp;\n\tconst char *xdigits,\n\t\t\t   *curtok;\n\tint\t\t\tch,\n\t\t\t\tsaw_xdigit;\n\tu_int\t\tval;\n\tint\t\t\tdigits;\n\tint\t\t\tbits;\n\n\tif (size < NS_IN6ADDRSZ)\n\t\tgoto emsgsize;\n\n\tmemset((tp = tmp), '\\0', NS_IN6ADDRSZ);\n\tendp = tp + NS_IN6ADDRSZ;\n\tcolonp = NULL;\n\t/* Leading :: requires some special handling. */\n\tif (*src == ':')\n\t\tif (*++src != ':')\n\t\t\tgoto enoent;\n\tcurtok = src;\n\tsaw_xdigit = 0;\n\tval = 0;\n\tdigits = 0;\n\tbits = -1;\n\twhile ((ch = *src++) != '\\0')\n\t{\n\t\tconst char *pch;\n\n\t\tif ((pch = strchr((xdigits = xdigits_l), ch)) == NULL)\n\t\t\tpch = strchr((xdigits = xdigits_u), ch);\n\t\tif (pch != NULL)\n\t\t{\n\t\t\tval <<= 4;\n\t\t\tval |= (pch - xdigits);\n\t\t\tif (++digits > 4)\n\t\t\t\tgoto enoent;\n\t\t\tsaw_xdigit = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == ':')\n\t\t{\n\t\t\tcurtok = src;\n\t\t\tif (!saw_xdigit)\n\t\t\t{\n\t\t\t\tif (colonp)\n\t\t\t\t\tgoto enoent;\n\t\t\t\tcolonp = tp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (*src == '\\0')\n\t\t\t\tgoto enoent;\n\t\t\tif (tp + NS_INT16SZ > endp)\n\t\t\t\tgoto enoent;\n\t\t\t*tp++ = (u_char) (val >> 8) & 0xff;\n\t\t\t*tp++ = (u_char) val & 0xff;\n\t\t\tsaw_xdigit = 0;\n\t\t\tdigits = 0;\n\t\t\tval = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&\n\t\t\tgetv4(curtok, tp, &bits) > 0)\n\t\t{\n\t\t\ttp += NS_INADDRSZ;\n\t\t\tsaw_xdigit = 0;\n\t\t\tbreak;\t\t\t\t/* '\\0' was seen by inet_pton4(). */\n\t\t}\n\t\tif (ch == '/' && getbits(src, &bits) > 0)\n\t\t\tbreak;\n\t\tgoto enoent;\n\t}\n\tif (saw_xdigit)\n\t{\n\t\tif (tp + NS_INT16SZ > endp)\n\t\t\tgoto enoent;\n\t\t*tp++ = (u_char) (val >> 8) & 0xff;\n\t\t*tp++ = (u_char) val & 0xff;\n\t}\n\tif (bits == -1)\n\t\tbits = 128;\n\n\tendp = tmp + 16;\n\n\tif (colonp != NULL)\n\t{\n\t\t/*\n\t\t * Since some memmove()'s erroneously fail to handle overlapping\n\t\t * regions, we'll do the shift by hand.\n\t\t */\n\t\tconst int\tn = tp - colonp;\n\t\tint\t\t\ti;\n\n\t\tif (tp == endp)\n\t\t\tgoto enoent;\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tendp[-i] = colonp[n - i];\n\t\t\tcolonp[n - i] = 0;\n\t\t}\n\t\ttp = endp;\n\t}\n\tif (tp != endp)\n\t\tgoto enoent;\n\n\t/*\n\t * Copy out the result.\n\t */\n\tmemcpy(dst, tmp, NS_IN6ADDRSZ);\n\n\treturn bits;\n\nenoent:\n\terrno = ENOENT;\n\treturn -1;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NS_INADDRSZ 4",
            "#define NS_INT16SZ 2",
            "#define NS_IN6ADDRSZ 16"
          ],
          "globals_used": [
            "static int\tinet_net_pton_ipv4(const char *src, u_char *dst);",
            "static int\tinet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size);",
            "static int\tinet_net_pton_ipv6(const char *src, u_char *dst);",
            "static int\tinet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */\n#include <ctype.h>\n#include <assert.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\n#define NS_INADDRSZ 4\n#define NS_INT16SZ 2\n#define NS_IN6ADDRSZ 16\n\nstatic int\tinet_net_pton_ipv4(const char *src, u_char *dst);\nstatic int\tinet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size);\nstatic int\tinet_net_pton_ipv6(const char *src, u_char *dst);\nstatic int\tinet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size);\n\nstatic int\ninet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size)\n{\n\tstatic const char xdigits_l[] = \"0123456789abcdef\",\n\t\t\t\txdigits_u[] = \"0123456789ABCDEF\";\n\tu_char\t\ttmp[NS_IN6ADDRSZ],\n\t\t\t   *tp,\n\t\t\t   *endp,\n\t\t\t   *colonp;\n\tconst char *xdigits,\n\t\t\t   *curtok;\n\tint\t\t\tch,\n\t\t\t\tsaw_xdigit;\n\tu_int\t\tval;\n\tint\t\t\tdigits;\n\tint\t\t\tbits;\n\n\tif (size < NS_IN6ADDRSZ)\n\t\tgoto emsgsize;\n\n\tmemset((tp = tmp), '\\0', NS_IN6ADDRSZ);\n\tendp = tp + NS_IN6ADDRSZ;\n\tcolonp = NULL;\n\t/* Leading :: requires some special handling. */\n\tif (*src == ':')\n\t\tif (*++src != ':')\n\t\t\tgoto enoent;\n\tcurtok = src;\n\tsaw_xdigit = 0;\n\tval = 0;\n\tdigits = 0;\n\tbits = -1;\n\twhile ((ch = *src++) != '\\0')\n\t{\n\t\tconst char *pch;\n\n\t\tif ((pch = strchr((xdigits = xdigits_l), ch)) == NULL)\n\t\t\tpch = strchr((xdigits = xdigits_u), ch);\n\t\tif (pch != NULL)\n\t\t{\n\t\t\tval <<= 4;\n\t\t\tval |= (pch - xdigits);\n\t\t\tif (++digits > 4)\n\t\t\t\tgoto enoent;\n\t\t\tsaw_xdigit = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == ':')\n\t\t{\n\t\t\tcurtok = src;\n\t\t\tif (!saw_xdigit)\n\t\t\t{\n\t\t\t\tif (colonp)\n\t\t\t\t\tgoto enoent;\n\t\t\t\tcolonp = tp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (*src == '\\0')\n\t\t\t\tgoto enoent;\n\t\t\tif (tp + NS_INT16SZ > endp)\n\t\t\t\tgoto enoent;\n\t\t\t*tp++ = (u_char) (val >> 8) & 0xff;\n\t\t\t*tp++ = (u_char) val & 0xff;\n\t\t\tsaw_xdigit = 0;\n\t\t\tdigits = 0;\n\t\t\tval = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&\n\t\t\tgetv4(curtok, tp, &bits) > 0)\n\t\t{\n\t\t\ttp += NS_INADDRSZ;\n\t\t\tsaw_xdigit = 0;\n\t\t\tbreak;\t\t\t\t/* '\\0' was seen by inet_pton4(). */\n\t\t}\n\t\tif (ch == '/' && getbits(src, &bits) > 0)\n\t\t\tbreak;\n\t\tgoto enoent;\n\t}\n\tif (saw_xdigit)\n\t{\n\t\tif (tp + NS_INT16SZ > endp)\n\t\t\tgoto enoent;\n\t\t*tp++ = (u_char) (val >> 8) & 0xff;\n\t\t*tp++ = (u_char) val & 0xff;\n\t}\n\tif (bits == -1)\n\t\tbits = 128;\n\n\tendp = tmp + 16;\n\n\tif (colonp != NULL)\n\t{\n\t\t/*\n\t\t * Since some memmove()'s erroneously fail to handle overlapping\n\t\t * regions, we'll do the shift by hand.\n\t\t */\n\t\tconst int\tn = tp - colonp;\n\t\tint\t\t\ti;\n\n\t\tif (tp == endp)\n\t\t\tgoto enoent;\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tendp[-i] = colonp[n - i];\n\t\t\tcolonp[n - i] = 0;\n\t\t}\n\t\ttp = endp;\n\t}\n\tif (tp != endp)\n\t\tgoto enoent;\n\n\t/*\n\t * Copy out the result.\n\t */\n\tmemcpy(dst, tmp, NS_IN6ADDRSZ);\n\n\treturn bits;\n\nenoent:\n\terrno = ENOENT;\n\treturn -1;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_net_pton_ipv6",
          "args": [
            "src",
            "dst"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "inet_net_pton_ipv6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_net_pton.c",
          "lines": "428-432",
          "snippet": "static int\ninet_net_pton_ipv6(const char *src, u_char *dst)\n{\n\treturn inet_cidr_pton_ipv6(src, dst, 16);\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tinet_net_pton_ipv4(const char *src, u_char *dst);",
            "static int\tinet_net_pton_ipv6(const char *src, u_char *dst);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */\n#include <ctype.h>\n#include <assert.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_net_pton_ipv4(const char *src, u_char *dst);\nstatic int\tinet_net_pton_ipv6(const char *src, u_char *dst);\n\nstatic int\ninet_net_pton_ipv6(const char *src, u_char *dst)\n{\n\treturn inet_cidr_pton_ipv6(src, dst, 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_cidr_pton_ipv4",
          "args": [
            "src",
            "dst",
            "size"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "inet_cidr_pton_ipv4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_net_pton.c",
          "lines": "96-240",
          "snippet": "static int\ninet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size)\n{\n\tstatic const char xdigits[] = \"0123456789abcdef\";\n\tstatic const char digits[] = \"0123456789\";\n\tint\t\t\tn,\n\t\t\t\tch,\n\t\t\t\ttmp = 0,\n\t\t\t\tdirty,\n\t\t\t\tbits;\n\tconst u_char *odst = dst;\n\n\tch = *src++;\n\tif (ch == '0' && (src[0] == 'x' || src[0] == 'X')\n\t\t&& isxdigit((unsigned char) src[1]))\n\t{\n\t\t/* Hexadecimal: Eat nybble string. */\n\t\tif (size <= 0U)\n\t\t\tgoto emsgsize;\n\t\tdirty = 0;\n\t\tsrc++;\t\t\t\t\t/* skip x or X. */\n\t\twhile ((ch = *src++) != '\\0' && isxdigit((unsigned char) ch))\n\t\t{\n\t\t\tif (isupper((unsigned char) ch))\n\t\t\t\tch = tolower((unsigned char) ch);\n\t\t\tn = strchr(xdigits, ch) - xdigits;\n\t\t\tassert(n >= 0 && n <= 15);\n\t\t\tif (dirty == 0)\n\t\t\t\ttmp = n;\n\t\t\telse\n\t\t\t\ttmp = (tmp << 4) | n;\n\t\t\tif (++dirty == 2)\n\t\t\t{\n\t\t\t\tif (size-- <= 0U)\n\t\t\t\t\tgoto emsgsize;\n\t\t\t\t*dst++ = (u_char) tmp;\n\t\t\t\tdirty = 0;\n\t\t\t}\n\t\t}\n\t\tif (dirty)\n\t\t{\t\t\t\t\t\t/* Odd trailing nybble? */\n\t\t\tif (size-- <= 0U)\n\t\t\t\tgoto emsgsize;\n\t\t\t*dst++ = (u_char) (tmp << 4);\n\t\t}\n\t}\n\telse if (isdigit((unsigned char) ch))\n\t{\n\t\t/* Decimal: eat dotted digit string. */\n\t\tfor (;;)\n\t\t{\n\t\t\ttmp = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tn = strchr(digits, ch) - digits;\n\t\t\t\tassert(n >= 0 && n <= 9);\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += n;\n\t\t\t\tif (tmp > 255)\n\t\t\t\t\tgoto enoent;\n\t\t\t} while ((ch = *src++) != '\\0' &&\n\t\t\t\t\t isdigit((unsigned char) ch));\n\t\t\tif (size-- <= 0U)\n\t\t\t\tgoto emsgsize;\n\t\t\t*dst++ = (u_char) tmp;\n\t\t\tif (ch == '\\0' || ch == '/')\n\t\t\t\tbreak;\n\t\t\tif (ch != '.')\n\t\t\t\tgoto enoent;\n\t\t\tch = *src++;\n\t\t\tif (!isdigit((unsigned char) ch))\n\t\t\t\tgoto enoent;\n\t\t}\n\t}\n\telse\n\t\tgoto enoent;\n\n\tbits = -1;\n\tif (ch == '/' && isdigit((unsigned char) src[0]) && dst > odst)\n\t{\n\t\t/* CIDR width specifier.  Nothing can follow it. */\n\t\tch = *src++;\t\t\t/* Skip over the /. */\n\t\tbits = 0;\n\t\tdo\n\t\t{\n\t\t\tn = strchr(digits, ch) - digits;\n\t\t\tassert(n >= 0 && n <= 9);\n\t\t\tbits *= 10;\n\t\t\tbits += n;\n\t\t} while ((ch = *src++) != '\\0' && isdigit((unsigned char) ch));\n\t\tif (ch != '\\0')\n\t\t\tgoto enoent;\n\t\tif (bits > 32)\n\t\t\tgoto emsgsize;\n\t}\n\n\t/* Firey death and destruction unless we prefetched EOS. */\n\tif (ch != '\\0')\n\t\tgoto enoent;\n\n\t/* If nothing was written to the destination, we found no address. */\n\tif (dst == odst)\n\t\tgoto enoent;\n\t/* If no CIDR spec was given, infer width from net class. */\n\tif (bits == -1)\n\t{\n\t\tif (*odst >= 240)\t\t/* Class E */\n\t\t\tbits = 32;\n\t\telse if (*odst >= 224)\t/* Class D */\n\t\t\tbits = 8;\n\t\telse if (*odst >= 192)\t/* Class C */\n\t\t\tbits = 24;\n\t\telse if (*odst >= 128)\t/* Class B */\n\t\t\tbits = 16;\n\t\telse\n\t\t\t/* Class A */\n\t\t\tbits = 8;\n\t\t/* If imputed mask is narrower than specified octets, widen. */\n\t\tif (bits < ((dst - odst) * 8))\n\t\t\tbits = (dst - odst) * 8;\n\n\t\t/*\n\t\t * If there are no additional bits specified for a class D address\n\t\t * adjust bits to 4.\n\t\t */\n\t\tif (bits == 8 && *odst == 224)\n\t\t\tbits = 4;\n\t}\n\t/* Extend network to cover the actual mask. */\n\twhile (bits > ((dst - odst) * 8))\n\t{\n\t\tif (size-- <= 0U)\n\t\t\tgoto emsgsize;\n\t\t*dst++ = '\\0';\n\t}\n\treturn bits;\n\nenoent:\n\terrno = ENOENT;\n\treturn -1;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tinet_net_pton_ipv4(const char *src, u_char *dst);",
            "static int\tinet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size);",
            "static int\tinet_net_pton_ipv6(const char *src, u_char *dst);",
            "static int\tinet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */\n#include <ctype.h>\n#include <assert.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_net_pton_ipv4(const char *src, u_char *dst);\nstatic int\tinet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size);\nstatic int\tinet_net_pton_ipv6(const char *src, u_char *dst);\nstatic int\tinet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size);\n\nstatic int\ninet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size)\n{\n\tstatic const char xdigits[] = \"0123456789abcdef\";\n\tstatic const char digits[] = \"0123456789\";\n\tint\t\t\tn,\n\t\t\t\tch,\n\t\t\t\ttmp = 0,\n\t\t\t\tdirty,\n\t\t\t\tbits;\n\tconst u_char *odst = dst;\n\n\tch = *src++;\n\tif (ch == '0' && (src[0] == 'x' || src[0] == 'X')\n\t\t&& isxdigit((unsigned char) src[1]))\n\t{\n\t\t/* Hexadecimal: Eat nybble string. */\n\t\tif (size <= 0U)\n\t\t\tgoto emsgsize;\n\t\tdirty = 0;\n\t\tsrc++;\t\t\t\t\t/* skip x or X. */\n\t\twhile ((ch = *src++) != '\\0' && isxdigit((unsigned char) ch))\n\t\t{\n\t\t\tif (isupper((unsigned char) ch))\n\t\t\t\tch = tolower((unsigned char) ch);\n\t\t\tn = strchr(xdigits, ch) - xdigits;\n\t\t\tassert(n >= 0 && n <= 15);\n\t\t\tif (dirty == 0)\n\t\t\t\ttmp = n;\n\t\t\telse\n\t\t\t\ttmp = (tmp << 4) | n;\n\t\t\tif (++dirty == 2)\n\t\t\t{\n\t\t\t\tif (size-- <= 0U)\n\t\t\t\t\tgoto emsgsize;\n\t\t\t\t*dst++ = (u_char) tmp;\n\t\t\t\tdirty = 0;\n\t\t\t}\n\t\t}\n\t\tif (dirty)\n\t\t{\t\t\t\t\t\t/* Odd trailing nybble? */\n\t\t\tif (size-- <= 0U)\n\t\t\t\tgoto emsgsize;\n\t\t\t*dst++ = (u_char) (tmp << 4);\n\t\t}\n\t}\n\telse if (isdigit((unsigned char) ch))\n\t{\n\t\t/* Decimal: eat dotted digit string. */\n\t\tfor (;;)\n\t\t{\n\t\t\ttmp = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tn = strchr(digits, ch) - digits;\n\t\t\t\tassert(n >= 0 && n <= 9);\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += n;\n\t\t\t\tif (tmp > 255)\n\t\t\t\t\tgoto enoent;\n\t\t\t} while ((ch = *src++) != '\\0' &&\n\t\t\t\t\t isdigit((unsigned char) ch));\n\t\t\tif (size-- <= 0U)\n\t\t\t\tgoto emsgsize;\n\t\t\t*dst++ = (u_char) tmp;\n\t\t\tif (ch == '\\0' || ch == '/')\n\t\t\t\tbreak;\n\t\t\tif (ch != '.')\n\t\t\t\tgoto enoent;\n\t\t\tch = *src++;\n\t\t\tif (!isdigit((unsigned char) ch))\n\t\t\t\tgoto enoent;\n\t\t}\n\t}\n\telse\n\t\tgoto enoent;\n\n\tbits = -1;\n\tif (ch == '/' && isdigit((unsigned char) src[0]) && dst > odst)\n\t{\n\t\t/* CIDR width specifier.  Nothing can follow it. */\n\t\tch = *src++;\t\t\t/* Skip over the /. */\n\t\tbits = 0;\n\t\tdo\n\t\t{\n\t\t\tn = strchr(digits, ch) - digits;\n\t\t\tassert(n >= 0 && n <= 9);\n\t\t\tbits *= 10;\n\t\t\tbits += n;\n\t\t} while ((ch = *src++) != '\\0' && isdigit((unsigned char) ch));\n\t\tif (ch != '\\0')\n\t\t\tgoto enoent;\n\t\tif (bits > 32)\n\t\t\tgoto emsgsize;\n\t}\n\n\t/* Firey death and destruction unless we prefetched EOS. */\n\tif (ch != '\\0')\n\t\tgoto enoent;\n\n\t/* If nothing was written to the destination, we found no address. */\n\tif (dst == odst)\n\t\tgoto enoent;\n\t/* If no CIDR spec was given, infer width from net class. */\n\tif (bits == -1)\n\t{\n\t\tif (*odst >= 240)\t\t/* Class E */\n\t\t\tbits = 32;\n\t\telse if (*odst >= 224)\t/* Class D */\n\t\t\tbits = 8;\n\t\telse if (*odst >= 192)\t/* Class C */\n\t\t\tbits = 24;\n\t\telse if (*odst >= 128)\t/* Class B */\n\t\t\tbits = 16;\n\t\telse\n\t\t\t/* Class A */\n\t\t\tbits = 8;\n\t\t/* If imputed mask is narrower than specified octets, widen. */\n\t\tif (bits < ((dst - odst) * 8))\n\t\t\tbits = (dst - odst) * 8;\n\n\t\t/*\n\t\t * If there are no additional bits specified for a class D address\n\t\t * adjust bits to 4.\n\t\t */\n\t\tif (bits == 8 && *odst == 224)\n\t\t\tbits = 4;\n\t}\n\t/* Extend network to cover the actual mask. */\n\twhile (bits > ((dst - odst) * 8))\n\t{\n\t\tif (size-- <= 0U)\n\t\t\tgoto emsgsize;\n\t\t*dst++ = '\\0';\n\t}\n\treturn bits;\n\nenoent:\n\terrno = ENOENT;\n\treturn -1;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_net_pton_ipv4",
          "args": [
            "src",
            "dst"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "inet_net_pton_ipv4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_net_pton.c",
          "lines": "259-346",
          "snippet": "static int\ninet_net_pton_ipv4(const char *src, u_char *dst)\n{\n\tstatic const char digits[] = \"0123456789\";\n\tconst u_char *odst = dst;\n\tint\t\t\tn,\n\t\t\t\tch,\n\t\t\t\ttmp,\n\t\t\t\tbits;\n\tsize_t\t\tsize = 4;\n\n\t/* Get the mantissa. */\n\twhile (ch = *src++, isdigit((unsigned char) ch))\n\t{\n\t\ttmp = 0;\n\t\tdo\n\t\t{\n\t\t\tn = strchr(digits, ch) - digits;\n\t\t\tassert(n >= 0 && n <= 9);\n\t\t\ttmp *= 10;\n\t\t\ttmp += n;\n\t\t\tif (tmp > 255)\n\t\t\t\tgoto enoent;\n\t\t} while ((ch = *src++) != '\\0' && isdigit((unsigned char) ch));\n\t\tif (size-- == 0)\n\t\t\tgoto emsgsize;\n\t\t*dst++ = (u_char) tmp;\n\t\tif (ch == '\\0' || ch == '/')\n\t\t\tbreak;\n\t\tif (ch != '.')\n\t\t\tgoto enoent;\n\t}\n\n\t/* Get the prefix length if any. */\n\tbits = -1;\n\tif (ch == '/' && isdigit((unsigned char) src[0]) && dst > odst)\n\t{\n\t\t/* CIDR width specifier.  Nothing can follow it. */\n\t\tch = *src++;\t\t\t/* Skip over the /. */\n\t\tbits = 0;\n\t\tdo\n\t\t{\n\t\t\tn = strchr(digits, ch) - digits;\n\t\t\tassert(n >= 0 && n <= 9);\n\t\t\tbits *= 10;\n\t\t\tbits += n;\n\t\t} while ((ch = *src++) != '\\0' && isdigit((unsigned char) ch));\n\t\tif (ch != '\\0')\n\t\t\tgoto enoent;\n\t\tif (bits > 32)\n\t\t\tgoto emsgsize;\n\t}\n\n\t/* Firey death and destruction unless we prefetched EOS. */\n\tif (ch != '\\0')\n\t\tgoto enoent;\n\n\t/* Prefix length can default to /32 only if all four octets spec'd. */\n\tif (bits == -1)\n\t{\n\t\tif (dst - odst == 4)\n\t\t\tbits = 32;\n\t\telse\n\t\t\tgoto enoent;\n\t}\n\n\t/* If nothing was written to the destination, we found no address. */\n\tif (dst == odst)\n\t\tgoto enoent;\n\n\t/* If prefix length overspecifies mantissa, life is bad. */\n\tif ((bits / 8) > (dst - odst))\n\t\tgoto enoent;\n\n\t/* Extend address to four octets. */\n\twhile (size-- > 0)\n\t\t*dst++ = 0;\n\n\treturn bits;\n\nenoent:\n\terrno = ENOENT;\n\treturn -1;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tinet_net_pton_ipv4(const char *src, u_char *dst);",
            "static int\tinet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size);",
            "static int\tinet_net_pton_ipv6(const char *src, u_char *dst);",
            "static int\tinet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */\n#include <ctype.h>\n#include <assert.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_net_pton_ipv4(const char *src, u_char *dst);\nstatic int\tinet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size);\nstatic int\tinet_net_pton_ipv6(const char *src, u_char *dst);\nstatic int\tinet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size);\n\nstatic int\ninet_net_pton_ipv4(const char *src, u_char *dst)\n{\n\tstatic const char digits[] = \"0123456789\";\n\tconst u_char *odst = dst;\n\tint\t\t\tn,\n\t\t\t\tch,\n\t\t\t\ttmp,\n\t\t\t\tbits;\n\tsize_t\t\tsize = 4;\n\n\t/* Get the mantissa. */\n\twhile (ch = *src++, isdigit((unsigned char) ch))\n\t{\n\t\ttmp = 0;\n\t\tdo\n\t\t{\n\t\t\tn = strchr(digits, ch) - digits;\n\t\t\tassert(n >= 0 && n <= 9);\n\t\t\ttmp *= 10;\n\t\t\ttmp += n;\n\t\t\tif (tmp > 255)\n\t\t\t\tgoto enoent;\n\t\t} while ((ch = *src++) != '\\0' && isdigit((unsigned char) ch));\n\t\tif (size-- == 0)\n\t\t\tgoto emsgsize;\n\t\t*dst++ = (u_char) tmp;\n\t\tif (ch == '\\0' || ch == '/')\n\t\t\tbreak;\n\t\tif (ch != '.')\n\t\t\tgoto enoent;\n\t}\n\n\t/* Get the prefix length if any. */\n\tbits = -1;\n\tif (ch == '/' && isdigit((unsigned char) src[0]) && dst > odst)\n\t{\n\t\t/* CIDR width specifier.  Nothing can follow it. */\n\t\tch = *src++;\t\t\t/* Skip over the /. */\n\t\tbits = 0;\n\t\tdo\n\t\t{\n\t\t\tn = strchr(digits, ch) - digits;\n\t\t\tassert(n >= 0 && n <= 9);\n\t\t\tbits *= 10;\n\t\t\tbits += n;\n\t\t} while ((ch = *src++) != '\\0' && isdigit((unsigned char) ch));\n\t\tif (ch != '\\0')\n\t\t\tgoto enoent;\n\t\tif (bits > 32)\n\t\t\tgoto emsgsize;\n\t}\n\n\t/* Firey death and destruction unless we prefetched EOS. */\n\tif (ch != '\\0')\n\t\tgoto enoent;\n\n\t/* Prefix length can default to /32 only if all four octets spec'd. */\n\tif (bits == -1)\n\t{\n\t\tif (dst - odst == 4)\n\t\t\tbits = 32;\n\t\telse\n\t\t\tgoto enoent;\n\t}\n\n\t/* If nothing was written to the destination, we found no address. */\n\tif (dst == odst)\n\t\tgoto enoent;\n\n\t/* If prefix length overspecifies mantissa, life is bad. */\n\tif ((bits / 8) > (dst - odst))\n\t\tgoto enoent;\n\n\t/* Extend address to four octets. */\n\twhile (size-- > 0)\n\t\t*dst++ = 0;\n\n\treturn bits;\n\nenoent:\n\terrno = ENOENT;\n\treturn -1;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\" /* pgrminclude ignore */\t/* needed on some\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * platforms */\n#include <ctype.h>\n#include <assert.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_net_pton_ipv4(const char *src, u_char *dst);\nstatic int\tinet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size);\nstatic int\tinet_net_pton_ipv6(const char *src, u_char *dst);\nstatic int\tinet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size);\n\nint\ninet_net_pton(int af, const char *src, void *dst, size_t size)\n{\n\tswitch (af)\n\t{\n\t\tcase PGSQL_AF_INET:\n\t\t\treturn size == -1 ?\n\t\t\t\tinet_net_pton_ipv4(src, dst) :\n\t\t\t\tinet_cidr_pton_ipv4(src, dst, size);\n\t\tcase PGSQL_AF_INET6:\n\t\t\treturn size == -1 ?\n\t\t\t\tinet_net_pton_ipv6(src, dst) :\n\t\t\t\tinet_cidr_pton_ipv6(src, dst, size);\n\t\tdefault:\n\t\t\terrno = EAFNOSUPPORT;\n\t\t\treturn -1;\n\t}\n}"
  }
]