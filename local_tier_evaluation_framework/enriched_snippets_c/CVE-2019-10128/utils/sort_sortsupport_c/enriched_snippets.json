[
  {
    "function_name": "PrepareSortSupportFromIndexRel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sortsupport.c",
    "lines": "159-176",
    "snippet": "void\nPrepareSortSupportFromIndexRel(Relation indexRel, int16 strategy,\n\t\t\t\t\t\t\t   SortSupport ssup)\n{\n\tOid\t\t\topfamily = indexRel->rd_opfamily[ssup->ssup_attno - 1];\n\tOid\t\t\topcintype = indexRel->rd_opcintype[ssup->ssup_attno - 1];\n\n\tAssert(ssup->comparator == NULL);\n\n\tif (indexRel->rd_rel->relam != BTREE_AM_OID)\n\t\telog(ERROR, \"unexpected non-btree AM: %u\", indexRel->rd_rel->relam);\n\tif (strategy != BTGreaterStrategyNumber &&\n\t\tstrategy != BTLessStrategyNumber)\n\t\telog(ERROR, \"unexpected sort support strategy: %d\", strategy);\n\tssup->ssup_reverse = (strategy == BTGreaterStrategyNumber);\n\n\tFinishSortSupportFunction(opfamily, opcintype, ssup);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FinishSortSupportFunction",
          "args": [
            "opfamily",
            "opcintype",
            "ssup"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "FinishSortSupportFunction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sortsupport.c",
          "lines": "92-123",
          "snippet": "static void\nFinishSortSupportFunction(Oid opfamily, Oid opcintype, SortSupport ssup)\n{\n\tOid\t\t\tsortSupportFunction;\n\n\t/* Look for a sort support function */\n\tsortSupportFunction = get_opfamily_proc(opfamily, opcintype, opcintype,\n\t\t\t\t\t\t\t\t\t\t\tBTSORTSUPPORT_PROC);\n\tif (OidIsValid(sortSupportFunction))\n\t{\n\t\t/*\n\t\t * The sort support function can provide a comparator, but it can also\n\t\t * choose not to so (e.g. based on the selected collation).\n\t\t */\n\t\tOidFunctionCall1(sortSupportFunction, PointerGetDatum(ssup));\n\t}\n\n\tif (ssup->comparator == NULL)\n\t{\n\t\tOid\t\t\tsortFunction;\n\n\t\tsortFunction = get_opfamily_proc(opfamily, opcintype, opcintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\tif (!OidIsValid(sortFunction))\n\t\t\telog(ERROR, \"missing support function %d(%u,%u) in opfamily %u\",\n\t\t\t\t BTORDER_PROC, opcintype, opcintype, opfamily);\n\n\t\t/* We'll use a shim to call the old-style btree comparator */\n\t\tPrepareSortSupportComparisonShim(sortFunction, ssup);\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_am.h\"\n#include \"access/nbtree.h\"\n#include \"postgres.h\"\n\nstatic void\nFinishSortSupportFunction(Oid opfamily, Oid opcintype, SortSupport ssup)\n{\n\tOid\t\t\tsortSupportFunction;\n\n\t/* Look for a sort support function */\n\tsortSupportFunction = get_opfamily_proc(opfamily, opcintype, opcintype,\n\t\t\t\t\t\t\t\t\t\t\tBTSORTSUPPORT_PROC);\n\tif (OidIsValid(sortSupportFunction))\n\t{\n\t\t/*\n\t\t * The sort support function can provide a comparator, but it can also\n\t\t * choose not to so (e.g. based on the selected collation).\n\t\t */\n\t\tOidFunctionCall1(sortSupportFunction, PointerGetDatum(ssup));\n\t}\n\n\tif (ssup->comparator == NULL)\n\t{\n\t\tOid\t\t\tsortFunction;\n\n\t\tsortFunction = get_opfamily_proc(opfamily, opcintype, opcintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\tif (!OidIsValid(sortFunction))\n\t\t\telog(ERROR, \"missing support function %d(%u,%u) in opfamily %u\",\n\t\t\t\t BTORDER_PROC, opcintype, opcintype, opfamily);\n\n\t\t/* We'll use a shim to call the old-style btree comparator */\n\t\tPrepareSortSupportComparisonShim(sortFunction, ssup);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected sort support strategy: %d\"",
            "strategy"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ssup->comparator == NULL"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_am.h\"\n#include \"access/nbtree.h\"\n#include \"postgres.h\"\n\nvoid\nPrepareSortSupportFromIndexRel(Relation indexRel, int16 strategy,\n\t\t\t\t\t\t\t   SortSupport ssup)\n{\n\tOid\t\t\topfamily = indexRel->rd_opfamily[ssup->ssup_attno - 1];\n\tOid\t\t\topcintype = indexRel->rd_opcintype[ssup->ssup_attno - 1];\n\n\tAssert(ssup->comparator == NULL);\n\n\tif (indexRel->rd_rel->relam != BTREE_AM_OID)\n\t\telog(ERROR, \"unexpected non-btree AM: %u\", indexRel->rd_rel->relam);\n\tif (strategy != BTGreaterStrategyNumber &&\n\t\tstrategy != BTLessStrategyNumber)\n\t\telog(ERROR, \"unexpected sort support strategy: %d\", strategy);\n\tssup->ssup_reverse = (strategy == BTGreaterStrategyNumber);\n\n\tFinishSortSupportFunction(opfamily, opcintype, ssup);\n}"
  },
  {
    "function_name": "PrepareSortSupportFromOrderingOp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sortsupport.c",
    "lines": "132-149",
    "snippet": "void\nPrepareSortSupportFromOrderingOp(Oid orderingOp, SortSupport ssup)\n{\n\tOid\t\t\topfamily;\n\tOid\t\t\topcintype;\n\tint16\t\tstrategy;\n\n\tAssert(ssup->comparator == NULL);\n\n\t/* Find the operator in pg_amop */\n\tif (!get_ordering_op_properties(orderingOp, &opfamily, &opcintype,\n\t\t\t\t\t\t\t\t\t&strategy))\n\t\telog(ERROR, \"operator %u is not a valid ordering operator\",\n\t\t\t orderingOp);\n\tssup->ssup_reverse = (strategy == BTGreaterStrategyNumber);\n\n\tFinishSortSupportFunction(opfamily, opcintype, ssup);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FinishSortSupportFunction",
          "args": [
            "opfamily",
            "opcintype",
            "ssup"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "FinishSortSupportFunction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sortsupport.c",
          "lines": "92-123",
          "snippet": "static void\nFinishSortSupportFunction(Oid opfamily, Oid opcintype, SortSupport ssup)\n{\n\tOid\t\t\tsortSupportFunction;\n\n\t/* Look for a sort support function */\n\tsortSupportFunction = get_opfamily_proc(opfamily, opcintype, opcintype,\n\t\t\t\t\t\t\t\t\t\t\tBTSORTSUPPORT_PROC);\n\tif (OidIsValid(sortSupportFunction))\n\t{\n\t\t/*\n\t\t * The sort support function can provide a comparator, but it can also\n\t\t * choose not to so (e.g. based on the selected collation).\n\t\t */\n\t\tOidFunctionCall1(sortSupportFunction, PointerGetDatum(ssup));\n\t}\n\n\tif (ssup->comparator == NULL)\n\t{\n\t\tOid\t\t\tsortFunction;\n\n\t\tsortFunction = get_opfamily_proc(opfamily, opcintype, opcintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\tif (!OidIsValid(sortFunction))\n\t\t\telog(ERROR, \"missing support function %d(%u,%u) in opfamily %u\",\n\t\t\t\t BTORDER_PROC, opcintype, opcintype, opfamily);\n\n\t\t/* We'll use a shim to call the old-style btree comparator */\n\t\tPrepareSortSupportComparisonShim(sortFunction, ssup);\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_am.h\"\n#include \"access/nbtree.h\"\n#include \"postgres.h\"\n\nstatic void\nFinishSortSupportFunction(Oid opfamily, Oid opcintype, SortSupport ssup)\n{\n\tOid\t\t\tsortSupportFunction;\n\n\t/* Look for a sort support function */\n\tsortSupportFunction = get_opfamily_proc(opfamily, opcintype, opcintype,\n\t\t\t\t\t\t\t\t\t\t\tBTSORTSUPPORT_PROC);\n\tif (OidIsValid(sortSupportFunction))\n\t{\n\t\t/*\n\t\t * The sort support function can provide a comparator, but it can also\n\t\t * choose not to so (e.g. based on the selected collation).\n\t\t */\n\t\tOidFunctionCall1(sortSupportFunction, PointerGetDatum(ssup));\n\t}\n\n\tif (ssup->comparator == NULL)\n\t{\n\t\tOid\t\t\tsortFunction;\n\n\t\tsortFunction = get_opfamily_proc(opfamily, opcintype, opcintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\tif (!OidIsValid(sortFunction))\n\t\t\telog(ERROR, \"missing support function %d(%u,%u) in opfamily %u\",\n\t\t\t\t BTORDER_PROC, opcintype, opcintype, opfamily);\n\n\t\t/* We'll use a shim to call the old-style btree comparator */\n\t\tPrepareSortSupportComparisonShim(sortFunction, ssup);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"operator %u is not a valid ordering operator\"",
            "orderingOp"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ordering_op_properties",
          "args": [
            "orderingOp",
            "&opfamily",
            "&opcintype",
            "&strategy"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "get_ordering_op_properties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "203-250",
          "snippet": "bool\nget_ordering_op_properties(Oid opno,\n\t\t\t\t\t\t   Oid *opfamily, Oid *opcintype, int16 *strategy)\n{\n\tbool\t\tresult = false;\n\tCatCList   *catlist;\n\tint\t\t\ti;\n\n\t/* ensure outputs are initialized on failure */\n\t*opfamily = InvalidOid;\n\t*opcintype = InvalidOid;\n\t*strategy = 0;\n\n\t/*\n\t * Search pg_amop to see if the target operator is registered as the \"<\"\n\t * or \">\" operator of any btree opfamily.\n\t */\n\tcatlist = SearchSysCacheList1(AMOPOPID, ObjectIdGetDatum(opno));\n\n\tfor (i = 0; i < catlist->n_members; i++)\n\t{\n\t\tHeapTuple\ttuple = &catlist->members[i]->tuple;\n\t\tForm_pg_amop aform = (Form_pg_amop) GETSTRUCT(tuple);\n\n\t\t/* must be btree */\n\t\tif (aform->amopmethod != BTREE_AM_OID)\n\t\t\tcontinue;\n\n\t\tif (aform->amopstrategy == BTLessStrategyNumber ||\n\t\t\taform->amopstrategy == BTGreaterStrategyNumber)\n\t\t{\n\t\t\t/* Found it ... should have consistent input types */\n\t\t\tif (aform->amoplefttype == aform->amoprighttype)\n\t\t\t{\n\t\t\t\t/* Found a suitable opfamily, return info */\n\t\t\t\t*opfamily = aform->amopfamily;\n\t\t\t\t*opcintype = aform->amoplefttype;\n\t\t\t\t*strategy = aform->amopstrategy;\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tReleaseSysCacheList(catlist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_ordering_op_properties(Oid opno,\n\t\t\t\t\t\t   Oid *opfamily, Oid *opcintype, int16 *strategy)\n{\n\tbool\t\tresult = false;\n\tCatCList   *catlist;\n\tint\t\t\ti;\n\n\t/* ensure outputs are initialized on failure */\n\t*opfamily = InvalidOid;\n\t*opcintype = InvalidOid;\n\t*strategy = 0;\n\n\t/*\n\t * Search pg_amop to see if the target operator is registered as the \"<\"\n\t * or \">\" operator of any btree opfamily.\n\t */\n\tcatlist = SearchSysCacheList1(AMOPOPID, ObjectIdGetDatum(opno));\n\n\tfor (i = 0; i < catlist->n_members; i++)\n\t{\n\t\tHeapTuple\ttuple = &catlist->members[i]->tuple;\n\t\tForm_pg_amop aform = (Form_pg_amop) GETSTRUCT(tuple);\n\n\t\t/* must be btree */\n\t\tif (aform->amopmethod != BTREE_AM_OID)\n\t\t\tcontinue;\n\n\t\tif (aform->amopstrategy == BTLessStrategyNumber ||\n\t\t\taform->amopstrategy == BTGreaterStrategyNumber)\n\t\t{\n\t\t\t/* Found it ... should have consistent input types */\n\t\t\tif (aform->amoplefttype == aform->amoprighttype)\n\t\t\t{\n\t\t\t\t/* Found a suitable opfamily, return info */\n\t\t\t\t*opfamily = aform->amopfamily;\n\t\t\t\t*opcintype = aform->amoplefttype;\n\t\t\t\t*strategy = aform->amopstrategy;\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tReleaseSysCacheList(catlist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ssup->comparator == NULL"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_am.h\"\n#include \"access/nbtree.h\"\n#include \"postgres.h\"\n\nvoid\nPrepareSortSupportFromOrderingOp(Oid orderingOp, SortSupport ssup)\n{\n\tOid\t\t\topfamily;\n\tOid\t\t\topcintype;\n\tint16\t\tstrategy;\n\n\tAssert(ssup->comparator == NULL);\n\n\t/* Find the operator in pg_amop */\n\tif (!get_ordering_op_properties(orderingOp, &opfamily, &opcintype,\n\t\t\t\t\t\t\t\t\t&strategy))\n\t\telog(ERROR, \"operator %u is not a valid ordering operator\",\n\t\t\t orderingOp);\n\tssup->ssup_reverse = (strategy == BTGreaterStrategyNumber);\n\n\tFinishSortSupportFunction(opfamily, opcintype, ssup);\n}"
  },
  {
    "function_name": "FinishSortSupportFunction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sortsupport.c",
    "lines": "92-123",
    "snippet": "static void\nFinishSortSupportFunction(Oid opfamily, Oid opcintype, SortSupport ssup)\n{\n\tOid\t\t\tsortSupportFunction;\n\n\t/* Look for a sort support function */\n\tsortSupportFunction = get_opfamily_proc(opfamily, opcintype, opcintype,\n\t\t\t\t\t\t\t\t\t\t\tBTSORTSUPPORT_PROC);\n\tif (OidIsValid(sortSupportFunction))\n\t{\n\t\t/*\n\t\t * The sort support function can provide a comparator, but it can also\n\t\t * choose not to so (e.g. based on the selected collation).\n\t\t */\n\t\tOidFunctionCall1(sortSupportFunction, PointerGetDatum(ssup));\n\t}\n\n\tif (ssup->comparator == NULL)\n\t{\n\t\tOid\t\t\tsortFunction;\n\n\t\tsortFunction = get_opfamily_proc(opfamily, opcintype, opcintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\tif (!OidIsValid(sortFunction))\n\t\t\telog(ERROR, \"missing support function %d(%u,%u) in opfamily %u\",\n\t\t\t\t BTORDER_PROC, opcintype, opcintype, opfamily);\n\n\t\t/* We'll use a shim to call the old-style btree comparator */\n\t\tPrepareSortSupportComparisonShim(sortFunction, ssup);\n\t}\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrepareSortSupportComparisonShim",
          "args": [
            "sortFunction",
            "ssup"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareSortSupportComparisonShim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sortsupport.c",
          "lines": "66-85",
          "snippet": "void\nPrepareSortSupportComparisonShim(Oid cmpFunc, SortSupport ssup)\n{\n\tSortShimExtra *extra;\n\n\textra = (SortShimExtra *) MemoryContextAlloc(ssup->ssup_cxt,\n\t\t\t\t\t\t\t\t\t\t\t\t sizeof(SortShimExtra));\n\n\t/* Lookup the comparison function */\n\tfmgr_info_cxt(cmpFunc, &extra->flinfo, ssup->ssup_cxt);\n\n\t/* We can initialize the callinfo just once and re-use it */\n\tInitFunctionCallInfoData(extra->fcinfo, &extra->flinfo, 2,\n\t\t\t\t\t\t\t ssup->ssup_collation, NULL, NULL);\n\textra->fcinfo.argnull[0] = false;\n\textra->fcinfo.argnull[1] = false;\n\n\tssup->ssup_extra = extra;\n\tssup->comparator = comparison_shim;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_am.h\"\n#include \"access/nbtree.h\"\n#include \"postgres.h\"\n\nvoid\nPrepareSortSupportComparisonShim(Oid cmpFunc, SortSupport ssup)\n{\n\tSortShimExtra *extra;\n\n\textra = (SortShimExtra *) MemoryContextAlloc(ssup->ssup_cxt,\n\t\t\t\t\t\t\t\t\t\t\t\t sizeof(SortShimExtra));\n\n\t/* Lookup the comparison function */\n\tfmgr_info_cxt(cmpFunc, &extra->flinfo, ssup->ssup_cxt);\n\n\t/* We can initialize the callinfo just once and re-use it */\n\tInitFunctionCallInfoData(extra->fcinfo, &extra->flinfo, 2,\n\t\t\t\t\t\t\t ssup->ssup_collation, NULL, NULL);\n\textra->fcinfo.argnull[0] = false;\n\textra->fcinfo.argnull[1] = false;\n\n\tssup->ssup_extra = extra;\n\tssup->comparator = comparison_shim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"missing support function %d(%u,%u) in opfamily %u\"",
            "BTORDER_PROC",
            "opcintype",
            "opcintype",
            "opfamily"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "sortFunction"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_opfamily_proc",
          "args": [
            "opfamily",
            "opcintype",
            "opcintype",
            "BTORDER_PROC"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "get_opfamily_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "743-761",
          "snippet": "Oid\nget_opfamily_proc(Oid opfamily, Oid lefttype, Oid righttype, int16 procnum)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amproc amproc_tup;\n\tRegProcedure result;\n\n\ttp = SearchSysCache4(AMPROCNUM,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(procnum));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamproc_tup = (Form_pg_amproc) GETSTRUCT(tp);\n\tresult = amproc_tup->amproc;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_opfamily_proc(Oid opfamily, Oid lefttype, Oid righttype, int16 procnum)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amproc amproc_tup;\n\tRegProcedure result;\n\n\ttp = SearchSysCache4(AMPROCNUM,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(procnum));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamproc_tup = (Form_pg_amproc) GETSTRUCT(tp);\n\tresult = amproc_tup->amproc;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidFunctionCall1",
          "args": [
            "sortSupportFunction",
            "PointerGetDatum(ssup)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "ssup"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "sortSupportFunction"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_am.h\"\n#include \"access/nbtree.h\"\n#include \"postgres.h\"\n\nstatic void\nFinishSortSupportFunction(Oid opfamily, Oid opcintype, SortSupport ssup)\n{\n\tOid\t\t\tsortSupportFunction;\n\n\t/* Look for a sort support function */\n\tsortSupportFunction = get_opfamily_proc(opfamily, opcintype, opcintype,\n\t\t\t\t\t\t\t\t\t\t\tBTSORTSUPPORT_PROC);\n\tif (OidIsValid(sortSupportFunction))\n\t{\n\t\t/*\n\t\t * The sort support function can provide a comparator, but it can also\n\t\t * choose not to so (e.g. based on the selected collation).\n\t\t */\n\t\tOidFunctionCall1(sortSupportFunction, PointerGetDatum(ssup));\n\t}\n\n\tif (ssup->comparator == NULL)\n\t{\n\t\tOid\t\t\tsortFunction;\n\n\t\tsortFunction = get_opfamily_proc(opfamily, opcintype, opcintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\tif (!OidIsValid(sortFunction))\n\t\t\telog(ERROR, \"missing support function %d(%u,%u) in opfamily %u\",\n\t\t\t\t BTORDER_PROC, opcintype, opcintype, opfamily);\n\n\t\t/* We'll use a shim to call the old-style btree comparator */\n\t\tPrepareSortSupportComparisonShim(sortFunction, ssup);\n\t}\n}"
  },
  {
    "function_name": "PrepareSortSupportComparisonShim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sortsupport.c",
    "lines": "66-85",
    "snippet": "void\nPrepareSortSupportComparisonShim(Oid cmpFunc, SortSupport ssup)\n{\n\tSortShimExtra *extra;\n\n\textra = (SortShimExtra *) MemoryContextAlloc(ssup->ssup_cxt,\n\t\t\t\t\t\t\t\t\t\t\t\t sizeof(SortShimExtra));\n\n\t/* Lookup the comparison function */\n\tfmgr_info_cxt(cmpFunc, &extra->flinfo, ssup->ssup_cxt);\n\n\t/* We can initialize the callinfo just once and re-use it */\n\tInitFunctionCallInfoData(extra->fcinfo, &extra->flinfo, 2,\n\t\t\t\t\t\t\t ssup->ssup_collation, NULL, NULL);\n\textra->fcinfo.argnull[0] = false;\n\textra->fcinfo.argnull[1] = false;\n\n\tssup->ssup_extra = extra;\n\tssup->comparator = comparison_shim;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "extra->fcinfo",
            "&extra->flinfo",
            "2",
            "ssup->ssup_collation",
            "NULL",
            "NULL"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "cmpFunc",
            "&extra->flinfo",
            "ssup->ssup_cxt"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "ssup->ssup_cxt",
            "sizeof(SortShimExtra)"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_am.h\"\n#include \"access/nbtree.h\"\n#include \"postgres.h\"\n\nvoid\nPrepareSortSupportComparisonShim(Oid cmpFunc, SortSupport ssup)\n{\n\tSortShimExtra *extra;\n\n\textra = (SortShimExtra *) MemoryContextAlloc(ssup->ssup_cxt,\n\t\t\t\t\t\t\t\t\t\t\t\t sizeof(SortShimExtra));\n\n\t/* Lookup the comparison function */\n\tfmgr_info_cxt(cmpFunc, &extra->flinfo, ssup->ssup_cxt);\n\n\t/* We can initialize the callinfo just once and re-use it */\n\tInitFunctionCallInfoData(extra->fcinfo, &extra->flinfo, 2,\n\t\t\t\t\t\t\t ssup->ssup_collation, NULL, NULL);\n\textra->fcinfo.argnull[0] = false;\n\textra->fcinfo.argnull[1] = false;\n\n\tssup->ssup_extra = extra;\n\tssup->comparator = comparison_shim;\n}"
  },
  {
    "function_name": "comparison_shim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sortsupport.c",
    "lines": "41-60",
    "snippet": "static int\ncomparison_shim(Datum x, Datum y, SortSupport ssup)\n{\n\tSortShimExtra *extra = (SortShimExtra *) ssup->ssup_extra;\n\tDatum\t\tresult;\n\n\textra->fcinfo.arg[0] = x;\n\textra->fcinfo.arg[1] = y;\n\n\t/* just for paranoia's sake, we reset isnull each time */\n\textra->fcinfo.isnull = false;\n\n\tresult = FunctionCallInvoke(&extra->fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (extra->fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", extra->flinfo.fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "extra->flinfo.fn_oid"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&extra->fcinfo"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_am.h\"\n#include \"access/nbtree.h\"\n#include \"postgres.h\"\n\nstatic int\ncomparison_shim(Datum x, Datum y, SortSupport ssup)\n{\n\tSortShimExtra *extra = (SortShimExtra *) ssup->ssup_extra;\n\tDatum\t\tresult;\n\n\textra->fcinfo.arg[0] = x;\n\textra->fcinfo.arg[1] = y;\n\n\t/* just for paranoia's sake, we reset isnull each time */\n\textra->fcinfo.isnull = false;\n\n\tresult = FunctionCallInvoke(&extra->fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (extra->fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", extra->flinfo.fn_oid);\n\n\treturn result;\n}"
  }
]