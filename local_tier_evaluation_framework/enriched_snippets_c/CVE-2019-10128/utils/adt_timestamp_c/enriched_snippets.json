[
  {
    "function_name": "generate_series_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "5359-5435",
    "snippet": "Datum\ngenerate_series_timestamptz(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tgenerate_series_timestamptz_fctx *fctx;\n\tTimestampTz result;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTimestampTz start = PG_GETARG_TIMESTAMPTZ(0);\n\t\tTimestampTz finish = PG_GETARG_TIMESTAMPTZ(1);\n\t\tInterval   *step = PG_GETARG_INTERVAL_P(2);\n\t\tMemoryContext oldcontext;\n\t\tInterval\tinterval_zero;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* allocate memory for user context */\n\t\tfctx = (generate_series_timestamptz_fctx *)\n\t\t\tpalloc(sizeof(generate_series_timestamptz_fctx));\n\n\t\t/*\n\t\t * Use fctx to keep state from call to call. Seed current with the\n\t\t * original start value\n\t\t */\n\t\tfctx->current = start;\n\t\tfctx->finish = finish;\n\t\tfctx->step = *step;\n\n\t\t/* Determine sign of the interval */\n\t\tMemSet(&interval_zero, 0, sizeof(Interval));\n\t\tfctx->step_sign = interval_cmp_internal(&fctx->step, &interval_zero);\n\n\t\tif (fctx->step_sign == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"step size cannot equal zero\")));\n\n\t\tfuncctx->user_fctx = fctx;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\n\t/*\n\t * get the saved state and use current as the result for this iteration\n\t */\n\tfctx = funcctx->user_fctx;\n\tresult = fctx->current;\n\n\tif (fctx->step_sign > 0 ?\n\t\ttimestamp_cmp_internal(result, fctx->finish) <= 0 :\n\t\ttimestamp_cmp_internal(result, fctx->finish) >= 0)\n\t{\n\t\t/* increment current in preparation for next iteration */\n\t\tfctx->current = DatumGetTimestampTz(\n\t\t\t\t\t\t\t\t\t\t\tDirectFunctionCall2(timestamptz_pl_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTimestampTzGetDatum(fctx->current),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(&fctx->step)));\n\n\t\t/* do when there is more left to send */\n\t\tSRF_RETURN_NEXT(funcctx, TimestampTzGetDatum(result));\n\t}\n\telse\n\t{\n\t\t/* do when there is no more left */\n\t\tSRF_RETURN_DONE(funcctx);\n\t}\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 5433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "TimestampTzGetDatum(result)"
          ],
          "line": 5428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampTzGetDatum",
          "args": [
            "result"
          ],
          "line": 5428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTimestampTz",
          "args": [
            "DirectFunctionCall2(timestamptz_pl_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTimestampTzGetDatum(fctx->current),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(&fctx->step))"
          ],
          "line": 5422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "timestamptz_pl_interval",
            "TimestampTzGetDatum(fctx->current)",
            "PointerGetDatum(&fctx->step)"
          ],
          "line": 5423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "&fctx->step"
          ],
          "line": 5425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampTzGetDatum",
          "args": [
            "fctx->current"
          ],
          "line": 5424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "result",
            "fctx->finish"
          ],
          "line": 5419
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 5409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 5405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"step size cannot equal zero\"))"
          ],
          "line": 5400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"step size cannot equal zero\""
          ],
          "line": 5402
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 5401
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "interval_cmp_internal",
          "args": [
            "&fctx->step",
            "&interval_zero"
          ],
          "line": 5397
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2333-2340",
          "snippet": "static int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&interval_zero",
            "0",
            "sizeof(Interval)"
          ],
          "line": 5396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(generate_series_timestamptz_fctx)"
          ],
          "line": 5385
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 5381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 5376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "2"
          ],
          "line": 5371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 5370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 5369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 5367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ngenerate_series_timestamptz(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tgenerate_series_timestamptz_fctx *fctx;\n\tTimestampTz result;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTimestampTz start = PG_GETARG_TIMESTAMPTZ(0);\n\t\tTimestampTz finish = PG_GETARG_TIMESTAMPTZ(1);\n\t\tInterval   *step = PG_GETARG_INTERVAL_P(2);\n\t\tMemoryContext oldcontext;\n\t\tInterval\tinterval_zero;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* allocate memory for user context */\n\t\tfctx = (generate_series_timestamptz_fctx *)\n\t\t\tpalloc(sizeof(generate_series_timestamptz_fctx));\n\n\t\t/*\n\t\t * Use fctx to keep state from call to call. Seed current with the\n\t\t * original start value\n\t\t */\n\t\tfctx->current = start;\n\t\tfctx->finish = finish;\n\t\tfctx->step = *step;\n\n\t\t/* Determine sign of the interval */\n\t\tMemSet(&interval_zero, 0, sizeof(Interval));\n\t\tfctx->step_sign = interval_cmp_internal(&fctx->step, &interval_zero);\n\n\t\tif (fctx->step_sign == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"step size cannot equal zero\")));\n\n\t\tfuncctx->user_fctx = fctx;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\n\t/*\n\t * get the saved state and use current as the result for this iteration\n\t */\n\tfctx = funcctx->user_fctx;\n\tresult = fctx->current;\n\n\tif (fctx->step_sign > 0 ?\n\t\ttimestamp_cmp_internal(result, fctx->finish) <= 0 :\n\t\ttimestamp_cmp_internal(result, fctx->finish) >= 0)\n\t{\n\t\t/* increment current in preparation for next iteration */\n\t\tfctx->current = DatumGetTimestampTz(\n\t\t\t\t\t\t\t\t\t\t\tDirectFunctionCall2(timestamptz_pl_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTimestampTzGetDatum(fctx->current),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(&fctx->step)));\n\n\t\t/* do when there is more left to send */\n\t\tSRF_RETURN_NEXT(funcctx, TimestampTzGetDatum(result));\n\t}\n\telse\n\t{\n\t\t/* do when there is no more left */\n\t\tSRF_RETURN_DONE(funcctx);\n\t}\n}"
  },
  {
    "function_name": "generate_series_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "5278-5354",
    "snippet": "Datum\ngenerate_series_timestamp(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tgenerate_series_timestamp_fctx *fctx;\n\tTimestamp\tresult;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTimestamp\tstart = PG_GETARG_TIMESTAMP(0);\n\t\tTimestamp\tfinish = PG_GETARG_TIMESTAMP(1);\n\t\tInterval   *step = PG_GETARG_INTERVAL_P(2);\n\t\tMemoryContext oldcontext;\n\t\tInterval\tinterval_zero;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* allocate memory for user context */\n\t\tfctx = (generate_series_timestamp_fctx *)\n\t\t\tpalloc(sizeof(generate_series_timestamp_fctx));\n\n\t\t/*\n\t\t * Use fctx to keep state from call to call. Seed current with the\n\t\t * original start value\n\t\t */\n\t\tfctx->current = start;\n\t\tfctx->finish = finish;\n\t\tfctx->step = *step;\n\n\t\t/* Determine sign of the interval */\n\t\tMemSet(&interval_zero, 0, sizeof(Interval));\n\t\tfctx->step_sign = interval_cmp_internal(&fctx->step, &interval_zero);\n\n\t\tif (fctx->step_sign == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"step size cannot equal zero\")));\n\n\t\tfuncctx->user_fctx = fctx;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\n\t/*\n\t * get the saved state and use current as the result for this iteration\n\t */\n\tfctx = funcctx->user_fctx;\n\tresult = fctx->current;\n\n\tif (fctx->step_sign > 0 ?\n\t\ttimestamp_cmp_internal(result, fctx->finish) <= 0 :\n\t\ttimestamp_cmp_internal(result, fctx->finish) >= 0)\n\t{\n\t\t/* increment current in preparation for next iteration */\n\t\tfctx->current = DatumGetTimestamp(\n\t\t\t\t\t\t\t\t\t\t  DirectFunctionCall2(timestamp_pl_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  TimestampGetDatum(fctx->current),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(&fctx->step)));\n\n\t\t/* do when there is more left to send */\n\t\tSRF_RETURN_NEXT(funcctx, TimestampGetDatum(result));\n\t}\n\telse\n\t{\n\t\t/* do when there is no more left */\n\t\tSRF_RETURN_DONE(funcctx);\n\t}\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 5352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "TimestampGetDatum(result)"
          ],
          "line": 5347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampGetDatum",
          "args": [
            "result"
          ],
          "line": 5347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTimestamp",
          "args": [
            "DirectFunctionCall2(timestamp_pl_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  TimestampGetDatum(fctx->current),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(&fctx->step))"
          ],
          "line": 5341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "timestamp_pl_interval",
            "TimestampGetDatum(fctx->current)",
            "PointerGetDatum(&fctx->step)"
          ],
          "line": 5342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "&fctx->step"
          ],
          "line": 5344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampGetDatum",
          "args": [
            "fctx->current"
          ],
          "line": 5343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "result",
            "fctx->finish"
          ],
          "line": 5338
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 5328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 5324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"step size cannot equal zero\"))"
          ],
          "line": 5319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"step size cannot equal zero\""
          ],
          "line": 5321
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 5320
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "interval_cmp_internal",
          "args": [
            "&fctx->step",
            "&interval_zero"
          ],
          "line": 5316
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2333-2340",
          "snippet": "static int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&interval_zero",
            "0",
            "sizeof(Interval)"
          ],
          "line": 5315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(generate_series_timestamp_fctx)"
          ],
          "line": 5304
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 5300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 5295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "2"
          ],
          "line": 5290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 5289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 5288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 5286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ngenerate_series_timestamp(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tgenerate_series_timestamp_fctx *fctx;\n\tTimestamp\tresult;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTimestamp\tstart = PG_GETARG_TIMESTAMP(0);\n\t\tTimestamp\tfinish = PG_GETARG_TIMESTAMP(1);\n\t\tInterval   *step = PG_GETARG_INTERVAL_P(2);\n\t\tMemoryContext oldcontext;\n\t\tInterval\tinterval_zero;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* allocate memory for user context */\n\t\tfctx = (generate_series_timestamp_fctx *)\n\t\t\tpalloc(sizeof(generate_series_timestamp_fctx));\n\n\t\t/*\n\t\t * Use fctx to keep state from call to call. Seed current with the\n\t\t * original start value\n\t\t */\n\t\tfctx->current = start;\n\t\tfctx->finish = finish;\n\t\tfctx->step = *step;\n\n\t\t/* Determine sign of the interval */\n\t\tMemSet(&interval_zero, 0, sizeof(Interval));\n\t\tfctx->step_sign = interval_cmp_internal(&fctx->step, &interval_zero);\n\n\t\tif (fctx->step_sign == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"step size cannot equal zero\")));\n\n\t\tfuncctx->user_fctx = fctx;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\n\t/*\n\t * get the saved state and use current as the result for this iteration\n\t */\n\tfctx = funcctx->user_fctx;\n\tresult = fctx->current;\n\n\tif (fctx->step_sign > 0 ?\n\t\ttimestamp_cmp_internal(result, fctx->finish) <= 0 :\n\t\ttimestamp_cmp_internal(result, fctx->finish) >= 0)\n\t{\n\t\t/* increment current in preparation for next iteration */\n\t\tfctx->current = DatumGetTimestamp(\n\t\t\t\t\t\t\t\t\t\t  DirectFunctionCall2(timestamp_pl_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  TimestampGetDatum(fctx->current),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(&fctx->step)));\n\n\t\t/* do when there is more left to send */\n\t\tSRF_RETURN_NEXT(funcctx, TimestampGetDatum(result));\n\t}\n\telse\n\t{\n\t\t/* do when there is no more left */\n\t\tSRF_RETURN_DONE(funcctx);\n\t}\n}"
  },
  {
    "function_name": "timestamptz_izone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "5245-5273",
    "snippet": "Datum\ntimestamptz_izone(PG_FUNCTION_ARGS)\n{\n\tInterval   *zone = PG_GETARG_INTERVAL_P(0);\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestamp\tresult;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_TIMESTAMP(timestamp);\n\n\tif (zone->month != 0 || zone->day != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval time zone \\\"%s\\\" must not include months or days\",\n\t\t\t\t\t\tDatumGetCString(DirectFunctionCall1(interval_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(zone))))));\n\n\ttz = -(zone->time / USECS_PER_SEC);\n\n\tresult = dt2local(timestamp, tz);\n\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 5272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 5268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 5270
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 5269
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 5267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt2local",
          "args": [
            "timestamp",
            "tz"
          ],
          "line": 5265
        },
        "resolved": true,
        "details": {
          "function_name": "dt2local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1951-1956",
          "snippet": "static Timestamp\ndt2local(Timestamp dt, int tz)\n{\n\tdt -= (tz * USECS_PER_SEC);\n\treturn dt;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Timestamp\ndt2local(Timestamp dt, int tz)\n{\n\tdt -= (tz * USECS_PER_SEC);\n\treturn dt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval time zone \\\"%s\\\" must not include months or days\",\n\t\t\t\t\t\tDatumGetCString(DirectFunctionCall1(interval_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(zone)))))"
          ],
          "line": 5257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(interval_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(zone))"
          ],
          "line": 5260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "interval_out",
            "PointerGetDatum(zone)"
          ],
          "line": 5260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "zone"
          ],
          "line": 5261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "timestamp"
          ],
          "line": 5254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 5253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 5249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 5248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamptz_izone(PG_FUNCTION_ARGS)\n{\n\tInterval   *zone = PG_GETARG_INTERVAL_P(0);\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestamp\tresult;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_TIMESTAMP(timestamp);\n\n\tif (zone->month != 0 || zone->day != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval time zone \\\"%s\\\" must not include months or days\",\n\t\t\t\t\t\tDatumGetCString(DirectFunctionCall1(interval_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(zone))))));\n\n\ttz = -(zone->time / USECS_PER_SEC);\n\n\tresult = dt2local(timestamp, tz);\n\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "timestamptz_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "5158-5239",
    "snippet": "Datum\ntimestamptz_zone(PG_FUNCTION_ARGS)\n{\n\ttext\t   *zone = PG_GETARG_TEXT_PP(0);\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestamp\tresult;\n\tint\t\t\ttz;\n\tchar\t\ttzname[TZ_STRLEN_MAX + 1];\n\tchar\t   *lowzone;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tpg_tz\t   *tzp;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_TIMESTAMP(timestamp);\n\n\t/*\n\t * Look up the requested timezone.  First we look in the timezone\n\t * abbreviation table (to handle cases like \"EST\"), and if that fails, we\n\t * look in the timezone database (to handle cases like\n\t * \"America/New_York\").  (This matches the order in which timestamp input\n\t * checks the cases; it's important because the timezone database unwisely\n\t * uses a few zone names that are identical to offset abbreviations.)\n\t */\n\ttext_to_cstring_buffer(zone, tzname, sizeof(tzname));\n\n\t/* DecodeTimezoneAbbrev requires lowercase input */\n\tlowzone = downcase_truncate_identifier(tzname,\n\t\t\t\t\t\t\t\t\t\t   strlen(tzname),\n\t\t\t\t\t\t\t\t\t\t   false);\n\n\ttype = DecodeTimezoneAbbrev(0, lowzone, &val, &tzp);\n\n\tif (type == TZ || type == DTZ)\n\t{\n\t\t/* fixed-offset abbreviation */\n\t\ttz = -val;\n\t\tresult = dt2local(timestamp, tz);\n\t}\n\telse if (type == DYNTZ)\n\t{\n\t\t/* dynamic-offset abbreviation, resolve using specified time */\n\t\tint\t\t\tisdst;\n\n\t\ttz = DetermineTimeZoneAbbrevOffsetTS(timestamp, tzname, tzp, &isdst);\n\t\tresult = dt2local(timestamp, tz);\n\t}\n\telse\n\t{\n\t\t/* try it as a full zone name */\n\t\ttzp = pg_tzset(tzname);\n\t\tif (tzp)\n\t\t{\n\t\t\t/* Apply the timezone change */\n\t\t\tstruct pg_tm tm;\n\t\t\tfsec_t\t\tfsec;\n\n\t\t\tif (timestamp2tm(timestamp, &tz, &tm, &fsec, NULL, tzp) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\tif (tm2timestamp(&tm, fsec, NULL, &result) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname)));\n\t\t\tresult = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static Timestamp dt2local(Timestamp dt, int timezone);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 5238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 5234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 5236
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 5235
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 5233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname))"
          ],
          "line": 5226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 5220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm2timestamp",
          "args": [
            "&tm",
            "fsec",
            "NULL",
            "&result"
          ],
          "line": 5219
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1853-1895",
          "snippet": "int\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 5216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "&tz",
            "&tm",
            "&fsec",
            "NULL",
            "tzp"
          ],
          "line": 5215
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_tzset",
          "args": [
            "tzname"
          ],
          "line": 5208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt2local",
          "args": [
            "timestamp",
            "tz"
          ],
          "line": 5203
        },
        "resolved": true,
        "details": {
          "function_name": "dt2local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1951-1956",
          "snippet": "static Timestamp\ndt2local(Timestamp dt, int tz)\n{\n\tdt -= (tz * USECS_PER_SEC);\n\treturn dt;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Timestamp\ndt2local(Timestamp dt, int tz)\n{\n\tdt -= (tz * USECS_PER_SEC);\n\treturn dt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneAbbrevOffsetTS",
          "args": [
            "timestamp",
            "tzname",
            "tzp",
            "&isdst"
          ],
          "line": 5202
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneAbbrevOffsetTS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1653-1682",
          "snippet": "int\nDetermineTimeZoneAbbrevOffsetTS(TimestampTz ts, const char *abbr,\n\t\t\t\t\t\t\t\tpg_tz *tzp, int *isdst)\n{\n\tpg_time_t\tt = timestamptz_to_time_t(ts);\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\ttz;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\n\t/*\n\t * If the abbrev matches anything in the zone data, this is pretty easy.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, isdst))\n\t\treturn abbr_offset;\n\n\t/*\n\t * Else, break down the timestamp so we can use DetermineTimeZoneOffset.\n\t */\n\tif (timestamp2tm(ts, &tz, &tm, &fsec, NULL, tzp) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tzone_offset = DetermineTimeZoneOffset(&tm, tzp);\n\t*isdst = tm.tm_isdst;\n\treturn zone_offset;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "static bool DetermineTimeZoneAbbrevOffsetInternal(pg_time_t t,\n\t\t\t\t\t\t\t\t\t  const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nstatic bool DetermineTimeZoneAbbrevOffsetInternal(pg_time_t t,\n\t\t\t\t\t\t\t\t\t  const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst);\n\nint\nDetermineTimeZoneAbbrevOffsetTS(TimestampTz ts, const char *abbr,\n\t\t\t\t\t\t\t\tpg_tz *tzp, int *isdst)\n{\n\tpg_time_t\tt = timestamptz_to_time_t(ts);\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\ttz;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\n\t/*\n\t * If the abbrev matches anything in the zone data, this is pretty easy.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, isdst))\n\t\treturn abbr_offset;\n\n\t/*\n\t * Else, break down the timestamp so we can use DetermineTimeZoneOffset.\n\t */\n\tif (timestamp2tm(ts, &tz, &tm, &fsec, NULL, tzp) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tzone_offset = DetermineTimeZoneOffset(&tm, tzp);\n\t*isdst = tm.tm_isdst;\n\treturn zone_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeTimezoneAbbrev",
          "args": [
            "0",
            "lowzone",
            "&val",
            "&tzp"
          ],
          "line": 5189
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeTimezoneAbbrev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2970-3010",
          "snippet": "int\nDecodeTimezoneAbbrev(int field, char *lowtoken,\n\t\t\t\t\t int *offset, pg_tz **tz)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = abbrevcache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\tif (zoneabbrevtbl)\n\t\t\ttp = datebsearch(lowtoken, zoneabbrevtbl->abbrevs,\n\t\t\t\t\t\t\t zoneabbrevtbl->numabbrevs);\n\t\telse\n\t\t\ttp = NULL;\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*offset = 0;\n\t\t*tz = NULL;\n\t}\n\telse\n\t{\n\t\tabbrevcache[field] = tp;\n\t\ttype = tp->type;\n\t\tif (type == DYNTZ)\n\t\t{\n\t\t\t*offset = 0;\n\t\t\t*tz = FetchDynamicTimeZone(zoneabbrevtbl, tp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*offset = tp->value;\n\t\t\t*tz = NULL;\n\t\t}\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static TimeZoneAbbrevTable *zoneabbrevtbl = NULL;",
            "static const datetkn *abbrevcache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic TimeZoneAbbrevTable *zoneabbrevtbl = NULL;\nstatic const datetkn *abbrevcache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeTimezoneAbbrev(int field, char *lowtoken,\n\t\t\t\t\t int *offset, pg_tz **tz)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = abbrevcache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\tif (zoneabbrevtbl)\n\t\t\ttp = datebsearch(lowtoken, zoneabbrevtbl->abbrevs,\n\t\t\t\t\t\t\t zoneabbrevtbl->numabbrevs);\n\t\telse\n\t\t\ttp = NULL;\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*offset = 0;\n\t\t*tz = NULL;\n\t}\n\telse\n\t{\n\t\tabbrevcache[field] = tp;\n\t\ttype = tp->type;\n\t\tif (type == DYNTZ)\n\t\t{\n\t\t\t*offset = 0;\n\t\t\t*tz = FetchDynamicTimeZone(zoneabbrevtbl, tp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*offset = tp->value;\n\t\t\t*tz = NULL;\n\t\t}\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcase_truncate_identifier",
          "args": [
            "tzname",
            "strlen(tzname)",
            "false"
          ],
          "line": 5185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tzname"
          ],
          "line": 5186
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring_buffer",
          "args": [
            "zone",
            "tzname",
            "sizeof(tzname)"
          ],
          "line": 5182
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "212-232",
          "snippet": "void\ntext_to_cstring_buffer(const text *src, char *dst, size_t dst_len)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *srcunpacked = pg_detoast_datum_packed((struct varlena *) src);\n\tsize_t\t\tsrc_len = VARSIZE_ANY_EXHDR(srcunpacked);\n\n\tif (dst_len > 0)\n\t{\n\t\tdst_len--;\n\t\tif (dst_len >= src_len)\n\t\t\tdst_len = src_len;\n\t\telse\t\t\t\t\t/* ensure truncation is encoding-safe */\n\t\t\tdst_len = pg_mbcliplen(VARDATA_ANY(srcunpacked), src_len, dst_len);\n\t\tmemcpy(dst, VARDATA_ANY(srcunpacked), dst_len);\n\t\tdst[dst_len] = '\\0';\n\t}\n\n\tif (srcunpacked != src)\n\t\tpfree(srcunpacked);\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\ntext_to_cstring_buffer(const text *src, char *dst, size_t dst_len)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *srcunpacked = pg_detoast_datum_packed((struct varlena *) src);\n\tsize_t\t\tsrc_len = VARSIZE_ANY_EXHDR(srcunpacked);\n\n\tif (dst_len > 0)\n\t{\n\t\tdst_len--;\n\t\tif (dst_len >= src_len)\n\t\t\tdst_len = src_len;\n\t\telse\t\t\t\t\t/* ensure truncation is encoding-safe */\n\t\t\tdst_len = pg_mbcliplen(VARDATA_ANY(srcunpacked), src_len, dst_len);\n\t\tmemcpy(dst, VARDATA_ANY(srcunpacked), dst_len);\n\t\tdst[dst_len] = '\\0';\n\t}\n\n\tif (srcunpacked != src)\n\t\tpfree(srcunpacked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "timestamp"
          ],
          "line": 5172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 5171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 5162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 5161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamptz_zone(PG_FUNCTION_ARGS)\n{\n\ttext\t   *zone = PG_GETARG_TEXT_PP(0);\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestamp\tresult;\n\tint\t\t\ttz;\n\tchar\t\ttzname[TZ_STRLEN_MAX + 1];\n\tchar\t   *lowzone;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tpg_tz\t   *tzp;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_TIMESTAMP(timestamp);\n\n\t/*\n\t * Look up the requested timezone.  First we look in the timezone\n\t * abbreviation table (to handle cases like \"EST\"), and if that fails, we\n\t * look in the timezone database (to handle cases like\n\t * \"America/New_York\").  (This matches the order in which timestamp input\n\t * checks the cases; it's important because the timezone database unwisely\n\t * uses a few zone names that are identical to offset abbreviations.)\n\t */\n\ttext_to_cstring_buffer(zone, tzname, sizeof(tzname));\n\n\t/* DecodeTimezoneAbbrev requires lowercase input */\n\tlowzone = downcase_truncate_identifier(tzname,\n\t\t\t\t\t\t\t\t\t\t   strlen(tzname),\n\t\t\t\t\t\t\t\t\t\t   false);\n\n\ttype = DecodeTimezoneAbbrev(0, lowzone, &val, &tzp);\n\n\tif (type == TZ || type == DTZ)\n\t{\n\t\t/* fixed-offset abbreviation */\n\t\ttz = -val;\n\t\tresult = dt2local(timestamp, tz);\n\t}\n\telse if (type == DYNTZ)\n\t{\n\t\t/* dynamic-offset abbreviation, resolve using specified time */\n\t\tint\t\t\tisdst;\n\n\t\ttz = DetermineTimeZoneAbbrevOffsetTS(timestamp, tzname, tzp, &isdst);\n\t\tresult = dt2local(timestamp, tz);\n\t}\n\telse\n\t{\n\t\t/* try it as a full zone name */\n\t\ttzp = pg_tzset(tzname);\n\t\tif (tzp)\n\t\t{\n\t\t\t/* Apply the timezone change */\n\t\t\tstruct pg_tm tm;\n\t\t\tfsec_t\t\tfsec;\n\n\t\t\tif (timestamp2tm(timestamp, &tz, &tm, &fsec, NULL, tzp) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\tif (tm2timestamp(&tm, fsec, NULL, &result) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname)));\n\t\t\tresult = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "timestamptz2timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "5129-5152",
    "snippet": "static Timestamp\ntimestamptz2timestamp(TimestampTz timestamp)\n{\n\tTimestamp\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 5147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 5149
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 5148
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm2timestamp",
          "args": [
            "tm",
            "fsec",
            "NULL",
            "&result"
          ],
          "line": 5146
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1853-1895",
          "snippet": "int\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 5143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "&tz",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 5142
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 5138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic Timestamp\ntimestamptz2timestamp(TimestampTz timestamp)\n{\n\tTimestamp\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "timestamptz_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "5121-5127",
    "snippet": "Datum\ntimestamptz_timestamp(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(0);\n\n\tPG_RETURN_TIMESTAMP(timestamptz2timestamp(timestamp));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "timestamptz2timestamp(timestamp)"
          ],
          "line": 5126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamptz2timestamp",
          "args": [
            "timestamp"
          ],
          "line": 5126
        },
        "resolved": true,
        "details": {
          "function_name": "timestamptz2timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5129-5152",
          "snippet": "static Timestamp\ntimestamptz2timestamp(TimestampTz timestamp)\n{\n\tTimestamp\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic Timestamp\ntimestamptz2timestamp(TimestampTz timestamp)\n{\n\tTimestamp\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 5124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamptz_timestamp(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(0);\n\n\tPG_RETURN_TIMESTAMP(timestamptz2timestamp(timestamp));\n}"
  },
  {
    "function_name": "timestamp2timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "5089-5116",
    "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 5110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 5112
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 5111
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm2timestamp",
          "args": [
            "tm",
            "fsec",
            "&tz",
            "&result"
          ],
          "line": 5109
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1853-1895",
          "snippet": "int\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneOffset",
          "args": [
            "tm",
            "session_timezone"
          ],
          "line": 5107
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1454-1460",
          "snippet": "int\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 5103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "NULL",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 5102
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 5098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "timestamp_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "5081-5087",
    "snippet": "Datum\ntimestamp_timestamptz(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\n\tPG_RETURN_TIMESTAMPTZ(timestamp2timestamptz(timestamp));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "timestamp2timestamptz(timestamp)"
          ],
          "line": 5086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2timestamptz",
          "args": [
            "timestamp"
          ],
          "line": 5086
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5089-5116",
          "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 5084
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamp_timestamptz(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\n\tPG_RETURN_TIMESTAMPTZ(timestamp2timestamptz(timestamp));\n}"
  },
  {
    "function_name": "timestamp_izone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "5048-5076",
    "snippet": "Datum\ntimestamp_izone(PG_FUNCTION_ARGS)\n{\n\tInterval   *zone = PG_GETARG_INTERVAL_P(0);\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz result;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_TIMESTAMPTZ(timestamp);\n\n\tif (zone->month != 0 || zone->day != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval time zone \\\"%s\\\" must not include months or days\",\n\t\t\t\t\t\tDatumGetCString(DirectFunctionCall1(interval_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(zone))))));\n\n\ttz = zone->time / USECS_PER_SEC;\n\n\tresult = dt2local(timestamp, tz);\n\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tPG_RETURN_TIMESTAMPTZ(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "result"
          ],
          "line": 5075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 5071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 5073
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 5072
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 5070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt2local",
          "args": [
            "timestamp",
            "tz"
          ],
          "line": 5068
        },
        "resolved": true,
        "details": {
          "function_name": "dt2local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1951-1956",
          "snippet": "static Timestamp\ndt2local(Timestamp dt, int tz)\n{\n\tdt -= (tz * USECS_PER_SEC);\n\treturn dt;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Timestamp\ndt2local(Timestamp dt, int tz)\n{\n\tdt -= (tz * USECS_PER_SEC);\n\treturn dt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval time zone \\\"%s\\\" must not include months or days\",\n\t\t\t\t\t\tDatumGetCString(DirectFunctionCall1(interval_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(zone)))))"
          ],
          "line": 5060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(interval_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(zone))"
          ],
          "line": 5063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "interval_out",
            "PointerGetDatum(zone)"
          ],
          "line": 5063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "zone"
          ],
          "line": 5064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "timestamp"
          ],
          "line": 5057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 5056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 5052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 5051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamp_izone(PG_FUNCTION_ARGS)\n{\n\tInterval   *zone = PG_GETARG_INTERVAL_P(0);\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz result;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_TIMESTAMPTZ(timestamp);\n\n\tif (zone->month != 0 || zone->day != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval time zone \\\"%s\\\" must not include months or days\",\n\t\t\t\t\t\tDatumGetCString(DirectFunctionCall1(interval_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(zone))))));\n\n\ttz = zone->time / USECS_PER_SEC;\n\n\tresult = dt2local(timestamp, tz);\n\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tPG_RETURN_TIMESTAMPTZ(result);\n}"
  },
  {
    "function_name": "timestamp_izone_transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "5039-5043",
    "snippet": "Datum\ntimestamp_izone_transform(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_POINTER(NULL);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "NULL"
          ],
          "line": 5042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_izone_transform(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_POINTER(NULL);\n}"
  },
  {
    "function_name": "timestamp_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "4948-5031",
    "snippet": "Datum\ntimestamp_zone(PG_FUNCTION_ARGS)\n{\n\ttext\t   *zone = PG_GETARG_TEXT_PP(0);\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz result;\n\tint\t\t\ttz;\n\tchar\t\ttzname[TZ_STRLEN_MAX + 1];\n\tchar\t   *lowzone;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tpg_tz\t   *tzp;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_TIMESTAMPTZ(timestamp);\n\n\t/*\n\t * Look up the requested timezone.  First we look in the timezone\n\t * abbreviation table (to handle cases like \"EST\"), and if that fails, we\n\t * look in the timezone database (to handle cases like\n\t * \"America/New_York\").  (This matches the order in which timestamp input\n\t * checks the cases; it's important because the timezone database unwisely\n\t * uses a few zone names that are identical to offset abbreviations.)\n\t */\n\ttext_to_cstring_buffer(zone, tzname, sizeof(tzname));\n\n\t/* DecodeTimezoneAbbrev requires lowercase input */\n\tlowzone = downcase_truncate_identifier(tzname,\n\t\t\t\t\t\t\t\t\t\t   strlen(tzname),\n\t\t\t\t\t\t\t\t\t\t   false);\n\n\ttype = DecodeTimezoneAbbrev(0, lowzone, &val, &tzp);\n\n\tif (type == TZ || type == DTZ)\n\t{\n\t\t/* fixed-offset abbreviation */\n\t\ttz = val;\n\t\tresult = dt2local(timestamp, tz);\n\t}\n\telse if (type == DYNTZ)\n\t{\n\t\t/* dynamic-offset abbreviation, resolve using specified time */\n\t\tif (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, tzp) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\ttz = -DetermineTimeZoneAbbrevOffset(&tm, tzname, tzp);\n\t\tresult = dt2local(timestamp, tz);\n\t}\n\telse\n\t{\n\t\t/* try it as a full zone name */\n\t\ttzp = pg_tzset(tzname);\n\t\tif (tzp)\n\t\t{\n\t\t\t/* Apply the timezone change */\n\t\t\tif (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, tzp) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\ttz = DetermineTimeZoneOffset(&tm, tzp);\n\t\t\tif (tm2timestamp(&tm, fsec, &tz, &result) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname)));\n\t\t\tresult = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tPG_RETURN_TIMESTAMPTZ(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static Timestamp dt2local(Timestamp dt, int timezone);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "result"
          ],
          "line": 5030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 5026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 5028
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 5027
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 5025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname))"
          ],
          "line": 5018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 5012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm2timestamp",
          "args": [
            "&tm",
            "fsec",
            "&tz",
            "&result"
          ],
          "line": 5011
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1853-1895",
          "snippet": "int\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneOffset",
          "args": [
            "&tm",
            "tzp"
          ],
          "line": 5010
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1454-1460",
          "snippet": "int\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 5007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "NULL",
            "&tm",
            "&fsec",
            "NULL",
            "tzp"
          ],
          "line": 5006
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_tzset",
          "args": [
            "tzname"
          ],
          "line": 5002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt2local",
          "args": [
            "timestamp",
            "tz"
          ],
          "line": 4997
        },
        "resolved": true,
        "details": {
          "function_name": "dt2local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1951-1956",
          "snippet": "static Timestamp\ndt2local(Timestamp dt, int tz)\n{\n\tdt -= (tz * USECS_PER_SEC);\n\treturn dt;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Timestamp\ndt2local(Timestamp dt, int tz)\n{\n\tdt -= (tz * USECS_PER_SEC);\n\treturn dt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneAbbrevOffset",
          "args": [
            "&tm",
            "tzname",
            "tzp"
          ],
          "line": 4996
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneAbbrevOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1615-1645",
          "snippet": "int\nDetermineTimeZoneAbbrevOffset(struct pg_tm *tm, const char *abbr, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\tabbr_isdst;\n\n\t/*\n\t * Compute the UTC time we want to probe at.  (In event of overflow, we'll\n\t * probe at the epoch, which is a bit random but probably doesn't matter.)\n\t */\n\tzone_offset = DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n\n\t/*\n\t * Try to match the abbreviation to something in the zone definition.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, &abbr_isdst))\n\t{\n\t\t/* Success, so use the abbrev-specific answers. */\n\t\ttm->tm_isdst = abbr_isdst;\n\t\treturn abbr_offset;\n\t}\n\n\t/*\n\t * No match, so use the answers we already got from\n\t * DetermineTimeZoneOffsetInternal.\n\t */\n\treturn zone_offset;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneAbbrevOffset(struct pg_tm *tm, const char *abbr, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\tabbr_isdst;\n\n\t/*\n\t * Compute the UTC time we want to probe at.  (In event of overflow, we'll\n\t * probe at the epoch, which is a bit random but probably doesn't matter.)\n\t */\n\tzone_offset = DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n\n\t/*\n\t * Try to match the abbreviation to something in the zone definition.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, &abbr_isdst))\n\t{\n\t\t/* Success, so use the abbrev-specific answers. */\n\t\ttm->tm_isdst = abbr_isdst;\n\t\treturn abbr_offset;\n\t}\n\n\t/*\n\t * No match, so use the answers we already got from\n\t * DetermineTimeZoneOffsetInternal.\n\t */\n\treturn zone_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 4993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeTimezoneAbbrev",
          "args": [
            "0",
            "lowzone",
            "&val",
            "&tzp"
          ],
          "line": 4981
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeTimezoneAbbrev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2970-3010",
          "snippet": "int\nDecodeTimezoneAbbrev(int field, char *lowtoken,\n\t\t\t\t\t int *offset, pg_tz **tz)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = abbrevcache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\tif (zoneabbrevtbl)\n\t\t\ttp = datebsearch(lowtoken, zoneabbrevtbl->abbrevs,\n\t\t\t\t\t\t\t zoneabbrevtbl->numabbrevs);\n\t\telse\n\t\t\ttp = NULL;\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*offset = 0;\n\t\t*tz = NULL;\n\t}\n\telse\n\t{\n\t\tabbrevcache[field] = tp;\n\t\ttype = tp->type;\n\t\tif (type == DYNTZ)\n\t\t{\n\t\t\t*offset = 0;\n\t\t\t*tz = FetchDynamicTimeZone(zoneabbrevtbl, tp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*offset = tp->value;\n\t\t\t*tz = NULL;\n\t\t}\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static TimeZoneAbbrevTable *zoneabbrevtbl = NULL;",
            "static const datetkn *abbrevcache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic TimeZoneAbbrevTable *zoneabbrevtbl = NULL;\nstatic const datetkn *abbrevcache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeTimezoneAbbrev(int field, char *lowtoken,\n\t\t\t\t\t int *offset, pg_tz **tz)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = abbrevcache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\tif (zoneabbrevtbl)\n\t\t\ttp = datebsearch(lowtoken, zoneabbrevtbl->abbrevs,\n\t\t\t\t\t\t\t zoneabbrevtbl->numabbrevs);\n\t\telse\n\t\t\ttp = NULL;\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*offset = 0;\n\t\t*tz = NULL;\n\t}\n\telse\n\t{\n\t\tabbrevcache[field] = tp;\n\t\ttype = tp->type;\n\t\tif (type == DYNTZ)\n\t\t{\n\t\t\t*offset = 0;\n\t\t\t*tz = FetchDynamicTimeZone(zoneabbrevtbl, tp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*offset = tp->value;\n\t\t\t*tz = NULL;\n\t\t}\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcase_truncate_identifier",
          "args": [
            "tzname",
            "strlen(tzname)",
            "false"
          ],
          "line": 4977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tzname"
          ],
          "line": 4978
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring_buffer",
          "args": [
            "zone",
            "tzname",
            "sizeof(tzname)"
          ],
          "line": 4974
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "212-232",
          "snippet": "void\ntext_to_cstring_buffer(const text *src, char *dst, size_t dst_len)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *srcunpacked = pg_detoast_datum_packed((struct varlena *) src);\n\tsize_t\t\tsrc_len = VARSIZE_ANY_EXHDR(srcunpacked);\n\n\tif (dst_len > 0)\n\t{\n\t\tdst_len--;\n\t\tif (dst_len >= src_len)\n\t\t\tdst_len = src_len;\n\t\telse\t\t\t\t\t/* ensure truncation is encoding-safe */\n\t\t\tdst_len = pg_mbcliplen(VARDATA_ANY(srcunpacked), src_len, dst_len);\n\t\tmemcpy(dst, VARDATA_ANY(srcunpacked), dst_len);\n\t\tdst[dst_len] = '\\0';\n\t}\n\n\tif (srcunpacked != src)\n\t\tpfree(srcunpacked);\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\ntext_to_cstring_buffer(const text *src, char *dst, size_t dst_len)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *srcunpacked = pg_detoast_datum_packed((struct varlena *) src);\n\tsize_t\t\tsrc_len = VARSIZE_ANY_EXHDR(srcunpacked);\n\n\tif (dst_len > 0)\n\t{\n\t\tdst_len--;\n\t\tif (dst_len >= src_len)\n\t\t\tdst_len = src_len;\n\t\telse\t\t\t\t\t/* ensure truncation is encoding-safe */\n\t\t\tdst_len = pg_mbcliplen(VARDATA_ANY(srcunpacked), src_len, dst_len);\n\t\tmemcpy(dst, VARDATA_ANY(srcunpacked), dst_len);\n\t\tdst[dst_len] = '\\0';\n\t}\n\n\tif (srcunpacked != src)\n\t\tpfree(srcunpacked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "timestamp"
          ],
          "line": 4964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 4963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 4952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 4951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamp_zone(PG_FUNCTION_ARGS)\n{\n\ttext\t   *zone = PG_GETARG_TEXT_PP(0);\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz result;\n\tint\t\t\ttz;\n\tchar\t\ttzname[TZ_STRLEN_MAX + 1];\n\tchar\t   *lowzone;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tpg_tz\t   *tzp;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_TIMESTAMPTZ(timestamp);\n\n\t/*\n\t * Look up the requested timezone.  First we look in the timezone\n\t * abbreviation table (to handle cases like \"EST\"), and if that fails, we\n\t * look in the timezone database (to handle cases like\n\t * \"America/New_York\").  (This matches the order in which timestamp input\n\t * checks the cases; it's important because the timezone database unwisely\n\t * uses a few zone names that are identical to offset abbreviations.)\n\t */\n\ttext_to_cstring_buffer(zone, tzname, sizeof(tzname));\n\n\t/* DecodeTimezoneAbbrev requires lowercase input */\n\tlowzone = downcase_truncate_identifier(tzname,\n\t\t\t\t\t\t\t\t\t\t   strlen(tzname),\n\t\t\t\t\t\t\t\t\t\t   false);\n\n\ttype = DecodeTimezoneAbbrev(0, lowzone, &val, &tzp);\n\n\tif (type == TZ || type == DTZ)\n\t{\n\t\t/* fixed-offset abbreviation */\n\t\ttz = val;\n\t\tresult = dt2local(timestamp, tz);\n\t}\n\telse if (type == DYNTZ)\n\t{\n\t\t/* dynamic-offset abbreviation, resolve using specified time */\n\t\tif (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, tzp) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\ttz = -DetermineTimeZoneAbbrevOffset(&tm, tzname, tzp);\n\t\tresult = dt2local(timestamp, tz);\n\t}\n\telse\n\t{\n\t\t/* try it as a full zone name */\n\t\ttzp = pg_tzset(tzname);\n\t\tif (tzp)\n\t\t{\n\t\t\t/* Apply the timezone change */\n\t\t\tif (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, tzp) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\ttz = DetermineTimeZoneOffset(&tm, tzp);\n\t\t\tif (tm2timestamp(&tm, fsec, &tz, &result) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname)));\n\t\t\tresult = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tPG_RETURN_TIMESTAMPTZ(result);\n}"
  },
  {
    "function_name": "timestamp_zone_transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "4934-4938",
    "snippet": "Datum\ntimestamp_zone_transform(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_POINTER(NULL);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "NULL"
          ],
          "line": 4937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_zone_transform(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_POINTER(NULL);\n}"
  },
  {
    "function_name": "interval_part",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "4815-4925",
    "snippet": "Datum\ninterval_part(PG_FUNCTION_ARGS)\n{\n\ttext\t   *units = PG_GETARG_TEXT_PP(0);\n\tInterval   *interval = PG_GETARG_INTERVAL_P(1);\n\tfloat8\t\tresult;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tchar\t   *lowunits;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tlowunits = downcase_truncate_identifier(VARDATA_ANY(units),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(units),\n\t\t\t\t\t\t\t\t\t\t\tfalse);\n\n\ttype = DecodeUnits(0, lowunits, &val);\n\tif (type == UNKNOWN_FIELD)\n\t\ttype = DecodeSpecial(0, lowunits, &val);\n\n\tif (type == UNITS)\n\t{\n\t\tif (interval2tm(*interval, tm, &fsec) == 0)\n\t\t{\n\t\t\tswitch (val)\n\t\t\t{\n\t\t\t\tcase DTK_MICROSEC:\n\t\t\t\t\tresult = tm->tm_sec * 1000000.0 + fsec;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_MILLISEC:\n\t\t\t\t\tresult = tm->tm_sec * 1000.0 + fsec / 1000.0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\tresult = tm->tm_sec + fsec / 1000000.0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\tresult = tm->tm_min;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\tresult = tm->tm_hour;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_DAY:\n\t\t\t\t\tresult = tm->tm_mday;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_MONTH:\n\t\t\t\t\tresult = tm->tm_mon;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_QUARTER:\n\t\t\t\t\tresult = (tm->tm_mon / 3) + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\tresult = tm->tm_year;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_DECADE:\n\t\t\t\t\t/* caution: C division may have negative remainder */\n\t\t\t\t\tresult = tm->tm_year / 10;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_CENTURY:\n\t\t\t\t\t/* caution: C division may have negative remainder */\n\t\t\t\t\tresult = tm->tm_year / 100;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_MILLENNIUM:\n\t\t\t\t\t/* caution: C division may have negative remainder */\n\t\t\t\t\tresult = tm->tm_year / 1000;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t errmsg(\"interval units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\t\tresult = 0;\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"could not convert interval to tm\");\n\t\t\tresult = 0;\n\t\t}\n\t}\n\telse if (type == RESERV && val == DTK_EPOCH)\n\t{\n\t\tresult = interval->time / 1000000.0;\n\t\tresult += ((double) DAYS_PER_YEAR * SECS_PER_DAY) * (interval->month / MONTHS_PER_YEAR);\n\t\tresult += ((double) DAYS_PER_MONTH * SECS_PER_DAY) * (interval->month % MONTHS_PER_YEAR);\n\t\tresult += ((double) SECS_PER_DAY) * interval->day;\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits)));\n\t\tresult = 0;\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 4924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits))"
          ],
          "line": 4917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"interval units \\\"%s\\\" not recognized\"",
            "lowunits"
          ],
          "line": 4919
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 4918
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not convert interval to tm\""
          ],
          "line": 4904
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t errmsg(\"interval units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\t\tlowunits))"
          ],
          "line": 4894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval2tm",
          "args": [
            "*interval",
            "tm",
            "&fsec"
          ],
          "line": 4838
        },
        "resolved": true,
        "details": {
          "function_name": "interval2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1901-1927",
          "snippet": "int\ninterval2tm(Interval span, struct pg_tm *tm, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\tTimeOffset\ttfrac;\n\n\ttm->tm_year = span.month / MONTHS_PER_YEAR;\n\ttm->tm_mon = span.month % MONTHS_PER_YEAR;\n\ttm->tm_mday = span.day;\n\ttime = span.time;\n\n\ttfrac = time / USECS_PER_HOUR;\n\ttime -= tfrac * USECS_PER_HOUR;\n\ttm->tm_hour = tfrac;\n\tif (!SAMESIGN(tm->tm_hour, tfrac))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\ttfrac = time / USECS_PER_MINUTE;\n\ttime -= tfrac * USECS_PER_MINUTE;\n\ttm->tm_min = tfrac;\n\ttfrac = time / USECS_PER_SEC;\n\t*fsec = time - (tfrac * USECS_PER_SEC);\n\ttm->tm_sec = tfrac;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ninterval2tm(Interval span, struct pg_tm *tm, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\tTimeOffset\ttfrac;\n\n\ttm->tm_year = span.month / MONTHS_PER_YEAR;\n\ttm->tm_mon = span.month % MONTHS_PER_YEAR;\n\ttm->tm_mday = span.day;\n\ttime = span.time;\n\n\ttfrac = time / USECS_PER_HOUR;\n\ttime -= tfrac * USECS_PER_HOUR;\n\ttm->tm_hour = tfrac;\n\tif (!SAMESIGN(tm->tm_hour, tfrac))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\ttfrac = time / USECS_PER_MINUTE;\n\ttime -= tfrac * USECS_PER_MINUTE;\n\ttm->tm_min = tfrac;\n\ttfrac = time / USECS_PER_SEC;\n\t*fsec = time - (tfrac * USECS_PER_SEC);\n\ttm->tm_sec = tfrac;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeSpecial",
          "args": [
            "0",
            "lowunits",
            "&val"
          ],
          "line": 4834
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3025-3050",
          "snippet": "int\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
            "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];",
            "static const datetkn *datecache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\nstatic const datetkn *datecache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeUnits",
          "args": [
            "0",
            "lowunits",
            "&val"
          ],
          "line": 4832
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeUnits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3716-3741",
          "snippet": "int\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};",
            "static int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];",
            "static const datetkn *deltacache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};\nstatic int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];\nstatic const datetkn *deltacache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcase_truncate_identifier",
          "args": [
            "VARDATA_ANY(units)",
            "VARSIZE_ANY_EXHDR(units)",
            "false"
          ],
          "line": 4828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "units"
          ],
          "line": 4829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "units"
          ],
          "line": 4828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 4819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 4818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nDatum\ninterval_part(PG_FUNCTION_ARGS)\n{\n\ttext\t   *units = PG_GETARG_TEXT_PP(0);\n\tInterval   *interval = PG_GETARG_INTERVAL_P(1);\n\tfloat8\t\tresult;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tchar\t   *lowunits;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tlowunits = downcase_truncate_identifier(VARDATA_ANY(units),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(units),\n\t\t\t\t\t\t\t\t\t\t\tfalse);\n\n\ttype = DecodeUnits(0, lowunits, &val);\n\tif (type == UNKNOWN_FIELD)\n\t\ttype = DecodeSpecial(0, lowunits, &val);\n\n\tif (type == UNITS)\n\t{\n\t\tif (interval2tm(*interval, tm, &fsec) == 0)\n\t\t{\n\t\t\tswitch (val)\n\t\t\t{\n\t\t\t\tcase DTK_MICROSEC:\n\t\t\t\t\tresult = tm->tm_sec * 1000000.0 + fsec;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_MILLISEC:\n\t\t\t\t\tresult = tm->tm_sec * 1000.0 + fsec / 1000.0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\tresult = tm->tm_sec + fsec / 1000000.0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\tresult = tm->tm_min;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\tresult = tm->tm_hour;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_DAY:\n\t\t\t\t\tresult = tm->tm_mday;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_MONTH:\n\t\t\t\t\tresult = tm->tm_mon;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_QUARTER:\n\t\t\t\t\tresult = (tm->tm_mon / 3) + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\tresult = tm->tm_year;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_DECADE:\n\t\t\t\t\t/* caution: C division may have negative remainder */\n\t\t\t\t\tresult = tm->tm_year / 10;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_CENTURY:\n\t\t\t\t\t/* caution: C division may have negative remainder */\n\t\t\t\t\tresult = tm->tm_year / 100;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTK_MILLENNIUM:\n\t\t\t\t\t/* caution: C division may have negative remainder */\n\t\t\t\t\tresult = tm->tm_year / 1000;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t errmsg(\"interval units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\t\tresult = 0;\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"could not convert interval to tm\");\n\t\t\tresult = 0;\n\t\t}\n\t}\n\telse if (type == RESERV && val == DTK_EPOCH)\n\t{\n\t\tresult = interval->time / 1000000.0;\n\t\tresult += ((double) DAYS_PER_YEAR * SECS_PER_DAY) * (interval->month / MONTHS_PER_YEAR);\n\t\tresult += ((double) DAYS_PER_MONTH * SECS_PER_DAY) * (interval->month % MONTHS_PER_YEAR);\n\t\tresult += ((double) SECS_PER_DAY) * interval->day;\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits)));\n\t\tresult = 0;\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "timestamptz_part",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "4611-4809",
    "snippet": "Datum\ntimestamptz_part(PG_FUNCTION_ARGS)\n{\n\ttext\t   *units = PG_GETARG_TEXT_PP(0);\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(1);\n\tfloat8\t\tresult;\n\tTimestamp\tepoch;\n\tint\t\t\ttz;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tchar\t   *lowunits;\n\tdouble\t\tdummy;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tlowunits = downcase_truncate_identifier(VARDATA_ANY(units),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(units),\n\t\t\t\t\t\t\t\t\t\t\tfalse);\n\n\ttype = DecodeUnits(0, lowunits, &val);\n\tif (type == UNKNOWN_FIELD)\n\t\ttype = DecodeSpecial(0, lowunits, &val);\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t{\n\t\tresult = NonFiniteTimestampTzPart(type, val, lowunits,\n\t\t\t\t\t\t\t\t\t\t  TIMESTAMP_IS_NOBEGIN(timestamp),\n\t\t\t\t\t\t\t\t\t\t  true);\n\t\tif (result)\n\t\t\tPG_RETURN_FLOAT8(result);\n\t\telse\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tif (type == UNITS)\n\t{\n\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\tswitch (val)\n\t\t{\n\t\t\tcase DTK_TZ:\n\t\t\t\tresult = -tz;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ_MINUTE:\n\t\t\t\tresult = -tz;\n\t\t\t\tresult /= MINS_PER_HOUR;\n\t\t\t\tFMODULO(result, dummy, (double) MINS_PER_HOUR);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ_HOUR:\n\t\t\t\tdummy = -tz;\n\t\t\t\tFMODULO(dummy, result, (double) SECS_PER_HOUR);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MICROSEC:\n\t\t\t\tresult = tm->tm_sec * 1000000.0 + fsec;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MILLISEC:\n\t\t\t\tresult = tm->tm_sec * 1000.0 + fsec / 1000.0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_SECOND:\n\t\t\t\tresult = tm->tm_sec + fsec / 1000000.0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MINUTE:\n\t\t\t\tresult = tm->tm_min;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_HOUR:\n\t\t\t\tresult = tm->tm_hour;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DAY:\n\t\t\t\tresult = tm->tm_mday;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MONTH:\n\t\t\t\tresult = tm->tm_mon;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_QUARTER:\n\t\t\t\tresult = (tm->tm_mon - 1) / 3 + 1;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_WEEK:\n\t\t\t\tresult = (float8) date2isoweek(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_YEAR:\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\tresult = tm->tm_year;\n\t\t\t\telse\n\t\t\t\t\t/* there is no year 0, just 1 BC and 1 AD */\n\t\t\t\t\tresult = tm->tm_year - 1;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DECADE:\n\t\t\t\t/* see comments in timestamp_part */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\tresult = tm->tm_year / 10;\n\t\t\t\telse\n\t\t\t\t\tresult = -((8 - (tm->tm_year - 1)) / 10);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_CENTURY:\n\t\t\t\t/* see comments in timestamp_part */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\tresult = (tm->tm_year + 99) / 100;\n\t\t\t\telse\n\t\t\t\t\tresult = -((99 - (tm->tm_year - 1)) / 100);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MILLENNIUM:\n\t\t\t\t/* see comments in timestamp_part */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\tresult = (tm->tm_year + 999) / 1000;\n\t\t\t\telse\n\t\t\t\t\tresult = -((999 - (tm->tm_year - 1)) / 1000);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_JULIAN:\n\t\t\t\tresult = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\t\tresult += ((((tm->tm_hour * MINS_PER_HOUR) + tm->tm_min) * SECS_PER_MINUTE) +\n\t\t\t\t\t\t   tm->tm_sec + (fsec / 1000000.0)) / (double) SECS_PER_DAY;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_ISOYEAR:\n\t\t\t\tresult = date2isoyear(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DOW:\n\t\t\tcase DTK_ISODOW:\n\t\t\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t\tresult = j2day(date2j(tm->tm_year, tm->tm_mon, tm->tm_mday));\n\t\t\t\tif (val == DTK_ISODOW && result == 0)\n\t\t\t\t\tresult = 7;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DOY:\n\t\t\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t\tresult = (date2j(tm->tm_year, tm->tm_mon, tm->tm_mday)\n\t\t\t\t\t\t  - date2j(tm->tm_year, 1, 1) + 1);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\tresult = 0;\n\t\t}\n\n\t}\n\telse if (type == RESERV)\n\t{\n\t\tswitch (val)\n\t\t{\n\t\t\tcase DTK_EPOCH:\n\t\t\t\tepoch = SetEpochTimestamp();\n\t\t\t\t/* try to avoid precision loss in subtraction */\n\t\t\t\tif (timestamp < (PG_INT64_MAX + epoch))\n\t\t\t\t\tresult = (timestamp - epoch) / 1000000.0;\n\t\t\t\telse\n\t\t\t\t\tresult = ((float8) timestamp - epoch) / 1000000.0;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\tresult = 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits)));\n\n\t\tresult = 0;\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 4808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits))"
          ],
          "line": 4800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp with time zone units \\\"%s\\\" not recognized\"",
            "lowunits"
          ],
          "line": 4802
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 4801
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits))"
          ],
          "line": 4791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetEpochTimestamp",
          "args": [],
          "line": 4782
        },
        "resolved": true,
        "details": {
          "function_name": "SetEpochTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2005-2017",
          "snippet": "Timestamp\nSetEpochTimestamp(void)\n{\n\tTimestamp\tdt;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tGetEpochTime(tm);\n\t/* we don't bother to test for failure ... */\n\ttm2timestamp(tm, 0, NULL, &dt);\n\n\treturn dt;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestamp\nSetEpochTimestamp(void)\n{\n\tTimestamp\tdt;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tGetEpochTime(tm);\n\t/* we don't bother to test for failure ... */\n\ttm2timestamp(tm, 0, NULL, &dt);\n\n\treturn dt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits))"
          ],
          "line": 4769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "1",
            "1"
          ],
          "line": 4765
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 4761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "&tz",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 4760
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "j2day",
          "args": [
            "date2j(tm->tm_year, tm->tm_mon, tm->tm_mday)"
          ],
          "line": 4754
        },
        "resolved": true,
        "details": {
          "function_name": "j2day",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "335-345",
          "snippet": "int\nj2day(int date)\n{\n\tdate += 1;\n\tdate %= 7;\n\t/* Cope if division truncates towards zero, as it probably does */\n\tif (date < 0)\n\t\tdate += 7;\n\n\treturn date;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nj2day(int date)\n{\n\tdate += 1;\n\tdate %= 7;\n\t/* Cope if division truncates towards zero, as it probably does */\n\tif (date < 0)\n\t\tdate += 7;\n\n\treturn date;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 4751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2isoyear",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 4745
        },
        "resolved": true,
        "details": {
          "function_name": "date2isoyearday",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4326-4330",
          "snippet": "int\ndate2isoyearday(int year, int mon, int mday)\n{\n\treturn date2j(year, mon, mday) - isoweek2j(date2isoyear(year, mon, mday), 1) + 1;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2isoyearday(int year, int mon, int mday)\n{\n\treturn date2j(year, mon, mday) - isoweek2j(date2isoyear(year, mon, mday), 1) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2isoweek",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 4703
        },
        "resolved": true,
        "details": {
          "function_name": "date2isoweek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4215-4262",
          "snippet": "int\ndate2isoweek(int year, int mon, int mday)\n{\n\tfloat8\t\tresult;\n\tint\t\t\tday0,\n\t\t\t\tday4,\n\t\t\t\tdayn;\n\n\t/* current day */\n\tdayn = date2j(year, mon, mday);\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\t/*\n\t * We need the first week containing a Thursday, otherwise this day falls\n\t * into the previous year for purposes of counting weeks\n\t */\n\tif (dayn < day4 - day0)\n\t{\n\t\tday4 = date2j(year - 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\t}\n\n\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\n\t/*\n\t * Sometimes the last few days in a year will fall into the first week of\n\t * the next year, so check for this.\n\t */\n\tif (result >= 52)\n\t{\n\t\tday4 = date2j(year + 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\n\t\tif (dayn >= day4 - day0)\n\t\t\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\t}\n\n\treturn (int) result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2isoweek(int year, int mon, int mday)\n{\n\tfloat8\t\tresult;\n\tint\t\t\tday0,\n\t\t\t\tday4,\n\t\t\t\tdayn;\n\n\t/* current day */\n\tdayn = date2j(year, mon, mday);\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\t/*\n\t * We need the first week containing a Thursday, otherwise this day falls\n\t * into the previous year for purposes of counting weeks\n\t */\n\tif (dayn < day4 - day0)\n\t{\n\t\tday4 = date2j(year - 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\t}\n\n\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\n\t/*\n\t * Sometimes the last few days in a year will fall into the first week of\n\t * the next year, so check for this.\n\t */\n\tif (result >= 52)\n\t{\n\t\tday4 = date2j(year + 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\n\t\tif (dayn >= day4 - day0)\n\t\t\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\t}\n\n\treturn (int) result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FMODULO",
          "args": [
            "dummy",
            "result",
            "(double) SECS_PER_HOUR"
          ],
          "line": 4667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FMODULO",
          "args": [
            "result",
            "dummy",
            "(double) MINS_PER_HOUR"
          ],
          "line": 4662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 4649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 4643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 4641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NonFiniteTimestampTzPart",
          "args": [
            "type",
            "val",
            "lowunits",
            "TIMESTAMP_IS_NOBEGIN(timestamp)",
            "true"
          ],
          "line": 4637
        },
        "resolved": true,
        "details": {
          "function_name": "NonFiniteTimestampTzPart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4343-4407",
          "snippet": "static float8\nNonFiniteTimestampTzPart(int type, int unit, char *lowunits,\n\t\t\t\t\t\t bool isNegative, bool isTz)\n{\n\tif ((type != UNITS) && (type != RESERV))\n\t{\n\t\tif (isTz)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tlowunits)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tlowunits)));\n\t}\n\n\tswitch (unit)\n\t{\n\t\t\t/* Oscillating units */\n\t\tcase DTK_MICROSEC:\n\t\tcase DTK_MILLISEC:\n\t\tcase DTK_SECOND:\n\t\tcase DTK_MINUTE:\n\t\tcase DTK_HOUR:\n\t\tcase DTK_DAY:\n\t\tcase DTK_MONTH:\n\t\tcase DTK_QUARTER:\n\t\tcase DTK_WEEK:\n\t\tcase DTK_DOW:\n\t\tcase DTK_ISODOW:\n\t\tcase DTK_DOY:\n\t\tcase DTK_TZ:\n\t\tcase DTK_TZ_MINUTE:\n\t\tcase DTK_TZ_HOUR:\n\t\t\treturn 0.0;\n\n\t\t\t/* Monotonically-increasing units */\n\t\tcase DTK_YEAR:\n\t\tcase DTK_DECADE:\n\t\tcase DTK_CENTURY:\n\t\tcase DTK_MILLENNIUM:\n\t\tcase DTK_JULIAN:\n\t\tcase DTK_ISOYEAR:\n\t\tcase DTK_EPOCH:\n\t\t\tif (isNegative)\n\t\t\t\treturn -get_float8_infinity();\n\t\t\telse\n\t\t\t\treturn get_float8_infinity();\n\n\t\tdefault:\n\t\t\tif (isTz)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\treturn 0.0;\t\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic float8\nNonFiniteTimestampTzPart(int type, int unit, char *lowunits,\n\t\t\t\t\t\t bool isNegative, bool isTz)\n{\n\tif ((type != UNITS) && (type != RESERV))\n\t{\n\t\tif (isTz)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tlowunits)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tlowunits)));\n\t}\n\n\tswitch (unit)\n\t{\n\t\t\t/* Oscillating units */\n\t\tcase DTK_MICROSEC:\n\t\tcase DTK_MILLISEC:\n\t\tcase DTK_SECOND:\n\t\tcase DTK_MINUTE:\n\t\tcase DTK_HOUR:\n\t\tcase DTK_DAY:\n\t\tcase DTK_MONTH:\n\t\tcase DTK_QUARTER:\n\t\tcase DTK_WEEK:\n\t\tcase DTK_DOW:\n\t\tcase DTK_ISODOW:\n\t\tcase DTK_DOY:\n\t\tcase DTK_TZ:\n\t\tcase DTK_TZ_MINUTE:\n\t\tcase DTK_TZ_HOUR:\n\t\t\treturn 0.0;\n\n\t\t\t/* Monotonically-increasing units */\n\t\tcase DTK_YEAR:\n\t\tcase DTK_DECADE:\n\t\tcase DTK_CENTURY:\n\t\tcase DTK_MILLENNIUM:\n\t\tcase DTK_JULIAN:\n\t\tcase DTK_ISOYEAR:\n\t\tcase DTK_EPOCH:\n\t\t\tif (isNegative)\n\t\t\t\treturn -get_float8_infinity();\n\t\t\telse\n\t\t\t\treturn get_float8_infinity();\n\n\t\tdefault:\n\t\t\tif (isTz)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\treturn 0.0;\t\t\t/* keep compiler quiet */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_IS_NOBEGIN",
          "args": [
            "timestamp"
          ],
          "line": 4638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 4635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeSpecial",
          "args": [
            "0",
            "lowunits",
            "&val"
          ],
          "line": 4633
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3025-3050",
          "snippet": "int\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
            "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];",
            "static const datetkn *datecache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\nstatic const datetkn *datecache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeUnits",
          "args": [
            "0",
            "lowunits",
            "&val"
          ],
          "line": 4631
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeUnits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3716-3741",
          "snippet": "int\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};",
            "static int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];",
            "static const datetkn *deltacache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};\nstatic int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];\nstatic const datetkn *deltacache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcase_truncate_identifier",
          "args": [
            "VARDATA_ANY(units)",
            "VARSIZE_ANY_EXHDR(units)",
            "false"
          ],
          "line": 4627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "units"
          ],
          "line": 4628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "units"
          ],
          "line": 4627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 4615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 4614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamptz_part(PG_FUNCTION_ARGS)\n{\n\ttext\t   *units = PG_GETARG_TEXT_PP(0);\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(1);\n\tfloat8\t\tresult;\n\tTimestamp\tepoch;\n\tint\t\t\ttz;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tchar\t   *lowunits;\n\tdouble\t\tdummy;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tlowunits = downcase_truncate_identifier(VARDATA_ANY(units),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(units),\n\t\t\t\t\t\t\t\t\t\t\tfalse);\n\n\ttype = DecodeUnits(0, lowunits, &val);\n\tif (type == UNKNOWN_FIELD)\n\t\ttype = DecodeSpecial(0, lowunits, &val);\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t{\n\t\tresult = NonFiniteTimestampTzPart(type, val, lowunits,\n\t\t\t\t\t\t\t\t\t\t  TIMESTAMP_IS_NOBEGIN(timestamp),\n\t\t\t\t\t\t\t\t\t\t  true);\n\t\tif (result)\n\t\t\tPG_RETURN_FLOAT8(result);\n\t\telse\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tif (type == UNITS)\n\t{\n\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\tswitch (val)\n\t\t{\n\t\t\tcase DTK_TZ:\n\t\t\t\tresult = -tz;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ_MINUTE:\n\t\t\t\tresult = -tz;\n\t\t\t\tresult /= MINS_PER_HOUR;\n\t\t\t\tFMODULO(result, dummy, (double) MINS_PER_HOUR);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ_HOUR:\n\t\t\t\tdummy = -tz;\n\t\t\t\tFMODULO(dummy, result, (double) SECS_PER_HOUR);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MICROSEC:\n\t\t\t\tresult = tm->tm_sec * 1000000.0 + fsec;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MILLISEC:\n\t\t\t\tresult = tm->tm_sec * 1000.0 + fsec / 1000.0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_SECOND:\n\t\t\t\tresult = tm->tm_sec + fsec / 1000000.0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MINUTE:\n\t\t\t\tresult = tm->tm_min;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_HOUR:\n\t\t\t\tresult = tm->tm_hour;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DAY:\n\t\t\t\tresult = tm->tm_mday;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MONTH:\n\t\t\t\tresult = tm->tm_mon;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_QUARTER:\n\t\t\t\tresult = (tm->tm_mon - 1) / 3 + 1;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_WEEK:\n\t\t\t\tresult = (float8) date2isoweek(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_YEAR:\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\tresult = tm->tm_year;\n\t\t\t\telse\n\t\t\t\t\t/* there is no year 0, just 1 BC and 1 AD */\n\t\t\t\t\tresult = tm->tm_year - 1;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DECADE:\n\t\t\t\t/* see comments in timestamp_part */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\tresult = tm->tm_year / 10;\n\t\t\t\telse\n\t\t\t\t\tresult = -((8 - (tm->tm_year - 1)) / 10);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_CENTURY:\n\t\t\t\t/* see comments in timestamp_part */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\tresult = (tm->tm_year + 99) / 100;\n\t\t\t\telse\n\t\t\t\t\tresult = -((99 - (tm->tm_year - 1)) / 100);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MILLENNIUM:\n\t\t\t\t/* see comments in timestamp_part */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\tresult = (tm->tm_year + 999) / 1000;\n\t\t\t\telse\n\t\t\t\t\tresult = -((999 - (tm->tm_year - 1)) / 1000);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_JULIAN:\n\t\t\t\tresult = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\t\tresult += ((((tm->tm_hour * MINS_PER_HOUR) + tm->tm_min) * SECS_PER_MINUTE) +\n\t\t\t\t\t\t   tm->tm_sec + (fsec / 1000000.0)) / (double) SECS_PER_DAY;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_ISOYEAR:\n\t\t\t\tresult = date2isoyear(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DOW:\n\t\t\tcase DTK_ISODOW:\n\t\t\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t\tresult = j2day(date2j(tm->tm_year, tm->tm_mon, tm->tm_mday));\n\t\t\t\tif (val == DTK_ISODOW && result == 0)\n\t\t\t\t\tresult = 7;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DOY:\n\t\t\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t\tresult = (date2j(tm->tm_year, tm->tm_mon, tm->tm_mday)\n\t\t\t\t\t\t  - date2j(tm->tm_year, 1, 1) + 1);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\tresult = 0;\n\t\t}\n\n\t}\n\telse if (type == RESERV)\n\t{\n\t\tswitch (val)\n\t\t{\n\t\t\tcase DTK_EPOCH:\n\t\t\t\tepoch = SetEpochTimestamp();\n\t\t\t\t/* try to avoid precision loss in subtraction */\n\t\t\t\tif (timestamp < (PG_INT64_MAX + epoch))\n\t\t\t\t\tresult = (timestamp - epoch) / 1000000.0;\n\t\t\t\telse\n\t\t\t\t\tresult = ((float8) timestamp - epoch) / 1000000.0;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\tresult = 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits)));\n\n\t\tresult = 0;\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "timestamp_part",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "4412-4606",
    "snippet": "Datum\ntimestamp_part(PG_FUNCTION_ARGS)\n{\n\ttext\t   *units = PG_GETARG_TEXT_PP(0);\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(1);\n\tfloat8\t\tresult;\n\tTimestamp\tepoch;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tchar\t   *lowunits;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tlowunits = downcase_truncate_identifier(VARDATA_ANY(units),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(units),\n\t\t\t\t\t\t\t\t\t\t\tfalse);\n\n\ttype = DecodeUnits(0, lowunits, &val);\n\tif (type == UNKNOWN_FIELD)\n\t\ttype = DecodeSpecial(0, lowunits, &val);\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t{\n\t\tresult = NonFiniteTimestampTzPart(type, val, lowunits,\n\t\t\t\t\t\t\t\t\t\t  TIMESTAMP_IS_NOBEGIN(timestamp),\n\t\t\t\t\t\t\t\t\t\t  false);\n\t\tif (result)\n\t\t\tPG_RETURN_FLOAT8(result);\n\t\telse\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tif (type == UNITS)\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\tswitch (val)\n\t\t{\n\t\t\tcase DTK_MICROSEC:\n\t\t\t\tresult = tm->tm_sec * 1000000.0 + fsec;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MILLISEC:\n\t\t\t\tresult = tm->tm_sec * 1000.0 + fsec / 1000.0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_SECOND:\n\t\t\t\tresult = tm->tm_sec + fsec / 1000000.0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MINUTE:\n\t\t\t\tresult = tm->tm_min;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_HOUR:\n\t\t\t\tresult = tm->tm_hour;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DAY:\n\t\t\t\tresult = tm->tm_mday;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MONTH:\n\t\t\t\tresult = tm->tm_mon;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_QUARTER:\n\t\t\t\tresult = (tm->tm_mon - 1) / 3 + 1;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_WEEK:\n\t\t\t\tresult = (float8) date2isoweek(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_YEAR:\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\tresult = tm->tm_year;\n\t\t\t\telse\n\t\t\t\t\t/* there is no year 0, just 1 BC and 1 AD */\n\t\t\t\t\tresult = tm->tm_year - 1;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DECADE:\n\n\t\t\t\t/*\n\t\t\t\t * what is a decade wrt dates? let us assume that decade 199\n\t\t\t\t * is 1990 thru 1999... decade 0 starts on year 1 BC, and -1\n\t\t\t\t * is 11 BC thru 2 BC...\n\t\t\t\t */\n\t\t\t\tif (tm->tm_year >= 0)\n\t\t\t\t\tresult = tm->tm_year / 10;\n\t\t\t\telse\n\t\t\t\t\tresult = -((8 - (tm->tm_year - 1)) / 10);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_CENTURY:\n\n\t\t\t\t/* ----\n\t\t\t\t * centuries AD, c>0: year in [ (c-1)* 100 + 1 : c*100 ]\n\t\t\t\t * centuries BC, c<0: year in [ c*100 : (c+1) * 100 - 1]\n\t\t\t\t * there is no number 0 century.\n\t\t\t\t * ----\n\t\t\t\t */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\tresult = (tm->tm_year + 99) / 100;\n\t\t\t\telse\n\t\t\t\t\t/* caution: C division may have negative remainder */\n\t\t\t\t\tresult = -((99 - (tm->tm_year - 1)) / 100);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MILLENNIUM:\n\t\t\t\t/* see comments above. */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\tresult = (tm->tm_year + 999) / 1000;\n\t\t\t\telse\n\t\t\t\t\tresult = -((999 - (tm->tm_year - 1)) / 1000);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_JULIAN:\n\t\t\t\tresult = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\t\tresult += ((((tm->tm_hour * MINS_PER_HOUR) + tm->tm_min) * SECS_PER_MINUTE) +\n\t\t\t\t\t\t   tm->tm_sec + (fsec / 1000000.0)) / (double) SECS_PER_DAY;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_ISOYEAR:\n\t\t\t\tresult = date2isoyear(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DOW:\n\t\t\tcase DTK_ISODOW:\n\t\t\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t\tresult = j2day(date2j(tm->tm_year, tm->tm_mon, tm->tm_mday));\n\t\t\t\tif (val == DTK_ISODOW && result == 0)\n\t\t\t\t\tresult = 7;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DOY:\n\t\t\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t\tresult = (date2j(tm->tm_year, tm->tm_mon, tm->tm_mday)\n\t\t\t\t\t\t  - date2j(tm->tm_year, 1, 1) + 1);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\tcase DTK_TZ_MINUTE:\n\t\t\tcase DTK_TZ_HOUR:\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\tresult = 0;\n\t\t}\n\t}\n\telse if (type == RESERV)\n\t{\n\t\tswitch (val)\n\t\t{\n\t\t\tcase DTK_EPOCH:\n\t\t\t\tepoch = SetEpochTimestamp();\n\t\t\t\t/* try to avoid precision loss in subtraction */\n\t\t\t\tif (timestamp < (PG_INT64_MAX + epoch))\n\t\t\t\t\tresult = (timestamp - epoch) / 1000000.0;\n\t\t\t\telse\n\t\t\t\t\tresult = ((float8) timestamp - epoch) / 1000000.0;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\tresult = 0;\n\t\t}\n\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not recognized\", lowunits)));\n\t\tresult = 0;\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 4605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not recognized\", lowunits))"
          ],
          "line": 4599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp units \\\"%s\\\" not recognized\"",
            "lowunits"
          ],
          "line": 4601
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 4600
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits))"
          ],
          "line": 4589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetEpochTimestamp",
          "args": [],
          "line": 4580
        },
        "resolved": true,
        "details": {
          "function_name": "SetEpochTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2005-2017",
          "snippet": "Timestamp\nSetEpochTimestamp(void)\n{\n\tTimestamp\tdt;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tGetEpochTime(tm);\n\t/* we don't bother to test for failure ... */\n\ttm2timestamp(tm, 0, NULL, &dt);\n\n\treturn dt;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestamp\nSetEpochTimestamp(void)\n{\n\tTimestamp\tdt;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tGetEpochTime(tm);\n\t/* we don't bother to test for failure ... */\n\ttm2timestamp(tm, 0, NULL, &dt);\n\n\treturn dt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits))"
          ],
          "line": 4568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "1",
            "1"
          ],
          "line": 4561
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 4557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "NULL",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 4556
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "j2day",
          "args": [
            "date2j(tm->tm_year, tm->tm_mon, tm->tm_mday)"
          ],
          "line": 4550
        },
        "resolved": true,
        "details": {
          "function_name": "j2day",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "335-345",
          "snippet": "int\nj2day(int date)\n{\n\tdate += 1;\n\tdate %= 7;\n\t/* Cope if division truncates towards zero, as it probably does */\n\tif (date < 0)\n\t\tdate += 7;\n\n\treturn date;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nj2day(int date)\n{\n\tdate += 1;\n\tdate %= 7;\n\t/* Cope if division truncates towards zero, as it probably does */\n\tif (date < 0)\n\t\tdate += 7;\n\n\treturn date;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 4547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2isoyear",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 4541
        },
        "resolved": true,
        "details": {
          "function_name": "date2isoyearday",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4326-4330",
          "snippet": "int\ndate2isoyearday(int year, int mon, int mday)\n{\n\treturn date2j(year, mon, mday) - isoweek2j(date2isoyear(year, mon, mday), 1) + 1;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2isoyearday(int year, int mon, int mday)\n{\n\treturn date2j(year, mon, mday) - isoweek2j(date2isoyear(year, mon, mday), 1) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2isoweek",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 4487
        },
        "resolved": true,
        "details": {
          "function_name": "date2isoweek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4215-4262",
          "snippet": "int\ndate2isoweek(int year, int mon, int mday)\n{\n\tfloat8\t\tresult;\n\tint\t\t\tday0,\n\t\t\t\tday4,\n\t\t\t\tdayn;\n\n\t/* current day */\n\tdayn = date2j(year, mon, mday);\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\t/*\n\t * We need the first week containing a Thursday, otherwise this day falls\n\t * into the previous year for purposes of counting weeks\n\t */\n\tif (dayn < day4 - day0)\n\t{\n\t\tday4 = date2j(year - 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\t}\n\n\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\n\t/*\n\t * Sometimes the last few days in a year will fall into the first week of\n\t * the next year, so check for this.\n\t */\n\tif (result >= 52)\n\t{\n\t\tday4 = date2j(year + 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\n\t\tif (dayn >= day4 - day0)\n\t\t\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\t}\n\n\treturn (int) result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2isoweek(int year, int mon, int mday)\n{\n\tfloat8\t\tresult;\n\tint\t\t\tday0,\n\t\t\t\tday4,\n\t\t\t\tdayn;\n\n\t/* current day */\n\tdayn = date2j(year, mon, mday);\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\t/*\n\t * We need the first week containing a Thursday, otherwise this day falls\n\t * into the previous year for purposes of counting weeks\n\t */\n\tif (dayn < day4 - day0)\n\t{\n\t\tday4 = date2j(year - 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\t}\n\n\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\n\t/*\n\t * Sometimes the last few days in a year will fall into the first week of\n\t * the next year, so check for this.\n\t */\n\tif (result >= 52)\n\t{\n\t\tday4 = date2j(year + 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\n\t\tif (dayn >= day4 - day0)\n\t\t\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\t}\n\n\treturn (int) result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 4448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 4442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 4440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NonFiniteTimestampTzPart",
          "args": [
            "type",
            "val",
            "lowunits",
            "TIMESTAMP_IS_NOBEGIN(timestamp)",
            "false"
          ],
          "line": 4436
        },
        "resolved": true,
        "details": {
          "function_name": "NonFiniteTimestampTzPart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4343-4407",
          "snippet": "static float8\nNonFiniteTimestampTzPart(int type, int unit, char *lowunits,\n\t\t\t\t\t\t bool isNegative, bool isTz)\n{\n\tif ((type != UNITS) && (type != RESERV))\n\t{\n\t\tif (isTz)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tlowunits)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tlowunits)));\n\t}\n\n\tswitch (unit)\n\t{\n\t\t\t/* Oscillating units */\n\t\tcase DTK_MICROSEC:\n\t\tcase DTK_MILLISEC:\n\t\tcase DTK_SECOND:\n\t\tcase DTK_MINUTE:\n\t\tcase DTK_HOUR:\n\t\tcase DTK_DAY:\n\t\tcase DTK_MONTH:\n\t\tcase DTK_QUARTER:\n\t\tcase DTK_WEEK:\n\t\tcase DTK_DOW:\n\t\tcase DTK_ISODOW:\n\t\tcase DTK_DOY:\n\t\tcase DTK_TZ:\n\t\tcase DTK_TZ_MINUTE:\n\t\tcase DTK_TZ_HOUR:\n\t\t\treturn 0.0;\n\n\t\t\t/* Monotonically-increasing units */\n\t\tcase DTK_YEAR:\n\t\tcase DTK_DECADE:\n\t\tcase DTK_CENTURY:\n\t\tcase DTK_MILLENNIUM:\n\t\tcase DTK_JULIAN:\n\t\tcase DTK_ISOYEAR:\n\t\tcase DTK_EPOCH:\n\t\t\tif (isNegative)\n\t\t\t\treturn -get_float8_infinity();\n\t\t\telse\n\t\t\t\treturn get_float8_infinity();\n\n\t\tdefault:\n\t\t\tif (isTz)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\treturn 0.0;\t\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic float8\nNonFiniteTimestampTzPart(int type, int unit, char *lowunits,\n\t\t\t\t\t\t bool isNegative, bool isTz)\n{\n\tif ((type != UNITS) && (type != RESERV))\n\t{\n\t\tif (isTz)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tlowunits)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tlowunits)));\n\t}\n\n\tswitch (unit)\n\t{\n\t\t\t/* Oscillating units */\n\t\tcase DTK_MICROSEC:\n\t\tcase DTK_MILLISEC:\n\t\tcase DTK_SECOND:\n\t\tcase DTK_MINUTE:\n\t\tcase DTK_HOUR:\n\t\tcase DTK_DAY:\n\t\tcase DTK_MONTH:\n\t\tcase DTK_QUARTER:\n\t\tcase DTK_WEEK:\n\t\tcase DTK_DOW:\n\t\tcase DTK_ISODOW:\n\t\tcase DTK_DOY:\n\t\tcase DTK_TZ:\n\t\tcase DTK_TZ_MINUTE:\n\t\tcase DTK_TZ_HOUR:\n\t\t\treturn 0.0;\n\n\t\t\t/* Monotonically-increasing units */\n\t\tcase DTK_YEAR:\n\t\tcase DTK_DECADE:\n\t\tcase DTK_CENTURY:\n\t\tcase DTK_MILLENNIUM:\n\t\tcase DTK_JULIAN:\n\t\tcase DTK_ISOYEAR:\n\t\tcase DTK_EPOCH:\n\t\t\tif (isNegative)\n\t\t\t\treturn -get_float8_infinity();\n\t\t\telse\n\t\t\t\treturn get_float8_infinity();\n\n\t\tdefault:\n\t\t\tif (isTz)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\treturn 0.0;\t\t\t/* keep compiler quiet */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_IS_NOBEGIN",
          "args": [
            "timestamp"
          ],
          "line": 4437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 4434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeSpecial",
          "args": [
            "0",
            "lowunits",
            "&val"
          ],
          "line": 4432
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3025-3050",
          "snippet": "int\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
            "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];",
            "static const datetkn *datecache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\nstatic const datetkn *datecache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeUnits",
          "args": [
            "0",
            "lowunits",
            "&val"
          ],
          "line": 4430
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeUnits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3716-3741",
          "snippet": "int\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};",
            "static int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];",
            "static const datetkn *deltacache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};\nstatic int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];\nstatic const datetkn *deltacache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcase_truncate_identifier",
          "args": [
            "VARDATA_ANY(units)",
            "VARSIZE_ANY_EXHDR(units)",
            "false"
          ],
          "line": 4426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "units"
          ],
          "line": 4427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "units"
          ],
          "line": 4426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 4416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 4415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamp_part(PG_FUNCTION_ARGS)\n{\n\ttext\t   *units = PG_GETARG_TEXT_PP(0);\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(1);\n\tfloat8\t\tresult;\n\tTimestamp\tepoch;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tchar\t   *lowunits;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tlowunits = downcase_truncate_identifier(VARDATA_ANY(units),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(units),\n\t\t\t\t\t\t\t\t\t\t\tfalse);\n\n\ttype = DecodeUnits(0, lowunits, &val);\n\tif (type == UNKNOWN_FIELD)\n\t\ttype = DecodeSpecial(0, lowunits, &val);\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t{\n\t\tresult = NonFiniteTimestampTzPart(type, val, lowunits,\n\t\t\t\t\t\t\t\t\t\t  TIMESTAMP_IS_NOBEGIN(timestamp),\n\t\t\t\t\t\t\t\t\t\t  false);\n\t\tif (result)\n\t\t\tPG_RETURN_FLOAT8(result);\n\t\telse\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tif (type == UNITS)\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\tswitch (val)\n\t\t{\n\t\t\tcase DTK_MICROSEC:\n\t\t\t\tresult = tm->tm_sec * 1000000.0 + fsec;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MILLISEC:\n\t\t\t\tresult = tm->tm_sec * 1000.0 + fsec / 1000.0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_SECOND:\n\t\t\t\tresult = tm->tm_sec + fsec / 1000000.0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MINUTE:\n\t\t\t\tresult = tm->tm_min;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_HOUR:\n\t\t\t\tresult = tm->tm_hour;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DAY:\n\t\t\t\tresult = tm->tm_mday;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MONTH:\n\t\t\t\tresult = tm->tm_mon;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_QUARTER:\n\t\t\t\tresult = (tm->tm_mon - 1) / 3 + 1;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_WEEK:\n\t\t\t\tresult = (float8) date2isoweek(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_YEAR:\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\tresult = tm->tm_year;\n\t\t\t\telse\n\t\t\t\t\t/* there is no year 0, just 1 BC and 1 AD */\n\t\t\t\t\tresult = tm->tm_year - 1;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DECADE:\n\n\t\t\t\t/*\n\t\t\t\t * what is a decade wrt dates? let us assume that decade 199\n\t\t\t\t * is 1990 thru 1999... decade 0 starts on year 1 BC, and -1\n\t\t\t\t * is 11 BC thru 2 BC...\n\t\t\t\t */\n\t\t\t\tif (tm->tm_year >= 0)\n\t\t\t\t\tresult = tm->tm_year / 10;\n\t\t\t\telse\n\t\t\t\t\tresult = -((8 - (tm->tm_year - 1)) / 10);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_CENTURY:\n\n\t\t\t\t/* ----\n\t\t\t\t * centuries AD, c>0: year in [ (c-1)* 100 + 1 : c*100 ]\n\t\t\t\t * centuries BC, c<0: year in [ c*100 : (c+1) * 100 - 1]\n\t\t\t\t * there is no number 0 century.\n\t\t\t\t * ----\n\t\t\t\t */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\tresult = (tm->tm_year + 99) / 100;\n\t\t\t\telse\n\t\t\t\t\t/* caution: C division may have negative remainder */\n\t\t\t\t\tresult = -((99 - (tm->tm_year - 1)) / 100);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MILLENNIUM:\n\t\t\t\t/* see comments above. */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\tresult = (tm->tm_year + 999) / 1000;\n\t\t\t\telse\n\t\t\t\t\tresult = -((999 - (tm->tm_year - 1)) / 1000);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_JULIAN:\n\t\t\t\tresult = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\t\tresult += ((((tm->tm_hour * MINS_PER_HOUR) + tm->tm_min) * SECS_PER_MINUTE) +\n\t\t\t\t\t\t   tm->tm_sec + (fsec / 1000000.0)) / (double) SECS_PER_DAY;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_ISOYEAR:\n\t\t\t\tresult = date2isoyear(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DOW:\n\t\t\tcase DTK_ISODOW:\n\t\t\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t\tresult = j2day(date2j(tm->tm_year, tm->tm_mon, tm->tm_mday));\n\t\t\t\tif (val == DTK_ISODOW && result == 0)\n\t\t\t\t\tresult = 7;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DOY:\n\t\t\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t\tresult = (date2j(tm->tm_year, tm->tm_mon, tm->tm_mday)\n\t\t\t\t\t\t  - date2j(tm->tm_year, 1, 1) + 1);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\tcase DTK_TZ_MINUTE:\n\t\t\tcase DTK_TZ_HOUR:\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\tresult = 0;\n\t\t}\n\t}\n\telse if (type == RESERV)\n\t{\n\t\tswitch (val)\n\t\t{\n\t\t\tcase DTK_EPOCH:\n\t\t\t\tepoch = SetEpochTimestamp();\n\t\t\t\t/* try to avoid precision loss in subtraction */\n\t\t\t\tif (timestamp < (PG_INT64_MAX + epoch))\n\t\t\t\t\tresult = (timestamp - epoch) / 1000000.0;\n\t\t\t\telse\n\t\t\t\t\tresult = ((float8) timestamp - epoch) / 1000000.0;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\tresult = 0;\n\t\t}\n\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not recognized\", lowunits)));\n\t\tresult = 0;\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "NonFiniteTimestampTzPart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "4343-4407",
    "snippet": "static float8\nNonFiniteTimestampTzPart(int type, int unit, char *lowunits,\n\t\t\t\t\t\t bool isNegative, bool isTz)\n{\n\tif ((type != UNITS) && (type != RESERV))\n\t{\n\t\tif (isTz)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tlowunits)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tlowunits)));\n\t}\n\n\tswitch (unit)\n\t{\n\t\t\t/* Oscillating units */\n\t\tcase DTK_MICROSEC:\n\t\tcase DTK_MILLISEC:\n\t\tcase DTK_SECOND:\n\t\tcase DTK_MINUTE:\n\t\tcase DTK_HOUR:\n\t\tcase DTK_DAY:\n\t\tcase DTK_MONTH:\n\t\tcase DTK_QUARTER:\n\t\tcase DTK_WEEK:\n\t\tcase DTK_DOW:\n\t\tcase DTK_ISODOW:\n\t\tcase DTK_DOY:\n\t\tcase DTK_TZ:\n\t\tcase DTK_TZ_MINUTE:\n\t\tcase DTK_TZ_HOUR:\n\t\t\treturn 0.0;\n\n\t\t\t/* Monotonically-increasing units */\n\t\tcase DTK_YEAR:\n\t\tcase DTK_DECADE:\n\t\tcase DTK_CENTURY:\n\t\tcase DTK_MILLENNIUM:\n\t\tcase DTK_JULIAN:\n\t\tcase DTK_ISOYEAR:\n\t\tcase DTK_EPOCH:\n\t\t\tif (isNegative)\n\t\t\t\treturn -get_float8_infinity();\n\t\t\telse\n\t\t\t\treturn get_float8_infinity();\n\n\t\tdefault:\n\t\t\tif (isTz)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\treturn 0.0;\t\t\t/* keep compiler quiet */\n\t}\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits))"
          ],
          "line": 4401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp units \\\"%s\\\" not supported\"",
            "lowunits"
          ],
          "line": 4403
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 4402
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits))"
          ],
          "line": 4396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_infinity",
          "args": [],
          "line": 4392
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_infinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "117-132",
          "snippet": "double\nget_float8_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (double) INFINITY;\n#else\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (double) (HUGE_VAL * HUGE_VAL);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ndouble\nget_float8_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (double) INFINITY;\n#else\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (double) (HUGE_VAL * HUGE_VAL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tlowunits))"
          ],
          "line": 4355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tlowunits))"
          ],
          "line": 4350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic float8\nNonFiniteTimestampTzPart(int type, int unit, char *lowunits,\n\t\t\t\t\t\t bool isNegative, bool isTz)\n{\n\tif ((type != UNITS) && (type != RESERV))\n\t{\n\t\tif (isTz)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tlowunits)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tlowunits)));\n\t}\n\n\tswitch (unit)\n\t{\n\t\t\t/* Oscillating units */\n\t\tcase DTK_MICROSEC:\n\t\tcase DTK_MILLISEC:\n\t\tcase DTK_SECOND:\n\t\tcase DTK_MINUTE:\n\t\tcase DTK_HOUR:\n\t\tcase DTK_DAY:\n\t\tcase DTK_MONTH:\n\t\tcase DTK_QUARTER:\n\t\tcase DTK_WEEK:\n\t\tcase DTK_DOW:\n\t\tcase DTK_ISODOW:\n\t\tcase DTK_DOY:\n\t\tcase DTK_TZ:\n\t\tcase DTK_TZ_MINUTE:\n\t\tcase DTK_TZ_HOUR:\n\t\t\treturn 0.0;\n\n\t\t\t/* Monotonically-increasing units */\n\t\tcase DTK_YEAR:\n\t\tcase DTK_DECADE:\n\t\tcase DTK_CENTURY:\n\t\tcase DTK_MILLENNIUM:\n\t\tcase DTK_JULIAN:\n\t\tcase DTK_ISOYEAR:\n\t\tcase DTK_EPOCH:\n\t\t\tif (isNegative)\n\t\t\t\treturn -get_float8_infinity();\n\t\t\telse\n\t\t\t\treturn get_float8_infinity();\n\n\t\tdefault:\n\t\t\tif (isTz)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\treturn 0.0;\t\t\t/* keep compiler quiet */\n\t}\n}"
  },
  {
    "function_name": "date2isoyearday",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "4326-4330",
    "snippet": "int\ndate2isoyearday(int year, int mon, int mday)\n{\n\treturn date2j(year, mon, mday) - isoweek2j(date2isoyear(year, mon, mday), 1) + 1;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isoweek2j",
          "args": [
            "date2isoyear(year, mon, mday)",
            "1"
          ],
          "line": 4329
        },
        "resolved": true,
        "details": {
          "function_name": "isoweek2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4164-4177",
          "snippet": "int\nisoweek2j(int year, int week)\n{\n\tint\t\t\tday0,\n\t\t\t\tday4;\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\treturn ((week - 1) * 7) + (day4 - day0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nisoweek2j(int year, int week)\n{\n\tint\t\t\tday0,\n\t\t\t\tday4;\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\treturn ((week - 1) * 7) + (day4 - day0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2isoyear",
          "args": [
            "year",
            "mon",
            "mday"
          ],
          "line": 4329
        },
        "resolved": true,
        "details": {
          "function_name": "date2isoyearday",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4326-4330",
          "snippet": "int\ndate2isoyearday(int year, int mon, int mday)\n{\n\treturn date2j(year, mon, mday) - isoweek2j(date2isoyear(year, mon, mday), 1) + 1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "year",
            "mon",
            "mday"
          ],
          "line": 4329
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2isoyearday(int year, int mon, int mday)\n{\n\treturn date2j(year, mon, mday) - isoweek2j(date2isoyear(year, mon, mday), 1) + 1;\n}"
  },
  {
    "function_name": "date2isoyear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "4269-4318",
    "snippet": "int\ndate2isoyear(int year, int mon, int mday)\n{\n\tfloat8\t\tresult;\n\tint\t\t\tday0,\n\t\t\t\tday4,\n\t\t\t\tdayn;\n\n\t/* current day */\n\tdayn = date2j(year, mon, mday);\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\t/*\n\t * We need the first week containing a Thursday, otherwise this day falls\n\t * into the previous year for purposes of counting weeks\n\t */\n\tif (dayn < day4 - day0)\n\t{\n\t\tday4 = date2j(year - 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\n\t\tyear--;\n\t}\n\n\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\n\t/*\n\t * Sometimes the last few days in a year will fall into the first week of\n\t * the next year, so check for this.\n\t */\n\tif (result >= 52)\n\t{\n\t\tday4 = date2j(year + 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\n\t\tif (dayn >= day4 - day0)\n\t\t\tyear++;\n\t}\n\n\treturn year;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "j2day",
          "args": [
            "day4 - 1"
          ],
          "line": 4311
        },
        "resolved": true,
        "details": {
          "function_name": "j2day",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "335-345",
          "snippet": "int\nj2day(int date)\n{\n\tdate += 1;\n\tdate %= 7;\n\t/* Cope if division truncates towards zero, as it probably does */\n\tif (date < 0)\n\t\tdate += 7;\n\n\treturn date;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nj2day(int date)\n{\n\tdate += 1;\n\tdate %= 7;\n\t/* Cope if division truncates towards zero, as it probably does */\n\tif (date < 0)\n\t\tdate += 7;\n\n\treturn date;\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "year + 1",
            "1",
            "4"
          ],
          "line": 4308
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2isoyear(int year, int mon, int mday)\n{\n\tfloat8\t\tresult;\n\tint\t\t\tday0,\n\t\t\t\tday4,\n\t\t\t\tdayn;\n\n\t/* current day */\n\tdayn = date2j(year, mon, mday);\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\t/*\n\t * We need the first week containing a Thursday, otherwise this day falls\n\t * into the previous year for purposes of counting weeks\n\t */\n\tif (dayn < day4 - day0)\n\t{\n\t\tday4 = date2j(year - 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\n\t\tyear--;\n\t}\n\n\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\n\t/*\n\t * Sometimes the last few days in a year will fall into the first week of\n\t * the next year, so check for this.\n\t */\n\tif (result >= 52)\n\t{\n\t\tday4 = date2j(year + 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\n\t\tif (dayn >= day4 - day0)\n\t\t\tyear++;\n\t}\n\n\treturn year;\n}"
  },
  {
    "function_name": "date2isoweek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "4215-4262",
    "snippet": "int\ndate2isoweek(int year, int mon, int mday)\n{\n\tfloat8\t\tresult;\n\tint\t\t\tday0,\n\t\t\t\tday4,\n\t\t\t\tdayn;\n\n\t/* current day */\n\tdayn = date2j(year, mon, mday);\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\t/*\n\t * We need the first week containing a Thursday, otherwise this day falls\n\t * into the previous year for purposes of counting weeks\n\t */\n\tif (dayn < day4 - day0)\n\t{\n\t\tday4 = date2j(year - 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\t}\n\n\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\n\t/*\n\t * Sometimes the last few days in a year will fall into the first week of\n\t * the next year, so check for this.\n\t */\n\tif (result >= 52)\n\t{\n\t\tday4 = date2j(year + 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\n\t\tif (dayn >= day4 - day0)\n\t\t\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\t}\n\n\treturn (int) result;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "j2day",
          "args": [
            "day4 - 1"
          ],
          "line": 4255
        },
        "resolved": true,
        "details": {
          "function_name": "j2day",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "335-345",
          "snippet": "int\nj2day(int date)\n{\n\tdate += 1;\n\tdate %= 7;\n\t/* Cope if division truncates towards zero, as it probably does */\n\tif (date < 0)\n\t\tdate += 7;\n\n\treturn date;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nj2day(int date)\n{\n\tdate += 1;\n\tdate %= 7;\n\t/* Cope if division truncates towards zero, as it probably does */\n\tif (date < 0)\n\t\tdate += 7;\n\n\treturn date;\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "year + 1",
            "1",
            "4"
          ],
          "line": 4252
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2isoweek(int year, int mon, int mday)\n{\n\tfloat8\t\tresult;\n\tint\t\t\tday0,\n\t\t\t\tday4,\n\t\t\t\tdayn;\n\n\t/* current day */\n\tdayn = date2j(year, mon, mday);\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\t/*\n\t * We need the first week containing a Thursday, otherwise this day falls\n\t * into the previous year for purposes of counting weeks\n\t */\n\tif (dayn < day4 - day0)\n\t{\n\t\tday4 = date2j(year - 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\t}\n\n\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\n\t/*\n\t * Sometimes the last few days in a year will fall into the first week of\n\t * the next year, so check for this.\n\t */\n\tif (result >= 52)\n\t{\n\t\tday4 = date2j(year + 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\n\t\tif (dayn >= day4 - day0)\n\t\t\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\t}\n\n\treturn (int) result;\n}"
  },
  {
    "function_name": "isoweekdate2date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "4197-4209",
    "snippet": "void\nisoweekdate2date(int isoweek, int wday, int *year, int *mon, int *mday)\n{\n\tint\t\t\tjday;\n\n\tjday = isoweek2j(*year, isoweek);\n\t/* convert Gregorian week start (Sunday=1) to ISO week start (Monday=1) */\n\tif (wday > 1)\n\t\tjday += wday - 2;\n\telse\n\t\tjday += 6;\n\tj2date(jday, year, mon, mday);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "j2date",
          "args": [
            "jday",
            "year",
            "mon",
            "mday"
          ],
          "line": 4208
        },
        "resolved": true,
        "details": {
          "function_name": "j2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "300-325",
          "snippet": "void\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isoweek2j",
          "args": [
            "*year",
            "isoweek"
          ],
          "line": 4202
        },
        "resolved": true,
        "details": {
          "function_name": "isoweek2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4164-4177",
          "snippet": "int\nisoweek2j(int year, int week)\n{\n\tint\t\t\tday0,\n\t\t\t\tday4;\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\treturn ((week - 1) * 7) + (day4 - day0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nisoweek2j(int year, int week)\n{\n\tint\t\t\tday0,\n\t\t\t\tday4;\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\treturn ((week - 1) * 7) + (day4 - day0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nisoweekdate2date(int isoweek, int wday, int *year, int *mon, int *mday)\n{\n\tint\t\t\tjday;\n\n\tjday = isoweek2j(*year, isoweek);\n\t/* convert Gregorian week start (Sunday=1) to ISO week start (Monday=1) */\n\tif (wday > 1)\n\t\tjday += wday - 2;\n\telse\n\t\tjday += 6;\n\tj2date(jday, year, mon, mday);\n}"
  },
  {
    "function_name": "isoweek2date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "4184-4188",
    "snippet": "void\nisoweek2date(int woy, int *year, int *mon, int *mday)\n{\n\tj2date(isoweek2j(*year, woy), year, mon, mday);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "j2date",
          "args": [
            "isoweek2j(*year, woy)",
            "year",
            "mon",
            "mday"
          ],
          "line": 4187
        },
        "resolved": true,
        "details": {
          "function_name": "j2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "300-325",
          "snippet": "void\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isoweek2j",
          "args": [
            "*year",
            "woy"
          ],
          "line": 4187
        },
        "resolved": true,
        "details": {
          "function_name": "isoweek2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4164-4177",
          "snippet": "int\nisoweek2j(int year, int week)\n{\n\tint\t\t\tday0,\n\t\t\t\tday4;\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\treturn ((week - 1) * 7) + (day4 - day0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nisoweek2j(int year, int week)\n{\n\tint\t\t\tday0,\n\t\t\t\tday4;\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\treturn ((week - 1) * 7) + (day4 - day0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nisoweek2date(int woy, int *year, int *mon, int *mday)\n{\n\tj2date(isoweek2j(*year, woy), year, mon, mday);\n}"
  },
  {
    "function_name": "isoweek2j",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "4164-4177",
    "snippet": "int\nisoweek2j(int year, int week)\n{\n\tint\t\t\tday0,\n\t\t\t\tday4;\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\treturn ((week - 1) * 7) + (day4 - day0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "j2day",
          "args": [
            "day4 - 1"
          ],
          "line": 4174
        },
        "resolved": true,
        "details": {
          "function_name": "j2day",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "335-345",
          "snippet": "int\nj2day(int date)\n{\n\tdate += 1;\n\tdate %= 7;\n\t/* Cope if division truncates towards zero, as it probably does */\n\tif (date < 0)\n\t\tdate += 7;\n\n\treturn date;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nj2day(int date)\n{\n\tdate += 1;\n\tdate %= 7;\n\t/* Cope if division truncates towards zero, as it probably does */\n\tif (date < 0)\n\t\tdate += 7;\n\n\treturn date;\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "year",
            "1",
            "4"
          ],
          "line": 4171
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nisoweek2j(int year, int week)\n{\n\tint\t\t\tday0,\n\t\t\t\tday4;\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\treturn ((week - 1) * 7) + (day4 - day0);\n}"
  },
  {
    "function_name": "interval_trunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "4060-4157",
    "snippet": "Datum\ninterval_trunc(PG_FUNCTION_ARGS)\n{\n\ttext\t   *units = PG_GETARG_TEXT_PP(0);\n\tInterval   *interval = PG_GETARG_INTERVAL_P(1);\n\tInterval   *result;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tchar\t   *lowunits;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tlowunits = downcase_truncate_identifier(VARDATA_ANY(units),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(units),\n\t\t\t\t\t\t\t\t\t\t\tfalse);\n\n\ttype = DecodeUnits(0, lowunits, &val);\n\n\tif (type == UNITS)\n\t{\n\t\tif (interval2tm(*interval, tm, &fsec) == 0)\n\t\t{\n\t\t\tswitch (val)\n\t\t\t{\n\t\t\t\tcase DTK_MILLENNIUM:\n\t\t\t\t\t/* caution: C division may have negative remainder */\n\t\t\t\t\ttm->tm_year = (tm->tm_year / 1000) * 1000;\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_CENTURY:\n\t\t\t\t\t/* caution: C division may have negative remainder */\n\t\t\t\t\ttm->tm_year = (tm->tm_year / 100) * 100;\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_DECADE:\n\t\t\t\t\t/* caution: C division may have negative remainder */\n\t\t\t\t\ttm->tm_year = (tm->tm_year / 10) * 10;\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\ttm->tm_mon = 0;\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_QUARTER:\n\t\t\t\t\ttm->tm_mon = 3 * (tm->tm_mon / 3);\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_MONTH:\n\t\t\t\t\ttm->tm_mday = 0;\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_DAY:\n\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\tfsec = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DTK_MILLISEC:\n\t\t\t\t\tfsec = (fsec / 1000) * 1000;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DTK_MICROSEC:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (val == DTK_WEEK)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t errmsg(\"interval units \\\"%s\\\" not supported \"\n\t\t\t\t\t\t\t\t\t\t\"because months usually have fractional weeks\",\n\t\t\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t errmsg(\"interval units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t}\n\n\t\t\tif (tm2interval(tm, fsec, result) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"interval out of range\")));\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"could not convert interval to tm\");\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits)));\n\t}\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits))"
          ],
          "line": 4150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"interval units \\\"%s\\\" not recognized\"",
            "lowunits"
          ],
          "line": 4152
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 4151
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not convert interval to tm\""
          ],
          "line": 4146
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 4141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm2interval",
          "args": [
            "tm",
            "fsec",
            "result"
          ],
          "line": 4140
        },
        "resolved": true,
        "details": {
          "function_name": "tm2interval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1929-1943",
          "snippet": "int\ntm2interval(struct pg_tm *tm, fsec_t fsec, Interval *span)\n{\n\tdouble\t\ttotal_months = (double) tm->tm_year * MONTHS_PER_YEAR + tm->tm_mon;\n\n\tif (total_months > INT_MAX || total_months < INT_MIN)\n\t\treturn -1;\n\tspan->month = total_months;\n\tspan->day = tm->tm_mday;\n\tspan->time = (((((tm->tm_hour * INT64CONST(60)) +\n\t\t\t\t\t tm->tm_min) * INT64CONST(60)) +\n\t\t\t\t   tm->tm_sec) * USECS_PER_SEC) + fsec;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2interval(struct pg_tm *tm, fsec_t fsec, Interval *span)\n{\n\tdouble\t\ttotal_months = (double) tm->tm_year * MONTHS_PER_YEAR + tm->tm_mon;\n\n\tif (total_months > INT_MAX || total_months < INT_MIN)\n\t\treturn -1;\n\tspan->month = total_months;\n\tspan->day = tm->tm_mday;\n\tspan->time = (((((tm->tm_hour * INT64CONST(60)) +\n\t\t\t\t\t tm->tm_min) * INT64CONST(60)) +\n\t\t\t\t   tm->tm_sec) * USECS_PER_SEC) + fsec;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t errmsg(\"interval units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\t\t\tlowunits))"
          ],
          "line": 4134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t errmsg(\"interval units \\\"%s\\\" not supported \"\n\t\t\t\t\t\t\t\t\t\t\"because months usually have fractional weeks\",\n\t\t\t\t\t\t\t\t\t\tlowunits))"
          ],
          "line": 4128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval2tm",
          "args": [
            "*interval",
            "tm",
            "&fsec"
          ],
          "line": 4083
        },
        "resolved": true,
        "details": {
          "function_name": "interval2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1901-1927",
          "snippet": "int\ninterval2tm(Interval span, struct pg_tm *tm, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\tTimeOffset\ttfrac;\n\n\ttm->tm_year = span.month / MONTHS_PER_YEAR;\n\ttm->tm_mon = span.month % MONTHS_PER_YEAR;\n\ttm->tm_mday = span.day;\n\ttime = span.time;\n\n\ttfrac = time / USECS_PER_HOUR;\n\ttime -= tfrac * USECS_PER_HOUR;\n\ttm->tm_hour = tfrac;\n\tif (!SAMESIGN(tm->tm_hour, tfrac))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\ttfrac = time / USECS_PER_MINUTE;\n\ttime -= tfrac * USECS_PER_MINUTE;\n\ttm->tm_min = tfrac;\n\ttfrac = time / USECS_PER_SEC;\n\t*fsec = time - (tfrac * USECS_PER_SEC);\n\ttm->tm_sec = tfrac;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ninterval2tm(Interval span, struct pg_tm *tm, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\tTimeOffset\ttfrac;\n\n\ttm->tm_year = span.month / MONTHS_PER_YEAR;\n\ttm->tm_mon = span.month % MONTHS_PER_YEAR;\n\ttm->tm_mday = span.day;\n\ttime = span.time;\n\n\ttfrac = time / USECS_PER_HOUR;\n\ttime -= tfrac * USECS_PER_HOUR;\n\ttm->tm_hour = tfrac;\n\tif (!SAMESIGN(tm->tm_hour, tfrac))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\ttfrac = time / USECS_PER_MINUTE;\n\ttime -= tfrac * USECS_PER_MINUTE;\n\ttm->tm_min = tfrac;\n\ttfrac = time / USECS_PER_SEC;\n\t*fsec = time - (tfrac * USECS_PER_SEC);\n\ttm->tm_sec = tfrac;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeUnits",
          "args": [
            "0",
            "lowunits",
            "&val"
          ],
          "line": 4079
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeUnits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3716-3741",
          "snippet": "int\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};",
            "static int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];",
            "static const datetkn *deltacache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};\nstatic int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];\nstatic const datetkn *deltacache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcase_truncate_identifier",
          "args": [
            "VARDATA_ANY(units)",
            "VARSIZE_ANY_EXHDR(units)",
            "false"
          ],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "units"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "units"
          ],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 4073
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 4064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 4063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nDatum\ninterval_trunc(PG_FUNCTION_ARGS)\n{\n\ttext\t   *units = PG_GETARG_TEXT_PP(0);\n\tInterval   *interval = PG_GETARG_INTERVAL_P(1);\n\tInterval   *result;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tchar\t   *lowunits;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tlowunits = downcase_truncate_identifier(VARDATA_ANY(units),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(units),\n\t\t\t\t\t\t\t\t\t\t\tfalse);\n\n\ttype = DecodeUnits(0, lowunits, &val);\n\n\tif (type == UNITS)\n\t{\n\t\tif (interval2tm(*interval, tm, &fsec) == 0)\n\t\t{\n\t\t\tswitch (val)\n\t\t\t{\n\t\t\t\tcase DTK_MILLENNIUM:\n\t\t\t\t\t/* caution: C division may have negative remainder */\n\t\t\t\t\ttm->tm_year = (tm->tm_year / 1000) * 1000;\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_CENTURY:\n\t\t\t\t\t/* caution: C division may have negative remainder */\n\t\t\t\t\ttm->tm_year = (tm->tm_year / 100) * 100;\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_DECADE:\n\t\t\t\t\t/* caution: C division may have negative remainder */\n\t\t\t\t\ttm->tm_year = (tm->tm_year / 10) * 10;\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\ttm->tm_mon = 0;\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_QUARTER:\n\t\t\t\t\ttm->tm_mon = 3 * (tm->tm_mon / 3);\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_MONTH:\n\t\t\t\t\ttm->tm_mday = 0;\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_DAY:\n\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t/* FALL THRU */\n\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\tfsec = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DTK_MILLISEC:\n\t\t\t\t\tfsec = (fsec / 1000) * 1000;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DTK_MICROSEC:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (val == DTK_WEEK)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t errmsg(\"interval units \\\"%s\\\" not supported \"\n\t\t\t\t\t\t\t\t\t\t\"because months usually have fractional weeks\",\n\t\t\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t errmsg(\"interval units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t}\n\n\t\t\tif (tm2interval(tm, fsec, result) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"interval out of range\")));\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"could not convert interval to tm\");\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits)));\n\t}\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "timestamptz_trunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3911-4055",
    "snippet": "Datum\ntimestamptz_trunc(PG_FUNCTION_ARGS)\n{\n\ttext\t   *units = PG_GETARG_TEXT_PP(0);\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz result;\n\tint\t\t\ttz;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tbool\t\tredotz = false;\n\tchar\t   *lowunits;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_TIMESTAMPTZ(timestamp);\n\n\tlowunits = downcase_truncate_identifier(VARDATA_ANY(units),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(units),\n\t\t\t\t\t\t\t\t\t\t\tfalse);\n\n\ttype = DecodeUnits(0, lowunits, &val);\n\n\tif (type == UNITS)\n\t{\n\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\tswitch (val)\n\t\t{\n\t\t\tcase DTK_WEEK:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\twoy;\n\n\t\t\t\t\twoy = date2isoweek(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If it is week 52/53 and the month is January, then the\n\t\t\t\t\t * week must belong to the previous year. Also, some\n\t\t\t\t\t * December dates belong to the next year.\n\t\t\t\t\t */\n\t\t\t\t\tif (woy >= 52 && tm->tm_mon == 1)\n\t\t\t\t\t\t--tm->tm_year;\n\t\t\t\t\tif (woy <= 1 && tm->tm_mon == MONTHS_PER_YEAR)\n\t\t\t\t\t\t++tm->tm_year;\n\t\t\t\t\tisoweek2date(woy, &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\tfsec = 0;\n\t\t\t\t\tredotz = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* one may consider DTK_THOUSAND and DTK_HUNDRED... */\n\t\t\tcase DTK_MILLENNIUM:\n\n\t\t\t\t/*\n\t\t\t\t * truncating to the millennium? what is this supposed to\n\t\t\t\t * mean? let us put the first year of the millennium... i.e.\n\t\t\t\t * -1000, 1, 1001, 2001...\n\t\t\t\t */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\ttm->tm_year = ((tm->tm_year + 999) / 1000) * 1000 - 999;\n\t\t\t\telse\n\t\t\t\t\ttm->tm_year = -((999 - (tm->tm_year - 1)) / 1000) * 1000 + 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_CENTURY:\n\t\t\t\t/* truncating to the century? as above: -100, 1, 101... */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\ttm->tm_year = ((tm->tm_year + 99) / 100) * 100 - 99;\n\t\t\t\telse\n\t\t\t\t\ttm->tm_year = -((99 - (tm->tm_year - 1)) / 100) * 100 + 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_DECADE:\n\n\t\t\t\t/*\n\t\t\t\t * truncating to the decade? first year of the decade. must\n\t\t\t\t * not be applied if year was truncated before!\n\t\t\t\t */\n\t\t\t\tif (val != DTK_MILLENNIUM && val != DTK_CENTURY)\n\t\t\t\t{\n\t\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\t\ttm->tm_year = (tm->tm_year / 10) * 10;\n\t\t\t\t\telse\n\t\t\t\t\t\ttm->tm_year = -((8 - (tm->tm_year - 1)) / 10) * 10;\n\t\t\t\t}\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_YEAR:\n\t\t\t\ttm->tm_mon = 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_QUARTER:\n\t\t\t\ttm->tm_mon = (3 * ((tm->tm_mon - 1) / 3)) + 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_MONTH:\n\t\t\t\ttm->tm_mday = 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_DAY:\n\t\t\t\ttm->tm_hour = 0;\n\t\t\t\tredotz = true;\t/* for all cases >= DAY */\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_HOUR:\n\t\t\t\ttm->tm_min = 0;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_MINUTE:\n\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_SECOND:\n\t\t\t\tfsec = 0;\n\t\t\t\tbreak;\n\t\t\tcase DTK_MILLISEC:\n\t\t\t\tfsec = (fsec / 1000) * 1000;\n\t\t\t\tbreak;\n\t\t\tcase DTK_MICROSEC:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not \"\n\t\t\t\t\t\t\t\t\"supported\", lowunits)));\n\t\t\t\tresult = 0;\n\t\t}\n\n\t\tif (redotz)\n\t\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits)));\n\t\tresult = 0;\n\t}\n\n\tPG_RETURN_TIMESTAMPTZ(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "result"
          ],
          "line": 4054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits))"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp with time zone units \\\"%s\\\" not recognized\"",
            "lowunits"
          ],
          "line": 4049
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 4048
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 4041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm2timestamp",
          "args": [
            "tm",
            "fsec",
            "&tz",
            "&result"
          ],
          "line": 4040
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1853-1895",
          "snippet": "int\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneOffset",
          "args": [
            "tm",
            "session_timezone"
          ],
          "line": 4038
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1454-1460",
          "snippet": "int\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not \"\n\t\t\t\t\t\t\t\t\"supported\", lowunits))"
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isoweek2date",
          "args": [
            "woy",
            "&(tm->tm_year)",
            "&(tm->tm_mon)",
            "&(tm->tm_mday)"
          ],
          "line": 3959
        },
        "resolved": true,
        "details": {
          "function_name": "isoweek2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4184-4188",
          "snippet": "void\nisoweek2date(int woy, int *year, int *mon, int *mday)\n{\n\tj2date(isoweek2j(*year, woy), year, mon, mday);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nisoweek2date(int woy, int *year, int *mon, int *mday)\n{\n\tj2date(isoweek2j(*year, woy), year, mon, mday);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2isoweek",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 3948
        },
        "resolved": true,
        "details": {
          "function_name": "date2isoweek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4215-4262",
          "snippet": "int\ndate2isoweek(int year, int mon, int mday)\n{\n\tfloat8\t\tresult;\n\tint\t\t\tday0,\n\t\t\t\tday4,\n\t\t\t\tdayn;\n\n\t/* current day */\n\tdayn = date2j(year, mon, mday);\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\t/*\n\t * We need the first week containing a Thursday, otherwise this day falls\n\t * into the previous year for purposes of counting weeks\n\t */\n\tif (dayn < day4 - day0)\n\t{\n\t\tday4 = date2j(year - 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\t}\n\n\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\n\t/*\n\t * Sometimes the last few days in a year will fall into the first week of\n\t * the next year, so check for this.\n\t */\n\tif (result >= 52)\n\t{\n\t\tday4 = date2j(year + 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\n\t\tif (dayn >= day4 - day0)\n\t\t\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\t}\n\n\treturn (int) result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2isoweek(int year, int mon, int mday)\n{\n\tfloat8\t\tresult;\n\tint\t\t\tday0,\n\t\t\t\tday4,\n\t\t\t\tdayn;\n\n\t/* current day */\n\tdayn = date2j(year, mon, mday);\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\t/*\n\t * We need the first week containing a Thursday, otherwise this day falls\n\t * into the previous year for purposes of counting weeks\n\t */\n\tif (dayn < day4 - day0)\n\t{\n\t\tday4 = date2j(year - 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\t}\n\n\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\n\t/*\n\t * Sometimes the last few days in a year will fall into the first week of\n\t * the next year, so check for this.\n\t */\n\tif (result >= 52)\n\t{\n\t\tday4 = date2j(year + 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\n\t\tif (dayn >= day4 - day0)\n\t\t\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\t}\n\n\treturn (int) result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 3938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "&tz",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 3937
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeUnits",
          "args": [
            "0",
            "lowunits",
            "&val"
          ],
          "line": 3933
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeUnits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3716-3741",
          "snippet": "int\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};",
            "static int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];",
            "static const datetkn *deltacache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};\nstatic int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];\nstatic const datetkn *deltacache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcase_truncate_identifier",
          "args": [
            "VARDATA_ANY(units)",
            "VARSIZE_ANY_EXHDR(units)",
            "false"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "units"
          ],
          "line": 3930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "units"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "timestamp"
          ],
          "line": 3927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 3926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 3915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 3914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamptz_trunc(PG_FUNCTION_ARGS)\n{\n\ttext\t   *units = PG_GETARG_TEXT_PP(0);\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz result;\n\tint\t\t\ttz;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tbool\t\tredotz = false;\n\tchar\t   *lowunits;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_TIMESTAMPTZ(timestamp);\n\n\tlowunits = downcase_truncate_identifier(VARDATA_ANY(units),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(units),\n\t\t\t\t\t\t\t\t\t\t\tfalse);\n\n\ttype = DecodeUnits(0, lowunits, &val);\n\n\tif (type == UNITS)\n\t{\n\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\tswitch (val)\n\t\t{\n\t\t\tcase DTK_WEEK:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\twoy;\n\n\t\t\t\t\twoy = date2isoweek(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If it is week 52/53 and the month is January, then the\n\t\t\t\t\t * week must belong to the previous year. Also, some\n\t\t\t\t\t * December dates belong to the next year.\n\t\t\t\t\t */\n\t\t\t\t\tif (woy >= 52 && tm->tm_mon == 1)\n\t\t\t\t\t\t--tm->tm_year;\n\t\t\t\t\tif (woy <= 1 && tm->tm_mon == MONTHS_PER_YEAR)\n\t\t\t\t\t\t++tm->tm_year;\n\t\t\t\t\tisoweek2date(woy, &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\tfsec = 0;\n\t\t\t\t\tredotz = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* one may consider DTK_THOUSAND and DTK_HUNDRED... */\n\t\t\tcase DTK_MILLENNIUM:\n\n\t\t\t\t/*\n\t\t\t\t * truncating to the millennium? what is this supposed to\n\t\t\t\t * mean? let us put the first year of the millennium... i.e.\n\t\t\t\t * -1000, 1, 1001, 2001...\n\t\t\t\t */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\ttm->tm_year = ((tm->tm_year + 999) / 1000) * 1000 - 999;\n\t\t\t\telse\n\t\t\t\t\ttm->tm_year = -((999 - (tm->tm_year - 1)) / 1000) * 1000 + 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_CENTURY:\n\t\t\t\t/* truncating to the century? as above: -100, 1, 101... */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\ttm->tm_year = ((tm->tm_year + 99) / 100) * 100 - 99;\n\t\t\t\telse\n\t\t\t\t\ttm->tm_year = -((99 - (tm->tm_year - 1)) / 100) * 100 + 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_DECADE:\n\n\t\t\t\t/*\n\t\t\t\t * truncating to the decade? first year of the decade. must\n\t\t\t\t * not be applied if year was truncated before!\n\t\t\t\t */\n\t\t\t\tif (val != DTK_MILLENNIUM && val != DTK_CENTURY)\n\t\t\t\t{\n\t\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\t\ttm->tm_year = (tm->tm_year / 10) * 10;\n\t\t\t\t\telse\n\t\t\t\t\t\ttm->tm_year = -((8 - (tm->tm_year - 1)) / 10) * 10;\n\t\t\t\t}\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_YEAR:\n\t\t\t\ttm->tm_mon = 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_QUARTER:\n\t\t\t\ttm->tm_mon = (3 * ((tm->tm_mon - 1) / 3)) + 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_MONTH:\n\t\t\t\ttm->tm_mday = 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_DAY:\n\t\t\t\ttm->tm_hour = 0;\n\t\t\t\tredotz = true;\t/* for all cases >= DAY */\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_HOUR:\n\t\t\t\ttm->tm_min = 0;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_MINUTE:\n\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_SECOND:\n\t\t\t\tfsec = 0;\n\t\t\t\tbreak;\n\t\t\tcase DTK_MILLISEC:\n\t\t\t\tfsec = (fsec / 1000) * 1000;\n\t\t\t\tbreak;\n\t\t\tcase DTK_MICROSEC:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not \"\n\t\t\t\t\t\t\t\t\"supported\", lowunits)));\n\t\t\t\tresult = 0;\n\t\t}\n\n\t\tif (redotz)\n\t\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"timestamp with time zone units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits)));\n\t\tresult = 0;\n\t}\n\n\tPG_RETURN_TIMESTAMPTZ(result);\n}"
  },
  {
    "function_name": "timestamp_trunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3777-3906",
    "snippet": "Datum\ntimestamp_trunc(PG_FUNCTION_ARGS)\n{\n\ttext\t   *units = PG_GETARG_TEXT_PP(0);\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tresult;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tchar\t   *lowunits;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_TIMESTAMP(timestamp);\n\n\tlowunits = downcase_truncate_identifier(VARDATA_ANY(units),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(units),\n\t\t\t\t\t\t\t\t\t\t\tfalse);\n\n\ttype = DecodeUnits(0, lowunits, &val);\n\n\tif (type == UNITS)\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\tswitch (val)\n\t\t{\n\t\t\tcase DTK_WEEK:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\twoy;\n\n\t\t\t\t\twoy = date2isoweek(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If it is week 52/53 and the month is January, then the\n\t\t\t\t\t * week must belong to the previous year. Also, some\n\t\t\t\t\t * December dates belong to the next year.\n\t\t\t\t\t */\n\t\t\t\t\tif (woy >= 52 && tm->tm_mon == 1)\n\t\t\t\t\t\t--tm->tm_year;\n\t\t\t\t\tif (woy <= 1 && tm->tm_mon == MONTHS_PER_YEAR)\n\t\t\t\t\t\t++tm->tm_year;\n\t\t\t\t\tisoweek2date(woy, &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\tfsec = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase DTK_MILLENNIUM:\n\t\t\t\t/* see comments in timestamptz_trunc */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\ttm->tm_year = ((tm->tm_year + 999) / 1000) * 1000 - 999;\n\t\t\t\telse\n\t\t\t\t\ttm->tm_year = -((999 - (tm->tm_year - 1)) / 1000) * 1000 + 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_CENTURY:\n\t\t\t\t/* see comments in timestamptz_trunc */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\ttm->tm_year = ((tm->tm_year + 99) / 100) * 100 - 99;\n\t\t\t\telse\n\t\t\t\t\ttm->tm_year = -((99 - (tm->tm_year - 1)) / 100) * 100 + 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_DECADE:\n\t\t\t\t/* see comments in timestamptz_trunc */\n\t\t\t\tif (val != DTK_MILLENNIUM && val != DTK_CENTURY)\n\t\t\t\t{\n\t\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\t\ttm->tm_year = (tm->tm_year / 10) * 10;\n\t\t\t\t\telse\n\t\t\t\t\t\ttm->tm_year = -((8 - (tm->tm_year - 1)) / 10) * 10;\n\t\t\t\t}\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_YEAR:\n\t\t\t\ttm->tm_mon = 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_QUARTER:\n\t\t\t\ttm->tm_mon = (3 * ((tm->tm_mon - 1) / 3)) + 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_MONTH:\n\t\t\t\ttm->tm_mday = 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_DAY:\n\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_HOUR:\n\t\t\t\ttm->tm_min = 0;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_MINUTE:\n\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_SECOND:\n\t\t\t\tfsec = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MILLISEC:\n\t\t\t\tfsec = (fsec / 1000) * 1000;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MICROSEC:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\tresult = 0;\n\t\t}\n\n\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits)));\n\t\tresult = 0;\n\t}\n\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 3905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits))"
          ],
          "line": 3898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp units \\\"%s\\\" not recognized\"",
            "lowunits"
          ],
          "line": 3900
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 3899
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 3892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm2timestamp",
          "args": [
            "tm",
            "fsec",
            "NULL",
            "&result"
          ],
          "line": 3891
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1853-1895",
          "snippet": "int\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits))"
          ],
          "line": 3884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isoweek2date",
          "args": [
            "woy",
            "&(tm->tm_year)",
            "&(tm->tm_mon)",
            "&(tm->tm_mday)"
          ],
          "line": 3823
        },
        "resolved": true,
        "details": {
          "function_name": "isoweek2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4184-4188",
          "snippet": "void\nisoweek2date(int woy, int *year, int *mon, int *mday)\n{\n\tj2date(isoweek2j(*year, woy), year, mon, mday);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nisoweek2date(int woy, int *year, int *mon, int *mday)\n{\n\tj2date(isoweek2j(*year, woy), year, mon, mday);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2isoweek",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 3812
        },
        "resolved": true,
        "details": {
          "function_name": "date2isoweek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4215-4262",
          "snippet": "int\ndate2isoweek(int year, int mon, int mday)\n{\n\tfloat8\t\tresult;\n\tint\t\t\tday0,\n\t\t\t\tday4,\n\t\t\t\tdayn;\n\n\t/* current day */\n\tdayn = date2j(year, mon, mday);\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\t/*\n\t * We need the first week containing a Thursday, otherwise this day falls\n\t * into the previous year for purposes of counting weeks\n\t */\n\tif (dayn < day4 - day0)\n\t{\n\t\tday4 = date2j(year - 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\t}\n\n\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\n\t/*\n\t * Sometimes the last few days in a year will fall into the first week of\n\t * the next year, so check for this.\n\t */\n\tif (result >= 52)\n\t{\n\t\tday4 = date2j(year + 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\n\t\tif (dayn >= day4 - day0)\n\t\t\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\t}\n\n\treturn (int) result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2isoweek(int year, int mon, int mday)\n{\n\tfloat8\t\tresult;\n\tint\t\t\tday0,\n\t\t\t\tday4,\n\t\t\t\tdayn;\n\n\t/* current day */\n\tdayn = date2j(year, mon, mday);\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\t/*\n\t * We need the first week containing a Thursday, otherwise this day falls\n\t * into the previous year for purposes of counting weeks\n\t */\n\tif (dayn < day4 - day0)\n\t{\n\t\tday4 = date2j(year - 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\t}\n\n\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\n\t/*\n\t * Sometimes the last few days in a year will fall into the first week of\n\t * the next year, so check for this.\n\t */\n\tif (result >= 52)\n\t{\n\t\tday4 = date2j(year + 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\n\t\tif (dayn >= day4 - day0)\n\t\t\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\t}\n\n\treturn (int) result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 3802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "NULL",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 3801
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeUnits",
          "args": [
            "0",
            "lowunits",
            "&val"
          ],
          "line": 3797
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeUnits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3716-3741",
          "snippet": "int\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};",
            "static int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];",
            "static const datetkn *deltacache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};\nstatic int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];\nstatic const datetkn *deltacache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcase_truncate_identifier",
          "args": [
            "VARDATA_ANY(units)",
            "VARSIZE_ANY_EXHDR(units)",
            "false"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "units"
          ],
          "line": 3794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "units"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "timestamp"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 3790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamp_trunc(PG_FUNCTION_ARGS)\n{\n\ttext\t   *units = PG_GETARG_TEXT_PP(0);\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tresult;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tchar\t   *lowunits;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_TIMESTAMP(timestamp);\n\n\tlowunits = downcase_truncate_identifier(VARDATA_ANY(units),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(units),\n\t\t\t\t\t\t\t\t\t\t\tfalse);\n\n\ttype = DecodeUnits(0, lowunits, &val);\n\n\tif (type == UNITS)\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\tswitch (val)\n\t\t{\n\t\t\tcase DTK_WEEK:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\twoy;\n\n\t\t\t\t\twoy = date2isoweek(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If it is week 52/53 and the month is January, then the\n\t\t\t\t\t * week must belong to the previous year. Also, some\n\t\t\t\t\t * December dates belong to the next year.\n\t\t\t\t\t */\n\t\t\t\t\tif (woy >= 52 && tm->tm_mon == 1)\n\t\t\t\t\t\t--tm->tm_year;\n\t\t\t\t\tif (woy <= 1 && tm->tm_mon == MONTHS_PER_YEAR)\n\t\t\t\t\t\t++tm->tm_year;\n\t\t\t\t\tisoweek2date(woy, &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\tfsec = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase DTK_MILLENNIUM:\n\t\t\t\t/* see comments in timestamptz_trunc */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\ttm->tm_year = ((tm->tm_year + 999) / 1000) * 1000 - 999;\n\t\t\t\telse\n\t\t\t\t\ttm->tm_year = -((999 - (tm->tm_year - 1)) / 1000) * 1000 + 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_CENTURY:\n\t\t\t\t/* see comments in timestamptz_trunc */\n\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\ttm->tm_year = ((tm->tm_year + 99) / 100) * 100 - 99;\n\t\t\t\telse\n\t\t\t\t\ttm->tm_year = -((99 - (tm->tm_year - 1)) / 100) * 100 + 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_DECADE:\n\t\t\t\t/* see comments in timestamptz_trunc */\n\t\t\t\tif (val != DTK_MILLENNIUM && val != DTK_CENTURY)\n\t\t\t\t{\n\t\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\t\ttm->tm_year = (tm->tm_year / 10) * 10;\n\t\t\t\t\telse\n\t\t\t\t\t\ttm->tm_year = -((8 - (tm->tm_year - 1)) / 10) * 10;\n\t\t\t\t}\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_YEAR:\n\t\t\t\ttm->tm_mon = 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_QUARTER:\n\t\t\t\ttm->tm_mon = (3 * ((tm->tm_mon - 1) / 3)) + 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_MONTH:\n\t\t\t\ttm->tm_mday = 1;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_DAY:\n\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_HOUR:\n\t\t\t\ttm->tm_min = 0;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_MINUTE:\n\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t/* FALL THRU */\n\t\t\tcase DTK_SECOND:\n\t\t\t\tfsec = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MILLISEC:\n\t\t\t\tfsec = (fsec / 1000) * 1000;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MICROSEC:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not supported\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\tresult = 0;\n\t\t}\n\n\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"timestamp units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits)));\n\t\tresult = 0;\n\t}\n\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "timestamptz_age",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3650-3766",
    "snippet": "Datum\ntimestamptz_age(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tInterval   *result;\n\tfsec_t\t\tfsec,\n\t\t\t\tfsec1,\n\t\t\t\tfsec2;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tstruct pg_tm tt1,\n\t\t\t   *tm1 = &tt1;\n\tstruct pg_tm tt2,\n\t\t\t   *tm2 = &tt2;\n\tint\t\t\ttz1;\n\tint\t\t\ttz2;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tif (timestamp2tm(dt1, &tz1, tm1, &fsec1, NULL, NULL) == 0 &&\n\t\ttimestamp2tm(dt2, &tz2, tm2, &fsec2, NULL, NULL) == 0)\n\t{\n\t\t/* form the symbolic difference */\n\t\tfsec = fsec1 - fsec2;\n\t\ttm->tm_sec = tm1->tm_sec - tm2->tm_sec;\n\t\ttm->tm_min = tm1->tm_min - tm2->tm_min;\n\t\ttm->tm_hour = tm1->tm_hour - tm2->tm_hour;\n\t\ttm->tm_mday = tm1->tm_mday - tm2->tm_mday;\n\t\ttm->tm_mon = tm1->tm_mon - tm2->tm_mon;\n\t\ttm->tm_year = tm1->tm_year - tm2->tm_year;\n\n\t\t/* flip sign if necessary... */\n\t\tif (dt1 < dt2)\n\t\t{\n\t\t\tfsec = -fsec;\n\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\ttm->tm_mday = -tm->tm_mday;\n\t\t\ttm->tm_mon = -tm->tm_mon;\n\t\t\ttm->tm_year = -tm->tm_year;\n\t\t}\n\n\t\t/* propagate any negative fields into the next higher field */\n\t\twhile (fsec < 0)\n\t\t{\n\t\t\tfsec += USECS_PER_SEC;\n\t\t\ttm->tm_sec--;\n\t\t}\n\n\t\twhile (tm->tm_sec < 0)\n\t\t{\n\t\t\ttm->tm_sec += SECS_PER_MINUTE;\n\t\t\ttm->tm_min--;\n\t\t}\n\n\t\twhile (tm->tm_min < 0)\n\t\t{\n\t\t\ttm->tm_min += MINS_PER_HOUR;\n\t\t\ttm->tm_hour--;\n\t\t}\n\n\t\twhile (tm->tm_hour < 0)\n\t\t{\n\t\t\ttm->tm_hour += HOURS_PER_DAY;\n\t\t\ttm->tm_mday--;\n\t\t}\n\n\t\twhile (tm->tm_mday < 0)\n\t\t{\n\t\t\tif (dt1 < dt2)\n\t\t\t{\n\t\t\t\ttm->tm_mday += day_tab[isleap(tm1->tm_year)][tm1->tm_mon - 1];\n\t\t\t\ttm->tm_mon--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttm->tm_mday += day_tab[isleap(tm2->tm_year)][tm2->tm_mon - 1];\n\t\t\t\ttm->tm_mon--;\n\t\t\t}\n\t\t}\n\n\t\twhile (tm->tm_mon < 0)\n\t\t{\n\t\t\ttm->tm_mon += MONTHS_PER_YEAR;\n\t\t\ttm->tm_year--;\n\t\t}\n\n\t\t/*\n\t\t * Note: we deliberately ignore any difference between tz1 and tz2.\n\t\t */\n\n\t\t/* recover sign if necessary... */\n\t\tif (dt1 < dt2)\n\t\t{\n\t\t\tfsec = -fsec;\n\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\ttm->tm_mday = -tm->tm_mday;\n\t\t\ttm->tm_mon = -tm->tm_mon;\n\t\t\ttm->tm_year = -tm->tm_year;\n\t\t}\n\n\t\tif (tm2interval(tm, fsec, result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"interval out of range\")));\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 3765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 3761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 3763
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 3762
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 3756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm2interval",
          "args": [
            "tm",
            "fsec",
            "result"
          ],
          "line": 3755
        },
        "resolved": true,
        "details": {
          "function_name": "tm2interval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1929-1943",
          "snippet": "int\ntm2interval(struct pg_tm *tm, fsec_t fsec, Interval *span)\n{\n\tdouble\t\ttotal_months = (double) tm->tm_year * MONTHS_PER_YEAR + tm->tm_mon;\n\n\tif (total_months > INT_MAX || total_months < INT_MIN)\n\t\treturn -1;\n\tspan->month = total_months;\n\tspan->day = tm->tm_mday;\n\tspan->time = (((((tm->tm_hour * INT64CONST(60)) +\n\t\t\t\t\t tm->tm_min) * INT64CONST(60)) +\n\t\t\t\t   tm->tm_sec) * USECS_PER_SEC) + fsec;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2interval(struct pg_tm *tm, fsec_t fsec, Interval *span)\n{\n\tdouble\t\ttotal_months = (double) tm->tm_year * MONTHS_PER_YEAR + tm->tm_mon;\n\n\tif (total_months > INT_MAX || total_months < INT_MIN)\n\t\treturn -1;\n\tspan->month = total_months;\n\tspan->day = tm->tm_mday;\n\tspan->time = (((((tm->tm_hour * INT64CONST(60)) +\n\t\t\t\t\t tm->tm_min) * INT64CONST(60)) +\n\t\t\t\t   tm->tm_sec) * USECS_PER_SEC) + fsec;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isleap",
          "args": [
            "tm2->tm_year"
          ],
          "line": 3728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isleap",
          "args": [
            "tm1->tm_year"
          ],
          "line": 3723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "dt2",
            "&tz2",
            "tm2",
            "&fsec2",
            "NULL",
            "NULL"
          ],
          "line": 3671
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 3668
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 3654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 3653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamptz_age(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tInterval   *result;\n\tfsec_t\t\tfsec,\n\t\t\t\tfsec1,\n\t\t\t\tfsec2;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tstruct pg_tm tt1,\n\t\t\t   *tm1 = &tt1;\n\tstruct pg_tm tt2,\n\t\t\t   *tm2 = &tt2;\n\tint\t\t\ttz1;\n\tint\t\t\ttz2;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tif (timestamp2tm(dt1, &tz1, tm1, &fsec1, NULL, NULL) == 0 &&\n\t\ttimestamp2tm(dt2, &tz2, tm2, &fsec2, NULL, NULL) == 0)\n\t{\n\t\t/* form the symbolic difference */\n\t\tfsec = fsec1 - fsec2;\n\t\ttm->tm_sec = tm1->tm_sec - tm2->tm_sec;\n\t\ttm->tm_min = tm1->tm_min - tm2->tm_min;\n\t\ttm->tm_hour = tm1->tm_hour - tm2->tm_hour;\n\t\ttm->tm_mday = tm1->tm_mday - tm2->tm_mday;\n\t\ttm->tm_mon = tm1->tm_mon - tm2->tm_mon;\n\t\ttm->tm_year = tm1->tm_year - tm2->tm_year;\n\n\t\t/* flip sign if necessary... */\n\t\tif (dt1 < dt2)\n\t\t{\n\t\t\tfsec = -fsec;\n\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\ttm->tm_mday = -tm->tm_mday;\n\t\t\ttm->tm_mon = -tm->tm_mon;\n\t\t\ttm->tm_year = -tm->tm_year;\n\t\t}\n\n\t\t/* propagate any negative fields into the next higher field */\n\t\twhile (fsec < 0)\n\t\t{\n\t\t\tfsec += USECS_PER_SEC;\n\t\t\ttm->tm_sec--;\n\t\t}\n\n\t\twhile (tm->tm_sec < 0)\n\t\t{\n\t\t\ttm->tm_sec += SECS_PER_MINUTE;\n\t\t\ttm->tm_min--;\n\t\t}\n\n\t\twhile (tm->tm_min < 0)\n\t\t{\n\t\t\ttm->tm_min += MINS_PER_HOUR;\n\t\t\ttm->tm_hour--;\n\t\t}\n\n\t\twhile (tm->tm_hour < 0)\n\t\t{\n\t\t\ttm->tm_hour += HOURS_PER_DAY;\n\t\t\ttm->tm_mday--;\n\t\t}\n\n\t\twhile (tm->tm_mday < 0)\n\t\t{\n\t\t\tif (dt1 < dt2)\n\t\t\t{\n\t\t\t\ttm->tm_mday += day_tab[isleap(tm1->tm_year)][tm1->tm_mon - 1];\n\t\t\t\ttm->tm_mon--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttm->tm_mday += day_tab[isleap(tm2->tm_year)][tm2->tm_mon - 1];\n\t\t\t\ttm->tm_mon--;\n\t\t\t}\n\t\t}\n\n\t\twhile (tm->tm_mon < 0)\n\t\t{\n\t\t\ttm->tm_mon += MONTHS_PER_YEAR;\n\t\t\ttm->tm_year--;\n\t\t}\n\n\t\t/*\n\t\t * Note: we deliberately ignore any difference between tz1 and tz2.\n\t\t */\n\n\t\t/* recover sign if necessary... */\n\t\tif (dt1 < dt2)\n\t\t{\n\t\t\tfsec = -fsec;\n\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\ttm->tm_mday = -tm->tm_mday;\n\t\t\ttm->tm_mon = -tm->tm_mon;\n\t\t\ttm->tm_year = -tm->tm_year;\n\t\t}\n\n\t\tif (tm2interval(tm, fsec, result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"interval out of range\")));\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "timestamp_age",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3531-3641",
    "snippet": "Datum\ntimestamp_age(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tInterval   *result;\n\tfsec_t\t\tfsec,\n\t\t\t\tfsec1,\n\t\t\t\tfsec2;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tstruct pg_tm tt1,\n\t\t\t   *tm1 = &tt1;\n\tstruct pg_tm tt2,\n\t\t\t   *tm2 = &tt2;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tif (timestamp2tm(dt1, NULL, tm1, &fsec1, NULL, NULL) == 0 &&\n\t\ttimestamp2tm(dt2, NULL, tm2, &fsec2, NULL, NULL) == 0)\n\t{\n\t\t/* form the symbolic difference */\n\t\tfsec = fsec1 - fsec2;\n\t\ttm->tm_sec = tm1->tm_sec - tm2->tm_sec;\n\t\ttm->tm_min = tm1->tm_min - tm2->tm_min;\n\t\ttm->tm_hour = tm1->tm_hour - tm2->tm_hour;\n\t\ttm->tm_mday = tm1->tm_mday - tm2->tm_mday;\n\t\ttm->tm_mon = tm1->tm_mon - tm2->tm_mon;\n\t\ttm->tm_year = tm1->tm_year - tm2->tm_year;\n\n\t\t/* flip sign if necessary... */\n\t\tif (dt1 < dt2)\n\t\t{\n\t\t\tfsec = -fsec;\n\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\ttm->tm_mday = -tm->tm_mday;\n\t\t\ttm->tm_mon = -tm->tm_mon;\n\t\t\ttm->tm_year = -tm->tm_year;\n\t\t}\n\n\t\t/* propagate any negative fields into the next higher field */\n\t\twhile (fsec < 0)\n\t\t{\n\t\t\tfsec += USECS_PER_SEC;\n\t\t\ttm->tm_sec--;\n\t\t}\n\n\t\twhile (tm->tm_sec < 0)\n\t\t{\n\t\t\ttm->tm_sec += SECS_PER_MINUTE;\n\t\t\ttm->tm_min--;\n\t\t}\n\n\t\twhile (tm->tm_min < 0)\n\t\t{\n\t\t\ttm->tm_min += MINS_PER_HOUR;\n\t\t\ttm->tm_hour--;\n\t\t}\n\n\t\twhile (tm->tm_hour < 0)\n\t\t{\n\t\t\ttm->tm_hour += HOURS_PER_DAY;\n\t\t\ttm->tm_mday--;\n\t\t}\n\n\t\twhile (tm->tm_mday < 0)\n\t\t{\n\t\t\tif (dt1 < dt2)\n\t\t\t{\n\t\t\t\ttm->tm_mday += day_tab[isleap(tm1->tm_year)][tm1->tm_mon - 1];\n\t\t\t\ttm->tm_mon--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttm->tm_mday += day_tab[isleap(tm2->tm_year)][tm2->tm_mon - 1];\n\t\t\t\ttm->tm_mon--;\n\t\t\t}\n\t\t}\n\n\t\twhile (tm->tm_mon < 0)\n\t\t{\n\t\t\ttm->tm_mon += MONTHS_PER_YEAR;\n\t\t\ttm->tm_year--;\n\t\t}\n\n\t\t/* recover sign if necessary... */\n\t\tif (dt1 < dt2)\n\t\t{\n\t\t\tfsec = -fsec;\n\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\ttm->tm_mday = -tm->tm_mday;\n\t\t\ttm->tm_mon = -tm->tm_mon;\n\t\t\ttm->tm_year = -tm->tm_year;\n\t\t}\n\n\t\tif (tm2interval(tm, fsec, result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"interval out of range\")));\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 3640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 3636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 3638
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 3637
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm2interval",
          "args": [
            "tm",
            "fsec",
            "result"
          ],
          "line": 3630
        },
        "resolved": true,
        "details": {
          "function_name": "tm2interval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1929-1943",
          "snippet": "int\ntm2interval(struct pg_tm *tm, fsec_t fsec, Interval *span)\n{\n\tdouble\t\ttotal_months = (double) tm->tm_year * MONTHS_PER_YEAR + tm->tm_mon;\n\n\tif (total_months > INT_MAX || total_months < INT_MIN)\n\t\treturn -1;\n\tspan->month = total_months;\n\tspan->day = tm->tm_mday;\n\tspan->time = (((((tm->tm_hour * INT64CONST(60)) +\n\t\t\t\t\t tm->tm_min) * INT64CONST(60)) +\n\t\t\t\t   tm->tm_sec) * USECS_PER_SEC) + fsec;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2interval(struct pg_tm *tm, fsec_t fsec, Interval *span)\n{\n\tdouble\t\ttotal_months = (double) tm->tm_year * MONTHS_PER_YEAR + tm->tm_mon;\n\n\tif (total_months > INT_MAX || total_months < INT_MIN)\n\t\treturn -1;\n\tspan->month = total_months;\n\tspan->day = tm->tm_mday;\n\tspan->time = (((((tm->tm_hour * INT64CONST(60)) +\n\t\t\t\t\t tm->tm_min) * INT64CONST(60)) +\n\t\t\t\t   tm->tm_sec) * USECS_PER_SEC) + fsec;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isleap",
          "args": [
            "tm2->tm_year"
          ],
          "line": 3607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isleap",
          "args": [
            "tm1->tm_year"
          ],
          "line": 3602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "dt2",
            "NULL",
            "tm2",
            "&fsec2",
            "NULL",
            "NULL"
          ],
          "line": 3550
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 3547
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 3535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 3534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamp_age(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tInterval   *result;\n\tfsec_t\t\tfsec,\n\t\t\t\tfsec1,\n\t\t\t\tfsec2;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tstruct pg_tm tt1,\n\t\t\t   *tm1 = &tt1;\n\tstruct pg_tm tt2,\n\t\t\t   *tm2 = &tt2;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tif (timestamp2tm(dt1, NULL, tm1, &fsec1, NULL, NULL) == 0 &&\n\t\ttimestamp2tm(dt2, NULL, tm2, &fsec2, NULL, NULL) == 0)\n\t{\n\t\t/* form the symbolic difference */\n\t\tfsec = fsec1 - fsec2;\n\t\ttm->tm_sec = tm1->tm_sec - tm2->tm_sec;\n\t\ttm->tm_min = tm1->tm_min - tm2->tm_min;\n\t\ttm->tm_hour = tm1->tm_hour - tm2->tm_hour;\n\t\ttm->tm_mday = tm1->tm_mday - tm2->tm_mday;\n\t\ttm->tm_mon = tm1->tm_mon - tm2->tm_mon;\n\t\ttm->tm_year = tm1->tm_year - tm2->tm_year;\n\n\t\t/* flip sign if necessary... */\n\t\tif (dt1 < dt2)\n\t\t{\n\t\t\tfsec = -fsec;\n\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\ttm->tm_mday = -tm->tm_mday;\n\t\t\ttm->tm_mon = -tm->tm_mon;\n\t\t\ttm->tm_year = -tm->tm_year;\n\t\t}\n\n\t\t/* propagate any negative fields into the next higher field */\n\t\twhile (fsec < 0)\n\t\t{\n\t\t\tfsec += USECS_PER_SEC;\n\t\t\ttm->tm_sec--;\n\t\t}\n\n\t\twhile (tm->tm_sec < 0)\n\t\t{\n\t\t\ttm->tm_sec += SECS_PER_MINUTE;\n\t\t\ttm->tm_min--;\n\t\t}\n\n\t\twhile (tm->tm_min < 0)\n\t\t{\n\t\t\ttm->tm_min += MINS_PER_HOUR;\n\t\t\ttm->tm_hour--;\n\t\t}\n\n\t\twhile (tm->tm_hour < 0)\n\t\t{\n\t\t\ttm->tm_hour += HOURS_PER_DAY;\n\t\t\ttm->tm_mday--;\n\t\t}\n\n\t\twhile (tm->tm_mday < 0)\n\t\t{\n\t\t\tif (dt1 < dt2)\n\t\t\t{\n\t\t\t\ttm->tm_mday += day_tab[isleap(tm1->tm_year)][tm1->tm_mon - 1];\n\t\t\t\ttm->tm_mon--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttm->tm_mday += day_tab[isleap(tm2->tm_year)][tm2->tm_mon - 1];\n\t\t\t\ttm->tm_mon--;\n\t\t\t}\n\t\t}\n\n\t\twhile (tm->tm_mon < 0)\n\t\t{\n\t\t\ttm->tm_mon += MONTHS_PER_YEAR;\n\t\t\ttm->tm_year--;\n\t\t}\n\n\t\t/* recover sign if necessary... */\n\t\tif (dt1 < dt2)\n\t\t{\n\t\t\tfsec = -fsec;\n\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\ttm->tm_mday = -tm->tm_mday;\n\t\t\ttm->tm_mon = -tm->tm_mon;\n\t\t\ttm->tm_year = -tm->tm_year;\n\t\t}\n\n\t\tif (tm2interval(tm, fsec, result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"interval out of range\")));\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "interval_avg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3497-3522",
    "snippet": "Datum\ninterval_avg(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tDatum\t   *transdatums;\n\tint\t\t\tndatums;\n\tInterval\tsumX,\n\t\t\t\tN;\n\n\tdeconstruct_array(transarray,\n\t\t\t\t\t  INTERVALOID, sizeof(Interval), false, 'd',\n\t\t\t\t\t  &transdatums, NULL, &ndatums);\n\tif (ndatums != 2)\n\t\telog(ERROR, \"expected 2-element interval array\");\n\n\tsumX = *(DatumGetIntervalP(transdatums[0]));\n\tN = *(DatumGetIntervalP(transdatums[1]));\n\n\t/* SQL defines AVG of no values to be NULL */\n\tif (N.time == 0)\n\t\tPG_RETURN_NULL();\n\n\treturn DirectFunctionCall2(interval_div,\n\t\t\t\t\t\t\t   IntervalPGetDatum(&sumX),\n\t\t\t\t\t\t\t   Float8GetDatum((double) N.time));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "interval_div",
            "IntervalPGetDatum(&sumX)",
            "Float8GetDatum((double) N.time)"
          ],
          "line": 3519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Float8GetDatum",
          "args": [
            "(double) N.time"
          ],
          "line": 3521
        },
        "resolved": true,
        "details": {
          "function_name": "Float8GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1900-1907",
          "snippet": "Datum\nFloat8GetDatum(float8 X)\n{\n\tfloat8\t   *retval = (float8 *) palloc(sizeof(float8));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nFloat8GetDatum(float8 X)\n{\n\tfloat8\t   *retval = (float8 *) palloc(sizeof(float8));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "&sumX"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "transdatums[1]"
          ],
          "line": 3513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "transdatums[0]"
          ],
          "line": 3512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"expected 2-element interval array\""
          ],
          "line": 3510
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "transarray",
            "INTERVALOID",
            "sizeof(Interval)",
            "false",
            "'d'",
            "&transdatums",
            "NULL",
            "&ndatums"
          ],
          "line": 3506
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 3500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_avg(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tDatum\t   *transdatums;\n\tint\t\t\tndatums;\n\tInterval\tsumX,\n\t\t\t\tN;\n\n\tdeconstruct_array(transarray,\n\t\t\t\t\t  INTERVALOID, sizeof(Interval), false, 'd',\n\t\t\t\t\t  &transdatums, NULL, &ndatums);\n\tif (ndatums != 2)\n\t\telog(ERROR, \"expected 2-element interval array\");\n\n\tsumX = *(DatumGetIntervalP(transdatums[0]));\n\tN = *(DatumGetIntervalP(transdatums[1]));\n\n\t/* SQL defines AVG of no values to be NULL */\n\tif (N.time == 0)\n\t\tPG_RETURN_NULL();\n\n\treturn DirectFunctionCall2(interval_div,\n\t\t\t\t\t\t\t   IntervalPGetDatum(&sumX),\n\t\t\t\t\t\t\t   Float8GetDatum((double) N.time));\n}"
  },
  {
    "function_name": "interval_accum_inv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3462-3495",
    "snippet": "Datum\ninterval_accum_inv(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tInterval   *newval = PG_GETARG_INTERVAL_P(1);\n\tDatum\t   *transdatums;\n\tint\t\t\tndatums;\n\tInterval\tsumX,\n\t\t\t\tN;\n\tInterval   *newsum;\n\tArrayType  *result;\n\n\tdeconstruct_array(transarray,\n\t\t\t\t\t  INTERVALOID, sizeof(Interval), false, 'd',\n\t\t\t\t\t  &transdatums, NULL, &ndatums);\n\tif (ndatums != 2)\n\t\telog(ERROR, \"expected 2-element interval array\");\n\n\tsumX = *(DatumGetIntervalP(transdatums[0]));\n\tN = *(DatumGetIntervalP(transdatums[1]));\n\n\tnewsum = DatumGetIntervalP(DirectFunctionCall2(interval_mi,\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(&sumX),\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(newval)));\n\tN.time -= 1;\n\n\ttransdatums[0] = IntervalPGetDatum(newsum);\n\ttransdatums[1] = IntervalPGetDatum(&N);\n\n\tresult = construct_array(transdatums, 2,\n\t\t\t\t\t\t\t INTERVALOID, sizeof(Interval), false, 'd');\n\n\tPG_RETURN_ARRAYTYPE_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "result"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_array",
          "args": [
            "transdatums",
            "2",
            "INTERVALOID",
            "sizeof(Interval)",
            "false",
            "'d'"
          ],
          "line": 3491
        },
        "resolved": true,
        "details": {
          "function_name": "construct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3290-3303",
          "snippet": "ArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "&N"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "newsum"
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "DirectFunctionCall2(interval_mi,\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(&sumX),\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(newval))"
          ],
          "line": 3483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "interval_mi",
            "IntervalPGetDatum(&sumX)",
            "IntervalPGetDatum(newval)"
          ],
          "line": 3483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "newval"
          ],
          "line": 3485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "&sumX"
          ],
          "line": 3484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "transdatums[1]"
          ],
          "line": 3481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "transdatums[0]"
          ],
          "line": 3480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"expected 2-element interval array\""
          ],
          "line": 3478
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "transarray",
            "INTERVALOID",
            "sizeof(Interval)",
            "false",
            "'d'",
            "&transdatums",
            "NULL",
            "&ndatums"
          ],
          "line": 3474
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 3465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_accum_inv(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tInterval   *newval = PG_GETARG_INTERVAL_P(1);\n\tDatum\t   *transdatums;\n\tint\t\t\tndatums;\n\tInterval\tsumX,\n\t\t\t\tN;\n\tInterval   *newsum;\n\tArrayType  *result;\n\n\tdeconstruct_array(transarray,\n\t\t\t\t\t  INTERVALOID, sizeof(Interval), false, 'd',\n\t\t\t\t\t  &transdatums, NULL, &ndatums);\n\tif (ndatums != 2)\n\t\telog(ERROR, \"expected 2-element interval array\");\n\n\tsumX = *(DatumGetIntervalP(transdatums[0]));\n\tN = *(DatumGetIntervalP(transdatums[1]));\n\n\tnewsum = DatumGetIntervalP(DirectFunctionCall2(interval_mi,\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(&sumX),\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(newval)));\n\tN.time -= 1;\n\n\ttransdatums[0] = IntervalPGetDatum(newsum);\n\ttransdatums[1] = IntervalPGetDatum(&N);\n\n\tresult = construct_array(transdatums, 2,\n\t\t\t\t\t\t\t INTERVALOID, sizeof(Interval), false, 'd');\n\n\tPG_RETURN_ARRAYTYPE_P(result);\n}"
  },
  {
    "function_name": "interval_combine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3413-3460",
    "snippet": "Datum\ninterval_combine(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray1 = PG_GETARG_ARRAYTYPE_P(0);\n\tArrayType  *transarray2 = PG_GETARG_ARRAYTYPE_P(1);\n\tDatum\t   *transdatums1;\n\tDatum\t   *transdatums2;\n\tint\t\t\tndatums1;\n\tint\t\t\tndatums2;\n\tInterval\tsum1,\n\t\t\t\tN1;\n\tInterval\tsum2,\n\t\t\t\tN2;\n\n\tInterval   *newsum;\n\tArrayType  *result;\n\n\tdeconstruct_array(transarray1,\n\t\t\t\t\t  INTERVALOID, sizeof(Interval), false, 'd',\n\t\t\t\t\t  &transdatums1, NULL, &ndatums1);\n\tif (ndatums1 != 2)\n\t\telog(ERROR, \"expected 2-element interval array\");\n\n\tsum1 = *(DatumGetIntervalP(transdatums1[0]));\n\tN1 = *(DatumGetIntervalP(transdatums1[1]));\n\n\tdeconstruct_array(transarray2,\n\t\t\t\t\t  INTERVALOID, sizeof(Interval), false, 'd',\n\t\t\t\t\t  &transdatums2, NULL, &ndatums2);\n\tif (ndatums2 != 2)\n\t\telog(ERROR, \"expected 2-element interval array\");\n\n\tsum2 = *(DatumGetIntervalP(transdatums2[0]));\n\tN2 = *(DatumGetIntervalP(transdatums2[1]));\n\n\tnewsum = DatumGetIntervalP(DirectFunctionCall2(interval_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(&sum1),\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(&sum2)));\n\tN1.time += N2.time;\n\n\ttransdatums1[0] = IntervalPGetDatum(newsum);\n\ttransdatums1[1] = IntervalPGetDatum(&N1);\n\n\tresult = construct_array(transdatums1, 2,\n\t\t\t\t\t\t\t INTERVALOID, sizeof(Interval), false, 'd');\n\n\tPG_RETURN_ARRAYTYPE_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "result"
          ],
          "line": 3459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_array",
          "args": [
            "transdatums1",
            "2",
            "INTERVALOID",
            "sizeof(Interval)",
            "false",
            "'d'"
          ],
          "line": 3456
        },
        "resolved": true,
        "details": {
          "function_name": "construct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3290-3303",
          "snippet": "ArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "&N1"
          ],
          "line": 3454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "newsum"
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "DirectFunctionCall2(interval_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(&sum1),\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(&sum2))"
          ],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "interval_pl",
            "IntervalPGetDatum(&sum1)",
            "IntervalPGetDatum(&sum2)"
          ],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "&sum2"
          ],
          "line": 3450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "&sum1"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "transdatums2[1]"
          ],
          "line": 3446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "transdatums2[0]"
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"expected 2-element interval array\""
          ],
          "line": 3443
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "transarray2",
            "INTERVALOID",
            "sizeof(Interval)",
            "false",
            "'d'",
            "&transdatums2",
            "NULL",
            "&ndatums2"
          ],
          "line": 3439
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "transdatums1[1]"
          ],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "transdatums1[0]"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 3417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_combine(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray1 = PG_GETARG_ARRAYTYPE_P(0);\n\tArrayType  *transarray2 = PG_GETARG_ARRAYTYPE_P(1);\n\tDatum\t   *transdatums1;\n\tDatum\t   *transdatums2;\n\tint\t\t\tndatums1;\n\tint\t\t\tndatums2;\n\tInterval\tsum1,\n\t\t\t\tN1;\n\tInterval\tsum2,\n\t\t\t\tN2;\n\n\tInterval   *newsum;\n\tArrayType  *result;\n\n\tdeconstruct_array(transarray1,\n\t\t\t\t\t  INTERVALOID, sizeof(Interval), false, 'd',\n\t\t\t\t\t  &transdatums1, NULL, &ndatums1);\n\tif (ndatums1 != 2)\n\t\telog(ERROR, \"expected 2-element interval array\");\n\n\tsum1 = *(DatumGetIntervalP(transdatums1[0]));\n\tN1 = *(DatumGetIntervalP(transdatums1[1]));\n\n\tdeconstruct_array(transarray2,\n\t\t\t\t\t  INTERVALOID, sizeof(Interval), false, 'd',\n\t\t\t\t\t  &transdatums2, NULL, &ndatums2);\n\tif (ndatums2 != 2)\n\t\telog(ERROR, \"expected 2-element interval array\");\n\n\tsum2 = *(DatumGetIntervalP(transdatums2[0]));\n\tN2 = *(DatumGetIntervalP(transdatums2[1]));\n\n\tnewsum = DatumGetIntervalP(DirectFunctionCall2(interval_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(&sum1),\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(&sum2)));\n\tN1.time += N2.time;\n\n\ttransdatums1[0] = IntervalPGetDatum(newsum);\n\ttransdatums1[1] = IntervalPGetDatum(&N1);\n\n\tresult = construct_array(transdatums1, 2,\n\t\t\t\t\t\t\t INTERVALOID, sizeof(Interval), false, 'd');\n\n\tPG_RETURN_ARRAYTYPE_P(result);\n}"
  },
  {
    "function_name": "interval_accum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3378-3411",
    "snippet": "Datum\ninterval_accum(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tInterval   *newval = PG_GETARG_INTERVAL_P(1);\n\tDatum\t   *transdatums;\n\tint\t\t\tndatums;\n\tInterval\tsumX,\n\t\t\t\tN;\n\tInterval   *newsum;\n\tArrayType  *result;\n\n\tdeconstruct_array(transarray,\n\t\t\t\t\t  INTERVALOID, sizeof(Interval), false, 'd',\n\t\t\t\t\t  &transdatums, NULL, &ndatums);\n\tif (ndatums != 2)\n\t\telog(ERROR, \"expected 2-element interval array\");\n\n\tsumX = *(DatumGetIntervalP(transdatums[0]));\n\tN = *(DatumGetIntervalP(transdatums[1]));\n\n\tnewsum = DatumGetIntervalP(DirectFunctionCall2(interval_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(&sumX),\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(newval)));\n\tN.time += 1;\n\n\ttransdatums[0] = IntervalPGetDatum(newsum);\n\ttransdatums[1] = IntervalPGetDatum(&N);\n\n\tresult = construct_array(transdatums, 2,\n\t\t\t\t\t\t\t INTERVALOID, sizeof(Interval), false, 'd');\n\n\tPG_RETURN_ARRAYTYPE_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "result"
          ],
          "line": 3410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_array",
          "args": [
            "transdatums",
            "2",
            "INTERVALOID",
            "sizeof(Interval)",
            "false",
            "'d'"
          ],
          "line": 3407
        },
        "resolved": true,
        "details": {
          "function_name": "construct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3290-3303",
          "snippet": "ArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "&N"
          ],
          "line": 3405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "newsum"
          ],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "DirectFunctionCall2(interval_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(&sumX),\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(newval))"
          ],
          "line": 3399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "interval_pl",
            "IntervalPGetDatum(&sumX)",
            "IntervalPGetDatum(newval)"
          ],
          "line": 3399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "newval"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "&sumX"
          ],
          "line": 3400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "transdatums[1]"
          ],
          "line": 3397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "transdatums[0]"
          ],
          "line": 3396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"expected 2-element interval array\""
          ],
          "line": 3394
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "transarray",
            "INTERVALOID",
            "sizeof(Interval)",
            "false",
            "'d'",
            "&transdatums",
            "NULL",
            "&ndatums"
          ],
          "line": 3390
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 3382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_accum(PG_FUNCTION_ARGS)\n{\n\tArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);\n\tInterval   *newval = PG_GETARG_INTERVAL_P(1);\n\tDatum\t   *transdatums;\n\tint\t\t\tndatums;\n\tInterval\tsumX,\n\t\t\t\tN;\n\tInterval   *newsum;\n\tArrayType  *result;\n\n\tdeconstruct_array(transarray,\n\t\t\t\t\t  INTERVALOID, sizeof(Interval), false, 'd',\n\t\t\t\t\t  &transdatums, NULL, &ndatums);\n\tif (ndatums != 2)\n\t\telog(ERROR, \"expected 2-element interval array\");\n\n\tsumX = *(DatumGetIntervalP(transdatums[0]));\n\tN = *(DatumGetIntervalP(transdatums[1]));\n\n\tnewsum = DatumGetIntervalP(DirectFunctionCall2(interval_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(&sumX),\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(newval)));\n\tN.time += 1;\n\n\ttransdatums[0] = IntervalPGetDatum(newsum);\n\ttransdatums[1] = IntervalPGetDatum(&N);\n\n\tresult = construct_array(transdatums, 2,\n\t\t\t\t\t\t\t INTERVALOID, sizeof(Interval), false, 'd');\n\n\tPG_RETURN_ARRAYTYPE_P(result);\n}"
  },
  {
    "function_name": "in_range_interval_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3336-3365",
    "snippet": "Datum\nin_range_interval_interval(PG_FUNCTION_ARGS)\n{\n\tInterval   *val = PG_GETARG_INTERVAL_P(0);\n\tInterval   *base = PG_GETARG_INTERVAL_P(1);\n\tInterval   *offset = PG_GETARG_INTERVAL_P(2);\n\tbool\t\tsub = PG_GETARG_BOOL(3);\n\tbool\t\tless = PG_GETARG_BOOL(4);\n\tInterval   *sum;\n\n\tif (int128_compare(interval_cmp_value(offset), int64_to_int128(0)) < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\")));\n\n\t/* We don't currently bother to avoid overflow hazards here */\n\tif (sub)\n\t\tsum = DatumGetIntervalP(DirectFunctionCall2(interval_mi,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(offset)));\n\telse\n\t\tsum = DatumGetIntervalP(DirectFunctionCall2(interval_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(offset)));\n\n\tif (less)\n\t\tPG_RETURN_BOOL(interval_cmp_internal(val, sum) <= 0);\n\telse\n\t\tPG_RETURN_BOOL(interval_cmp_internal(val, sum) >= 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "interval_cmp_internal(val, sum) >= 0"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval_cmp_internal",
          "args": [
            "val",
            "sum"
          ],
          "line": 3364
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2333-2340",
          "snippet": "static int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "interval_cmp_internal(val, sum) <= 0"
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "DirectFunctionCall2(interval_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(offset))"
          ],
          "line": 3357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "interval_pl",
            "IntervalPGetDatum(base)",
            "IntervalPGetDatum(offset)"
          ],
          "line": 3357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "offset"
          ],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "base"
          ],
          "line": 3358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "DirectFunctionCall2(interval_mi,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(offset))"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "interval_mi",
            "IntervalPGetDatum(base)",
            "IntervalPGetDatum(offset)"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "offset"
          ],
          "line": 3355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "base"
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\"))"
          ],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid preceding or following size in window function\""
          ],
          "line": 3349
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE"
          ],
          "line": 3348
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "int128_compare",
          "args": [
            "interval_cmp_value(offset)",
            "int64_to_int128(0)"
          ],
          "line": 3346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int64_to_int128",
          "args": [
            "0"
          ],
          "line": 3346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval_cmp_value",
          "args": [
            "offset"
          ],
          "line": 3346
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2308-2331",
          "snippet": "static inline INT128\ninterval_cmp_value(const Interval *interval)\n{\n\tINT128\t\tspan;\n\tint64\t\tdayfraction;\n\tint64\t\tdays;\n\n\t/*\n\t * Separate time field into days and dayfraction, then add the month and\n\t * day fields to the days part.  We cannot overflow int64 days here.\n\t */\n\tdayfraction = interval->time % USECS_PER_DAY;\n\tdays = interval->time / USECS_PER_DAY;\n\tdays += interval->month * INT64CONST(30);\n\tdays += interval->day;\n\n\t/* Widen dayfraction to 128 bits */\n\tspan = int64_to_int128(dayfraction);\n\n\t/* Scale up days to microseconds, forming a 128-bit product */\n\tint128_add_int64_mul_int64(&span, days, USECS_PER_DAY);\n\n\treturn span;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic inline INT128\ninterval_cmp_value(const Interval *interval)\n{\n\tINT128\t\tspan;\n\tint64\t\tdayfraction;\n\tint64\t\tdays;\n\n\t/*\n\t * Separate time field into days and dayfraction, then add the month and\n\t * day fields to the days part.  We cannot overflow int64 days here.\n\t */\n\tdayfraction = interval->time % USECS_PER_DAY;\n\tdays = interval->time / USECS_PER_DAY;\n\tdays += interval->month * INT64CONST(30);\n\tdays += interval->day;\n\n\t/* Widen dayfraction to 128 bits */\n\tspan = int64_to_int128(dayfraction);\n\n\t/* Scale up days to microseconds, forming a 128-bit product */\n\tint128_add_int64_mul_int64(&span, days, USECS_PER_DAY);\n\n\treturn span;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "4"
          ],
          "line": 3343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "3"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "2"
          ],
          "line": 3341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 3339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nin_range_interval_interval(PG_FUNCTION_ARGS)\n{\n\tInterval   *val = PG_GETARG_INTERVAL_P(0);\n\tInterval   *base = PG_GETARG_INTERVAL_P(1);\n\tInterval   *offset = PG_GETARG_INTERVAL_P(2);\n\tbool\t\tsub = PG_GETARG_BOOL(3);\n\tbool\t\tless = PG_GETARG_BOOL(4);\n\tInterval   *sum;\n\n\tif (int128_compare(interval_cmp_value(offset), int64_to_int128(0)) < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\")));\n\n\t/* We don't currently bother to avoid overflow hazards here */\n\tif (sub)\n\t\tsum = DatumGetIntervalP(DirectFunctionCall2(interval_mi,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(offset)));\n\telse\n\t\tsum = DatumGetIntervalP(DirectFunctionCall2(interval_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(offset)));\n\n\tif (less)\n\t\tPG_RETURN_BOOL(interval_cmp_internal(val, sum) <= 0);\n\telse\n\t\tPG_RETURN_BOOL(interval_cmp_internal(val, sum) >= 0);\n}"
  },
  {
    "function_name": "in_range_timestamp_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3305-3334",
    "snippet": "Datum\nin_range_timestamp_interval(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tval = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tbase = PG_GETARG_TIMESTAMP(1);\n\tInterval   *offset = PG_GETARG_INTERVAL_P(2);\n\tbool\t\tsub = PG_GETARG_BOOL(3);\n\tbool\t\tless = PG_GETARG_BOOL(4);\n\tTimestamp\tsum;\n\n\tif (int128_compare(interval_cmp_value(offset), int64_to_int128(0)) < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\")));\n\n\t/* We don't currently bother to avoid overflow hazards here */\n\tif (sub)\n\t\tsum = DatumGetTimestamp(DirectFunctionCall2(timestamp_mi_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\tTimestampGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(offset)));\n\telse\n\t\tsum = DatumGetTimestamp(DirectFunctionCall2(timestamp_pl_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\tTimestampGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(offset)));\n\n\tif (less)\n\t\tPG_RETURN_BOOL(val <= sum);\n\telse\n\t\tPG_RETURN_BOOL(val >= sum);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "val >= sum"
          ],
          "line": 3333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "val <= sum"
          ],
          "line": 3331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTimestamp",
          "args": [
            "DirectFunctionCall2(timestamp_pl_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\tTimestampGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(offset))"
          ],
          "line": 3326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "timestamp_pl_interval",
            "TimestampGetDatum(base)",
            "IntervalPGetDatum(offset)"
          ],
          "line": 3326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "offset"
          ],
          "line": 3328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampGetDatum",
          "args": [
            "base"
          ],
          "line": 3327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTimestamp",
          "args": [
            "DirectFunctionCall2(timestamp_mi_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\tTimestampGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(offset))"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "timestamp_mi_interval",
            "TimestampGetDatum(base)",
            "IntervalPGetDatum(offset)"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "offset"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampGetDatum",
          "args": [
            "base"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\"))"
          ],
          "line": 3316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid preceding or following size in window function\""
          ],
          "line": 3318
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE"
          ],
          "line": 3317
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "int128_compare",
          "args": [
            "interval_cmp_value(offset)",
            "int64_to_int128(0)"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int64_to_int128",
          "args": [
            "0"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval_cmp_value",
          "args": [
            "offset"
          ],
          "line": 3315
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2308-2331",
          "snippet": "static inline INT128\ninterval_cmp_value(const Interval *interval)\n{\n\tINT128\t\tspan;\n\tint64\t\tdayfraction;\n\tint64\t\tdays;\n\n\t/*\n\t * Separate time field into days and dayfraction, then add the month and\n\t * day fields to the days part.  We cannot overflow int64 days here.\n\t */\n\tdayfraction = interval->time % USECS_PER_DAY;\n\tdays = interval->time / USECS_PER_DAY;\n\tdays += interval->month * INT64CONST(30);\n\tdays += interval->day;\n\n\t/* Widen dayfraction to 128 bits */\n\tspan = int64_to_int128(dayfraction);\n\n\t/* Scale up days to microseconds, forming a 128-bit product */\n\tint128_add_int64_mul_int64(&span, days, USECS_PER_DAY);\n\n\treturn span;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic inline INT128\ninterval_cmp_value(const Interval *interval)\n{\n\tINT128\t\tspan;\n\tint64\t\tdayfraction;\n\tint64\t\tdays;\n\n\t/*\n\t * Separate time field into days and dayfraction, then add the month and\n\t * day fields to the days part.  We cannot overflow int64 days here.\n\t */\n\tdayfraction = interval->time % USECS_PER_DAY;\n\tdays = interval->time / USECS_PER_DAY;\n\tdays += interval->month * INT64CONST(30);\n\tdays += interval->day;\n\n\t/* Widen dayfraction to 128 bits */\n\tspan = int64_to_int128(dayfraction);\n\n\t/* Scale up days to microseconds, forming a 128-bit product */\n\tint128_add_int64_mul_int64(&span, days, USECS_PER_DAY);\n\n\treturn span;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "4"
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "3"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "2"
          ],
          "line": 3310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 3309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nin_range_timestamp_interval(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tval = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tbase = PG_GETARG_TIMESTAMP(1);\n\tInterval   *offset = PG_GETARG_INTERVAL_P(2);\n\tbool\t\tsub = PG_GETARG_BOOL(3);\n\tbool\t\tless = PG_GETARG_BOOL(4);\n\tTimestamp\tsum;\n\n\tif (int128_compare(interval_cmp_value(offset), int64_to_int128(0)) < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\")));\n\n\t/* We don't currently bother to avoid overflow hazards here */\n\tif (sub)\n\t\tsum = DatumGetTimestamp(DirectFunctionCall2(timestamp_mi_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\tTimestampGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(offset)));\n\telse\n\t\tsum = DatumGetTimestamp(DirectFunctionCall2(timestamp_pl_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\tTimestampGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\tIntervalPGetDatum(offset)));\n\n\tif (less)\n\t\tPG_RETURN_BOOL(val <= sum);\n\telse\n\t\tPG_RETURN_BOOL(val >= sum);\n}"
  },
  {
    "function_name": "in_range_timestamptz_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3274-3303",
    "snippet": "Datum\nin_range_timestamptz_interval(PG_FUNCTION_ARGS)\n{\n\tTimestampTz val = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestampTz base = PG_GETARG_TIMESTAMPTZ(1);\n\tInterval   *offset = PG_GETARG_INTERVAL_P(2);\n\tbool\t\tsub = PG_GETARG_BOOL(3);\n\tbool\t\tless = PG_GETARG_BOOL(4);\n\tTimestampTz sum;\n\n\tif (int128_compare(interval_cmp_value(offset), int64_to_int128(0)) < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\")));\n\n\t/* We don't currently bother to avoid overflow hazards here */\n\tif (sub)\n\t\tsum = DatumGetTimestampTz(DirectFunctionCall2(timestamptz_mi_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  TimestampTzGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  IntervalPGetDatum(offset)));\n\telse\n\t\tsum = DatumGetTimestampTz(DirectFunctionCall2(timestamptz_pl_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  TimestampTzGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  IntervalPGetDatum(offset)));\n\n\tif (less)\n\t\tPG_RETURN_BOOL(val <= sum);\n\telse\n\t\tPG_RETURN_BOOL(val >= sum);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "val >= sum"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "val <= sum"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTimestampTz",
          "args": [
            "DirectFunctionCall2(timestamptz_pl_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  TimestampTzGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  IntervalPGetDatum(offset))"
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "timestamptz_pl_interval",
            "TimestampTzGetDatum(base)",
            "IntervalPGetDatum(offset)"
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "offset"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampTzGetDatum",
          "args": [
            "base"
          ],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTimestampTz",
          "args": [
            "DirectFunctionCall2(timestamptz_mi_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  TimestampTzGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  IntervalPGetDatum(offset))"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "timestamptz_mi_interval",
            "TimestampTzGetDatum(base)",
            "IntervalPGetDatum(offset)"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "offset"
          ],
          "line": 3293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampTzGetDatum",
          "args": [
            "base"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\"))"
          ],
          "line": 3285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid preceding or following size in window function\""
          ],
          "line": 3287
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE"
          ],
          "line": 3286
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "int128_compare",
          "args": [
            "interval_cmp_value(offset)",
            "int64_to_int128(0)"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int64_to_int128",
          "args": [
            "0"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval_cmp_value",
          "args": [
            "offset"
          ],
          "line": 3284
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2308-2331",
          "snippet": "static inline INT128\ninterval_cmp_value(const Interval *interval)\n{\n\tINT128\t\tspan;\n\tint64\t\tdayfraction;\n\tint64\t\tdays;\n\n\t/*\n\t * Separate time field into days and dayfraction, then add the month and\n\t * day fields to the days part.  We cannot overflow int64 days here.\n\t */\n\tdayfraction = interval->time % USECS_PER_DAY;\n\tdays = interval->time / USECS_PER_DAY;\n\tdays += interval->month * INT64CONST(30);\n\tdays += interval->day;\n\n\t/* Widen dayfraction to 128 bits */\n\tspan = int64_to_int128(dayfraction);\n\n\t/* Scale up days to microseconds, forming a 128-bit product */\n\tint128_add_int64_mul_int64(&span, days, USECS_PER_DAY);\n\n\treturn span;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic inline INT128\ninterval_cmp_value(const Interval *interval)\n{\n\tINT128\t\tspan;\n\tint64\t\tdayfraction;\n\tint64\t\tdays;\n\n\t/*\n\t * Separate time field into days and dayfraction, then add the month and\n\t * day fields to the days part.  We cannot overflow int64 days here.\n\t */\n\tdayfraction = interval->time % USECS_PER_DAY;\n\tdays = interval->time / USECS_PER_DAY;\n\tdays += interval->month * INT64CONST(30);\n\tdays += interval->day;\n\n\t/* Widen dayfraction to 128 bits */\n\tspan = int64_to_int128(dayfraction);\n\n\t/* Scale up days to microseconds, forming a 128-bit product */\n\tint128_add_int64_mul_int64(&span, days, USECS_PER_DAY);\n\n\treturn span;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "4"
          ],
          "line": 3281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "3"
          ],
          "line": 3280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "2"
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 3277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nin_range_timestamptz_interval(PG_FUNCTION_ARGS)\n{\n\tTimestampTz val = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestampTz base = PG_GETARG_TIMESTAMPTZ(1);\n\tInterval   *offset = PG_GETARG_INTERVAL_P(2);\n\tbool\t\tsub = PG_GETARG_BOOL(3);\n\tbool\t\tless = PG_GETARG_BOOL(4);\n\tTimestampTz sum;\n\n\tif (int128_compare(interval_cmp_value(offset), int64_to_int128(0)) < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\")));\n\n\t/* We don't currently bother to avoid overflow hazards here */\n\tif (sub)\n\t\tsum = DatumGetTimestampTz(DirectFunctionCall2(timestamptz_mi_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  TimestampTzGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  IntervalPGetDatum(offset)));\n\telse\n\t\tsum = DatumGetTimestampTz(DirectFunctionCall2(timestamptz_pl_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  TimestampTzGetDatum(base),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  IntervalPGetDatum(offset)));\n\n\tif (less)\n\t\tPG_RETURN_BOOL(val <= sum);\n\telse\n\t\tPG_RETURN_BOOL(val >= sum);\n}"
  },
  {
    "function_name": "interval_div",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3222-3262",
    "snippet": "Datum\ninterval_div(PG_FUNCTION_ARGS)\n{\n\tInterval   *span = PG_GETARG_INTERVAL_P(0);\n\tfloat8\t\tfactor = PG_GETARG_FLOAT8(1);\n\tdouble\t\tmonth_remainder_days,\n\t\t\t\tsec_remainder;\n\tint32\t\torig_month = span->month,\n\t\t\t\torig_day = span->day;\n\tInterval   *result;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tif (factor == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult->month = (int32) (span->month / factor);\n\tresult->day = (int32) (span->day / factor);\n\n\t/*\n\t * Fractional months full days into days.  See comment in interval_mul().\n\t */\n\tmonth_remainder_days = (orig_month / factor - result->month) * DAYS_PER_MONTH;\n\tmonth_remainder_days = TSROUND(month_remainder_days);\n\tsec_remainder = (orig_day / factor - result->day +\n\t\t\t\t\t month_remainder_days - (int) month_remainder_days) * SECS_PER_DAY;\n\tsec_remainder = TSROUND(sec_remainder);\n\tif (Abs(sec_remainder) >= SECS_PER_DAY)\n\t{\n\t\tresult->day += (int) (sec_remainder / SECS_PER_DAY);\n\t\tsec_remainder -= (int) (sec_remainder / SECS_PER_DAY) * SECS_PER_DAY;\n\t}\n\n\t/* cascade units down */\n\tresult->day += (int32) month_remainder_days;\n\tresult->time = rint(span->time / factor + sec_remainder * USECS_PER_SEC);\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "span->time / factor + sec_remainder * USECS_PER_SEC"
          ],
          "line": 3259
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Abs",
          "args": [
            "sec_remainder"
          ],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSROUND",
          "args": [
            "sec_remainder"
          ],
          "line": 3250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSROUND",
          "args": [
            "month_remainder_days"
          ],
          "line": 3247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "span->day / factor"
          ],
          "line": 3241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "span->month / factor"
          ],
          "line": 3240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\"))"
          ],
          "line": 3236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"division by zero\""
          ],
          "line": 3238
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DIVISION_BY_ZERO"
          ],
          "line": 3237
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 3233
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 3225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_div(PG_FUNCTION_ARGS)\n{\n\tInterval   *span = PG_GETARG_INTERVAL_P(0);\n\tfloat8\t\tfactor = PG_GETARG_FLOAT8(1);\n\tdouble\t\tmonth_remainder_days,\n\t\t\t\tsec_remainder;\n\tint32\t\torig_month = span->month,\n\t\t\t\torig_day = span->day;\n\tInterval   *result;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tif (factor == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult->month = (int32) (span->month / factor);\n\tresult->day = (int32) (span->day / factor);\n\n\t/*\n\t * Fractional months full days into days.  See comment in interval_mul().\n\t */\n\tmonth_remainder_days = (orig_month / factor - result->month) * DAYS_PER_MONTH;\n\tmonth_remainder_days = TSROUND(month_remainder_days);\n\tsec_remainder = (orig_day / factor - result->day +\n\t\t\t\t\t month_remainder_days - (int) month_remainder_days) * SECS_PER_DAY;\n\tsec_remainder = TSROUND(sec_remainder);\n\tif (Abs(sec_remainder) >= SECS_PER_DAY)\n\t{\n\t\tresult->day += (int) (sec_remainder / SECS_PER_DAY);\n\t\tsec_remainder -= (int) (sec_remainder / SECS_PER_DAY) * SECS_PER_DAY;\n\t}\n\n\t/* cascade units down */\n\tresult->day += (int32) month_remainder_days;\n\tresult->time = rint(span->time / factor + sec_remainder * USECS_PER_SEC);\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "mul_d_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3212-3220",
    "snippet": "Datum\nmul_d_interval(PG_FUNCTION_ARGS)\n{\n\t/* Args are float8 and Interval *, but leave them as generic Datum */\n\tDatum\t\tfactor = PG_GETARG_DATUM(0);\n\tDatum\t\tspan = PG_GETARG_DATUM(1);\n\n\treturn DirectFunctionCall2(interval_mul, span, factor);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "interval_mul",
            "span",
            "factor"
          ],
          "line": 3219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 3216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nmul_d_interval(PG_FUNCTION_ARGS)\n{\n\t/* Args are float8 and Interval *, but leave them as generic Datum */\n\tDatum\t\tfactor = PG_GETARG_DATUM(0);\n\tDatum\t\tspan = PG_GETARG_DATUM(1);\n\n\treturn DirectFunctionCall2(interval_mul, span, factor);\n}"
  },
  {
    "function_name": "interval_mul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3135-3210",
    "snippet": "Datum\ninterval_mul(PG_FUNCTION_ARGS)\n{\n\tInterval   *span = PG_GETARG_INTERVAL_P(0);\n\tfloat8\t\tfactor = PG_GETARG_FLOAT8(1);\n\tdouble\t\tmonth_remainder_days,\n\t\t\t\tsec_remainder,\n\t\t\t\tresult_double;\n\tint32\t\torig_month = span->month,\n\t\t\t\torig_day = span->day;\n\tInterval   *result;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tresult_double = span->month * factor;\n\tif (isnan(result_double) ||\n\t\tresult_double > INT_MAX || result_double < INT_MIN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\tresult->month = (int32) result_double;\n\n\tresult_double = span->day * factor;\n\tif (isnan(result_double) ||\n\t\tresult_double > INT_MAX || result_double < INT_MIN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\tresult->day = (int32) result_double;\n\n\t/*\n\t * The above correctly handles the whole-number part of the month and day\n\t * products, but we have to do something with any fractional part\n\t * resulting when the factor is non-integral.  We cascade the fractions\n\t * down to lower units using the conversion factors DAYS_PER_MONTH and\n\t * SECS_PER_DAY.  Note we do NOT cascade up, since we are not forced to do\n\t * so by the representation.  The user can choose to cascade up later,\n\t * using justify_hours and/or justify_days.\n\t */\n\n\t/*\n\t * Fractional months full days into days.\n\t *\n\t * Floating point calculation are inherently imprecise, so these\n\t * calculations are crafted to produce the most reliable result possible.\n\t * TSROUND() is needed to more accurately produce whole numbers where\n\t * appropriate.\n\t */\n\tmonth_remainder_days = (orig_month * factor - result->month) * DAYS_PER_MONTH;\n\tmonth_remainder_days = TSROUND(month_remainder_days);\n\tsec_remainder = (orig_day * factor - result->day +\n\t\t\t\t\t month_remainder_days - (int) month_remainder_days) * SECS_PER_DAY;\n\tsec_remainder = TSROUND(sec_remainder);\n\n\t/*\n\t * Might have 24:00:00 hours due to rounding, or >24 hours because of time\n\t * cascade from months and days.  It might still be >24 if the combination\n\t * of cascade and the seconds factor operation itself.\n\t */\n\tif (Abs(sec_remainder) >= SECS_PER_DAY)\n\t{\n\t\tresult->day += (int) (sec_remainder / SECS_PER_DAY);\n\t\tsec_remainder -= (int) (sec_remainder / SECS_PER_DAY) * SECS_PER_DAY;\n\t}\n\n\t/* cascade units down */\n\tresult->day += (int32) month_remainder_days;\n\tresult_double = rint(span->time * factor + sec_remainder * USECS_PER_SEC);\n\tif (result_double > PG_INT64_MAX || result_double < PG_INT64_MIN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\tresult->time = (int64) result_double;\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 3209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"interval out of range\""
          ],
          "line": 3206
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 3205
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "span->time * factor + sec_remainder * USECS_PER_SEC"
          ],
          "line": 3202
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Abs",
          "args": [
            "sec_remainder"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSROUND",
          "args": [
            "sec_remainder"
          ],
          "line": 3187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSROUND",
          "args": [
            "month_remainder_days"
          ],
          "line": 3184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "result_double"
          ],
          "line": 3158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "result_double"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_mul(PG_FUNCTION_ARGS)\n{\n\tInterval   *span = PG_GETARG_INTERVAL_P(0);\n\tfloat8\t\tfactor = PG_GETARG_FLOAT8(1);\n\tdouble\t\tmonth_remainder_days,\n\t\t\t\tsec_remainder,\n\t\t\t\tresult_double;\n\tint32\t\torig_month = span->month,\n\t\t\t\torig_day = span->day;\n\tInterval   *result;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tresult_double = span->month * factor;\n\tif (isnan(result_double) ||\n\t\tresult_double > INT_MAX || result_double < INT_MIN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\tresult->month = (int32) result_double;\n\n\tresult_double = span->day * factor;\n\tif (isnan(result_double) ||\n\t\tresult_double > INT_MAX || result_double < INT_MIN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\tresult->day = (int32) result_double;\n\n\t/*\n\t * The above correctly handles the whole-number part of the month and day\n\t * products, but we have to do something with any fractional part\n\t * resulting when the factor is non-integral.  We cascade the fractions\n\t * down to lower units using the conversion factors DAYS_PER_MONTH and\n\t * SECS_PER_DAY.  Note we do NOT cascade up, since we are not forced to do\n\t * so by the representation.  The user can choose to cascade up later,\n\t * using justify_hours and/or justify_days.\n\t */\n\n\t/*\n\t * Fractional months full days into days.\n\t *\n\t * Floating point calculation are inherently imprecise, so these\n\t * calculations are crafted to produce the most reliable result possible.\n\t * TSROUND() is needed to more accurately produce whole numbers where\n\t * appropriate.\n\t */\n\tmonth_remainder_days = (orig_month * factor - result->month) * DAYS_PER_MONTH;\n\tmonth_remainder_days = TSROUND(month_remainder_days);\n\tsec_remainder = (orig_day * factor - result->day +\n\t\t\t\t\t month_remainder_days - (int) month_remainder_days) * SECS_PER_DAY;\n\tsec_remainder = TSROUND(sec_remainder);\n\n\t/*\n\t * Might have 24:00:00 hours due to rounding, or >24 hours because of time\n\t * cascade from months and days.  It might still be >24 if the combination\n\t * of cascade and the seconds factor operation itself.\n\t */\n\tif (Abs(sec_remainder) >= SECS_PER_DAY)\n\t{\n\t\tresult->day += (int) (sec_remainder / SECS_PER_DAY);\n\t\tsec_remainder -= (int) (sec_remainder / SECS_PER_DAY) * SECS_PER_DAY;\n\t}\n\n\t/* cascade units down */\n\tresult->day += (int32) month_remainder_days;\n\tresult_double = rint(span->time * factor + sec_remainder * USECS_PER_SEC);\n\tif (result_double > PG_INT64_MAX || result_double < PG_INT64_MIN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\tresult->time = (int64) result_double;\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "interval_mi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3095-3127",
    "snippet": "Datum\ninterval_mi(PG_FUNCTION_ARGS)\n{\n\tInterval   *span1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *span2 = PG_GETARG_INTERVAL_P(1);\n\tInterval   *result;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tresult->month = span1->month - span2->month;\n\t/* overflow check copied from int4mi */\n\tif (!SAMESIGN(span1->month, span2->month) &&\n\t\t!SAMESIGN(result->month, span1->month))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\n\tresult->day = span1->day - span2->day;\n\tif (!SAMESIGN(span1->day, span2->day) &&\n\t\t!SAMESIGN(result->day, span1->day))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\n\tresult->time = span1->time - span2->time;\n\tif (!SAMESIGN(span1->time, span2->time) &&\n\t\t!SAMESIGN(result->time, span1->time))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 3126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"interval out of range\""
          ],
          "line": 3124
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 3123
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAMESIGN",
          "args": [
            "result->time",
            "span1->time"
          ],
          "line": 3121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAMESIGN",
          "args": [
            "span1->time",
            "span2->time"
          ],
          "line": 3120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAMESIGN",
          "args": [
            "result->day",
            "span1->day"
          ],
          "line": 3114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAMESIGN",
          "args": [
            "span1->day",
            "span2->day"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 3108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAMESIGN",
          "args": [
            "result->month",
            "span1->month"
          ],
          "line": 3107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAMESIGN",
          "args": [
            "span1->month",
            "span2->month"
          ],
          "line": 3106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 3102
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_mi(PG_FUNCTION_ARGS)\n{\n\tInterval   *span1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *span2 = PG_GETARG_INTERVAL_P(1);\n\tInterval   *result;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tresult->month = span1->month - span2->month;\n\t/* overflow check copied from int4mi */\n\tif (!SAMESIGN(span1->month, span2->month) &&\n\t\t!SAMESIGN(result->month, span1->month))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\n\tresult->day = span1->day - span2->day;\n\tif (!SAMESIGN(span1->day, span2->day) &&\n\t\t!SAMESIGN(result->day, span1->day))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\n\tresult->time = span1->time - span2->time;\n\tif (!SAMESIGN(span1->time, span2->time) &&\n\t\t!SAMESIGN(result->time, span1->time))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "interval_pl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3061-3093",
    "snippet": "Datum\ninterval_pl(PG_FUNCTION_ARGS)\n{\n\tInterval   *span1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *span2 = PG_GETARG_INTERVAL_P(1);\n\tInterval   *result;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tresult->month = span1->month + span2->month;\n\t/* overflow check copied from int4pl */\n\tif (SAMESIGN(span1->month, span2->month) &&\n\t\t!SAMESIGN(result->month, span1->month))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\n\tresult->day = span1->day + span2->day;\n\tif (SAMESIGN(span1->day, span2->day) &&\n\t\t!SAMESIGN(result->day, span1->day))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\n\tresult->time = span1->time + span2->time;\n\tif (SAMESIGN(span1->time, span2->time) &&\n\t\t!SAMESIGN(result->time, span1->time))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 3092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"interval out of range\""
          ],
          "line": 3090
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAMESIGN",
          "args": [
            "result->time",
            "span1->time"
          ],
          "line": 3087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAMESIGN",
          "args": [
            "span1->time",
            "span2->time"
          ],
          "line": 3086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAMESIGN",
          "args": [
            "result->day",
            "span1->day"
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAMESIGN",
          "args": [
            "span1->day",
            "span2->day"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 3074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAMESIGN",
          "args": [
            "result->month",
            "span1->month"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAMESIGN",
          "args": [
            "span1->month",
            "span2->month"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 3068
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 3064
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_pl(PG_FUNCTION_ARGS)\n{\n\tInterval   *span1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *span2 = PG_GETARG_INTERVAL_P(1);\n\tInterval   *result;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tresult->month = span1->month + span2->month;\n\t/* overflow check copied from int4pl */\n\tif (SAMESIGN(span1->month, span2->month) &&\n\t\t!SAMESIGN(result->month, span1->month))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\n\tresult->day = span1->day + span2->day;\n\tif (SAMESIGN(span1->day, span2->day) &&\n\t\t!SAMESIGN(result->day, span1->day))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\n\tresult->time = span1->time + span2->time;\n\tif (SAMESIGN(span1->time, span2->time) &&\n\t\t!SAMESIGN(result->time, span1->time))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "interval_larger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3047-3059",
    "snippet": "Datum\ninterval_larger(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\tInterval   *result;\n\n\tif (interval_cmp_internal(interval1, interval2) > 0)\n\t\tresult = interval1;\n\telse\n\t\tresult = interval2;\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval_cmp_internal",
          "args": [
            "interval1",
            "interval2"
          ],
          "line": 3054
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2333-2340",
          "snippet": "static int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 3050
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_larger(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\tInterval   *result;\n\n\tif (interval_cmp_internal(interval1, interval2) > 0)\n\t\tresult = interval1;\n\telse\n\t\tresult = interval2;\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "interval_smaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3032-3045",
    "snippet": "Datum\ninterval_smaller(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\tInterval   *result;\n\n\t/* use interval_cmp_internal to be sure this agrees with comparisons */\n\tif (interval_cmp_internal(interval1, interval2) < 0)\n\t\tresult = interval1;\n\telse\n\t\tresult = interval2;\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval_cmp_internal",
          "args": [
            "interval1",
            "interval2"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2333-2340",
          "snippet": "static int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 3035
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_smaller(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\tInterval   *result;\n\n\t/* use interval_cmp_internal to be sure this agrees with comparisons */\n\tif (interval_cmp_internal(interval1, interval2) < 0)\n\t\tresult = interval1;\n\telse\n\t\tresult = interval2;\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "interval_um",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "3003-3029",
    "snippet": "Datum\ninterval_um(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval = PG_GETARG_INTERVAL_P(0);\n\tInterval   *result;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tresult->time = -interval->time;\n\t/* overflow check copied from int4um */\n\tif (interval->time != 0 && SAMESIGN(result->time, interval->time))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\tresult->day = -interval->day;\n\tif (interval->day != 0 && SAMESIGN(result->day, interval->day))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\tresult->month = -interval->month;\n\tif (interval->month != 0 && SAMESIGN(result->month, interval->month))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"interval out of range\""
          ],
          "line": 3026
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 3025
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAMESIGN",
          "args": [
            "result->month",
            "interval->month"
          ],
          "line": 3023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAMESIGN",
          "args": [
            "result->day",
            "interval->day"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAMESIGN",
          "args": [
            "result->time",
            "interval->time"
          ],
          "line": 3013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_um(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval = PG_GETARG_INTERVAL_P(0);\n\tInterval   *result;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tresult->time = -interval->time;\n\t/* overflow check copied from int4um */\n\tif (interval->time != 0 && SAMESIGN(result->time, interval->time))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\tresult->day = -interval->day;\n\tif (interval->day != 0 && SAMESIGN(result->day, interval->day))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\tresult->month = -interval->month;\n\tif (interval->month != 0 && SAMESIGN(result->month, interval->month))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "timestamptz_mi_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2986-3000",
    "snippet": "Datum\ntimestamptz_mi_interval(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tInterval\ttspan;\n\n\ttspan.month = -span->month;\n\ttspan.day = -span->day;\n\ttspan.time = -span->time;\n\n\treturn DirectFunctionCall2(timestamptz_pl_interval,\n\t\t\t\t\t\t\t   TimestampGetDatum(timestamp),\n\t\t\t\t\t\t\t   PointerGetDatum(&tspan));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "timestamptz_pl_interval",
            "TimestampGetDatum(timestamp)",
            "PointerGetDatum(&tspan)"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "&tspan"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampGetDatum",
          "args": [
            "timestamp"
          ],
          "line": 2998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 2990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 2989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamptz_mi_interval(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tInterval\ttspan;\n\n\ttspan.month = -span->month;\n\ttspan.day = -span->day;\n\ttspan.time = -span->time;\n\n\treturn DirectFunctionCall2(timestamptz_pl_interval,\n\t\t\t\t\t\t\t   TimestampGetDatum(timestamp),\n\t\t\t\t\t\t\t   PointerGetDatum(&tspan));\n}"
  },
  {
    "function_name": "timestamptz_pl_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2902-2984",
    "snippet": "Datum\ntimestamptz_pl_interval(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tTimestampTz result;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (span->month != 0)\n\t\t{\n\t\t\tstruct pg_tm tt,\n\t\t\t\t\t   *tm = &tt;\n\t\t\tfsec_t\t\tfsec;\n\n\t\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\ttm->tm_mon += span->month;\n\t\t\tif (tm->tm_mon > MONTHS_PER_YEAR)\n\t\t\t{\n\t\t\t\ttm->tm_year += (tm->tm_mon - 1) / MONTHS_PER_YEAR;\n\t\t\t\ttm->tm_mon = ((tm->tm_mon - 1) % MONTHS_PER_YEAR) + 1;\n\t\t\t}\n\t\t\telse if (tm->tm_mon < 1)\n\t\t\t{\n\t\t\t\ttm->tm_year += tm->tm_mon / MONTHS_PER_YEAR - 1;\n\t\t\t\ttm->tm_mon = tm->tm_mon % MONTHS_PER_YEAR + MONTHS_PER_YEAR;\n\t\t\t}\n\n\t\t\t/* adjust for end of month boundary problems... */\n\t\t\tif (tm->tm_mday > day_tab[isleap(tm->tm_year)][tm->tm_mon - 1])\n\t\t\t\ttm->tm_mday = (day_tab[isleap(tm->tm_year)][tm->tm_mon - 1]);\n\n\t\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\t\tif (tm2timestamp(tm, fsec, &tz, &timestamp) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t}\n\n\t\tif (span->day != 0)\n\t\t{\n\t\t\tstruct pg_tm tt,\n\t\t\t\t\t   *tm = &tt;\n\t\t\tfsec_t\t\tfsec;\n\t\t\tint\t\t\tjulian;\n\n\t\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t/* Add days by converting to and from Julian */\n\t\t\tjulian = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) + span->day;\n\t\t\tj2date(julian, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\n\t\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\t\tif (tm2timestamp(tm, fsec, &tz, &timestamp) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t}\n\n\t\ttimestamp += span->time;\n\n\t\tif (!IS_VALID_TIMESTAMP(timestamp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\tresult = timestamp;\n\t}\n\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 2976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 2978
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_TIMESTAMP",
          "args": [
            "timestamp"
          ],
          "line": 2975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 2968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm2timestamp",
          "args": [
            "tm",
            "fsec",
            "&tz",
            "&timestamp"
          ],
          "line": 2967
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1853-1895",
          "snippet": "int\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneOffset",
          "args": [
            "tm",
            "session_timezone"
          ],
          "line": 2965
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1454-1460",
          "snippet": "int\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "j2date",
          "args": [
            "julian",
            "&tm->tm_year",
            "&tm->tm_mon",
            "&tm->tm_mday"
          ],
          "line": 2963
        },
        "resolved": true,
        "details": {
          "function_name": "j2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "300-325",
          "snippet": "void\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 2962
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "&tz",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isleap",
          "args": [
            "tm->tm_year"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isleap",
          "args": [
            "tm->tm_year"
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 2910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamptz_pl_interval(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tTimestampTz result;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (span->month != 0)\n\t\t{\n\t\t\tstruct pg_tm tt,\n\t\t\t\t\t   *tm = &tt;\n\t\t\tfsec_t\t\tfsec;\n\n\t\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\ttm->tm_mon += span->month;\n\t\t\tif (tm->tm_mon > MONTHS_PER_YEAR)\n\t\t\t{\n\t\t\t\ttm->tm_year += (tm->tm_mon - 1) / MONTHS_PER_YEAR;\n\t\t\t\ttm->tm_mon = ((tm->tm_mon - 1) % MONTHS_PER_YEAR) + 1;\n\t\t\t}\n\t\t\telse if (tm->tm_mon < 1)\n\t\t\t{\n\t\t\t\ttm->tm_year += tm->tm_mon / MONTHS_PER_YEAR - 1;\n\t\t\t\ttm->tm_mon = tm->tm_mon % MONTHS_PER_YEAR + MONTHS_PER_YEAR;\n\t\t\t}\n\n\t\t\t/* adjust for end of month boundary problems... */\n\t\t\tif (tm->tm_mday > day_tab[isleap(tm->tm_year)][tm->tm_mon - 1])\n\t\t\t\ttm->tm_mday = (day_tab[isleap(tm->tm_year)][tm->tm_mon - 1]);\n\n\t\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\t\tif (tm2timestamp(tm, fsec, &tz, &timestamp) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t}\n\n\t\tif (span->day != 0)\n\t\t{\n\t\t\tstruct pg_tm tt,\n\t\t\t\t\t   *tm = &tt;\n\t\t\tfsec_t\t\tfsec;\n\t\t\tint\t\t\tjulian;\n\n\t\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t/* Add days by converting to and from Julian */\n\t\t\tjulian = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) + span->day;\n\t\t\tj2date(julian, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\n\t\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\t\tif (tm2timestamp(tm, fsec, &tz, &timestamp) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t}\n\n\t\ttimestamp += span->time;\n\n\t\tif (!IS_VALID_TIMESTAMP(timestamp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\tresult = timestamp;\n\t}\n\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "timestamp_mi_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2876-2890",
    "snippet": "Datum\ntimestamp_mi_interval(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tInterval\ttspan;\n\n\ttspan.month = -span->month;\n\ttspan.day = -span->day;\n\ttspan.time = -span->time;\n\n\treturn DirectFunctionCall2(timestamp_pl_interval,\n\t\t\t\t\t\t\t   TimestampGetDatum(timestamp),\n\t\t\t\t\t\t\t   PointerGetDatum(&tspan));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "timestamp_pl_interval",
            "TimestampGetDatum(timestamp)",
            "PointerGetDatum(&tspan)"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "&tspan"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampGetDatum",
          "args": [
            "timestamp"
          ],
          "line": 2888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamp_mi_interval(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tInterval\ttspan;\n\n\ttspan.month = -span->month;\n\ttspan.day = -span->day;\n\ttspan.time = -span->time;\n\n\treturn DirectFunctionCall2(timestamp_pl_interval,\n\t\t\t\t\t\t\t   TimestampGetDatum(timestamp),\n\t\t\t\t\t\t\t   PointerGetDatum(&tspan));\n}"
  },
  {
    "function_name": "timestamp_pl_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2797-2874",
    "snippet": "Datum\ntimestamp_pl_interval(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tTimestamp\tresult;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (span->month != 0)\n\t\t{\n\t\t\tstruct pg_tm tt,\n\t\t\t\t\t   *tm = &tt;\n\t\t\tfsec_t\t\tfsec;\n\n\t\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\ttm->tm_mon += span->month;\n\t\t\tif (tm->tm_mon > MONTHS_PER_YEAR)\n\t\t\t{\n\t\t\t\ttm->tm_year += (tm->tm_mon - 1) / MONTHS_PER_YEAR;\n\t\t\t\ttm->tm_mon = ((tm->tm_mon - 1) % MONTHS_PER_YEAR) + 1;\n\t\t\t}\n\t\t\telse if (tm->tm_mon < 1)\n\t\t\t{\n\t\t\t\ttm->tm_year += tm->tm_mon / MONTHS_PER_YEAR - 1;\n\t\t\t\ttm->tm_mon = tm->tm_mon % MONTHS_PER_YEAR + MONTHS_PER_YEAR;\n\t\t\t}\n\n\t\t\t/* adjust for end of month boundary problems... */\n\t\t\tif (tm->tm_mday > day_tab[isleap(tm->tm_year)][tm->tm_mon - 1])\n\t\t\t\ttm->tm_mday = (day_tab[isleap(tm->tm_year)][tm->tm_mon - 1]);\n\n\t\t\tif (tm2timestamp(tm, fsec, NULL, &timestamp) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t}\n\n\t\tif (span->day != 0)\n\t\t{\n\t\t\tstruct pg_tm tt,\n\t\t\t\t\t   *tm = &tt;\n\t\t\tfsec_t\t\tfsec;\n\t\t\tint\t\t\tjulian;\n\n\t\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t/* Add days by converting to and from Julian */\n\t\t\tjulian = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) + span->day;\n\t\t\tj2date(julian, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\n\t\t\tif (tm2timestamp(tm, fsec, NULL, &timestamp) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t}\n\n\t\ttimestamp += span->time;\n\n\t\tif (!IS_VALID_TIMESTAMP(timestamp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\tresult = timestamp;\n\t}\n\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 2868
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 2867
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_TIMESTAMP",
          "args": [
            "timestamp"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm2timestamp",
          "args": [
            "tm",
            "fsec",
            "NULL",
            "&timestamp"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1853-1895",
          "snippet": "int\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "j2date",
          "args": [
            "julian",
            "&tm->tm_year",
            "&tm->tm_mon",
            "&tm->tm_mday"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "j2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "300-325",
          "snippet": "void\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 2854
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "NULL",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 2848
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isleap",
          "args": [
            "tm->tm_year"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isleap",
          "args": [
            "tm->tm_year"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamp_pl_interval(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tTimestamp\tresult;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (span->month != 0)\n\t\t{\n\t\t\tstruct pg_tm tt,\n\t\t\t\t\t   *tm = &tt;\n\t\t\tfsec_t\t\tfsec;\n\n\t\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\ttm->tm_mon += span->month;\n\t\t\tif (tm->tm_mon > MONTHS_PER_YEAR)\n\t\t\t{\n\t\t\t\ttm->tm_year += (tm->tm_mon - 1) / MONTHS_PER_YEAR;\n\t\t\t\ttm->tm_mon = ((tm->tm_mon - 1) % MONTHS_PER_YEAR) + 1;\n\t\t\t}\n\t\t\telse if (tm->tm_mon < 1)\n\t\t\t{\n\t\t\t\ttm->tm_year += tm->tm_mon / MONTHS_PER_YEAR - 1;\n\t\t\t\ttm->tm_mon = tm->tm_mon % MONTHS_PER_YEAR + MONTHS_PER_YEAR;\n\t\t\t}\n\n\t\t\t/* adjust for end of month boundary problems... */\n\t\t\tif (tm->tm_mday > day_tab[isleap(tm->tm_year)][tm->tm_mon - 1])\n\t\t\t\ttm->tm_mday = (day_tab[isleap(tm->tm_year)][tm->tm_mon - 1]);\n\n\t\t\tif (tm2timestamp(tm, fsec, NULL, &timestamp) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t}\n\n\t\tif (span->day != 0)\n\t\t{\n\t\t\tstruct pg_tm tt,\n\t\t\t\t\t   *tm = &tt;\n\t\t\tfsec_t\t\tfsec;\n\t\t\tint\t\t\tjulian;\n\n\t\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t/* Add days by converting to and from Julian */\n\t\t\tjulian = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) + span->day;\n\t\t\tj2date(julian, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\n\t\t\tif (tm2timestamp(tm, fsec, NULL, &timestamp) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t}\n\n\t\ttimestamp += span->time;\n\n\t\tif (!IS_VALID_TIMESTAMP(timestamp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\tresult = timestamp;\n\t}\n\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "interval_justify_days",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2757-2785",
    "snippet": "Datum\ninterval_justify_days(PG_FUNCTION_ARGS)\n{\n\tInterval   *span = PG_GETARG_INTERVAL_P(0);\n\tInterval   *result;\n\tint32\t\twholemonth;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\tresult->month = span->month;\n\tresult->day = span->day;\n\tresult->time = span->time;\n\n\twholemonth = result->day / DAYS_PER_MONTH;\n\tresult->day -= wholemonth * DAYS_PER_MONTH;\n\tresult->month += wholemonth;\n\n\tif (result->month > 0 && result->day < 0)\n\t{\n\t\tresult->day += DAYS_PER_MONTH;\n\t\tresult->month--;\n\t}\n\telse if (result->month < 0 && result->day > 0)\n\t{\n\t\tresult->day -= DAYS_PER_MONTH;\n\t\tresult->month++;\n\t}\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_justify_days(PG_FUNCTION_ARGS)\n{\n\tInterval   *span = PG_GETARG_INTERVAL_P(0);\n\tInterval   *result;\n\tint32\t\twholemonth;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\tresult->month = span->month;\n\tresult->day = span->day;\n\tresult->time = span->time;\n\n\twholemonth = result->day / DAYS_PER_MONTH;\n\tresult->day -= wholemonth * DAYS_PER_MONTH;\n\tresult->month += wholemonth;\n\n\tif (result->month > 0 && result->day < 0)\n\t{\n\t\tresult->day += DAYS_PER_MONTH;\n\t\tresult->month--;\n\t}\n\telse if (result->month < 0 && result->day > 0)\n\t{\n\t\tresult->day -= DAYS_PER_MONTH;\n\t\tresult->month++;\n\t}\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "interval_justify_hours",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2722-2749",
    "snippet": "Datum\ninterval_justify_hours(PG_FUNCTION_ARGS)\n{\n\tInterval   *span = PG_GETARG_INTERVAL_P(0);\n\tInterval   *result;\n\tTimeOffset\twholeday;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\tresult->month = span->month;\n\tresult->day = span->day;\n\tresult->time = span->time;\n\n\tTMODULO(result->time, wholeday, USECS_PER_DAY);\n\tresult->day += wholeday;\t/* could overflow... */\n\n\tif (result->day > 0 && result->time < 0)\n\t{\n\t\tresult->time += USECS_PER_DAY;\n\t\tresult->day--;\n\t}\n\telse if (result->day < 0 && result->time > 0)\n\t{\n\t\tresult->time -= USECS_PER_DAY;\n\t\tresult->day++;\n\t}\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TMODULO",
          "args": [
            "result->time",
            "wholeday",
            "USECS_PER_DAY"
          ],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 2729
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_justify_hours(PG_FUNCTION_ARGS)\n{\n\tInterval   *span = PG_GETARG_INTERVAL_P(0);\n\tInterval   *result;\n\tTimeOffset\twholeday;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\tresult->month = span->month;\n\tresult->day = span->day;\n\tresult->time = span->time;\n\n\tTMODULO(result->time, wholeday, USECS_PER_DAY);\n\tresult->day += wholeday;\t/* could overflow... */\n\n\tif (result->day > 0 && result->time < 0)\n\t{\n\t\tresult->time += USECS_PER_DAY;\n\t\tresult->day--;\n\t}\n\telse if (result->day < 0 && result->time > 0)\n\t{\n\t\tresult->time -= USECS_PER_DAY;\n\t\tresult->day++;\n\t}\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "interval_justify_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2667-2712",
    "snippet": "Datum\ninterval_justify_interval(PG_FUNCTION_ARGS)\n{\n\tInterval   *span = PG_GETARG_INTERVAL_P(0);\n\tInterval   *result;\n\tTimeOffset\twholeday;\n\tint32\t\twholemonth;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\tresult->month = span->month;\n\tresult->day = span->day;\n\tresult->time = span->time;\n\n\tTMODULO(result->time, wholeday, USECS_PER_DAY);\n\tresult->day += wholeday;\t/* could overflow... */\n\n\twholemonth = result->day / DAYS_PER_MONTH;\n\tresult->day -= wholemonth * DAYS_PER_MONTH;\n\tresult->month += wholemonth;\n\n\tif (result->month > 0 &&\n\t\t(result->day < 0 || (result->day == 0 && result->time < 0)))\n\t{\n\t\tresult->day += DAYS_PER_MONTH;\n\t\tresult->month--;\n\t}\n\telse if (result->month < 0 &&\n\t\t\t (result->day > 0 || (result->day == 0 && result->time > 0)))\n\t{\n\t\tresult->day -= DAYS_PER_MONTH;\n\t\tresult->month++;\n\t}\n\n\tif (result->day > 0 && result->time < 0)\n\t{\n\t\tresult->time += USECS_PER_DAY;\n\t\tresult->day--;\n\t}\n\telse if (result->day < 0 && result->time > 0)\n\t{\n\t\tresult->time -= USECS_PER_DAY;\n\t\tresult->day++;\n\t}\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TMODULO",
          "args": [
            "result->time",
            "wholeday",
            "USECS_PER_DAY"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_justify_interval(PG_FUNCTION_ARGS)\n{\n\tInterval   *span = PG_GETARG_INTERVAL_P(0);\n\tInterval   *result;\n\tTimeOffset\twholeday;\n\tint32\t\twholemonth;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\tresult->month = span->month;\n\tresult->day = span->day;\n\tresult->time = span->time;\n\n\tTMODULO(result->time, wholeday, USECS_PER_DAY);\n\tresult->day += wholeday;\t/* could overflow... */\n\n\twholemonth = result->day / DAYS_PER_MONTH;\n\tresult->day -= wholemonth * DAYS_PER_MONTH;\n\tresult->month += wholemonth;\n\n\tif (result->month > 0 &&\n\t\t(result->day < 0 || (result->day == 0 && result->time < 0)))\n\t{\n\t\tresult->day += DAYS_PER_MONTH;\n\t\tresult->month--;\n\t}\n\telse if (result->month < 0 &&\n\t\t\t (result->day > 0 || (result->day == 0 && result->time > 0)))\n\t{\n\t\tresult->day -= DAYS_PER_MONTH;\n\t\tresult->month++;\n\t}\n\n\tif (result->day > 0 && result->time < 0)\n\t{\n\t\tresult->time += USECS_PER_DAY;\n\t\tresult->day--;\n\t}\n\telse if (result->day < 0 && result->time > 0)\n\t{\n\t\tresult->time -= USECS_PER_DAY;\n\t\tresult->day++;\n\t}\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "timestamp_mi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2605-2653",
    "snippet": "Datum\ntimestamp_mi(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tInterval   *result;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tif (TIMESTAMP_NOT_FINITE(dt1) || TIMESTAMP_NOT_FINITE(dt2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"cannot subtract infinite timestamps\")));\n\n\tresult->time = dt1 - dt2;\n\n\tresult->month = 0;\n\tresult->day = 0;\n\n\t/*----------\n\t *\tThis is wrong, but removing it breaks a lot of regression tests.\n\t *\tFor example:\n\t *\n\t *\ttest=> SET timezone = 'EST5EDT';\n\t *\ttest=> SELECT\n\t *\ttest-> ('2005-10-30 13:22:00-05'::timestamptz -\n\t *\ttest(>\t'2005-10-29 13:22:00-04'::timestamptz);\n\t *\t?column?\n\t *\t----------------\n\t *\t 1 day 01:00:00\n\t *\t (1 row)\n\t *\n\t *\tso adding that to the first timestamp gets:\n\t *\n\t *\t test=> SELECT\n\t *\t test-> ('2005-10-29 13:22:00-04'::timestamptz +\n\t *\t test(> ('2005-10-30 13:22:00-05'::timestamptz -\n\t *\t test(>  '2005-10-29 13:22:00-04'::timestamptz)) at time zone 'EST';\n\t *\t\ttimezone\n\t *\t--------------------\n\t *\t2005-10-30 14:22:00\n\t *\t(1 row)\n\t *----------\n\t */\n\tresult = DatumGetIntervalP(DirectFunctionCall1(interval_justify_hours,\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(result)));\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Timestamp dt2local(Timestamp dt, int timezone);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "DirectFunctionCall1(interval_justify_hours,\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(result))"
          ],
          "line": 2649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "interval_justify_hours",
            "IntervalPGetDatum(result)"
          ],
          "line": 2649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "result"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"cannot subtract infinite timestamps\"))"
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot subtract infinite timestamps\""
          ],
          "line": 2617
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 2616
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "dt2"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "dt1"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamp_mi(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tInterval   *result;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tif (TIMESTAMP_NOT_FINITE(dt1) || TIMESTAMP_NOT_FINITE(dt2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"cannot subtract infinite timestamps\")));\n\n\tresult->time = dt1 - dt2;\n\n\tresult->month = 0;\n\tresult->day = 0;\n\n\t/*----------\n\t *\tThis is wrong, but removing it breaks a lot of regression tests.\n\t *\tFor example:\n\t *\n\t *\ttest=> SET timezone = 'EST5EDT';\n\t *\ttest=> SELECT\n\t *\ttest-> ('2005-10-30 13:22:00-05'::timestamptz -\n\t *\ttest(>\t'2005-10-29 13:22:00-04'::timestamptz);\n\t *\t?column?\n\t *\t----------------\n\t *\t 1 day 01:00:00\n\t *\t (1 row)\n\t *\n\t *\tso adding that to the first timestamp gets:\n\t *\n\t *\t test=> SELECT\n\t *\t test-> ('2005-10-29 13:22:00-04'::timestamptz +\n\t *\t test(> ('2005-10-30 13:22:00-05'::timestamptz -\n\t *\t test(>  '2005-10-29 13:22:00-04'::timestamptz)) at time zone 'EST';\n\t *\t\ttimezone\n\t *\t--------------------\n\t *\t2005-10-30 14:22:00\n\t *\t(1 row)\n\t *----------\n\t */\n\tresult = DatumGetIntervalP(DirectFunctionCall1(interval_justify_hours,\n\t\t\t\t\t\t\t\t\t\t\t\t   IntervalPGetDatum(result)));\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "timestamp_larger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2590-2602",
    "snippet": "Datum\ntimestamp_larger(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tresult;\n\n\tif (timestamp_cmp_internal(dt1, dt2) > 0)\n\t\tresult = dt1;\n\telse\n\t\tresult = dt2;\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_larger(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tresult;\n\n\tif (timestamp_cmp_internal(dt1, dt2) > 0)\n\t\tresult = dt1;\n\telse\n\t\tresult = dt2;\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "timestamp_smaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2575-2588",
    "snippet": "Datum\ntimestamp_smaller(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tresult;\n\n\t/* use timestamp_cmp_internal to be sure this agrees with comparisons */\n\tif (timestamp_cmp_internal(dt1, dt2) < 0)\n\t\tresult = dt1;\n\telse\n\t\tresult = dt2;\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_smaller(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tresult;\n\n\t/* use timestamp_cmp_internal to be sure this agrees with comparisons */\n\tif (timestamp_cmp_internal(dt1, dt2) < 0)\n\t\tresult = dt1;\n\telse\n\t\tresult = dt2;\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "overlaps_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2450-2568",
    "snippet": "Datum\noverlaps_timestamp(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * The arguments are Timestamps, but we leave them as generic Datums to\n\t * avoid unnecessary conversions between value and reference forms --- not\n\t * to mention possible dereferences of null pointers.\n\t */\n\tDatum\t\tts1 = PG_GETARG_DATUM(0);\n\tDatum\t\tte1 = PG_GETARG_DATUM(1);\n\tDatum\t\tts2 = PG_GETARG_DATUM(2);\n\tDatum\t\tte2 = PG_GETARG_DATUM(3);\n\tbool\t\tts1IsNull = PG_ARGISNULL(0);\n\tbool\t\tte1IsNull = PG_ARGISNULL(1);\n\tbool\t\tts2IsNull = PG_ARGISNULL(2);\n\tbool\t\tte2IsNull = PG_ARGISNULL(3);\n\n#define TIMESTAMP_GT(t1,t2) \\\n\tDatumGetBool(DirectFunctionCall2(timestamp_gt,t1,t2))\n#define TIMESTAMP_LT(t1,t2) \\\n\tDatumGetBool(DirectFunctionCall2(timestamp_lt,t1,t2))\n\n\t/*\n\t * If both endpoints of interval 1 are null, the result is null (unknown).\n\t * If just one endpoint is null, take ts1 as the non-null one. Otherwise,\n\t * take ts1 as the lesser endpoint.\n\t */\n\tif (ts1IsNull)\n\t{\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\t/* swap null for non-null */\n\t\tts1 = te1;\n\t\tte1IsNull = true;\n\t}\n\telse if (!te1IsNull)\n\t{\n\t\tif (TIMESTAMP_GT(ts1, te1))\n\t\t{\n\t\t\tDatum\t\ttt = ts1;\n\n\t\t\tts1 = te1;\n\t\t\tte1 = tt;\n\t\t}\n\t}\n\n\t/* Likewise for interval 2. */\n\tif (ts2IsNull)\n\t{\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\t/* swap null for non-null */\n\t\tts2 = te2;\n\t\tte2IsNull = true;\n\t}\n\telse if (!te2IsNull)\n\t{\n\t\tif (TIMESTAMP_GT(ts2, te2))\n\t\t{\n\t\t\tDatum\t\ttt = ts2;\n\n\t\t\tts2 = te2;\n\t\t\tte2 = tt;\n\t\t}\n\t}\n\n\t/*\n\t * At this point neither ts1 nor ts2 is null, so we can consider three\n\t * cases: ts1 > ts2, ts1 < ts2, ts1 = ts2\n\t */\n\tif (TIMESTAMP_GT(ts1, ts2))\n\t{\n\t\t/*\n\t\t * This case is ts1 < te2 OR te1 < te2, which may look redundant but\n\t\t * in the presence of nulls it's not quite completely so.\n\t\t */\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tif (TIMESTAMP_LT(ts1, te2))\n\t\t\tPG_RETURN_BOOL(true);\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\n\t\t/*\n\t\t * If te1 is not null then we had ts1 <= te1 above, and we just found\n\t\t * ts1 >= te2, hence te1 >= te2.\n\t\t */\n\t\tPG_RETURN_BOOL(false);\n\t}\n\telse if (TIMESTAMP_LT(ts1, ts2))\n\t{\n\t\t/* This case is ts2 < te1 OR te2 < te1 */\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tif (TIMESTAMP_LT(ts2, te1))\n\t\t\tPG_RETURN_BOOL(true);\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\n\t\t/*\n\t\t * If te2 is not null then we had ts2 <= te2 above, and we just found\n\t\t * ts2 >= te1, hence te2 >= te1.\n\t\t */\n\t\tPG_RETURN_BOOL(false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For ts1 = ts2 the spec says te1 <> te2 OR te1 = te2, which is a\n\t\t * rather silly way of saying \"true if both are non-null, else null\".\n\t\t */\n\t\tif (te1IsNull || te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tPG_RETURN_BOOL(true);\n\t}\n\n#undef TIMESTAMP_GT\n#undef TIMESTAMP_LT\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_LT",
          "args": [
            "ts2",
            "te1"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_LT",
          "args": [
            "ts1",
            "ts2"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_LT",
          "args": [
            "ts1",
            "te2"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_GT",
          "args": [
            "ts1",
            "ts2"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_GT",
          "args": [
            "ts2",
            "te2"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_GT",
          "args": [
            "ts1",
            "te1"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "3"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "3"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "2"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noverlaps_timestamp(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * The arguments are Timestamps, but we leave them as generic Datums to\n\t * avoid unnecessary conversions between value and reference forms --- not\n\t * to mention possible dereferences of null pointers.\n\t */\n\tDatum\t\tts1 = PG_GETARG_DATUM(0);\n\tDatum\t\tte1 = PG_GETARG_DATUM(1);\n\tDatum\t\tts2 = PG_GETARG_DATUM(2);\n\tDatum\t\tte2 = PG_GETARG_DATUM(3);\n\tbool\t\tts1IsNull = PG_ARGISNULL(0);\n\tbool\t\tte1IsNull = PG_ARGISNULL(1);\n\tbool\t\tts2IsNull = PG_ARGISNULL(2);\n\tbool\t\tte2IsNull = PG_ARGISNULL(3);\n\n#define TIMESTAMP_GT(t1,t2) \\\n\tDatumGetBool(DirectFunctionCall2(timestamp_gt,t1,t2))\n#define TIMESTAMP_LT(t1,t2) \\\n\tDatumGetBool(DirectFunctionCall2(timestamp_lt,t1,t2))\n\n\t/*\n\t * If both endpoints of interval 1 are null, the result is null (unknown).\n\t * If just one endpoint is null, take ts1 as the non-null one. Otherwise,\n\t * take ts1 as the lesser endpoint.\n\t */\n\tif (ts1IsNull)\n\t{\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\t/* swap null for non-null */\n\t\tts1 = te1;\n\t\tte1IsNull = true;\n\t}\n\telse if (!te1IsNull)\n\t{\n\t\tif (TIMESTAMP_GT(ts1, te1))\n\t\t{\n\t\t\tDatum\t\ttt = ts1;\n\n\t\t\tts1 = te1;\n\t\t\tte1 = tt;\n\t\t}\n\t}\n\n\t/* Likewise for interval 2. */\n\tif (ts2IsNull)\n\t{\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\t/* swap null for non-null */\n\t\tts2 = te2;\n\t\tte2IsNull = true;\n\t}\n\telse if (!te2IsNull)\n\t{\n\t\tif (TIMESTAMP_GT(ts2, te2))\n\t\t{\n\t\t\tDatum\t\ttt = ts2;\n\n\t\t\tts2 = te2;\n\t\t\tte2 = tt;\n\t\t}\n\t}\n\n\t/*\n\t * At this point neither ts1 nor ts2 is null, so we can consider three\n\t * cases: ts1 > ts2, ts1 < ts2, ts1 = ts2\n\t */\n\tif (TIMESTAMP_GT(ts1, ts2))\n\t{\n\t\t/*\n\t\t * This case is ts1 < te2 OR te1 < te2, which may look redundant but\n\t\t * in the presence of nulls it's not quite completely so.\n\t\t */\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tif (TIMESTAMP_LT(ts1, te2))\n\t\t\tPG_RETURN_BOOL(true);\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\n\t\t/*\n\t\t * If te1 is not null then we had ts1 <= te1 above, and we just found\n\t\t * ts1 >= te2, hence te1 >= te2.\n\t\t */\n\t\tPG_RETURN_BOOL(false);\n\t}\n\telse if (TIMESTAMP_LT(ts1, ts2))\n\t{\n\t\t/* This case is ts2 < te1 OR te2 < te1 */\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tif (TIMESTAMP_LT(ts2, te1))\n\t\t\tPG_RETURN_BOOL(true);\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\n\t\t/*\n\t\t * If te2 is not null then we had ts2 <= te2 above, and we just found\n\t\t * ts2 >= te1, hence te2 >= te1.\n\t\t */\n\t\tPG_RETURN_BOOL(false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For ts1 = ts2 the spec says te1 <> te2 OR te1 = te2, which is a\n\t\t * rather silly way of saying \"true if both are non-null, else null\".\n\t\t */\n\t\tif (te1IsNull || te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tPG_RETURN_BOOL(true);\n\t}\n\n#undef TIMESTAMP_GT\n#undef TIMESTAMP_LT\n}"
  },
  {
    "function_name": "interval_hash_extended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2430-2442",
    "snippet": "Datum\ninterval_hash_extended(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval = PG_GETARG_INTERVAL_P(0);\n\tINT128\t\tspan = interval_cmp_value(interval);\n\tint64\t\tspan64;\n\n\t/* Same approach as interval_hash */\n\tspan64 = int128_to_int64(span);\n\n\treturn DirectFunctionCall2(hashint8extended, Int64GetDatumFast(span64),\n\t\t\t\t\t\t\t   PG_GETARG_DATUM(1));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "hashint8extended",
            "Int64GetDatumFast(span64)",
            "PG_GETARG_DATUM(1)"
          ],
          "line": 2440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatumFast",
          "args": [
            "span64"
          ],
          "line": 2440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int128_to_int64",
          "args": [
            "span"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval_cmp_value",
          "args": [
            "interval"
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2308-2331",
          "snippet": "static inline INT128\ninterval_cmp_value(const Interval *interval)\n{\n\tINT128\t\tspan;\n\tint64\t\tdayfraction;\n\tint64\t\tdays;\n\n\t/*\n\t * Separate time field into days and dayfraction, then add the month and\n\t * day fields to the days part.  We cannot overflow int64 days here.\n\t */\n\tdayfraction = interval->time % USECS_PER_DAY;\n\tdays = interval->time / USECS_PER_DAY;\n\tdays += interval->month * INT64CONST(30);\n\tdays += interval->day;\n\n\t/* Widen dayfraction to 128 bits */\n\tspan = int64_to_int128(dayfraction);\n\n\t/* Scale up days to microseconds, forming a 128-bit product */\n\tint128_add_int64_mul_int64(&span, days, USECS_PER_DAY);\n\n\treturn span;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic inline INT128\ninterval_cmp_value(const Interval *interval)\n{\n\tINT128\t\tspan;\n\tint64\t\tdayfraction;\n\tint64\t\tdays;\n\n\t/*\n\t * Separate time field into days and dayfraction, then add the month and\n\t * day fields to the days part.  We cannot overflow int64 days here.\n\t */\n\tdayfraction = interval->time % USECS_PER_DAY;\n\tdays = interval->time / USECS_PER_DAY;\n\tdays += interval->month * INT64CONST(30);\n\tdays += interval->day;\n\n\t/* Widen dayfraction to 128 bits */\n\tspan = int64_to_int128(dayfraction);\n\n\t/* Scale up days to microseconds, forming a 128-bit product */\n\tint128_add_int64_mul_int64(&span, days, USECS_PER_DAY);\n\n\treturn span;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_hash_extended(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval = PG_GETARG_INTERVAL_P(0);\n\tINT128\t\tspan = interval_cmp_value(interval);\n\tint64\t\tspan64;\n\n\t/* Same approach as interval_hash */\n\tspan64 = int128_to_int64(span);\n\n\treturn DirectFunctionCall2(hashint8extended, Int64GetDatumFast(span64),\n\t\t\t\t\t\t\t   PG_GETARG_DATUM(1));\n}"
  },
  {
    "function_name": "interval_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2412-2428",
    "snippet": "Datum\ninterval_hash(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval = PG_GETARG_INTERVAL_P(0);\n\tINT128\t\tspan = interval_cmp_value(interval);\n\tint64\t\tspan64;\n\n\t/*\n\t * Use only the least significant 64 bits for hashing.  The upper 64 bits\n\t * seldom add any useful information, and besides we must do it like this\n\t * for compatibility with hashes calculated before use of INT128 was\n\t * introduced.\n\t */\n\tspan64 = int128_to_int64(span);\n\n\treturn DirectFunctionCall1(hashint8, Int64GetDatumFast(span64));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "hashint8",
            "Int64GetDatumFast(span64)"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatumFast",
          "args": [
            "span64"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int128_to_int64",
          "args": [
            "span"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval_cmp_value",
          "args": [
            "interval"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2308-2331",
          "snippet": "static inline INT128\ninterval_cmp_value(const Interval *interval)\n{\n\tINT128\t\tspan;\n\tint64\t\tdayfraction;\n\tint64\t\tdays;\n\n\t/*\n\t * Separate time field into days and dayfraction, then add the month and\n\t * day fields to the days part.  We cannot overflow int64 days here.\n\t */\n\tdayfraction = interval->time % USECS_PER_DAY;\n\tdays = interval->time / USECS_PER_DAY;\n\tdays += interval->month * INT64CONST(30);\n\tdays += interval->day;\n\n\t/* Widen dayfraction to 128 bits */\n\tspan = int64_to_int128(dayfraction);\n\n\t/* Scale up days to microseconds, forming a 128-bit product */\n\tint128_add_int64_mul_int64(&span, days, USECS_PER_DAY);\n\n\treturn span;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic inline INT128\ninterval_cmp_value(const Interval *interval)\n{\n\tINT128\t\tspan;\n\tint64\t\tdayfraction;\n\tint64\t\tdays;\n\n\t/*\n\t * Separate time field into days and dayfraction, then add the month and\n\t * day fields to the days part.  We cannot overflow int64 days here.\n\t */\n\tdayfraction = interval->time % USECS_PER_DAY;\n\tdays = interval->time / USECS_PER_DAY;\n\tdays += interval->month * INT64CONST(30);\n\tdays += interval->day;\n\n\t/* Widen dayfraction to 128 bits */\n\tspan = int64_to_int128(dayfraction);\n\n\t/* Scale up days to microseconds, forming a 128-bit product */\n\tint128_add_int64_mul_int64(&span, days, USECS_PER_DAY);\n\n\treturn span;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 2415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_hash(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval = PG_GETARG_INTERVAL_P(0);\n\tINT128\t\tspan = interval_cmp_value(interval);\n\tint64\t\tspan64;\n\n\t/*\n\t * Use only the least significant 64 bits for hashing.  The upper 64 bits\n\t * seldom add any useful information, and besides we must do it like this\n\t * for compatibility with hashes calculated before use of INT128 was\n\t * introduced.\n\t */\n\tspan64 = int128_to_int64(span);\n\n\treturn DirectFunctionCall1(hashint8, Int64GetDatumFast(span64));\n}"
  },
  {
    "function_name": "interval_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2396-2403",
    "snippet": "Datum\ninterval_cmp(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\n\tPG_RETURN_INT32(interval_cmp_internal(interval1, interval2));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "interval_cmp_internal(interval1, interval2)"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval_cmp_internal",
          "args": [
            "interval1",
            "interval2"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2333-2340",
          "snippet": "static int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_cmp(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\n\tPG_RETURN_INT32(interval_cmp_internal(interval1, interval2));\n}"
  },
  {
    "function_name": "interval_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2387-2394",
    "snippet": "Datum\ninterval_ge(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\n\tPG_RETURN_BOOL(interval_cmp_internal(interval1, interval2) >= 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "interval_cmp_internal(interval1, interval2) >= 0"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval_cmp_internal",
          "args": [
            "interval1",
            "interval2"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2333-2340",
          "snippet": "static int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_ge(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\n\tPG_RETURN_BOOL(interval_cmp_internal(interval1, interval2) >= 0);\n}"
  },
  {
    "function_name": "interval_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2378-2385",
    "snippet": "Datum\ninterval_le(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\n\tPG_RETURN_BOOL(interval_cmp_internal(interval1, interval2) <= 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "interval_cmp_internal(interval1, interval2) <= 0"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval_cmp_internal",
          "args": [
            "interval1",
            "interval2"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2333-2340",
          "snippet": "static int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_le(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\n\tPG_RETURN_BOOL(interval_cmp_internal(interval1, interval2) <= 0);\n}"
  },
  {
    "function_name": "interval_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2369-2376",
    "snippet": "Datum\ninterval_gt(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\n\tPG_RETURN_BOOL(interval_cmp_internal(interval1, interval2) > 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "interval_cmp_internal(interval1, interval2) > 0"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval_cmp_internal",
          "args": [
            "interval1",
            "interval2"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2333-2340",
          "snippet": "static int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_gt(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\n\tPG_RETURN_BOOL(interval_cmp_internal(interval1, interval2) > 0);\n}"
  },
  {
    "function_name": "interval_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2360-2367",
    "snippet": "Datum\ninterval_lt(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\n\tPG_RETURN_BOOL(interval_cmp_internal(interval1, interval2) < 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "interval_cmp_internal(interval1, interval2) < 0"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval_cmp_internal",
          "args": [
            "interval1",
            "interval2"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2333-2340",
          "snippet": "static int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_lt(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\n\tPG_RETURN_BOOL(interval_cmp_internal(interval1, interval2) < 0);\n}"
  },
  {
    "function_name": "interval_ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2351-2358",
    "snippet": "Datum\ninterval_ne(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\n\tPG_RETURN_BOOL(interval_cmp_internal(interval1, interval2) != 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "interval_cmp_internal(interval1, interval2) != 0"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval_cmp_internal",
          "args": [
            "interval1",
            "interval2"
          ],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2333-2340",
          "snippet": "static int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_ne(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\n\tPG_RETURN_BOOL(interval_cmp_internal(interval1, interval2) != 0);\n}"
  },
  {
    "function_name": "interval_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2342-2349",
    "snippet": "Datum\ninterval_eq(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\n\tPG_RETURN_BOOL(interval_cmp_internal(interval1, interval2) == 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "interval_cmp_internal(interval1, interval2) == 0"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval_cmp_internal",
          "args": [
            "interval1",
            "interval2"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2333-2340",
          "snippet": "static int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_eq(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval1 = PG_GETARG_INTERVAL_P(0);\n\tInterval   *interval2 = PG_GETARG_INTERVAL_P(1);\n\n\tPG_RETURN_BOOL(interval_cmp_internal(interval1, interval2) == 0);\n}"
  },
  {
    "function_name": "interval_cmp_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2333-2340",
    "snippet": "static int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "int128_compare",
          "args": [
            "span1",
            "span2"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval_cmp_value",
          "args": [
            "interval2"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "interval_cmp_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2308-2331",
          "snippet": "static inline INT128\ninterval_cmp_value(const Interval *interval)\n{\n\tINT128\t\tspan;\n\tint64\t\tdayfraction;\n\tint64\t\tdays;\n\n\t/*\n\t * Separate time field into days and dayfraction, then add the month and\n\t * day fields to the days part.  We cannot overflow int64 days here.\n\t */\n\tdayfraction = interval->time % USECS_PER_DAY;\n\tdays = interval->time / USECS_PER_DAY;\n\tdays += interval->month * INT64CONST(30);\n\tdays += interval->day;\n\n\t/* Widen dayfraction to 128 bits */\n\tspan = int64_to_int128(dayfraction);\n\n\t/* Scale up days to microseconds, forming a 128-bit product */\n\tint128_add_int64_mul_int64(&span, days, USECS_PER_DAY);\n\n\treturn span;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic inline INT128\ninterval_cmp_value(const Interval *interval)\n{\n\tINT128\t\tspan;\n\tint64\t\tdayfraction;\n\tint64\t\tdays;\n\n\t/*\n\t * Separate time field into days and dayfraction, then add the month and\n\t * day fields to the days part.  We cannot overflow int64 days here.\n\t */\n\tdayfraction = interval->time % USECS_PER_DAY;\n\tdays = interval->time / USECS_PER_DAY;\n\tdays += interval->month * INT64CONST(30);\n\tdays += interval->day;\n\n\t/* Widen dayfraction to 128 bits */\n\tspan = int64_to_int128(dayfraction);\n\n\t/* Scale up days to microseconds, forming a 128-bit product */\n\tint128_add_int64_mul_int64(&span, days, USECS_PER_DAY);\n\n\treturn span;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninterval_cmp_internal(Interval *interval1, Interval *interval2)\n{\n\tINT128\t\tspan1 = interval_cmp_value(interval1);\n\tINT128\t\tspan2 = interval_cmp_value(interval2);\n\n\treturn int128_compare(span1, span2);\n}"
  },
  {
    "function_name": "interval_cmp_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2308-2331",
    "snippet": "static inline INT128\ninterval_cmp_value(const Interval *interval)\n{\n\tINT128\t\tspan;\n\tint64\t\tdayfraction;\n\tint64\t\tdays;\n\n\t/*\n\t * Separate time field into days and dayfraction, then add the month and\n\t * day fields to the days part.  We cannot overflow int64 days here.\n\t */\n\tdayfraction = interval->time % USECS_PER_DAY;\n\tdays = interval->time / USECS_PER_DAY;\n\tdays += interval->month * INT64CONST(30);\n\tdays += interval->day;\n\n\t/* Widen dayfraction to 128 bits */\n\tspan = int64_to_int128(dayfraction);\n\n\t/* Scale up days to microseconds, forming a 128-bit product */\n\tint128_add_int64_mul_int64(&span, days, USECS_PER_DAY);\n\n\treturn span;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "int128_add_int64_mul_int64",
          "args": [
            "&span",
            "days",
            "USECS_PER_DAY"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int64_to_int128",
          "args": [
            "dayfraction"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "30"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic inline INT128\ninterval_cmp_value(const Interval *interval)\n{\n\tINT128\t\tspan;\n\tint64\t\tdayfraction;\n\tint64\t\tdays;\n\n\t/*\n\t * Separate time field into days and dayfraction, then add the month and\n\t * day fields to the days part.  We cannot overflow int64 days here.\n\t */\n\tdayfraction = interval->time % USECS_PER_DAY;\n\tdays = interval->time / USECS_PER_DAY;\n\tdays += interval->month * INT64CONST(30);\n\tdays += interval->day;\n\n\t/* Widen dayfraction to 128 bits */\n\tspan = int64_to_int128(dayfraction);\n\n\t/* Scale up days to microseconds, forming a 128-bit product */\n\tint128_add_int64_mul_int64(&span, days, USECS_PER_DAY);\n\n\treturn span;\n}"
  },
  {
    "function_name": "timestamptz_cmp_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2285-2295",
    "snippet": "Datum\ntimestamptz_cmp_timestamp(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz dt2;\n\n\tdt2 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_INT32(timestamp_cmp_internal(dt1, dt2));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "timestamp_cmp_internal(dt1, dt2)"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2timestamptz",
          "args": [
            "timestampVal"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5089-5116",
          "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamptz_cmp_timestamp(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz dt2;\n\n\tdt2 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_INT32(timestamp_cmp_internal(dt1, dt2));\n}"
  },
  {
    "function_name": "timestamptz_ge_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2273-2283",
    "snippet": "Datum\ntimestamptz_ge_timestamp(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz dt2;\n\n\tdt2 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) >= 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) >= 0"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2282
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2timestamptz",
          "args": [
            "timestampVal"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5089-5116",
          "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamptz_ge_timestamp(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz dt2;\n\n\tdt2 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) >= 0);\n}"
  },
  {
    "function_name": "timestamptz_le_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2261-2271",
    "snippet": "Datum\ntimestamptz_le_timestamp(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz dt2;\n\n\tdt2 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) <= 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) <= 0"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2timestamptz",
          "args": [
            "timestampVal"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5089-5116",
          "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamptz_le_timestamp(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz dt2;\n\n\tdt2 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) <= 0);\n}"
  },
  {
    "function_name": "timestamptz_gt_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2249-2259",
    "snippet": "Datum\ntimestamptz_gt_timestamp(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz dt2;\n\n\tdt2 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) > 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) > 0"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2timestamptz",
          "args": [
            "timestampVal"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5089-5116",
          "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamptz_gt_timestamp(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz dt2;\n\n\tdt2 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) > 0);\n}"
  },
  {
    "function_name": "timestamptz_lt_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2237-2247",
    "snippet": "Datum\ntimestamptz_lt_timestamp(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz dt2;\n\n\tdt2 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) < 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) < 0"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2timestamptz",
          "args": [
            "timestampVal"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5089-5116",
          "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamptz_lt_timestamp(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz dt2;\n\n\tdt2 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) < 0);\n}"
  },
  {
    "function_name": "timestamptz_ne_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2225-2235",
    "snippet": "Datum\ntimestamptz_ne_timestamp(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz dt2;\n\n\tdt2 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) != 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) != 0"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2timestamptz",
          "args": [
            "timestampVal"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5089-5116",
          "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamptz_ne_timestamp(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz dt2;\n\n\tdt2 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) != 0);\n}"
  },
  {
    "function_name": "timestamptz_eq_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2213-2223",
    "snippet": "Datum\ntimestamptz_eq_timestamp(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz dt2;\n\n\tdt2 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) == 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) == 0"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2timestamptz",
          "args": [
            "timestampVal"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5089-5116",
          "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamptz_eq_timestamp(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(1);\n\tTimestampTz dt2;\n\n\tdt2 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) == 0);\n}"
  },
  {
    "function_name": "timestamp_cmp_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2201-2211",
    "snippet": "Datum\ntimestamp_cmp_timestamptz(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_INT32(timestamp_cmp_internal(dt1, dt2));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "timestamp_cmp_internal(dt1, dt2)"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2timestamptz",
          "args": [
            "timestampVal"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5089-5116",
          "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_cmp_timestamptz(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_INT32(timestamp_cmp_internal(dt1, dt2));\n}"
  },
  {
    "function_name": "timestamp_ge_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2189-2199",
    "snippet": "Datum\ntimestamp_ge_timestamptz(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) >= 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) >= 0"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2198
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2timestamptz",
          "args": [
            "timestampVal"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5089-5116",
          "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_ge_timestamptz(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) >= 0);\n}"
  },
  {
    "function_name": "timestamp_le_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2177-2187",
    "snippet": "Datum\ntimestamp_le_timestamptz(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) <= 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) <= 0"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2timestamptz",
          "args": [
            "timestampVal"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5089-5116",
          "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_le_timestamptz(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) <= 0);\n}"
  },
  {
    "function_name": "timestamp_gt_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2165-2175",
    "snippet": "Datum\ntimestamp_gt_timestamptz(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) > 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) > 0"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2timestamptz",
          "args": [
            "timestampVal"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5089-5116",
          "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_gt_timestamptz(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) > 0);\n}"
  },
  {
    "function_name": "timestamp_lt_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2153-2163",
    "snippet": "Datum\ntimestamp_lt_timestamptz(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) < 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) < 0"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2timestamptz",
          "args": [
            "timestampVal"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5089-5116",
          "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_lt_timestamptz(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) < 0);\n}"
  },
  {
    "function_name": "timestamp_ne_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2141-2151",
    "snippet": "Datum\ntimestamp_ne_timestamptz(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) != 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) != 0"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2timestamptz",
          "args": [
            "timestampVal"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5089-5116",
          "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_ne_timestamptz(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) != 0);\n}"
  },
  {
    "function_name": "timestamp_eq_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2129-2139",
    "snippet": "Datum\ntimestamp_eq_timestamptz(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) == 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) == 0"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2timestamptz",
          "args": [
            "timestampVal"
          ],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5089-5116",
          "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_eq_timestamptz(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestampVal = PG_GETARG_TIMESTAMP(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = timestamp2timestamptz(timestampVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) == 0);\n}"
  },
  {
    "function_name": "timestamp_hash_extended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2119-2123",
    "snippet": "Datum\ntimestamp_hash_extended(PG_FUNCTION_ARGS)\n{\n\treturn hashint8extended(fcinfo);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashint8extended",
          "args": [
            "fcinfo"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_hash_extended(PG_FUNCTION_ARGS)\n{\n\treturn hashint8extended(fcinfo);\n}"
  },
  {
    "function_name": "timestamp_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2113-2117",
    "snippet": "Datum\ntimestamp_hash(PG_FUNCTION_ARGS)\n{\n\treturn hashint8(fcinfo);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashint8",
          "args": [
            "fcinfo"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_hash(PG_FUNCTION_ARGS)\n{\n\treturn hashint8(fcinfo);\n}"
  },
  {
    "function_name": "timestamp_sortsupport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2104-2111",
    "snippet": "Datum\ntimestamp_sortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\n\tssup->comparator = timestamp_fastcmp;\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_sortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\n\tssup->comparator = timestamp_fastcmp;\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "timestamp_fastcmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2095-2102",
    "snippet": "static int\ntimestamp_fastcmp(Datum x, Datum y, SortSupport ssup)\n{\n\tTimestamp\ta = DatumGetTimestamp(x);\n\tTimestamp\tb = DatumGetTimestamp(y);\n\n\treturn timestamp_cmp_internal(a, b);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "a",
            "b"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetTimestamp",
          "args": [
            "y"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTimestamp",
          "args": [
            "x"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ntimestamp_fastcmp(Datum x, Datum y, SortSupport ssup)\n{\n\tTimestamp\ta = DatumGetTimestamp(x);\n\tTimestamp\tb = DatumGetTimestamp(y);\n\n\treturn timestamp_cmp_internal(a, b);\n}"
  },
  {
    "function_name": "timestamp_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2085-2092",
    "snippet": "Datum\ntimestamp_cmp(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\n\tPG_RETURN_INT32(timestamp_cmp_internal(dt1, dt2));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "timestamp_cmp_internal(dt1, dt2)"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_cmp(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\n\tPG_RETURN_INT32(timestamp_cmp_internal(dt1, dt2));\n}"
  },
  {
    "function_name": "timestamp_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2076-2083",
    "snippet": "Datum\ntimestamp_ge(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) >= 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) >= 0"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_ge(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) >= 0);\n}"
  },
  {
    "function_name": "timestamp_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2067-2074",
    "snippet": "Datum\ntimestamp_le(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) <= 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) <= 0"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_le(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) <= 0);\n}"
  },
  {
    "function_name": "timestamp_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2058-2065",
    "snippet": "Datum\ntimestamp_gt(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) > 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) > 0"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_gt(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) > 0);\n}"
  },
  {
    "function_name": "timestamp_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2049-2056",
    "snippet": "Datum\ntimestamp_lt(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) < 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) < 0"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_lt(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) < 0);\n}"
  },
  {
    "function_name": "timestamp_ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2040-2047",
    "snippet": "Datum\ntimestamp_ne(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) != 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) != 0"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_ne(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) != 0);\n}"
  },
  {
    "function_name": "timestamp_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2031-2038",
    "snippet": "Datum\ntimestamp_eq(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) == 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) == 0"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_eq(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) == 0);\n}"
  },
  {
    "function_name": "timestamp_cmp_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2025-2029",
    "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
  },
  {
    "function_name": "SetEpochTimestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "2005-2017",
    "snippet": "Timestamp\nSetEpochTimestamp(void)\n{\n\tTimestamp\tdt;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tGetEpochTime(tm);\n\t/* we don't bother to test for failure ... */\n\ttm2timestamp(tm, 0, NULL, &dt);\n\n\treturn dt;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tm2timestamp",
          "args": [
            "tm",
            "0",
            "NULL",
            "&dt"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1853-1895",
          "snippet": "int\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetEpochTime",
          "args": [
            "tm"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "GetEpochTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1983-2003",
          "snippet": "void\nGetEpochTime(struct pg_tm *tm)\n{\n\tstruct pg_tm *t0;\n\tpg_time_t\tepoch = 0;\n\n\tt0 = pg_gmtime(&epoch);\n\n\tif (t0 == NULL)\n\t\telog(ERROR, \"could not convert epoch to timestamp: %m\");\n\n\ttm->tm_year = t0->tm_year;\n\ttm->tm_mon = t0->tm_mon;\n\ttm->tm_mday = t0->tm_mday;\n\ttm->tm_hour = t0->tm_hour;\n\ttm->tm_min = t0->tm_min;\n\ttm->tm_sec = t0->tm_sec;\n\n\ttm->tm_year += 1900;\n\ttm->tm_mon++;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nvoid\nGetEpochTime(struct pg_tm *tm)\n{\n\tstruct pg_tm *t0;\n\tpg_time_t\tepoch = 0;\n\n\tt0 = pg_gmtime(&epoch);\n\n\tif (t0 == NULL)\n\t\telog(ERROR, \"could not convert epoch to timestamp: %m\");\n\n\ttm->tm_year = t0->tm_year;\n\ttm->tm_mon = t0->tm_mon;\n\ttm->tm_mday = t0->tm_mday;\n\ttm->tm_hour = t0->tm_hour;\n\ttm->tm_min = t0->tm_min;\n\ttm->tm_sec = t0->tm_sec;\n\n\ttm->tm_year += 1900;\n\ttm->tm_mon++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestamp\nSetEpochTimestamp(void)\n{\n\tTimestamp\tdt;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tGetEpochTime(tm);\n\t/* we don't bother to test for failure ... */\n\ttm2timestamp(tm, 0, NULL, &dt);\n\n\treturn dt;\n}"
  },
  {
    "function_name": "GetEpochTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1983-2003",
    "snippet": "void\nGetEpochTime(struct pg_tm *tm)\n{\n\tstruct pg_tm *t0;\n\tpg_time_t\tepoch = 0;\n\n\tt0 = pg_gmtime(&epoch);\n\n\tif (t0 == NULL)\n\t\telog(ERROR, \"could not convert epoch to timestamp: %m\");\n\n\ttm->tm_year = t0->tm_year;\n\ttm->tm_mon = t0->tm_mon;\n\ttm->tm_mday = t0->tm_mday;\n\ttm->tm_hour = t0->tm_hour;\n\ttm->tm_min = t0->tm_min;\n\ttm->tm_sec = t0->tm_sec;\n\n\ttm->tm_year += 1900;\n\ttm->tm_mon++;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not convert epoch to timestamp: %m\""
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_gmtime",
          "args": [
            "&epoch"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nvoid\nGetEpochTime(struct pg_tm *tm)\n{\n\tstruct pg_tm *t0;\n\tpg_time_t\tepoch = 0;\n\n\tt0 = pg_gmtime(&epoch);\n\n\tif (t0 == NULL)\n\t\telog(ERROR, \"could not convert epoch to timestamp: %m\");\n\n\ttm->tm_year = t0->tm_year;\n\ttm->tm_mon = t0->tm_mon;\n\ttm->tm_mday = t0->tm_mday;\n\ttm->tm_hour = t0->tm_hour;\n\ttm->tm_min = t0->tm_min;\n\ttm->tm_sec = t0->tm_sec;\n\n\ttm->tm_year += 1900;\n\ttm->tm_mon++;\n}"
  },
  {
    "function_name": "interval_finite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1972-1976",
    "snippet": "Datum\ninterval_finite(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(true);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_finite(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(true);\n}"
  },
  {
    "function_name": "timestamp_finite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1964-1970",
    "snippet": "Datum\ntimestamp_finite(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\n\tPG_RETURN_BOOL(!TIMESTAMP_NOT_FINITE(timestamp));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "!TIMESTAMP_NOT_FINITE(timestamp)"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamp_finite(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\n\tPG_RETURN_BOOL(!TIMESTAMP_NOT_FINITE(timestamp));\n}"
  },
  {
    "function_name": "dt2local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1951-1956",
    "snippet": "static Timestamp\ndt2local(Timestamp dt, int tz)\n{\n\tdt -= (tz * USECS_PER_SEC);\n\treturn dt;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Timestamp\ndt2local(Timestamp dt, int tz)\n{\n\tdt -= (tz * USECS_PER_SEC);\n\treturn dt;\n}"
  },
  {
    "function_name": "time2t",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1945-1949",
    "snippet": "static TimeOffset\ntime2t(const int hour, const int min, const int sec, const fsec_t fsec)\n{\n\treturn (((((hour * MINS_PER_HOUR) + min) * SECS_PER_MINUTE) + sec) * USECS_PER_SEC) + fsec;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nstatic TimeOffset\ntime2t(const int hour, const int min, const int sec, const fsec_t fsec)\n{\n\treturn (((((hour * MINS_PER_HOUR) + min) * SECS_PER_MINUTE) + sec) * USECS_PER_SEC) + fsec;\n}"
  },
  {
    "function_name": "tm2interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1929-1943",
    "snippet": "int\ntm2interval(struct pg_tm *tm, fsec_t fsec, Interval *span)\n{\n\tdouble\t\ttotal_months = (double) tm->tm_year * MONTHS_PER_YEAR + tm->tm_mon;\n\n\tif (total_months > INT_MAX || total_months < INT_MIN)\n\t\treturn -1;\n\tspan->month = total_months;\n\tspan->day = tm->tm_mday;\n\tspan->time = (((((tm->tm_hour * INT64CONST(60)) +\n\t\t\t\t\t tm->tm_min) * INT64CONST(60)) +\n\t\t\t\t   tm->tm_sec) * USECS_PER_SEC) + fsec;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "60"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "60"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2interval(struct pg_tm *tm, fsec_t fsec, Interval *span)\n{\n\tdouble\t\ttotal_months = (double) tm->tm_year * MONTHS_PER_YEAR + tm->tm_mon;\n\n\tif (total_months > INT_MAX || total_months < INT_MIN)\n\t\treturn -1;\n\tspan->month = total_months;\n\tspan->day = tm->tm_mday;\n\tspan->time = (((((tm->tm_hour * INT64CONST(60)) +\n\t\t\t\t\t tm->tm_min) * INT64CONST(60)) +\n\t\t\t\t   tm->tm_sec) * USECS_PER_SEC) + fsec;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "interval2tm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1901-1927",
    "snippet": "int\ninterval2tm(Interval span, struct pg_tm *tm, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\tTimeOffset\ttfrac;\n\n\ttm->tm_year = span.month / MONTHS_PER_YEAR;\n\ttm->tm_mon = span.month % MONTHS_PER_YEAR;\n\ttm->tm_mday = span.day;\n\ttime = span.time;\n\n\ttfrac = time / USECS_PER_HOUR;\n\ttime -= tfrac * USECS_PER_HOUR;\n\ttm->tm_hour = tfrac;\n\tif (!SAMESIGN(tm->tm_hour, tfrac))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\ttfrac = time / USECS_PER_MINUTE;\n\ttime -= tfrac * USECS_PER_MINUTE;\n\ttm->tm_min = tfrac;\n\ttfrac = time / USECS_PER_SEC;\n\t*fsec = time - (tfrac * USECS_PER_SEC);\n\ttm->tm_sec = tfrac;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"interval out of range\""
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAMESIGN",
          "args": [
            "tm->tm_hour",
            "tfrac"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ninterval2tm(Interval span, struct pg_tm *tm, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\tTimeOffset\ttfrac;\n\n\ttm->tm_year = span.month / MONTHS_PER_YEAR;\n\ttm->tm_mon = span.month % MONTHS_PER_YEAR;\n\ttm->tm_mday = span.day;\n\ttime = span.time;\n\n\ttfrac = time / USECS_PER_HOUR;\n\ttime -= tfrac * USECS_PER_HOUR;\n\ttm->tm_hour = tfrac;\n\tif (!SAMESIGN(tm->tm_hour, tfrac))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\ttfrac = time / USECS_PER_MINUTE;\n\ttime -= tfrac * USECS_PER_MINUTE;\n\ttm->tm_min = tfrac;\n\ttfrac = time / USECS_PER_SEC;\n\t*fsec = time - (tfrac * USECS_PER_SEC);\n\ttm->tm_sec = tfrac;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tm2timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1853-1895",
    "snippet": "int\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_VALID_TIMESTAMP",
          "args": [
            "*result"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt2local",
          "args": [
            "*result",
            "-(*tzp)"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "dt2local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1951-1956",
          "snippet": "static Timestamp\ndt2local(Timestamp dt, int tz)\n{\n\tdt -= (tz * USECS_PER_SEC);\n\treturn dt;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Timestamp\ndt2local(Timestamp dt, int tz)\n{\n\tdt -= (tz * USECS_PER_SEC);\n\treturn dt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time2t",
          "args": [
            "tm->tm_hour",
            "tm->tm_min",
            "tm->tm_sec",
            "fsec"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "time2t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1945-1949",
          "snippet": "static TimeOffset\ntime2t(const int hour, const int min, const int sec, const fsec_t fsec)\n{\n\treturn (((((hour * MINS_PER_HOUR) + min) * SECS_PER_MINUTE) + sec) * USECS_PER_SEC) + fsec;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nstatic TimeOffset\ntime2t(const int hour, const int min, const int sec, const fsec_t fsec)\n{\n\treturn (((((hour * MINS_PER_HOUR) + min) * SECS_PER_MINUTE) + sec) * USECS_PER_SEC) + fsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_JULIAN",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "timestamp2tm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1757-1843",
    "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static Timestamp dt2local(Timestamp dt, int timezone);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_localtime",
          "args": [
            "&utime",
            "attimezone"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt2time",
          "args": [
            "time",
            "&tm->tm_hour",
            "&tm->tm_min",
            "&tm->tm_sec",
            "fsec"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "dt2time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1730-1743",
          "snippet": "void\ndt2time(Timestamp jd, int *hour, int *min, int *sec, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\n\ttime = jd;\n\n\t*hour = time / USECS_PER_HOUR;\n\ttime -= (*hour) * USECS_PER_HOUR;\n\t*min = time / USECS_PER_MINUTE;\n\ttime -= (*min) * USECS_PER_MINUTE;\n\t*sec = time / USECS_PER_SEC;\n\t*fsec = time - (*sec * USECS_PER_SEC);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nvoid\ndt2time(Timestamp jd, int *hour, int *min, int *sec, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\n\ttime = jd;\n\n\t*hour = time / USECS_PER_HOUR;\n\ttime -= (*hour) * USECS_PER_HOUR;\n\t*min = time / USECS_PER_MINUTE;\n\ttime -= (*min) * USECS_PER_MINUTE;\n\t*sec = time / USECS_PER_SEC;\n\t*fsec = time - (*sec * USECS_PER_SEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "j2date",
          "args": [
            "(int) date",
            "&tm->tm_year",
            "&tm->tm_mon",
            "&tm->tm_mday"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "j2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "300-325",
          "snippet": "void\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TMODULO",
          "args": [
            "time",
            "date",
            "USECS_PER_DAY"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dt2time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1730-1743",
    "snippet": "void\ndt2time(Timestamp jd, int *hour, int *min, int *sec, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\n\ttime = jd;\n\n\t*hour = time / USECS_PER_HOUR;\n\ttime -= (*hour) * USECS_PER_HOUR;\n\t*min = time / USECS_PER_MINUTE;\n\ttime -= (*min) * USECS_PER_MINUTE;\n\t*sec = time / USECS_PER_SEC;\n\t*fsec = time - (*sec * USECS_PER_SEC);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nvoid\ndt2time(Timestamp jd, int *hour, int *min, int *sec, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\n\ttime = jd;\n\n\t*hour = time / USECS_PER_HOUR;\n\ttime -= (*hour) * USECS_PER_HOUR;\n\t*min = time / USECS_PER_MINUTE;\n\ttime -= (*min) * USECS_PER_MINUTE;\n\t*sec = time / USECS_PER_SEC;\n\t*fsec = time - (*sec * USECS_PER_SEC);\n}"
  },
  {
    "function_name": "timestamptz_to_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1709-1727",
    "snippet": "const char *\ntimestamptz_to_str(TimestampTz t)\n{\n\tstatic char buf[MAXDATELEN + 1];\n\tint\t\t\ttz;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tconst char *tzn;\n\n\tif (TIMESTAMP_NOT_FINITE(t))\n\t\tEncodeSpecialTimestamp(t, buf);\n\telse if (timestamp2tm(t, &tz, tm, &fsec, &tzn, NULL) == 0)\n\t\tEncodeDateTime(tm, fsec, true, tz, tzn, USE_ISO_DATES, buf);\n\telse\n\t\tstrlcpy(buf, \"(timestamp out of range)\", sizeof(buf));\n\n\treturn buf;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "buf",
            "\"(timestamp out of range)\"",
            "sizeof(buf)"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_safe_strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ascii.c",
          "lines": "172-198",
          "snippet": "void\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/ascii.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/ascii.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeDateTime",
          "args": [
            "tm",
            "fsec",
            "true",
            "tz",
            "tzn",
            "USE_ISO_DATES",
            "buf"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3987-4149",
          "snippet": "void\nEncodeDateTime(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str)\n{\n\tint\t\t\tday;\n\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\t/*\n\t * Negative tm_isdst means we have no valid time zone translation.\n\t */\n\tif (tm->tm_isdst < 0)\n\t\tprint_tz = false;\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* Compatible with ISO-8601 date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = (style == USE_ISO_DATES) ? ' ' : 'T';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\tif (print_tz)\n\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* Compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\t/*\n\t\t\t * Note: the uses of %.*s in this function would be risky if the\n\t\t\t * timezone names ever contain non-ASCII characters.  However, all\n\t\t\t * TZ abbreviations in the IANA database are plain ASCII.\n\t\t\t */\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German variant on European style */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* Backward-compatible with traditional Postgres abstime dates */\n\t\t\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\ttm->tm_wday = j2day(day);\n\t\t\tmemcpy(str, days[tm->tm_wday], 3);\n\t\t\tstr += 3;\n\t\t\t*str++ = ' ';\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = ' ';\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t\t*str++ = ' ';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We have a time zone, but no string version. Use the\n\t\t\t\t\t * numeric form, but be sure to include a leading space to\n\t\t\t\t\t * avoid formatting something which would be rejected by\n\t\t\t\t\t * the date/time parser later. - thomas 2001-10-19\n\t\t\t\t\t */\n\t\t\t\t\t*str++ = ' ';\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "const char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};",
            "const char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nconst char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};\nconst char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};\n\nvoid\nEncodeDateTime(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str)\n{\n\tint\t\t\tday;\n\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\t/*\n\t * Negative tm_isdst means we have no valid time zone translation.\n\t */\n\tif (tm->tm_isdst < 0)\n\t\tprint_tz = false;\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* Compatible with ISO-8601 date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = (style == USE_ISO_DATES) ? ' ' : 'T';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\tif (print_tz)\n\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* Compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\t/*\n\t\t\t * Note: the uses of %.*s in this function would be risky if the\n\t\t\t * timezone names ever contain non-ASCII characters.  However, all\n\t\t\t * TZ abbreviations in the IANA database are plain ASCII.\n\t\t\t */\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German variant on European style */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* Backward-compatible with traditional Postgres abstime dates */\n\t\t\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\ttm->tm_wday = j2day(day);\n\t\t\tmemcpy(str, days[tm->tm_wday], 3);\n\t\t\tstr += 3;\n\t\t\t*str++ = ' ';\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = ' ';\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t\t*str++ = ' ';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We have a time zone, but no string version. Use the\n\t\t\t\t\t * numeric form, but be sure to include a leading space to\n\t\t\t\t\t * avoid formatting something which would be rejected by\n\t\t\t\t\t * the date/time parser later. - thomas 2001-10-19\n\t\t\t\t\t */\n\t\t\t\t\t*str++ = ' ';\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "t",
            "&tz",
            "tm",
            "&fsec",
            "&tzn",
            "NULL"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeSpecialTimestamp",
          "args": [
            "t",
            "buf"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeSpecialTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1522-1531",
          "snippet": "void\nEncodeSpecialTimestamp(Timestamp dt, char *str)\n{\n\tif (TIMESTAMP_IS_NOBEGIN(dt))\n\t\tstrcpy(str, EARLY);\n\telse if (TIMESTAMP_IS_NOEND(dt))\n\t\tstrcpy(str, LATE);\n\telse\t\t\t\t\t\t/* shouldn't happen */\n\t\telog(ERROR, \"invalid argument for EncodeSpecialTimestamp\");\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nEncodeSpecialTimestamp(Timestamp dt, char *str)\n{\n\tif (TIMESTAMP_IS_NOBEGIN(dt))\n\t\tstrcpy(str, EARLY);\n\telse if (TIMESTAMP_IS_NOEND(dt))\n\t\tstrcpy(str, LATE);\n\telse\t\t\t\t\t\t/* shouldn't happen */\n\t\telog(ERROR, \"invalid argument for EncodeSpecialTimestamp\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "t"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nconst char *\ntimestamptz_to_str(TimestampTz t)\n{\n\tstatic char buf[MAXDATELEN + 1];\n\tint\t\t\ttz;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tconst char *tzn;\n\n\tif (TIMESTAMP_NOT_FINITE(t))\n\t\tEncodeSpecialTimestamp(t, buf);\n\telse if (timestamp2tm(t, &tz, tm, &fsec, &tzn, NULL) == 0)\n\t\tEncodeDateTime(tm, fsec, true, tz, tzn, USE_ISO_DATES, buf);\n\telse\n\t\tstrlcpy(buf, \"(timestamp out of range)\", sizeof(buf));\n\n\treturn buf;\n}"
  },
  {
    "function_name": "timestamptz_to_time_t",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1691-1700",
    "snippet": "pg_time_t\ntimestamptz_to_time_t(TimestampTz t)\n{\n\tpg_time_t\tresult;\n\n\tresult = (pg_time_t) (t / USECS_PER_SEC +\n\t\t\t\t\t\t  ((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY));\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "t / USECS_PER_SEC +\n\t\t\t\t\t\t  ((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY)"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\npg_time_t\ntimestamptz_to_time_t(TimestampTz t)\n{\n\tpg_time_t\tresult;\n\n\tresult = (pg_time_t) (t / USECS_PER_SEC +\n\t\t\t\t\t\t  ((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY));\n\n\treturn result;\n}"
  },
  {
    "function_name": "time_t_to_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1669-1679",
    "snippet": "TimestampTz\ntime_t_to_timestamptz(pg_time_t tm)\n{\n\tTimestampTz result;\n\n\tresult = (TimestampTz) tm -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult *= USECS_PER_SEC;\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestampTz\ntime_t_to_timestamptz(pg_time_t tm)\n{\n\tTimestampTz result;\n\n\tresult = (TimestampTz) tm -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult *= USECS_PER_SEC;\n\n\treturn result;\n}"
  },
  {
    "function_name": "TimestampDifferenceExceeds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1648-1656",
    "snippet": "bool\nTimestampDifferenceExceeds(TimestampTz start_time,\n\t\t\t\t\t\t   TimestampTz stop_time,\n\t\t\t\t\t\t   int msec)\n{\n\tTimestampTz diff = stop_time - start_time;\n\n\treturn (diff >= msec * INT64CONST(1000));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "1000"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\nTimestampDifferenceExceeds(TimestampTz start_time,\n\t\t\t\t\t\t   TimestampTz stop_time,\n\t\t\t\t\t\t   int msec)\n{\n\tTimestampTz diff = stop_time - start_time;\n\n\treturn (diff >= msec * INT64CONST(1000));\n}"
  },
  {
    "function_name": "TimestampDifference",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1623-1639",
    "snippet": "void\nTimestampDifference(TimestampTz start_time, TimestampTz stop_time,\n\t\t\t\t\tlong *secs, int *microsecs)\n{\n\tTimestampTz diff = stop_time - start_time;\n\n\tif (diff <= 0)\n\t{\n\t\t*secs = 0;\n\t\t*microsecs = 0;\n\t}\n\telse\n\t{\n\t\t*secs = (long) (diff / USECS_PER_SEC);\n\t\t*microsecs = (int) (diff % USECS_PER_SEC);\n\t}\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nTimestampDifference(TimestampTz start_time, TimestampTz stop_time,\n\t\t\t\t\tlong *secs, int *microsecs)\n{\n\tTimestampTz diff = stop_time - start_time;\n\n\tif (diff <= 0)\n\t{\n\t\t*secs = 0;\n\t\t*microsecs = 0;\n\t}\n\telse\n\t{\n\t\t*secs = (long) (diff / USECS_PER_SEC);\n\t\t*microsecs = (int) (diff % USECS_PER_SEC);\n\t}\n}"
  },
  {
    "function_name": "GetSQLLocalTimestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1601-1610",
    "snippet": "Timestamp\nGetSQLLocalTimestamp(int32 typmod)\n{\n\tTimestamp\tts;\n\n\tts = timestamptz2timestamp(GetCurrentTransactionStartTimestamp());\n\tif (typmod >= 0)\n\t\tAdjustTimestampForTypmod(&ts, typmod);\n\treturn ts;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdjustTimestampForTypmod",
          "args": [
            "&ts",
            "typmod"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustTimestampForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "333-376",
          "snippet": "static void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
            "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamptz2timestamp",
          "args": [
            "GetCurrentTransactionStartTimestamp()"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "timestamptz2timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5129-5152",
          "snippet": "static Timestamp\ntimestamptz2timestamp(TimestampTz timestamp)\n{\n\tTimestamp\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic Timestamp\ntimestamptz2timestamp(TimestampTz timestamp)\n{\n\tTimestamp\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentTransactionStartTimestamp",
          "args": [],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nTimestamp\nGetSQLLocalTimestamp(int32 typmod)\n{\n\tTimestamp\tts;\n\n\tts = timestamptz2timestamp(GetCurrentTransactionStartTimestamp());\n\tif (typmod >= 0)\n\t\tAdjustTimestampForTypmod(&ts, typmod);\n\treturn ts;\n}"
  },
  {
    "function_name": "GetSQLCurrentTimestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1587-1596",
    "snippet": "TimestampTz\nGetSQLCurrentTimestamp(int32 typmod)\n{\n\tTimestampTz ts;\n\n\tts = GetCurrentTransactionStartTimestamp();\n\tif (typmod >= 0)\n\t\tAdjustTimestampForTypmod(&ts, typmod);\n\treturn ts;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdjustTimestampForTypmod",
          "args": [
            "&ts",
            "typmod"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustTimestampForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "333-376",
          "snippet": "static void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
            "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentTransactionStartTimestamp",
          "args": [],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nTimestampTz\nGetSQLCurrentTimestamp(int32 typmod)\n{\n\tTimestampTz ts;\n\n\tts = GetCurrentTransactionStartTimestamp();\n\tif (typmod >= 0)\n\t\tAdjustTimestampForTypmod(&ts, typmod);\n\treturn ts;\n}"
  },
  {
    "function_name": "GetCurrentTimestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1569-1582",
    "snippet": "TimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gettimeofday",
          "args": [
            "&tp",
            "NULL"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}"
  },
  {
    "function_name": "pg_conf_load_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1557-1561",
    "snippet": "Datum\npg_conf_load_time(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TIMESTAMPTZ(PgReloadTime);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "TimestampTz PgReloadTime;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "PgReloadTime"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestampTz PgReloadTime;\n\nDatum\npg_conf_load_time(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TIMESTAMPTZ(PgReloadTime);\n}"
  },
  {
    "function_name": "pg_postmaster_start_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1551-1555",
    "snippet": "Datum\npg_postmaster_start_time(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TIMESTAMPTZ(PgStartTime);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "TimestampTz PgStartTime;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "PgStartTime"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestampTz PgStartTime;\n\nDatum\npg_postmaster_start_time(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TIMESTAMPTZ(PgStartTime);\n}"
  },
  {
    "function_name": "clock_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1545-1549",
    "snippet": "Datum\nclock_timestamp(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TIMESTAMPTZ(GetCurrentTimestamp());\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "GetCurrentTimestamp()"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentTimestamp",
          "args": [],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurrentTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1569-1582",
          "snippet": "TimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nclock_timestamp(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TIMESTAMPTZ(GetCurrentTimestamp());\n}"
  },
  {
    "function_name": "statement_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1539-1543",
    "snippet": "Datum\nstatement_timestamp(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TIMESTAMPTZ(GetCurrentStatementStartTimestamp());\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "GetCurrentStatementStartTimestamp()"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentStatementStartTimestamp",
          "args": [],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nstatement_timestamp(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TIMESTAMPTZ(GetCurrentStatementStartTimestamp());\n}"
  },
  {
    "function_name": "now",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1533-1537",
    "snippet": "Datum\nnow(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TIMESTAMPTZ(GetCurrentTransactionStartTimestamp());\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "GetCurrentTransactionStartTimestamp()"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentTransactionStartTimestamp",
          "args": [],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nnow(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TIMESTAMPTZ(GetCurrentTransactionStartTimestamp());\n}"
  },
  {
    "function_name": "EncodeSpecialTimestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1522-1531",
    "snippet": "void\nEncodeSpecialTimestamp(Timestamp dt, char *str)\n{\n\tif (TIMESTAMP_IS_NOBEGIN(dt))\n\t\tstrcpy(str, EARLY);\n\telse if (TIMESTAMP_IS_NOEND(dt))\n\t\tstrcpy(str, LATE);\n\telse\t\t\t\t\t\t/* shouldn't happen */\n\t\telog(ERROR, \"invalid argument for EncodeSpecialTimestamp\");\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid argument for EncodeSpecialTimestamp\""
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "str",
            "LATE"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_IS_NOEND",
          "args": [
            "dt"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_IS_NOBEGIN",
          "args": [
            "dt"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nEncodeSpecialTimestamp(Timestamp dt, char *str)\n{\n\tif (TIMESTAMP_IS_NOBEGIN(dt))\n\t\tstrcpy(str, EARLY);\n\telse if (TIMESTAMP_IS_NOEND(dt))\n\t\tstrcpy(str, LATE);\n\telse\t\t\t\t\t\t/* shouldn't happen */\n\t\telog(ERROR, \"invalid argument for EncodeSpecialTimestamp\");\n}"
  },
  {
    "function_name": "make_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1486-1517",
    "snippet": "Datum\nmake_interval(PG_FUNCTION_ARGS)\n{\n\tint32\t\tyears = PG_GETARG_INT32(0);\n\tint32\t\tmonths = PG_GETARG_INT32(1);\n\tint32\t\tweeks = PG_GETARG_INT32(2);\n\tint32\t\tdays = PG_GETARG_INT32(3);\n\tint32\t\thours = PG_GETARG_INT32(4);\n\tint32\t\tmins = PG_GETARG_INT32(5);\n\tdouble\t\tsecs = PG_GETARG_FLOAT8(6);\n\tInterval   *result;\n\n\t/*\n\t * Reject out-of-range inputs.  We really ought to check the integer\n\t * inputs as well, but it's not entirely clear what limits to apply.\n\t */\n\tif (isinf(secs) || isnan(secs))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\tresult->month = years * MONTHS_PER_YEAR + months;\n\tresult->day = weeks * 7 + days;\n\n\tsecs = rint(secs * USECS_PER_SEC);\n\tresult->time = hours * ((int64) SECS_PER_HOUR * USECS_PER_SEC) +\n\t\tmins * ((int64) SECS_PER_MINUTE * USECS_PER_SEC) +\n\t\t(int64) secs;\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "secs * USECS_PER_SEC"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"interval out of range\""
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "secs"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "secs"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "6"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "5"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "4"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nmake_interval(PG_FUNCTION_ARGS)\n{\n\tint32\t\tyears = PG_GETARG_INT32(0);\n\tint32\t\tmonths = PG_GETARG_INT32(1);\n\tint32\t\tweeks = PG_GETARG_INT32(2);\n\tint32\t\tdays = PG_GETARG_INT32(3);\n\tint32\t\thours = PG_GETARG_INT32(4);\n\tint32\t\tmins = PG_GETARG_INT32(5);\n\tdouble\t\tsecs = PG_GETARG_FLOAT8(6);\n\tInterval   *result;\n\n\t/*\n\t * Reject out-of-range inputs.  We really ought to check the integer\n\t * inputs as well, but it's not entirely clear what limits to apply.\n\t */\n\tif (isinf(secs) || isnan(secs))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\tresult->month = years * MONTHS_PER_YEAR + months;\n\tresult->day = weeks * 7 + days;\n\n\tsecs = rint(secs * USECS_PER_SEC);\n\tresult->time = hours * ((int64) SECS_PER_HOUR * USECS_PER_SEC) +\n\t\tmins * ((int64) SECS_PER_MINUTE * USECS_PER_SEC) +\n\t\t(int64) secs;\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "AdjustIntervalForTypmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1319-1481",
    "snippet": "static void\nAdjustIntervalForTypmod(Interval *interval, int32 typmod)\n{\n\tstatic const int64 IntervalScales[MAX_INTERVAL_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 IntervalOffsets[MAX_INTERVAL_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\t/*\n\t * Unspecified range and precision? Then not necessary to adjust. Setting\n\t * typmod to -1 is the convention for all data types.\n\t */\n\tif (typmod >= 0)\n\t{\n\t\tint\t\t\trange = INTERVAL_RANGE(typmod);\n\t\tint\t\t\tprecision = INTERVAL_PRECISION(typmod);\n\n\t\t/*\n\t\t * Our interpretation of intervals with a limited set of fields is\n\t\t * that fields to the right of the last one specified are zeroed out,\n\t\t * but those to the left of it remain valid.  Thus for example there\n\t\t * is no operational difference between INTERVAL YEAR TO MONTH and\n\t\t * INTERVAL MONTH.  In some cases we could meaningfully enforce that\n\t\t * higher-order fields are zero; for example INTERVAL DAY could reject\n\t\t * nonzero \"month\" field.  However that seems a bit pointless when we\n\t\t * can't do it consistently.  (We cannot enforce a range limit on the\n\t\t * highest expected field, since we do not have any equivalent of\n\t\t * SQL's <interval leading field precision>.)  If we ever decide to\n\t\t * revisit this, interval_transform will likely require adjusting.\n\t\t *\n\t\t * Note: before PG 8.4 we interpreted a limited set of fields as\n\t\t * actually causing a \"modulo\" operation on a given value, potentially\n\t\t * losing high-order as well as low-order information.  But there is\n\t\t * no support for such behavior in the standard, and it seems fairly\n\t\t * undesirable on data consistency grounds anyway.  Now we only\n\t\t * perform truncation or rounding of low-order fields.\n\t\t */\n\t\tif (range == INTERVAL_FULL_RANGE)\n\t\t{\n\t\t\t/* Do nothing... */\n\t\t}\n\t\telse if (range == INTERVAL_MASK(YEAR))\n\t\t{\n\t\t\tinterval->month = (interval->month / MONTHS_PER_YEAR) * MONTHS_PER_YEAR;\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(MONTH))\n\t\t{\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\t/* YEAR TO MONTH */\n\t\telse if (range == (INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH)))\n\t\t{\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(DAY))\n\t\t{\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(HOUR))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_HOUR) *\n\t\t\t\tUSECS_PER_HOUR;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(MINUTE))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(SECOND))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* DAY TO HOUR */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_HOUR) *\n\t\t\t\tUSECS_PER_HOUR;\n\t\t}\n\t\t/* DAY TO MINUTE */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\t/* DAY TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* HOUR TO MINUTE */\n\t\telse if (range == (INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\t/* HOUR TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* MINUTE TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unrecognized interval typmod: %d\", typmod);\n\n\t\t/* Need to adjust sub-second precision? */\n\t\tif (precision != INTERVAL_FULL_PRECISION)\n\t\t{\n\t\t\tif (precision < 0 || precision > MAX_INTERVAL_PRECISION)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"interval(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\t\tprecision, 0, MAX_INTERVAL_PRECISION)));\n\n\t\t\tif (interval->time >= INT64CONST(0))\n\t\t\t{\n\t\t\t\tinterval->time = ((interval->time +\n\t\t\t\t\t\t\t\t   IntervalOffsets[precision]) /\n\t\t\t\t\t\t\t\t  IntervalScales[precision]) *\n\t\t\t\t\tIntervalScales[precision];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinterval->time = -(((-interval->time +\n\t\t\t\t\t\t\t\t\t IntervalOffsets[precision]) /\n\t\t\t\t\t\t\t\t\tIntervalScales[precision]) *\n\t\t\t\t\t\t\t\t   IntervalScales[precision]);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"interval(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\t\tprecision, 0, MAX_INTERVAL_PRECISION))"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"interval(%d) precision must be between %d and %d\"",
            "precision",
            "0",
            "MAX_INTERVAL_PRECISION"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized interval typmod: %d\"",
            "typmod"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MONTH"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "YEAR"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MONTH"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "YEAR"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_PRECISION",
          "args": [
            "typmod"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_RANGE",
          "args": [
            "typmod"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "5"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "50"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "500"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "5000"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "50000"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "500000"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "1"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "10"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "100"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "1000"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "10000"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "100000"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "1000000"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nstatic void\nAdjustIntervalForTypmod(Interval *interval, int32 typmod)\n{\n\tstatic const int64 IntervalScales[MAX_INTERVAL_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 IntervalOffsets[MAX_INTERVAL_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\t/*\n\t * Unspecified range and precision? Then not necessary to adjust. Setting\n\t * typmod to -1 is the convention for all data types.\n\t */\n\tif (typmod >= 0)\n\t{\n\t\tint\t\t\trange = INTERVAL_RANGE(typmod);\n\t\tint\t\t\tprecision = INTERVAL_PRECISION(typmod);\n\n\t\t/*\n\t\t * Our interpretation of intervals with a limited set of fields is\n\t\t * that fields to the right of the last one specified are zeroed out,\n\t\t * but those to the left of it remain valid.  Thus for example there\n\t\t * is no operational difference between INTERVAL YEAR TO MONTH and\n\t\t * INTERVAL MONTH.  In some cases we could meaningfully enforce that\n\t\t * higher-order fields are zero; for example INTERVAL DAY could reject\n\t\t * nonzero \"month\" field.  However that seems a bit pointless when we\n\t\t * can't do it consistently.  (We cannot enforce a range limit on the\n\t\t * highest expected field, since we do not have any equivalent of\n\t\t * SQL's <interval leading field precision>.)  If we ever decide to\n\t\t * revisit this, interval_transform will likely require adjusting.\n\t\t *\n\t\t * Note: before PG 8.4 we interpreted a limited set of fields as\n\t\t * actually causing a \"modulo\" operation on a given value, potentially\n\t\t * losing high-order as well as low-order information.  But there is\n\t\t * no support for such behavior in the standard, and it seems fairly\n\t\t * undesirable on data consistency grounds anyway.  Now we only\n\t\t * perform truncation or rounding of low-order fields.\n\t\t */\n\t\tif (range == INTERVAL_FULL_RANGE)\n\t\t{\n\t\t\t/* Do nothing... */\n\t\t}\n\t\telse if (range == INTERVAL_MASK(YEAR))\n\t\t{\n\t\t\tinterval->month = (interval->month / MONTHS_PER_YEAR) * MONTHS_PER_YEAR;\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(MONTH))\n\t\t{\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\t/* YEAR TO MONTH */\n\t\telse if (range == (INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH)))\n\t\t{\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(DAY))\n\t\t{\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(HOUR))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_HOUR) *\n\t\t\t\tUSECS_PER_HOUR;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(MINUTE))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(SECOND))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* DAY TO HOUR */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_HOUR) *\n\t\t\t\tUSECS_PER_HOUR;\n\t\t}\n\t\t/* DAY TO MINUTE */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\t/* DAY TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* HOUR TO MINUTE */\n\t\telse if (range == (INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\t/* HOUR TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* MINUTE TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unrecognized interval typmod: %d\", typmod);\n\n\t\t/* Need to adjust sub-second precision? */\n\t\tif (precision != INTERVAL_FULL_PRECISION)\n\t\t{\n\t\t\tif (precision < 0 || precision > MAX_INTERVAL_PRECISION)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"interval(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\t\tprecision, 0, MAX_INTERVAL_PRECISION)));\n\n\t\t\tif (interval->time >= INT64CONST(0))\n\t\t\t{\n\t\t\t\tinterval->time = ((interval->time +\n\t\t\t\t\t\t\t\t   IntervalOffsets[precision]) /\n\t\t\t\t\t\t\t\t  IntervalScales[precision]) *\n\t\t\t\t\tIntervalScales[precision];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinterval->time = -(((-interval->time +\n\t\t\t\t\t\t\t\t\t IntervalOffsets[precision]) /\n\t\t\t\t\t\t\t\t\tIntervalScales[precision]) *\n\t\t\t\t\t\t\t\t   IntervalScales[precision]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "interval_scale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1300-1313",
    "snippet": "Datum\ninterval_scale(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval = PG_GETARG_INTERVAL_P(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tInterval   *result;\n\n\tresult = palloc(sizeof(Interval));\n\t*result = *interval;\n\n\tAdjustIntervalForTypmod(result, typmod);\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustIntervalForTypmod",
          "args": [
            "result",
            "typmod"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustIntervalForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1319-1481",
          "snippet": "static void\nAdjustIntervalForTypmod(Interval *interval, int32 typmod)\n{\n\tstatic const int64 IntervalScales[MAX_INTERVAL_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 IntervalOffsets[MAX_INTERVAL_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\t/*\n\t * Unspecified range and precision? Then not necessary to adjust. Setting\n\t * typmod to -1 is the convention for all data types.\n\t */\n\tif (typmod >= 0)\n\t{\n\t\tint\t\t\trange = INTERVAL_RANGE(typmod);\n\t\tint\t\t\tprecision = INTERVAL_PRECISION(typmod);\n\n\t\t/*\n\t\t * Our interpretation of intervals with a limited set of fields is\n\t\t * that fields to the right of the last one specified are zeroed out,\n\t\t * but those to the left of it remain valid.  Thus for example there\n\t\t * is no operational difference between INTERVAL YEAR TO MONTH and\n\t\t * INTERVAL MONTH.  In some cases we could meaningfully enforce that\n\t\t * higher-order fields are zero; for example INTERVAL DAY could reject\n\t\t * nonzero \"month\" field.  However that seems a bit pointless when we\n\t\t * can't do it consistently.  (We cannot enforce a range limit on the\n\t\t * highest expected field, since we do not have any equivalent of\n\t\t * SQL's <interval leading field precision>.)  If we ever decide to\n\t\t * revisit this, interval_transform will likely require adjusting.\n\t\t *\n\t\t * Note: before PG 8.4 we interpreted a limited set of fields as\n\t\t * actually causing a \"modulo\" operation on a given value, potentially\n\t\t * losing high-order as well as low-order information.  But there is\n\t\t * no support for such behavior in the standard, and it seems fairly\n\t\t * undesirable on data consistency grounds anyway.  Now we only\n\t\t * perform truncation or rounding of low-order fields.\n\t\t */\n\t\tif (range == INTERVAL_FULL_RANGE)\n\t\t{\n\t\t\t/* Do nothing... */\n\t\t}\n\t\telse if (range == INTERVAL_MASK(YEAR))\n\t\t{\n\t\t\tinterval->month = (interval->month / MONTHS_PER_YEAR) * MONTHS_PER_YEAR;\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(MONTH))\n\t\t{\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\t/* YEAR TO MONTH */\n\t\telse if (range == (INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH)))\n\t\t{\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(DAY))\n\t\t{\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(HOUR))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_HOUR) *\n\t\t\t\tUSECS_PER_HOUR;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(MINUTE))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(SECOND))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* DAY TO HOUR */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_HOUR) *\n\t\t\t\tUSECS_PER_HOUR;\n\t\t}\n\t\t/* DAY TO MINUTE */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\t/* DAY TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* HOUR TO MINUTE */\n\t\telse if (range == (INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\t/* HOUR TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* MINUTE TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unrecognized interval typmod: %d\", typmod);\n\n\t\t/* Need to adjust sub-second precision? */\n\t\tif (precision != INTERVAL_FULL_PRECISION)\n\t\t{\n\t\t\tif (precision < 0 || precision > MAX_INTERVAL_PRECISION)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"interval(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\t\tprecision, 0, MAX_INTERVAL_PRECISION)));\n\n\t\t\tif (interval->time >= INT64CONST(0))\n\t\t\t{\n\t\t\t\tinterval->time = ((interval->time +\n\t\t\t\t\t\t\t\t   IntervalOffsets[precision]) /\n\t\t\t\t\t\t\t\t  IntervalScales[precision]) *\n\t\t\t\t\tIntervalScales[precision];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinterval->time = -(((-interval->time +\n\t\t\t\t\t\t\t\t\t IntervalOffsets[precision]) /\n\t\t\t\t\t\t\t\t\tIntervalScales[precision]) *\n\t\t\t\t\t\t\t\t   IntervalScales[precision]);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
            "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nstatic void\nAdjustIntervalForTypmod(Interval *interval, int32 typmod)\n{\n\tstatic const int64 IntervalScales[MAX_INTERVAL_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 IntervalOffsets[MAX_INTERVAL_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\t/*\n\t * Unspecified range and precision? Then not necessary to adjust. Setting\n\t * typmod to -1 is the convention for all data types.\n\t */\n\tif (typmod >= 0)\n\t{\n\t\tint\t\t\trange = INTERVAL_RANGE(typmod);\n\t\tint\t\t\tprecision = INTERVAL_PRECISION(typmod);\n\n\t\t/*\n\t\t * Our interpretation of intervals with a limited set of fields is\n\t\t * that fields to the right of the last one specified are zeroed out,\n\t\t * but those to the left of it remain valid.  Thus for example there\n\t\t * is no operational difference between INTERVAL YEAR TO MONTH and\n\t\t * INTERVAL MONTH.  In some cases we could meaningfully enforce that\n\t\t * higher-order fields are zero; for example INTERVAL DAY could reject\n\t\t * nonzero \"month\" field.  However that seems a bit pointless when we\n\t\t * can't do it consistently.  (We cannot enforce a range limit on the\n\t\t * highest expected field, since we do not have any equivalent of\n\t\t * SQL's <interval leading field precision>.)  If we ever decide to\n\t\t * revisit this, interval_transform will likely require adjusting.\n\t\t *\n\t\t * Note: before PG 8.4 we interpreted a limited set of fields as\n\t\t * actually causing a \"modulo\" operation on a given value, potentially\n\t\t * losing high-order as well as low-order information.  But there is\n\t\t * no support for such behavior in the standard, and it seems fairly\n\t\t * undesirable on data consistency grounds anyway.  Now we only\n\t\t * perform truncation or rounding of low-order fields.\n\t\t */\n\t\tif (range == INTERVAL_FULL_RANGE)\n\t\t{\n\t\t\t/* Do nothing... */\n\t\t}\n\t\telse if (range == INTERVAL_MASK(YEAR))\n\t\t{\n\t\t\tinterval->month = (interval->month / MONTHS_PER_YEAR) * MONTHS_PER_YEAR;\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(MONTH))\n\t\t{\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\t/* YEAR TO MONTH */\n\t\telse if (range == (INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH)))\n\t\t{\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(DAY))\n\t\t{\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(HOUR))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_HOUR) *\n\t\t\t\tUSECS_PER_HOUR;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(MINUTE))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(SECOND))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* DAY TO HOUR */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_HOUR) *\n\t\t\t\tUSECS_PER_HOUR;\n\t\t}\n\t\t/* DAY TO MINUTE */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\t/* DAY TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* HOUR TO MINUTE */\n\t\telse if (range == (INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\t/* HOUR TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* MINUTE TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unrecognized interval typmod: %d\", typmod);\n\n\t\t/* Need to adjust sub-second precision? */\n\t\tif (precision != INTERVAL_FULL_PRECISION)\n\t\t{\n\t\t\tif (precision < 0 || precision > MAX_INTERVAL_PRECISION)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"interval(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\t\tprecision, 0, MAX_INTERVAL_PRECISION)));\n\n\t\t\tif (interval->time >= INT64CONST(0))\n\t\t\t{\n\t\t\t\tinterval->time = ((interval->time +\n\t\t\t\t\t\t\t\t   IntervalOffsets[precision]) /\n\t\t\t\t\t\t\t\t  IntervalScales[precision]) *\n\t\t\t\t\tIntervalScales[precision];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinterval->time = -(((-interval->time +\n\t\t\t\t\t\t\t\t\t IntervalOffsets[precision]) /\n\t\t\t\t\t\t\t\t\tIntervalScales[precision]) *\n\t\t\t\t\t\t\t\t   IntervalScales[precision]);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nDatum\ninterval_scale(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval = PG_GETARG_INTERVAL_P(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tInterval   *result;\n\n\tresult = palloc(sizeof(Interval));\n\t*result = *interval;\n\n\tAdjustIntervalForTypmod(result, typmod);\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "interval_transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1243-1294",
    "snippet": "Datum\ninterval_transform(PG_FUNCTION_ARGS)\n{\n\tFuncExpr   *expr = castNode(FuncExpr, PG_GETARG_POINTER(0));\n\tNode\t   *ret = NULL;\n\tNode\t   *typmod;\n\n\tAssert(list_length(expr->args) >= 2);\n\n\ttypmod = (Node *) lsecond(expr->args);\n\n\tif (IsA(typmod, Const) &&!((Const *) typmod)->constisnull)\n\t{\n\t\tNode\t   *source = (Node *) linitial(expr->args);\n\t\tint32\t\tnew_typmod = DatumGetInt32(((Const *) typmod)->constvalue);\n\t\tbool\t\tnoop;\n\n\t\tif (new_typmod < 0)\n\t\t\tnoop = true;\n\t\telse\n\t\t{\n\t\t\tint32\t\told_typmod = exprTypmod(source);\n\t\t\tint\t\t\told_least_field;\n\t\t\tint\t\t\tnew_least_field;\n\t\t\tint\t\t\told_precis;\n\t\t\tint\t\t\tnew_precis;\n\n\t\t\told_least_field = intervaltypmodleastfield(old_typmod);\n\t\t\tnew_least_field = intervaltypmodleastfield(new_typmod);\n\t\t\tif (old_typmod < 0)\n\t\t\t\told_precis = INTERVAL_FULL_PRECISION;\n\t\t\telse\n\t\t\t\told_precis = INTERVAL_PRECISION(old_typmod);\n\t\t\tnew_precis = INTERVAL_PRECISION(new_typmod);\n\n\t\t\t/*\n\t\t\t * Cast is a no-op if least field stays the same or decreases\n\t\t\t * while precision stays the same or increases.  But precision,\n\t\t\t * which is to say, sub-second precision, only affects ranges that\n\t\t\t * include SECOND.\n\t\t\t */\n\t\t\tnoop = (new_least_field <= old_least_field) &&\n\t\t\t\t(old_least_field > 0 /* SECOND */ ||\n\t\t\t\t new_precis >= MAX_INTERVAL_PRECISION ||\n\t\t\t\t new_precis >= old_precis);\n\t\t}\n\t\tif (noop)\n\t\t\tret = relabel_to_typmod(source, new_typmod);\n\t}\n\n\tPG_RETURN_POINTER(ret);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "ret"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relabel_to_typmod",
          "args": [
            "source",
            "new_typmod"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_PRECISION",
          "args": [
            "new_typmod"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_PRECISION",
          "args": [
            "old_typmod"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intervaltypmodleastfield",
          "args": [
            "new_typmod"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "intervaltypmodleastfield",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1194-1235",
          "snippet": "static int\nintervaltypmodleastfield(int32 typmod)\n{\n\tif (typmod < 0)\n\t\treturn 0;\t\t\t\t/* SECOND */\n\n\tswitch (INTERVAL_RANGE(typmod))\n\t{\n\t\tcase INTERVAL_MASK(YEAR):\n\t\t\treturn 5;\t\t\t/* YEAR */\n\t\tcase INTERVAL_MASK(MONTH):\n\t\t\treturn 4;\t\t\t/* MONTH */\n\t\tcase INTERVAL_MASK(DAY):\n\t\t\treturn 3;\t\t\t/* DAY */\n\t\tcase INTERVAL_MASK(HOUR):\n\t\t\treturn 2;\t\t\t/* HOUR */\n\t\tcase INTERVAL_MASK(MINUTE):\n\t\t\treturn 1;\t\t\t/* MINUTE */\n\t\tcase INTERVAL_MASK(SECOND):\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tcase INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):\n\t\t\treturn 4;\t\t\t/* MONTH */\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):\n\t\t\treturn 2;\t\t\t/* HOUR */\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\treturn 1;\t\t\t/* MINUTE */\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\treturn 1;\t\t\t/* MINUTE */\n\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tcase INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tcase INTERVAL_FULL_RANGE:\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid INTERVAL typmod: 0x%x\", typmod);\n\t\t\tbreak;\n\t}\n\treturn 0;\t\t\t\t\t/* can't get here, but keep compiler quiet */\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
            "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nstatic int\nintervaltypmodleastfield(int32 typmod)\n{\n\tif (typmod < 0)\n\t\treturn 0;\t\t\t\t/* SECOND */\n\n\tswitch (INTERVAL_RANGE(typmod))\n\t{\n\t\tcase INTERVAL_MASK(YEAR):\n\t\t\treturn 5;\t\t\t/* YEAR */\n\t\tcase INTERVAL_MASK(MONTH):\n\t\t\treturn 4;\t\t\t/* MONTH */\n\t\tcase INTERVAL_MASK(DAY):\n\t\t\treturn 3;\t\t\t/* DAY */\n\t\tcase INTERVAL_MASK(HOUR):\n\t\t\treturn 2;\t\t\t/* HOUR */\n\t\tcase INTERVAL_MASK(MINUTE):\n\t\t\treturn 1;\t\t\t/* MINUTE */\n\t\tcase INTERVAL_MASK(SECOND):\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tcase INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):\n\t\t\treturn 4;\t\t\t/* MONTH */\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):\n\t\t\treturn 2;\t\t\t/* HOUR */\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\treturn 1;\t\t\t/* MINUTE */\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\treturn 1;\t\t\t/* MINUTE */\n\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tcase INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tcase INTERVAL_FULL_RANGE:\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid INTERVAL typmod: 0x%x\", typmod);\n\t\t\tbreak;\n\t}\n\treturn 0;\t\t\t\t\t/* can't get here, but keep compiler quiet */\n}"
        }
      },
      {
        "call_info": {
          "callee": "exprTypmod",
          "args": [
            "source"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "((Const *) typmod)->constvalue"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "expr->args"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "typmod",
            "Const"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lsecond",
          "args": [
            "expr->args"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "list_length(expr->args) >= 2"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "expr->args"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "FuncExpr",
            "PG_GETARG_POINTER(0)"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nDatum\ninterval_transform(PG_FUNCTION_ARGS)\n{\n\tFuncExpr   *expr = castNode(FuncExpr, PG_GETARG_POINTER(0));\n\tNode\t   *ret = NULL;\n\tNode\t   *typmod;\n\n\tAssert(list_length(expr->args) >= 2);\n\n\ttypmod = (Node *) lsecond(expr->args);\n\n\tif (IsA(typmod, Const) &&!((Const *) typmod)->constisnull)\n\t{\n\t\tNode\t   *source = (Node *) linitial(expr->args);\n\t\tint32\t\tnew_typmod = DatumGetInt32(((Const *) typmod)->constvalue);\n\t\tbool\t\tnoop;\n\n\t\tif (new_typmod < 0)\n\t\t\tnoop = true;\n\t\telse\n\t\t{\n\t\t\tint32\t\told_typmod = exprTypmod(source);\n\t\t\tint\t\t\told_least_field;\n\t\t\tint\t\t\tnew_least_field;\n\t\t\tint\t\t\told_precis;\n\t\t\tint\t\t\tnew_precis;\n\n\t\t\told_least_field = intervaltypmodleastfield(old_typmod);\n\t\t\tnew_least_field = intervaltypmodleastfield(new_typmod);\n\t\t\tif (old_typmod < 0)\n\t\t\t\told_precis = INTERVAL_FULL_PRECISION;\n\t\t\telse\n\t\t\t\told_precis = INTERVAL_PRECISION(old_typmod);\n\t\t\tnew_precis = INTERVAL_PRECISION(new_typmod);\n\n\t\t\t/*\n\t\t\t * Cast is a no-op if least field stays the same or decreases\n\t\t\t * while precision stays the same or increases.  But precision,\n\t\t\t * which is to say, sub-second precision, only affects ranges that\n\t\t\t * include SECOND.\n\t\t\t */\n\t\t\tnoop = (new_least_field <= old_least_field) &&\n\t\t\t\t(old_least_field > 0 /* SECOND */ ||\n\t\t\t\t new_precis >= MAX_INTERVAL_PRECISION ||\n\t\t\t\t new_precis >= old_precis);\n\t\t}\n\t\tif (noop)\n\t\t\tret = relabel_to_typmod(source, new_typmod);\n\t}\n\n\tPG_RETURN_POINTER(ret);\n}"
  },
  {
    "function_name": "intervaltypmodleastfield",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1194-1235",
    "snippet": "static int\nintervaltypmodleastfield(int32 typmod)\n{\n\tif (typmod < 0)\n\t\treturn 0;\t\t\t\t/* SECOND */\n\n\tswitch (INTERVAL_RANGE(typmod))\n\t{\n\t\tcase INTERVAL_MASK(YEAR):\n\t\t\treturn 5;\t\t\t/* YEAR */\n\t\tcase INTERVAL_MASK(MONTH):\n\t\t\treturn 4;\t\t\t/* MONTH */\n\t\tcase INTERVAL_MASK(DAY):\n\t\t\treturn 3;\t\t\t/* DAY */\n\t\tcase INTERVAL_MASK(HOUR):\n\t\t\treturn 2;\t\t\t/* HOUR */\n\t\tcase INTERVAL_MASK(MINUTE):\n\t\t\treturn 1;\t\t\t/* MINUTE */\n\t\tcase INTERVAL_MASK(SECOND):\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tcase INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):\n\t\t\treturn 4;\t\t\t/* MONTH */\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):\n\t\t\treturn 2;\t\t\t/* HOUR */\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\treturn 1;\t\t\t/* MINUTE */\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\treturn 1;\t\t\t/* MINUTE */\n\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tcase INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tcase INTERVAL_FULL_RANGE:\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid INTERVAL typmod: 0x%x\", typmod);\n\t\t\tbreak;\n\t}\n\treturn 0;\t\t\t\t\t/* can't get here, but keep compiler quiet */\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid INTERVAL typmod: 0x%x\"",
            "typmod"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MONTH"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "YEAR"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MONTH"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "YEAR"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_RANGE",
          "args": [
            "typmod"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nstatic int\nintervaltypmodleastfield(int32 typmod)\n{\n\tif (typmod < 0)\n\t\treturn 0;\t\t\t\t/* SECOND */\n\n\tswitch (INTERVAL_RANGE(typmod))\n\t{\n\t\tcase INTERVAL_MASK(YEAR):\n\t\t\treturn 5;\t\t\t/* YEAR */\n\t\tcase INTERVAL_MASK(MONTH):\n\t\t\treturn 4;\t\t\t/* MONTH */\n\t\tcase INTERVAL_MASK(DAY):\n\t\t\treturn 3;\t\t\t/* DAY */\n\t\tcase INTERVAL_MASK(HOUR):\n\t\t\treturn 2;\t\t\t/* HOUR */\n\t\tcase INTERVAL_MASK(MINUTE):\n\t\t\treturn 1;\t\t\t/* MINUTE */\n\t\tcase INTERVAL_MASK(SECOND):\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tcase INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):\n\t\t\treturn 4;\t\t\t/* MONTH */\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):\n\t\t\treturn 2;\t\t\t/* HOUR */\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\treturn 1;\t\t\t/* MINUTE */\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\treturn 1;\t\t\t/* MINUTE */\n\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tcase INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tcase INTERVAL_FULL_RANGE:\n\t\t\treturn 0;\t\t\t/* SECOND */\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid INTERVAL typmod: 0x%x\", typmod);\n\t\t\tbreak;\n\t}\n\treturn 0;\t\t\t\t\t/* can't get here, but keep compiler quiet */\n}"
  },
  {
    "function_name": "intervaltypmodout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1108-1182",
    "snippet": "Datum\nintervaltypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\tchar\t   *res = (char *) palloc(64);\n\tint\t\t\tfields;\n\tint\t\t\tprecision;\n\tconst char *fieldstr;\n\n\tif (typmod < 0)\n\t{\n\t\t*res = '\\0';\n\t\tPG_RETURN_CSTRING(res);\n\t}\n\n\tfields = INTERVAL_RANGE(typmod);\n\tprecision = INTERVAL_PRECISION(typmod);\n\n\tswitch (fields)\n\t{\n\t\tcase INTERVAL_MASK(YEAR):\n\t\t\tfieldstr = \" year\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(MONTH):\n\t\t\tfieldstr = \" month\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(DAY):\n\t\t\tfieldstr = \" day\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(HOUR):\n\t\t\tfieldstr = \" hour\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(MINUTE):\n\t\t\tfieldstr = \" minute\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(SECOND):\n\t\t\tfieldstr = \" second\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):\n\t\t\tfieldstr = \" year to month\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):\n\t\t\tfieldstr = \" day to hour\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\tfieldstr = \" day to minute\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\tfieldstr = \" day to second\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\tfieldstr = \" hour to minute\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\tfieldstr = \" hour to second\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\tfieldstr = \" minute to second\";\n\t\t\tbreak;\n\t\tcase INTERVAL_FULL_RANGE:\n\t\t\tfieldstr = \"\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid INTERVAL typmod: 0x%x\", typmod);\n\t\t\tfieldstr = \"\";\n\t\t\tbreak;\n\t}\n\n\tif (precision != INTERVAL_FULL_PRECISION)\n\t\tsnprintf(res, 64, \"%s(%d)\", fieldstr, precision);\n\telse\n\t\tsnprintf(res, 64, \"%s\", fieldstr);\n\n\tPG_RETURN_CSTRING(res);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "res"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "res",
            "64",
            "\"%s\"",
            "fieldstr"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "res",
            "64",
            "\"%s(%d)\"",
            "fieldstr",
            "precision"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid INTERVAL typmod: 0x%x\"",
            "typmod"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MONTH"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "YEAR"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MONTH"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "YEAR"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_PRECISION",
          "args": [
            "typmod"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_RANGE",
          "args": [
            "typmod"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "res"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "64"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nDatum\nintervaltypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\tchar\t   *res = (char *) palloc(64);\n\tint\t\t\tfields;\n\tint\t\t\tprecision;\n\tconst char *fieldstr;\n\n\tif (typmod < 0)\n\t{\n\t\t*res = '\\0';\n\t\tPG_RETURN_CSTRING(res);\n\t}\n\n\tfields = INTERVAL_RANGE(typmod);\n\tprecision = INTERVAL_PRECISION(typmod);\n\n\tswitch (fields)\n\t{\n\t\tcase INTERVAL_MASK(YEAR):\n\t\t\tfieldstr = \" year\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(MONTH):\n\t\t\tfieldstr = \" month\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(DAY):\n\t\t\tfieldstr = \" day\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(HOUR):\n\t\t\tfieldstr = \" hour\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(MINUTE):\n\t\t\tfieldstr = \" minute\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(SECOND):\n\t\t\tfieldstr = \" second\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):\n\t\t\tfieldstr = \" year to month\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):\n\t\t\tfieldstr = \" day to hour\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\tfieldstr = \" day to minute\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\tfieldstr = \" day to second\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\tfieldstr = \" hour to minute\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\tfieldstr = \" hour to second\";\n\t\t\tbreak;\n\t\tcase INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\tfieldstr = \" minute to second\";\n\t\t\tbreak;\n\t\tcase INTERVAL_FULL_RANGE:\n\t\t\tfieldstr = \"\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid INTERVAL typmod: 0x%x\", typmod);\n\t\t\tfieldstr = \"\";\n\t\t\tbreak;\n\t}\n\n\tif (precision != INTERVAL_FULL_PRECISION)\n\t\tsnprintf(res, 64, \"%s(%d)\", fieldstr, precision);\n\telse\n\t\tsnprintf(res, 64, \"%s\", fieldstr);\n\n\tPG_RETURN_CSTRING(res);\n}"
  },
  {
    "function_name": "intervaltypmodin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1029-1106",
    "snippet": "Datum\nintervaltypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\tint32\t   *tl;\n\tint\t\t\tn;\n\tint32\t\ttypmod;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * tl[0] - interval range (fields bitmask)\ttl[1] - precision (optional)\n\t *\n\t * Note we must validate tl[0] even though it's normally guaranteed\n\t * correct by the grammar --- consider SELECT 'foo'::\"interval\"(1000).\n\t */\n\tif (n > 0)\n\t{\n\t\tswitch (tl[0])\n\t\t{\n\t\t\tcase INTERVAL_MASK(YEAR):\n\t\t\tcase INTERVAL_MASK(MONTH):\n\t\t\tcase INTERVAL_MASK(DAY):\n\t\t\tcase INTERVAL_MASK(HOUR):\n\t\t\tcase INTERVAL_MASK(MINUTE):\n\t\t\tcase INTERVAL_MASK(SECOND):\n\t\t\tcase INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):\n\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):\n\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\tcase INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\tcase INTERVAL_FULL_RANGE:\n\t\t\t\t/* all OK */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"invalid INTERVAL type modifier\")));\n\t\t}\n\t}\n\n\tif (n == 1)\n\t{\n\t\tif (tl[0] != INTERVAL_FULL_RANGE)\n\t\t\ttypmod = INTERVAL_TYPMOD(INTERVAL_FULL_PRECISION, tl[0]);\n\t\telse\n\t\t\ttypmod = -1;\n\t}\n\telse if (n == 2)\n\t{\n\t\tif (tl[1] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"INTERVAL(%d) precision must not be negative\",\n\t\t\t\t\t\t\ttl[1])));\n\t\tif (tl[1] > MAX_INTERVAL_PRECISION)\n\t\t{\n\t\t\tereport(WARNING,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"INTERVAL(%d) precision reduced to maximum allowed, %d\",\n\t\t\t\t\t\t\ttl[1], MAX_INTERVAL_PRECISION)));\n\t\t\ttypmod = INTERVAL_TYPMOD(MAX_INTERVAL_PRECISION, tl[0]);\n\t\t}\n\t\telse\n\t\t\ttypmod = INTERVAL_TYPMOD(tl[1], tl[0]);\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid INTERVAL type modifier\")));\n\t\ttypmod = 0;\t\t\t\t/* keep compiler quiet */\n\t}\n\n\tPG_RETURN_INT32(typmod);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "typmod"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid INTERVAL type modifier\"))"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid INTERVAL type modifier\""
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "INTERVAL_TYPMOD",
          "args": [
            "tl[1]",
            "tl[0]"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_TYPMOD",
          "args": [
            "MAX_INTERVAL_PRECISION",
            "tl[0]"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "WARNING",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"INTERVAL(%d) precision reduced to maximum allowed, %d\",\n\t\t\t\t\t\t\ttl[1], MAX_INTERVAL_PRECISION))"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"INTERVAL(%d) precision must not be negative\",\n\t\t\t\t\t\t\ttl[1]))"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_TYPMOD",
          "args": [
            "INTERVAL_FULL_PRECISION",
            "tl[0]"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"invalid INTERVAL type modifier\"))"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MONTH"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "YEAR"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MONTH"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "YEAR"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetIntegerTypmods",
          "args": [
            "ta",
            "&n"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetIntegerTypmods",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "199-235",
          "snippet": "int32 *\nArrayGetIntegerTypmods(ArrayType *arr, int *n)\n{\n\tint32\t   *result;\n\tDatum\t   *elem_values;\n\tint\t\t\ti;\n\n\tif (ARR_ELEMTYPE(arr) != CSTRINGOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_ELEMENT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be type cstring[]\")));\n\n\tif (ARR_NDIM(arr) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be one-dimensional\")));\n\n\tif (array_contains_nulls(arr))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"typmod array must not contain nulls\")));\n\n\t/* hardwired knowledge about cstring's representation details here */\n\tdeconstruct_array(arr, CSTRINGOID,\n\t\t\t\t\t  -2, false, 'c',\n\t\t\t\t\t  &elem_values, NULL, n);\n\n\tresult = (int32 *) palloc(*n * sizeof(int32));\n\n\tfor (i = 0; i < *n; i++)\n\t\tresult[i] = pg_atoi(DatumGetCString(elem_values[i]),\n\t\t\t\t\t\t\tsizeof(int32), '\\0');\n\n\tpfree(elem_values);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint32 *\nArrayGetIntegerTypmods(ArrayType *arr, int *n)\n{\n\tint32\t   *result;\n\tDatum\t   *elem_values;\n\tint\t\t\ti;\n\n\tif (ARR_ELEMTYPE(arr) != CSTRINGOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_ELEMENT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be type cstring[]\")));\n\n\tif (ARR_NDIM(arr) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be one-dimensional\")));\n\n\tif (array_contains_nulls(arr))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"typmod array must not contain nulls\")));\n\n\t/* hardwired knowledge about cstring's representation details here */\n\tdeconstruct_array(arr, CSTRINGOID,\n\t\t\t\t\t  -2, false, 'c',\n\t\t\t\t\t  &elem_values, NULL, n);\n\n\tresult = (int32 *) palloc(*n * sizeof(int32));\n\n\tfor (i = 0; i < *n; i++)\n\t\tresult[i] = pg_atoi(DatumGetCString(elem_values[i]),\n\t\t\t\t\t\t\tsizeof(int32), '\\0');\n\n\tpfree(elem_values);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nDatum\nintervaltypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\tint32\t   *tl;\n\tint\t\t\tn;\n\tint32\t\ttypmod;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * tl[0] - interval range (fields bitmask)\ttl[1] - precision (optional)\n\t *\n\t * Note we must validate tl[0] even though it's normally guaranteed\n\t * correct by the grammar --- consider SELECT 'foo'::\"interval\"(1000).\n\t */\n\tif (n > 0)\n\t{\n\t\tswitch (tl[0])\n\t\t{\n\t\t\tcase INTERVAL_MASK(YEAR):\n\t\t\tcase INTERVAL_MASK(MONTH):\n\t\t\tcase INTERVAL_MASK(DAY):\n\t\t\tcase INTERVAL_MASK(HOUR):\n\t\t\tcase INTERVAL_MASK(MINUTE):\n\t\t\tcase INTERVAL_MASK(SECOND):\n\t\t\tcase INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):\n\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):\n\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\tcase INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\tcase INTERVAL_FULL_RANGE:\n\t\t\t\t/* all OK */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"invalid INTERVAL type modifier\")));\n\t\t}\n\t}\n\n\tif (n == 1)\n\t{\n\t\tif (tl[0] != INTERVAL_FULL_RANGE)\n\t\t\ttypmod = INTERVAL_TYPMOD(INTERVAL_FULL_PRECISION, tl[0]);\n\t\telse\n\t\t\ttypmod = -1;\n\t}\n\telse if (n == 2)\n\t{\n\t\tif (tl[1] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"INTERVAL(%d) precision must not be negative\",\n\t\t\t\t\t\t\ttl[1])));\n\t\tif (tl[1] > MAX_INTERVAL_PRECISION)\n\t\t{\n\t\t\tereport(WARNING,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"INTERVAL(%d) precision reduced to maximum allowed, %d\",\n\t\t\t\t\t\t\ttl[1], MAX_INTERVAL_PRECISION)));\n\t\t\ttypmod = INTERVAL_TYPMOD(MAX_INTERVAL_PRECISION, tl[0]);\n\t\t}\n\t\telse\n\t\t\ttypmod = INTERVAL_TYPMOD(tl[1], tl[0]);\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid INTERVAL type modifier\")));\n\t\ttypmod = 0;\t\t\t\t/* keep compiler quiet */\n\t}\n\n\tPG_RETURN_INT32(typmod);\n}"
  },
  {
    "function_name": "interval_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "1004-1015",
    "snippet": "Datum\ninterval_send(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval = PG_GETARG_INTERVAL_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint64(&buf, interval->time);\n\tpq_sendint32(&buf, interval->day);\n\tpq_sendint32(&buf, interval->month);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "interval->month"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "interval->day"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint64",
          "args": [
            "&buf",
            "interval->time"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_send(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval = PG_GETARG_INTERVAL_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint64(&buf, interval->time);\n\tpq_sendint32(&buf, interval->day);\n\tpq_sendint32(&buf, interval->month);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "interval_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "979-999",
    "snippet": "Datum\ninterval_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tInterval   *interval;\n\n\tinterval = (Interval *) palloc(sizeof(Interval));\n\n\tinterval->time = pq_getmsgint64(buf);\n\tinterval->day = pq_getmsgint(buf, sizeof(interval->day));\n\tinterval->month = pq_getmsgint(buf, sizeof(interval->month));\n\n\tAdjustIntervalForTypmod(interval, typmod);\n\n\tPG_RETURN_INTERVAL_P(interval);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "interval"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustIntervalForTypmod",
          "args": [
            "interval",
            "typmod"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustIntervalForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1319-1481",
          "snippet": "static void\nAdjustIntervalForTypmod(Interval *interval, int32 typmod)\n{\n\tstatic const int64 IntervalScales[MAX_INTERVAL_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 IntervalOffsets[MAX_INTERVAL_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\t/*\n\t * Unspecified range and precision? Then not necessary to adjust. Setting\n\t * typmod to -1 is the convention for all data types.\n\t */\n\tif (typmod >= 0)\n\t{\n\t\tint\t\t\trange = INTERVAL_RANGE(typmod);\n\t\tint\t\t\tprecision = INTERVAL_PRECISION(typmod);\n\n\t\t/*\n\t\t * Our interpretation of intervals with a limited set of fields is\n\t\t * that fields to the right of the last one specified are zeroed out,\n\t\t * but those to the left of it remain valid.  Thus for example there\n\t\t * is no operational difference between INTERVAL YEAR TO MONTH and\n\t\t * INTERVAL MONTH.  In some cases we could meaningfully enforce that\n\t\t * higher-order fields are zero; for example INTERVAL DAY could reject\n\t\t * nonzero \"month\" field.  However that seems a bit pointless when we\n\t\t * can't do it consistently.  (We cannot enforce a range limit on the\n\t\t * highest expected field, since we do not have any equivalent of\n\t\t * SQL's <interval leading field precision>.)  If we ever decide to\n\t\t * revisit this, interval_transform will likely require adjusting.\n\t\t *\n\t\t * Note: before PG 8.4 we interpreted a limited set of fields as\n\t\t * actually causing a \"modulo\" operation on a given value, potentially\n\t\t * losing high-order as well as low-order information.  But there is\n\t\t * no support for such behavior in the standard, and it seems fairly\n\t\t * undesirable on data consistency grounds anyway.  Now we only\n\t\t * perform truncation or rounding of low-order fields.\n\t\t */\n\t\tif (range == INTERVAL_FULL_RANGE)\n\t\t{\n\t\t\t/* Do nothing... */\n\t\t}\n\t\telse if (range == INTERVAL_MASK(YEAR))\n\t\t{\n\t\t\tinterval->month = (interval->month / MONTHS_PER_YEAR) * MONTHS_PER_YEAR;\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(MONTH))\n\t\t{\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\t/* YEAR TO MONTH */\n\t\telse if (range == (INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH)))\n\t\t{\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(DAY))\n\t\t{\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(HOUR))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_HOUR) *\n\t\t\t\tUSECS_PER_HOUR;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(MINUTE))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(SECOND))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* DAY TO HOUR */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_HOUR) *\n\t\t\t\tUSECS_PER_HOUR;\n\t\t}\n\t\t/* DAY TO MINUTE */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\t/* DAY TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* HOUR TO MINUTE */\n\t\telse if (range == (INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\t/* HOUR TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* MINUTE TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unrecognized interval typmod: %d\", typmod);\n\n\t\t/* Need to adjust sub-second precision? */\n\t\tif (precision != INTERVAL_FULL_PRECISION)\n\t\t{\n\t\t\tif (precision < 0 || precision > MAX_INTERVAL_PRECISION)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"interval(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\t\tprecision, 0, MAX_INTERVAL_PRECISION)));\n\n\t\t\tif (interval->time >= INT64CONST(0))\n\t\t\t{\n\t\t\t\tinterval->time = ((interval->time +\n\t\t\t\t\t\t\t\t   IntervalOffsets[precision]) /\n\t\t\t\t\t\t\t\t  IntervalScales[precision]) *\n\t\t\t\t\tIntervalScales[precision];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinterval->time = -(((-interval->time +\n\t\t\t\t\t\t\t\t\t IntervalOffsets[precision]) /\n\t\t\t\t\t\t\t\t\tIntervalScales[precision]) *\n\t\t\t\t\t\t\t\t   IntervalScales[precision]);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
            "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nstatic void\nAdjustIntervalForTypmod(Interval *interval, int32 typmod)\n{\n\tstatic const int64 IntervalScales[MAX_INTERVAL_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 IntervalOffsets[MAX_INTERVAL_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\t/*\n\t * Unspecified range and precision? Then not necessary to adjust. Setting\n\t * typmod to -1 is the convention for all data types.\n\t */\n\tif (typmod >= 0)\n\t{\n\t\tint\t\t\trange = INTERVAL_RANGE(typmod);\n\t\tint\t\t\tprecision = INTERVAL_PRECISION(typmod);\n\n\t\t/*\n\t\t * Our interpretation of intervals with a limited set of fields is\n\t\t * that fields to the right of the last one specified are zeroed out,\n\t\t * but those to the left of it remain valid.  Thus for example there\n\t\t * is no operational difference between INTERVAL YEAR TO MONTH and\n\t\t * INTERVAL MONTH.  In some cases we could meaningfully enforce that\n\t\t * higher-order fields are zero; for example INTERVAL DAY could reject\n\t\t * nonzero \"month\" field.  However that seems a bit pointless when we\n\t\t * can't do it consistently.  (We cannot enforce a range limit on the\n\t\t * highest expected field, since we do not have any equivalent of\n\t\t * SQL's <interval leading field precision>.)  If we ever decide to\n\t\t * revisit this, interval_transform will likely require adjusting.\n\t\t *\n\t\t * Note: before PG 8.4 we interpreted a limited set of fields as\n\t\t * actually causing a \"modulo\" operation on a given value, potentially\n\t\t * losing high-order as well as low-order information.  But there is\n\t\t * no support for such behavior in the standard, and it seems fairly\n\t\t * undesirable on data consistency grounds anyway.  Now we only\n\t\t * perform truncation or rounding of low-order fields.\n\t\t */\n\t\tif (range == INTERVAL_FULL_RANGE)\n\t\t{\n\t\t\t/* Do nothing... */\n\t\t}\n\t\telse if (range == INTERVAL_MASK(YEAR))\n\t\t{\n\t\t\tinterval->month = (interval->month / MONTHS_PER_YEAR) * MONTHS_PER_YEAR;\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(MONTH))\n\t\t{\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\t/* YEAR TO MONTH */\n\t\telse if (range == (INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH)))\n\t\t{\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(DAY))\n\t\t{\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(HOUR))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_HOUR) *\n\t\t\t\tUSECS_PER_HOUR;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(MINUTE))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(SECOND))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* DAY TO HOUR */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_HOUR) *\n\t\t\t\tUSECS_PER_HOUR;\n\t\t}\n\t\t/* DAY TO MINUTE */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\t/* DAY TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* HOUR TO MINUTE */\n\t\telse if (range == (INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\t/* HOUR TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* MINUTE TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unrecognized interval typmod: %d\", typmod);\n\n\t\t/* Need to adjust sub-second precision? */\n\t\tif (precision != INTERVAL_FULL_PRECISION)\n\t\t{\n\t\t\tif (precision < 0 || precision > MAX_INTERVAL_PRECISION)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"interval(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\t\tprecision, 0, MAX_INTERVAL_PRECISION)));\n\n\t\t\tif (interval->time >= INT64CONST(0))\n\t\t\t{\n\t\t\t\tinterval->time = ((interval->time +\n\t\t\t\t\t\t\t\t   IntervalOffsets[precision]) /\n\t\t\t\t\t\t\t\t  IntervalScales[precision]) *\n\t\t\t\t\tIntervalScales[precision];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinterval->time = -(((-interval->time +\n\t\t\t\t\t\t\t\t\t IntervalOffsets[precision]) /\n\t\t\t\t\t\t\t\t\tIntervalScales[precision]) *\n\t\t\t\t\t\t\t\t   IntervalScales[precision]);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(interval->month)"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(interval->day)"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint64",
          "args": [
            "buf"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nDatum\ninterval_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tInterval   *interval;\n\n\tinterval = (Interval *) palloc(sizeof(Interval));\n\n\tinterval->time = pq_getmsgint64(buf);\n\tinterval->day = pq_getmsgint(buf, sizeof(interval->day));\n\tinterval->month = pq_getmsgint(buf, sizeof(interval->month));\n\n\tAdjustIntervalForTypmod(interval, typmod);\n\n\tPG_RETURN_INTERVAL_P(interval);\n}"
  },
  {
    "function_name": "interval_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "957-974",
    "snippet": "Datum\ninterval_out(PG_FUNCTION_ARGS)\n{\n\tInterval   *span = PG_GETARG_INTERVAL_P(0);\n\tchar\t   *result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\n\tif (interval2tm(*span, tm, &fsec) != 0)\n\t\telog(ERROR, \"could not convert interval to tm\");\n\n\tEncodeInterval(tm, fsec, IntervalStyle, buf);\n\n\tresult = pstrdup(buf);\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "buf"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeInterval",
          "args": [
            "tm",
            "fsec",
            "IntervalStyle",
            "buf"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeInterval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "4229-4413",
          "snippet": "void\nEncodeInterval(struct pg_tm *tm, fsec_t fsec, int style, char *str)\n{\n\tchar\t   *cp = str;\n\tint\t\t\tyear = tm->tm_year;\n\tint\t\t\tmon = tm->tm_mon;\n\tint\t\t\tmday = tm->tm_mday;\n\tint\t\t\thour = tm->tm_hour;\n\tint\t\t\tmin = tm->tm_min;\n\tint\t\t\tsec = tm->tm_sec;\n\tbool\t\tis_before = false;\n\tbool\t\tis_zero = true;\n\n\t/*\n\t * The sign of year and month are guaranteed to match, since they are\n\t * stored internally as \"month\". But we'll need to check for is_before and\n\t * is_zero when determining the signs of day and hour/minute/seconds\n\t * fields.\n\t */\n\tswitch (style)\n\t{\n\t\t\t/* SQL Standard interval format */\n\t\tcase INTSTYLE_SQL_STANDARD:\n\t\t\t{\n\t\t\t\tbool\t\thas_negative = year < 0 || mon < 0 ||\n\t\t\t\tmday < 0 || hour < 0 ||\n\t\t\t\tmin < 0 || sec < 0 || fsec < 0;\n\t\t\t\tbool\t\thas_positive = year > 0 || mon > 0 ||\n\t\t\t\tmday > 0 || hour > 0 ||\n\t\t\t\tmin > 0 || sec > 0 || fsec > 0;\n\t\t\t\tbool\t\thas_year_month = year != 0 || mon != 0;\n\t\t\t\tbool\t\thas_day_time = mday != 0 || hour != 0 ||\n\t\t\t\tmin != 0 || sec != 0 || fsec != 0;\n\t\t\t\tbool\t\thas_day = mday != 0;\n\t\t\t\tbool\t\tsql_standard_value = !(has_negative && has_positive) &&\n\t\t\t\t!(has_year_month && has_day_time);\n\n\t\t\t\t/*\n\t\t\t\t * SQL Standard wants only 1 \"<sign>\" preceding the whole\n\t\t\t\t * interval ... but can't do that if mixed signs.\n\t\t\t\t */\n\t\t\t\tif (has_negative && sql_standard_value)\n\t\t\t\t{\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\t\tyear = -year;\n\t\t\t\t\tmon = -mon;\n\t\t\t\t\tmday = -mday;\n\t\t\t\t\thour = -hour;\n\t\t\t\t\tmin = -min;\n\t\t\t\t\tsec = -sec;\n\t\t\t\t\tfsec = -fsec;\n\t\t\t\t}\n\n\t\t\t\tif (!has_negative && !has_positive)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"0\");\n\t\t\t\t}\n\t\t\t\telse if (!sql_standard_value)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * For non sql-standard interval values, force outputting\n\t\t\t\t\t * the signs to avoid ambiguities with intervals with\n\t\t\t\t\t * mixed sign components.\n\t\t\t\t\t */\n\t\t\t\t\tchar\t\tyear_sign = (year < 0 || mon < 0) ? '-' : '+';\n\t\t\t\t\tchar\t\tday_sign = (mday < 0) ? '-' : '+';\n\t\t\t\t\tchar\t\tsec_sign = (hour < 0 || min < 0 ||\n\t\t\t\t\t\t\t\t\t\t\tsec < 0 || fsec < 0) ? '-' : '+';\n\n\t\t\t\t\tsprintf(cp, \"%c%d-%d %c%d %c%d:%02d:\",\n\t\t\t\t\t\t\tyear_sign, abs(year), abs(mon),\n\t\t\t\t\t\t\tday_sign, abs(mday),\n\t\t\t\t\t\t\tsec_sign, abs(hour), abs(min));\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t\telse if (has_year_month)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d-%d\", year, mon);\n\t\t\t\t}\n\t\t\t\telse if (has_day)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d %d:%02d:\", mday, hour, min);\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d:%02d:\", hour, min);\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* ISO 8601 \"time-intervals by duration only\" */\n\t\tcase INTSTYLE_ISO_8601:\n\t\t\t/* special-case zero to avoid printing nothing */\n\t\t\tif (year == 0 && mon == 0 && mday == 0 &&\n\t\t\t\thour == 0 && min == 0 && sec == 0 && fsec == 0)\n\t\t\t{\n\t\t\t\tsprintf(cp, \"PT0S\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*cp++ = 'P';\n\t\t\tcp = AddISO8601IntPart(cp, year, 'Y');\n\t\t\tcp = AddISO8601IntPart(cp, mon, 'M');\n\t\t\tcp = AddISO8601IntPart(cp, mday, 'D');\n\t\t\tif (hour != 0 || min != 0 || sec != 0 || fsec != 0)\n\t\t\t\t*cp++ = 'T';\n\t\t\tcp = AddISO8601IntPart(cp, hour, 'H');\n\t\t\tcp = AddISO8601IntPart(cp, min, 'M');\n\t\t\tif (sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\tif (sec < 0 || fsec < 0)\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, false);\n\t\t\t\t*cp++ = 'S';\n\t\t\t\t*cp++ = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* Compatible with postgresql < 8.4 when DateStyle = 'iso' */\n\t\tcase INTSTYLE_POSTGRES:\n\t\t\tcp = AddPostgresIntPart(cp, year, \"year\", &is_zero, &is_before);\n\n\t\t\t/*\n\t\t\t * Ideally we should spell out \"month\" like we do for \"year\" and\n\t\t\t * \"day\".  However, for backward compatibility, we can't easily\n\t\t\t * fix this.  bjm 2011-05-24\n\t\t\t */\n\t\t\tcp = AddPostgresIntPart(cp, mon, \"mon\", &is_zero, &is_before);\n\t\t\tcp = AddPostgresIntPart(cp, mday, \"day\", &is_zero, &is_before);\n\t\t\tif (is_zero || hour != 0 || min != 0 || sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\tbool\t\tminus = (hour < 0 || min < 0 || sec < 0 || fsec < 0);\n\n\t\t\t\tsprintf(cp, \"%s%s%02d:%02d:\",\n\t\t\t\t\t\tis_zero ? \"\" : \" \",\n\t\t\t\t\t\t(minus ? \"-\" : (is_before ? \"+\" : \"\")),\n\t\t\t\t\t\tabs(hour), abs(min));\n\t\t\t\tcp += strlen(cp);\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t*cp = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* Compatible with postgresql < 8.4 when DateStyle != 'iso' */\n\t\tcase INTSTYLE_POSTGRES_VERBOSE:\n\t\tdefault:\n\t\t\tstrcpy(cp, \"@\");\n\t\t\tcp++;\n\t\t\tcp = AddVerboseIntPart(cp, year, \"year\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, mon, \"mon\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, mday, \"day\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, hour, \"hour\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, min, \"min\", &is_zero, &is_before);\n\t\t\tif (sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\t*cp++ = ' ';\n\t\t\t\tif (sec < 0 || (sec == 0 && fsec < 0))\n\t\t\t\t{\n\t\t\t\t\tif (is_zero)\n\t\t\t\t\t\tis_before = true;\n\t\t\t\t\telse if (!is_before)\n\t\t\t\t\t\t*cp++ = '-';\n\t\t\t\t}\n\t\t\t\telse if (is_before)\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, false);\n\t\t\t\tsprintf(cp, \" sec%s\",\n\t\t\t\t\t\t(abs(sec) != 1 || fsec != 0) ? \"s\" : \"\");\n\t\t\t\tis_zero = false;\n\t\t\t}\n\t\t\t/* identically zero? then put in a unitless zero... */\n\t\t\tif (is_zero)\n\t\t\t\tstrcat(cp, \" 0\");\n\t\t\tif (is_before)\n\t\t\t\tstrcat(cp, \" ago\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nEncodeInterval(struct pg_tm *tm, fsec_t fsec, int style, char *str)\n{\n\tchar\t   *cp = str;\n\tint\t\t\tyear = tm->tm_year;\n\tint\t\t\tmon = tm->tm_mon;\n\tint\t\t\tmday = tm->tm_mday;\n\tint\t\t\thour = tm->tm_hour;\n\tint\t\t\tmin = tm->tm_min;\n\tint\t\t\tsec = tm->tm_sec;\n\tbool\t\tis_before = false;\n\tbool\t\tis_zero = true;\n\n\t/*\n\t * The sign of year and month are guaranteed to match, since they are\n\t * stored internally as \"month\". But we'll need to check for is_before and\n\t * is_zero when determining the signs of day and hour/minute/seconds\n\t * fields.\n\t */\n\tswitch (style)\n\t{\n\t\t\t/* SQL Standard interval format */\n\t\tcase INTSTYLE_SQL_STANDARD:\n\t\t\t{\n\t\t\t\tbool\t\thas_negative = year < 0 || mon < 0 ||\n\t\t\t\tmday < 0 || hour < 0 ||\n\t\t\t\tmin < 0 || sec < 0 || fsec < 0;\n\t\t\t\tbool\t\thas_positive = year > 0 || mon > 0 ||\n\t\t\t\tmday > 0 || hour > 0 ||\n\t\t\t\tmin > 0 || sec > 0 || fsec > 0;\n\t\t\t\tbool\t\thas_year_month = year != 0 || mon != 0;\n\t\t\t\tbool\t\thas_day_time = mday != 0 || hour != 0 ||\n\t\t\t\tmin != 0 || sec != 0 || fsec != 0;\n\t\t\t\tbool\t\thas_day = mday != 0;\n\t\t\t\tbool\t\tsql_standard_value = !(has_negative && has_positive) &&\n\t\t\t\t!(has_year_month && has_day_time);\n\n\t\t\t\t/*\n\t\t\t\t * SQL Standard wants only 1 \"<sign>\" preceding the whole\n\t\t\t\t * interval ... but can't do that if mixed signs.\n\t\t\t\t */\n\t\t\t\tif (has_negative && sql_standard_value)\n\t\t\t\t{\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\t\tyear = -year;\n\t\t\t\t\tmon = -mon;\n\t\t\t\t\tmday = -mday;\n\t\t\t\t\thour = -hour;\n\t\t\t\t\tmin = -min;\n\t\t\t\t\tsec = -sec;\n\t\t\t\t\tfsec = -fsec;\n\t\t\t\t}\n\n\t\t\t\tif (!has_negative && !has_positive)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"0\");\n\t\t\t\t}\n\t\t\t\telse if (!sql_standard_value)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * For non sql-standard interval values, force outputting\n\t\t\t\t\t * the signs to avoid ambiguities with intervals with\n\t\t\t\t\t * mixed sign components.\n\t\t\t\t\t */\n\t\t\t\t\tchar\t\tyear_sign = (year < 0 || mon < 0) ? '-' : '+';\n\t\t\t\t\tchar\t\tday_sign = (mday < 0) ? '-' : '+';\n\t\t\t\t\tchar\t\tsec_sign = (hour < 0 || min < 0 ||\n\t\t\t\t\t\t\t\t\t\t\tsec < 0 || fsec < 0) ? '-' : '+';\n\n\t\t\t\t\tsprintf(cp, \"%c%d-%d %c%d %c%d:%02d:\",\n\t\t\t\t\t\t\tyear_sign, abs(year), abs(mon),\n\t\t\t\t\t\t\tday_sign, abs(mday),\n\t\t\t\t\t\t\tsec_sign, abs(hour), abs(min));\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t\telse if (has_year_month)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d-%d\", year, mon);\n\t\t\t\t}\n\t\t\t\telse if (has_day)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d %d:%02d:\", mday, hour, min);\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d:%02d:\", hour, min);\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* ISO 8601 \"time-intervals by duration only\" */\n\t\tcase INTSTYLE_ISO_8601:\n\t\t\t/* special-case zero to avoid printing nothing */\n\t\t\tif (year == 0 && mon == 0 && mday == 0 &&\n\t\t\t\thour == 0 && min == 0 && sec == 0 && fsec == 0)\n\t\t\t{\n\t\t\t\tsprintf(cp, \"PT0S\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*cp++ = 'P';\n\t\t\tcp = AddISO8601IntPart(cp, year, 'Y');\n\t\t\tcp = AddISO8601IntPart(cp, mon, 'M');\n\t\t\tcp = AddISO8601IntPart(cp, mday, 'D');\n\t\t\tif (hour != 0 || min != 0 || sec != 0 || fsec != 0)\n\t\t\t\t*cp++ = 'T';\n\t\t\tcp = AddISO8601IntPart(cp, hour, 'H');\n\t\t\tcp = AddISO8601IntPart(cp, min, 'M');\n\t\t\tif (sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\tif (sec < 0 || fsec < 0)\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, false);\n\t\t\t\t*cp++ = 'S';\n\t\t\t\t*cp++ = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* Compatible with postgresql < 8.4 when DateStyle = 'iso' */\n\t\tcase INTSTYLE_POSTGRES:\n\t\t\tcp = AddPostgresIntPart(cp, year, \"year\", &is_zero, &is_before);\n\n\t\t\t/*\n\t\t\t * Ideally we should spell out \"month\" like we do for \"year\" and\n\t\t\t * \"day\".  However, for backward compatibility, we can't easily\n\t\t\t * fix this.  bjm 2011-05-24\n\t\t\t */\n\t\t\tcp = AddPostgresIntPart(cp, mon, \"mon\", &is_zero, &is_before);\n\t\t\tcp = AddPostgresIntPart(cp, mday, \"day\", &is_zero, &is_before);\n\t\t\tif (is_zero || hour != 0 || min != 0 || sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\tbool\t\tminus = (hour < 0 || min < 0 || sec < 0 || fsec < 0);\n\n\t\t\t\tsprintf(cp, \"%s%s%02d:%02d:\",\n\t\t\t\t\t\tis_zero ? \"\" : \" \",\n\t\t\t\t\t\t(minus ? \"-\" : (is_before ? \"+\" : \"\")),\n\t\t\t\t\t\tabs(hour), abs(min));\n\t\t\t\tcp += strlen(cp);\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t*cp = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* Compatible with postgresql < 8.4 when DateStyle != 'iso' */\n\t\tcase INTSTYLE_POSTGRES_VERBOSE:\n\t\tdefault:\n\t\t\tstrcpy(cp, \"@\");\n\t\t\tcp++;\n\t\t\tcp = AddVerboseIntPart(cp, year, \"year\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, mon, \"mon\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, mday, \"day\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, hour, \"hour\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, min, \"min\", &is_zero, &is_before);\n\t\t\tif (sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\t*cp++ = ' ';\n\t\t\t\tif (sec < 0 || (sec == 0 && fsec < 0))\n\t\t\t\t{\n\t\t\t\t\tif (is_zero)\n\t\t\t\t\t\tis_before = true;\n\t\t\t\t\telse if (!is_before)\n\t\t\t\t\t\t*cp++ = '-';\n\t\t\t\t}\n\t\t\t\telse if (is_before)\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, false);\n\t\t\t\tsprintf(cp, \" sec%s\",\n\t\t\t\t\t\t(abs(sec) != 1 || fsec != 0) ? \"s\" : \"\");\n\t\t\t\tis_zero = false;\n\t\t\t}\n\t\t\t/* identically zero? then put in a unitless zero... */\n\t\t\tif (is_zero)\n\t\t\t\tstrcat(cp, \" 0\");\n\t\t\tif (is_before)\n\t\t\t\tstrcat(cp, \" ago\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not convert interval to tm\""
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "interval2tm",
          "args": [
            "*span",
            "tm",
            "&fsec"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "interval2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1901-1927",
          "snippet": "int\ninterval2tm(Interval span, struct pg_tm *tm, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\tTimeOffset\ttfrac;\n\n\ttm->tm_year = span.month / MONTHS_PER_YEAR;\n\ttm->tm_mon = span.month % MONTHS_PER_YEAR;\n\ttm->tm_mday = span.day;\n\ttime = span.time;\n\n\ttfrac = time / USECS_PER_HOUR;\n\ttime -= tfrac * USECS_PER_HOUR;\n\ttm->tm_hour = tfrac;\n\tif (!SAMESIGN(tm->tm_hour, tfrac))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\ttfrac = time / USECS_PER_MINUTE;\n\ttime -= tfrac * USECS_PER_MINUTE;\n\ttm->tm_min = tfrac;\n\ttfrac = time / USECS_PER_SEC;\n\t*fsec = time - (tfrac * USECS_PER_SEC);\n\ttm->tm_sec = tfrac;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ninterval2tm(Interval span, struct pg_tm *tm, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\tTimeOffset\ttfrac;\n\n\ttm->tm_year = span.month / MONTHS_PER_YEAR;\n\ttm->tm_mon = span.month % MONTHS_PER_YEAR;\n\ttm->tm_mday = span.day;\n\ttime = span.time;\n\n\ttfrac = time / USECS_PER_HOUR;\n\ttime -= tfrac * USECS_PER_HOUR;\n\ttm->tm_hour = tfrac;\n\tif (!SAMESIGN(tm->tm_hour, tfrac))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\ttfrac = time / USECS_PER_MINUTE;\n\ttime -= tfrac * USECS_PER_MINUTE;\n\ttm->tm_min = tfrac;\n\ttfrac = time / USECS_PER_SEC;\n\t*fsec = time - (tfrac * USECS_PER_SEC);\n\ttm->tm_sec = tfrac;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nDatum\ninterval_out(PG_FUNCTION_ARGS)\n{\n\tInterval   *span = PG_GETARG_INTERVAL_P(0);\n\tchar\t   *result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\n\tif (interval2tm(*span, tm, &fsec) != 0)\n\t\telog(ERROR, \"could not convert interval to tm\");\n\n\tEncodeInterval(tm, fsec, IntervalStyle, buf);\n\n\tresult = pstrdup(buf);\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "interval_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "875-952",
    "snippet": "Datum\ninterval_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tInterval   *result;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tint\t\t\trange;\n\tint\t\t\tdterr;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tworkbuf[256];\n\n\ttm->tm_year = 0;\n\ttm->tm_mon = 0;\n\ttm->tm_mday = 0;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\tfsec = 0;\n\n\tif (typmod >= 0)\n\t\trange = INTERVAL_RANGE(typmod);\n\telse\n\t\trange = INTERVAL_FULL_RANGE;\n\n\tdterr = ParseDateTime(str, workbuf, sizeof(workbuf), field,\n\t\t\t\t\t\t  ftype, MAXDATEFIELDS, &nf);\n\tif (dterr == 0)\n\t\tdterr = DecodeInterval(field, ftype, nf, range,\n\t\t\t\t\t\t\t   &dtype, tm, &fsec);\n\n\t/* if those functions think it's a bad format, try ISO8601 style */\n\tif (dterr == DTERR_BAD_FORMAT)\n\t\tdterr = DecodeISO8601Interval(str,\n\t\t\t\t\t\t\t\t\t  &dtype, tm, &fsec);\n\n\tif (dterr != 0)\n\t{\n\t\tif (dterr == DTERR_FIELD_OVERFLOW)\n\t\t\tdterr = DTERR_INTERVAL_OVERFLOW;\n\t\tDateTimeParseError(dterr, str, \"interval\");\n\t}\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DELTA:\n\t\t\tif (tm2interval(tm, fsec, result) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"interval out of range\")));\n\t\t\tbreak;\n\n\t\tcase DTK_INVALID:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"date/time value \\\"%s\\\" is no longer supported\", str)));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected dtype %d while parsing interval \\\"%s\\\"\",\n\t\t\t\t dtype, str);\n\t}\n\n\tAdjustIntervalForTypmod(result, typmod);\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustIntervalForTypmod",
          "args": [
            "result",
            "typmod"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustIntervalForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1319-1481",
          "snippet": "static void\nAdjustIntervalForTypmod(Interval *interval, int32 typmod)\n{\n\tstatic const int64 IntervalScales[MAX_INTERVAL_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 IntervalOffsets[MAX_INTERVAL_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\t/*\n\t * Unspecified range and precision? Then not necessary to adjust. Setting\n\t * typmod to -1 is the convention for all data types.\n\t */\n\tif (typmod >= 0)\n\t{\n\t\tint\t\t\trange = INTERVAL_RANGE(typmod);\n\t\tint\t\t\tprecision = INTERVAL_PRECISION(typmod);\n\n\t\t/*\n\t\t * Our interpretation of intervals with a limited set of fields is\n\t\t * that fields to the right of the last one specified are zeroed out,\n\t\t * but those to the left of it remain valid.  Thus for example there\n\t\t * is no operational difference between INTERVAL YEAR TO MONTH and\n\t\t * INTERVAL MONTH.  In some cases we could meaningfully enforce that\n\t\t * higher-order fields are zero; for example INTERVAL DAY could reject\n\t\t * nonzero \"month\" field.  However that seems a bit pointless when we\n\t\t * can't do it consistently.  (We cannot enforce a range limit on the\n\t\t * highest expected field, since we do not have any equivalent of\n\t\t * SQL's <interval leading field precision>.)  If we ever decide to\n\t\t * revisit this, interval_transform will likely require adjusting.\n\t\t *\n\t\t * Note: before PG 8.4 we interpreted a limited set of fields as\n\t\t * actually causing a \"modulo\" operation on a given value, potentially\n\t\t * losing high-order as well as low-order information.  But there is\n\t\t * no support for such behavior in the standard, and it seems fairly\n\t\t * undesirable on data consistency grounds anyway.  Now we only\n\t\t * perform truncation or rounding of low-order fields.\n\t\t */\n\t\tif (range == INTERVAL_FULL_RANGE)\n\t\t{\n\t\t\t/* Do nothing... */\n\t\t}\n\t\telse if (range == INTERVAL_MASK(YEAR))\n\t\t{\n\t\t\tinterval->month = (interval->month / MONTHS_PER_YEAR) * MONTHS_PER_YEAR;\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(MONTH))\n\t\t{\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\t/* YEAR TO MONTH */\n\t\telse if (range == (INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH)))\n\t\t{\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(DAY))\n\t\t{\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(HOUR))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_HOUR) *\n\t\t\t\tUSECS_PER_HOUR;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(MINUTE))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(SECOND))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* DAY TO HOUR */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_HOUR) *\n\t\t\t\tUSECS_PER_HOUR;\n\t\t}\n\t\t/* DAY TO MINUTE */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\t/* DAY TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* HOUR TO MINUTE */\n\t\telse if (range == (INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\t/* HOUR TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* MINUTE TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unrecognized interval typmod: %d\", typmod);\n\n\t\t/* Need to adjust sub-second precision? */\n\t\tif (precision != INTERVAL_FULL_PRECISION)\n\t\t{\n\t\t\tif (precision < 0 || precision > MAX_INTERVAL_PRECISION)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"interval(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\t\tprecision, 0, MAX_INTERVAL_PRECISION)));\n\n\t\t\tif (interval->time >= INT64CONST(0))\n\t\t\t{\n\t\t\t\tinterval->time = ((interval->time +\n\t\t\t\t\t\t\t\t   IntervalOffsets[precision]) /\n\t\t\t\t\t\t\t\t  IntervalScales[precision]) *\n\t\t\t\t\tIntervalScales[precision];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinterval->time = -(((-interval->time +\n\t\t\t\t\t\t\t\t\t IntervalOffsets[precision]) /\n\t\t\t\t\t\t\t\t\tIntervalScales[precision]) *\n\t\t\t\t\t\t\t\t   IntervalScales[precision]);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
            "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nstatic void\nAdjustIntervalForTypmod(Interval *interval, int32 typmod)\n{\n\tstatic const int64 IntervalScales[MAX_INTERVAL_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 IntervalOffsets[MAX_INTERVAL_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\t/*\n\t * Unspecified range and precision? Then not necessary to adjust. Setting\n\t * typmod to -1 is the convention for all data types.\n\t */\n\tif (typmod >= 0)\n\t{\n\t\tint\t\t\trange = INTERVAL_RANGE(typmod);\n\t\tint\t\t\tprecision = INTERVAL_PRECISION(typmod);\n\n\t\t/*\n\t\t * Our interpretation of intervals with a limited set of fields is\n\t\t * that fields to the right of the last one specified are zeroed out,\n\t\t * but those to the left of it remain valid.  Thus for example there\n\t\t * is no operational difference between INTERVAL YEAR TO MONTH and\n\t\t * INTERVAL MONTH.  In some cases we could meaningfully enforce that\n\t\t * higher-order fields are zero; for example INTERVAL DAY could reject\n\t\t * nonzero \"month\" field.  However that seems a bit pointless when we\n\t\t * can't do it consistently.  (We cannot enforce a range limit on the\n\t\t * highest expected field, since we do not have any equivalent of\n\t\t * SQL's <interval leading field precision>.)  If we ever decide to\n\t\t * revisit this, interval_transform will likely require adjusting.\n\t\t *\n\t\t * Note: before PG 8.4 we interpreted a limited set of fields as\n\t\t * actually causing a \"modulo\" operation on a given value, potentially\n\t\t * losing high-order as well as low-order information.  But there is\n\t\t * no support for such behavior in the standard, and it seems fairly\n\t\t * undesirable on data consistency grounds anyway.  Now we only\n\t\t * perform truncation or rounding of low-order fields.\n\t\t */\n\t\tif (range == INTERVAL_FULL_RANGE)\n\t\t{\n\t\t\t/* Do nothing... */\n\t\t}\n\t\telse if (range == INTERVAL_MASK(YEAR))\n\t\t{\n\t\t\tinterval->month = (interval->month / MONTHS_PER_YEAR) * MONTHS_PER_YEAR;\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(MONTH))\n\t\t{\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\t/* YEAR TO MONTH */\n\t\telse if (range == (INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH)))\n\t\t{\n\t\t\tinterval->day = 0;\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(DAY))\n\t\t{\n\t\t\tinterval->time = 0;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(HOUR))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_HOUR) *\n\t\t\t\tUSECS_PER_HOUR;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(MINUTE))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\telse if (range == INTERVAL_MASK(SECOND))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* DAY TO HOUR */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_HOUR) *\n\t\t\t\tUSECS_PER_HOUR;\n\t\t}\n\t\t/* DAY TO MINUTE */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\t/* DAY TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(DAY) |\n\t\t\t\t\t\t   INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* HOUR TO MINUTE */\n\t\telse if (range == (INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE)))\n\t\t{\n\t\t\tinterval->time = (interval->time / USECS_PER_MINUTE) *\n\t\t\t\tUSECS_PER_MINUTE;\n\t\t}\n\t\t/* HOUR TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(HOUR) |\n\t\t\t\t\t\t   INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\t/* MINUTE TO SECOND */\n\t\telse if (range == (INTERVAL_MASK(MINUTE) |\n\t\t\t\t\t\t   INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\t/* fractional-second rounding will be dealt with below */\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unrecognized interval typmod: %d\", typmod);\n\n\t\t/* Need to adjust sub-second precision? */\n\t\tif (precision != INTERVAL_FULL_PRECISION)\n\t\t{\n\t\t\tif (precision < 0 || precision > MAX_INTERVAL_PRECISION)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"interval(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\t\tprecision, 0, MAX_INTERVAL_PRECISION)));\n\n\t\t\tif (interval->time >= INT64CONST(0))\n\t\t\t{\n\t\t\t\tinterval->time = ((interval->time +\n\t\t\t\t\t\t\t\t   IntervalOffsets[precision]) /\n\t\t\t\t\t\t\t\t  IntervalScales[precision]) *\n\t\t\t\t\tIntervalScales[precision];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinterval->time = -(((-interval->time +\n\t\t\t\t\t\t\t\t\t IntervalOffsets[precision]) /\n\t\t\t\t\t\t\t\t\tIntervalScales[precision]) *\n\t\t\t\t\t\t\t\t   IntervalScales[precision]);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected dtype %d while parsing interval \\\"%s\\\"\"",
            "dtype",
            "str"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"date/time value \\\"%s\\\" is no longer supported\", str))"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"date/time value \\\"%s\\\" is no longer supported\"",
            "str"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"interval out of range\"))"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm2interval",
          "args": [
            "tm",
            "fsec",
            "result"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "tm2interval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1929-1943",
          "snippet": "int\ntm2interval(struct pg_tm *tm, fsec_t fsec, Interval *span)\n{\n\tdouble\t\ttotal_months = (double) tm->tm_year * MONTHS_PER_YEAR + tm->tm_mon;\n\n\tif (total_months > INT_MAX || total_months < INT_MIN)\n\t\treturn -1;\n\tspan->month = total_months;\n\tspan->day = tm->tm_mday;\n\tspan->time = (((((tm->tm_hour * INT64CONST(60)) +\n\t\t\t\t\t tm->tm_min) * INT64CONST(60)) +\n\t\t\t\t   tm->tm_sec) * USECS_PER_SEC) + fsec;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2interval(struct pg_tm *tm, fsec_t fsec, Interval *span)\n{\n\tdouble\t\ttotal_months = (double) tm->tm_year * MONTHS_PER_YEAR + tm->tm_mon;\n\n\tif (total_months > INT_MAX || total_months < INT_MIN)\n\t\treturn -1;\n\tspan->month = total_months;\n\tspan->day = tm->tm_mday;\n\tspan->time = (((((tm->tm_hour * INT64CONST(60)) +\n\t\t\t\t\t tm->tm_min) * INT64CONST(60)) +\n\t\t\t\t   tm->tm_sec) * USECS_PER_SEC) + fsec;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DateTimeParseError",
          "args": [
            "dterr",
            "str",
            "\"interval\""
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeParseError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3753-3792",
          "snippet": "void\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeISO8601Interval",
          "args": [
            "str",
            "&dtype",
            "tm",
            "&fsec"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeISO8601Interval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3507-3703",
          "snippet": "int\nDecodeISO8601Interval(char *str,\n\t\t\t\t\t  int *dtype, struct pg_tm *tm, fsec_t *fsec)\n{\n\tbool\t\tdatepart = true;\n\tbool\t\thavefield = false;\n\n\t*dtype = DTK_DELTA;\n\tClearPgTm(tm, fsec);\n\n\tif (strlen(str) < 2 || str[0] != 'P')\n\t\treturn DTERR_BAD_FORMAT;\n\n\tstr++;\n\twhile (*str)\n\t{\n\t\tchar\t   *fieldstart;\n\t\tint\t\t\tval;\n\t\tdouble\t\tfval;\n\t\tchar\t\tunit;\n\t\tint\t\t\tdterr;\n\n\t\tif (*str == 'T')\t\t/* T indicates the beginning of the time part */\n\t\t{\n\t\t\tdatepart = false;\n\t\t\thavefield = false;\n\t\t\tstr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfieldstart = str;\n\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\n\t\t/*\n\t\t * Note: we could step off the end of the string here.  Code below\n\t\t * *must* exit the loop if unit == '\\0'.\n\t\t */\n\t\tunit = *str++;\n\n\t\tif (datepart)\n\t\t{\n\t\t\tswitch (unit)\t\t/* before T: Y M W D */\n\t\t\t{\n\t\t\t\tcase 'Y':\n\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\ttm->tm_mon += (fval * MONTHS_PER_YEAR);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\ttm->tm_mday += val * 7;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, 7);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T':\t\t/* ISO 8601 4.4.3.3 Alternative Format / Basic */\n\t\t\t\tcase '\\0':\n\t\t\t\t\tif (ISO8601IntegerWidth(fieldstart) == 8 && !havefield)\n\t\t\t\t\t{\n\t\t\t\t\t\ttm->tm_year += val / 10000;\n\t\t\t\t\t\ttm->tm_mon += (val / 100) % 100;\n\t\t\t\t\t\ttm->tm_mday += val % 100;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/* Else fall through to extended alternative format */\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase '-':\t\t/* ISO 8601 4.4.3.3 Alternative Format,\n\t\t\t\t\t\t\t\t * Extended */\n\t\t\t\t\tif (havefield)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\ttm->tm_mon += (fval * MONTHS_PER_YEAR);\n\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (unit == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (*str != '-')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tstr++;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\tdefault:\n\t\t\t\t\t/* not a valid date unit suffix */\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch (unit)\t\t/* after T: H M S */\n\t\t\t{\n\t\t\t\tcase 'H':\n\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\0':\t\t/* ISO 8601 4.4.3.3 Alternative Format */\n\t\t\t\t\tif (ISO8601IntegerWidth(fieldstart) == 6 && !havefield)\n\t\t\t\t\t{\n\t\t\t\t\t\ttm->tm_hour += val / 10000;\n\t\t\t\t\t\ttm->tm_min += (val / 100) % 100;\n\t\t\t\t\t\ttm->tm_sec += val % 100;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* Else fall through to extended alternative format */\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase ':':\t\t/* ISO 8601 4.4.3.3 Alternative Format,\n\t\t\t\t\t\t\t\t * Extended */\n\t\t\t\t\tif (havefield)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str != ':')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tstr++;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* not a valid time unit suffix */\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t}\n\n\t\thavefield = true;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDecodeISO8601Interval(char *str,\n\t\t\t\t\t  int *dtype, struct pg_tm *tm, fsec_t *fsec)\n{\n\tbool\t\tdatepart = true;\n\tbool\t\thavefield = false;\n\n\t*dtype = DTK_DELTA;\n\tClearPgTm(tm, fsec);\n\n\tif (strlen(str) < 2 || str[0] != 'P')\n\t\treturn DTERR_BAD_FORMAT;\n\n\tstr++;\n\twhile (*str)\n\t{\n\t\tchar\t   *fieldstart;\n\t\tint\t\t\tval;\n\t\tdouble\t\tfval;\n\t\tchar\t\tunit;\n\t\tint\t\t\tdterr;\n\n\t\tif (*str == 'T')\t\t/* T indicates the beginning of the time part */\n\t\t{\n\t\t\tdatepart = false;\n\t\t\thavefield = false;\n\t\t\tstr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfieldstart = str;\n\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\n\t\t/*\n\t\t * Note: we could step off the end of the string here.  Code below\n\t\t * *must* exit the loop if unit == '\\0'.\n\t\t */\n\t\tunit = *str++;\n\n\t\tif (datepart)\n\t\t{\n\t\t\tswitch (unit)\t\t/* before T: Y M W D */\n\t\t\t{\n\t\t\t\tcase 'Y':\n\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\ttm->tm_mon += (fval * MONTHS_PER_YEAR);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\ttm->tm_mday += val * 7;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, 7);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T':\t\t/* ISO 8601 4.4.3.3 Alternative Format / Basic */\n\t\t\t\tcase '\\0':\n\t\t\t\t\tif (ISO8601IntegerWidth(fieldstart) == 8 && !havefield)\n\t\t\t\t\t{\n\t\t\t\t\t\ttm->tm_year += val / 10000;\n\t\t\t\t\t\ttm->tm_mon += (val / 100) % 100;\n\t\t\t\t\t\ttm->tm_mday += val % 100;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/* Else fall through to extended alternative format */\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase '-':\t\t/* ISO 8601 4.4.3.3 Alternative Format,\n\t\t\t\t\t\t\t\t * Extended */\n\t\t\t\t\tif (havefield)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\ttm->tm_mon += (fval * MONTHS_PER_YEAR);\n\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (unit == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (*str != '-')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tstr++;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\tdefault:\n\t\t\t\t\t/* not a valid date unit suffix */\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch (unit)\t\t/* after T: H M S */\n\t\t\t{\n\t\t\t\tcase 'H':\n\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\0':\t\t/* ISO 8601 4.4.3.3 Alternative Format */\n\t\t\t\t\tif (ISO8601IntegerWidth(fieldstart) == 6 && !havefield)\n\t\t\t\t\t{\n\t\t\t\t\t\ttm->tm_hour += val / 10000;\n\t\t\t\t\t\ttm->tm_min += (val / 100) % 100;\n\t\t\t\t\t\ttm->tm_sec += val % 100;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* Else fall through to extended alternative format */\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase ':':\t\t/* ISO 8601 4.4.3.3 Alternative Format,\n\t\t\t\t\t\t\t\t * Extended */\n\t\t\t\t\tif (havefield)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str != ':')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tstr++;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* not a valid time unit suffix */\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t}\n\n\t\thavefield = true;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeInterval",
          "args": [
            "field",
            "ftype",
            "nf",
            "range",
            "&dtype",
            "tm",
            "&fsec"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeInterval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3081-3443",
          "snippet": "int\nDecodeInterval(char **field, int *ftype, int nf, int range,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec)\n{\n\tbool\t\tis_before = false;\n\tchar\t   *cp;\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\ti;\n\tint\t\t\tdterr;\n\tint\t\t\tval;\n\tdouble\t\tfval;\n\n\t*dtype = DTK_DELTA;\n\ttype = IGNORE_DTF;\n\tClearPgTm(tm, fsec);\n\n\t/* read through list backwards to pick up units before values */\n\tfor (i = nf - 1; i >= 0; i--)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_TIME:\n\t\t\t\tdterr = DecodeTime(field[i], fmask, range,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\t\t\t\ttype = DTK_DAY;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\n\t\t\t\t/*\n\t\t\t\t * Timezone means a token with a leading sign character and at\n\t\t\t\t * least one digit; there could be ':', '.', '-' embedded in\n\t\t\t\t * it as well.\n\t\t\t\t */\n\t\t\t\tAssert(*field[i] == '-' || *field[i] == '+');\n\n\t\t\t\t/*\n\t\t\t\t * Check for signed hh:mm or hh:mm:ss.  If so, process exactly\n\t\t\t\t * like DTK_TIME case above, plus handling the sign.\n\t\t\t\t */\n\t\t\t\tif (strchr(field[i] + 1, ':') != NULL &&\n\t\t\t\t\tDecodeTime(field[i] + 1, fmask, range,\n\t\t\t\t\t\t\t   &tmask, tm, fsec) == 0)\n\t\t\t\t{\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* flip the sign on all fields */\n\t\t\t\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\t\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\t\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\t\t\t\t*fsec = -(*fsec);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set the next type to be a day, if units are not\n\t\t\t\t\t * specified. This handles the case of '1 +02:03' since we\n\t\t\t\t\t * are reading right to left.\n\t\t\t\t\t */\n\t\t\t\t\ttype = DTK_DAY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Otherwise, fall through to DTK_NUMBER case, which can\n\t\t\t\t * handle signed float numbers and signed year-month values.\n\t\t\t\t */\n\n\t\t\t\t/* FALLTHROUGH */\n\n\t\t\tcase DTK_DATE:\n\t\t\tcase DTK_NUMBER:\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t{\n\t\t\t\t\t/* use typmod to decide what rightmost field is */\n\t\t\t\t\tswitch (range)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase INTERVAL_MASK(YEAR):\n\t\t\t\t\t\t\ttype = DTK_YEAR;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(MONTH):\n\t\t\t\t\t\tcase INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):\n\t\t\t\t\t\t\ttype = DTK_MONTH;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY):\n\t\t\t\t\t\t\ttype = DTK_DAY;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):\n\t\t\t\t\t\t\ttype = DTK_HOUR;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\t\ttype = DTK_MINUTE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\t\ttype = DTK_SECOND;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ttype = DTK_SECOND;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\terrno = 0;\n\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\tif (*cp == '-')\n\t\t\t\t{\n\t\t\t\t\t/* SQL \"years-months\" syntax */\n\t\t\t\t\tint\t\t\tval2;\n\n\t\t\t\t\tval2 = strtoint(cp + 1, &cp, 10);\n\t\t\t\t\tif (errno == ERANGE || val2 < 0 || val2 >= MONTHS_PER_YEAR)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\tif (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\ttype = DTK_MONTH;\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t\tval2 = -val2;\n\t\t\t\t\tif (((double) val * MONTHS_PER_YEAR + val2) > INT_MAX ||\n\t\t\t\t\t\t((double) val * MONTHS_PER_YEAR + val2) < INT_MIN)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\tval = val * MONTHS_PER_YEAR + val2;\n\t\t\t\t\tfval = 0;\n\t\t\t\t}\n\t\t\t\telse if (*cp == '.')\n\t\t\t\t{\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tfval = strtod(cp, &cp);\n\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t\tfval = -fval;\n\t\t\t\t}\n\t\t\t\telse if (*cp == '\\0')\n\t\t\t\t\tfval = 0;\n\t\t\t\telse\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\ttmask = 0;\t\t/* DTK_M(type); */\n\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase DTK_MICROSEC:\n\t\t\t\t\t\t*fsec += rint(val + fval);\n\t\t\t\t\t\ttmask = DTK_M(MICROSECOND);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MILLISEC:\n\t\t\t\t\t\t/* avoid overflowing the fsec field */\n\t\t\t\t\t\ttm->tm_sec += val / 1000;\n\t\t\t\t\t\tval -= (val / 1000) * 1000;\n\t\t\t\t\t\t*fsec += rint((val + fval) * 1000);\n\t\t\t\t\t\ttmask = DTK_M(MILLISECOND);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\t\t*fsec += rint(fval * 1000000);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If any subseconds were specified, consider this\n\t\t\t\t\t\t * microsecond and millisecond input as well.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (fval == 0)\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\ttype = DTK_DAY; /* set for next field */\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_WEEK:\n\t\t\t\t\t\ttm->tm_mday += val * 7;\n\t\t\t\t\t\tAdjustFractDays(fval, tm, fsec, 7);\n\t\t\t\t\t\ttmask = DTK_M(WEEK);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MONTH:\n\t\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR;\n\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_DECADE:\n\t\t\t\t\t\ttm->tm_year += val * 10;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 10;\n\t\t\t\t\t\ttmask = DTK_M(DECADE);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_CENTURY:\n\t\t\t\t\t\ttm->tm_year += val * 100;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 100;\n\t\t\t\t\t\ttmask = DTK_M(CENTURY);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MILLENNIUM:\n\t\t\t\t\t\ttm->tm_year += val * 1000;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 1000;\n\t\t\t\t\t\ttmask = DTK_M(MILLENNIUM);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\ttype = DecodeUnits(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = 0;\t\t/* DTK_M(type); */\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AGO:\n\t\t\t\t\t\tis_before = true;\n\t\t\t\t\t\ttype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\ttmask = (DTK_DATE_M | DTK_TIME_M);\n\t\t\t\t\t\t*dtype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\n\n\t/* ensure that at least one time field has been found */\n\tif (fmask == 0)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* ensure fractional seconds are fractional */\n\tif (*fsec != 0)\n\t{\n\t\tint\t\t\tsec;\n\n\t\tsec = *fsec / USECS_PER_SEC;\n\t\t*fsec -= sec * USECS_PER_SEC;\n\t\ttm->tm_sec += sec;\n\t}\n\n\t/*----------\n\t * The SQL standard defines the interval literal\n\t *\t '-1 1:00:00'\n\t * to mean \"negative 1 days and negative 1 hours\", while Postgres\n\t * traditionally treats this as meaning \"negative 1 days and positive\n\t * 1 hours\".  In SQL_STANDARD intervalstyle, we apply the leading sign\n\t * to all fields if there are no other explicit signs.\n\t *\n\t * We leave the signs alone if there are additional explicit signs.\n\t * This protects us against misinterpreting postgres-style dump output,\n\t * since the postgres-style output code has always put an explicit sign on\n\t * all fields following a negative field.  But note that SQL-spec output\n\t * is ambiguous and can be misinterpreted on load!\t(So it's best practice\n\t * to dump in postgres style, not SQL style.)\n\t *----------\n\t */\n\tif (IntervalStyle == INTSTYLE_SQL_STANDARD && *field[0] == '-')\n\t{\n\t\t/* Check for additional explicit signs */\n\t\tbool\t\tmore_signs = false;\n\n\t\tfor (i = 1; i < nf; i++)\n\t\t{\n\t\t\tif (*field[i] == '-' || *field[i] == '+')\n\t\t\t{\n\t\t\t\tmore_signs = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!more_signs)\n\t\t{\n\t\t\t/*\n\t\t\t * Rather than re-determining which field was field[0], just force\n\t\t\t * 'em all negative.\n\t\t\t */\n\t\t\tif (*fsec > 0)\n\t\t\t\t*fsec = -(*fsec);\n\t\t\tif (tm->tm_sec > 0)\n\t\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\tif (tm->tm_min > 0)\n\t\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\tif (tm->tm_hour > 0)\n\t\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\tif (tm->tm_mday > 0)\n\t\t\t\ttm->tm_mday = -tm->tm_mday;\n\t\t\tif (tm->tm_mon > 0)\n\t\t\t\ttm->tm_mon = -tm->tm_mon;\n\t\t\tif (tm->tm_year > 0)\n\t\t\t\ttm->tm_year = -tm->tm_year;\n\t\t}\n\t}\n\n\t/* finally, AGO negates everything */\n\tif (is_before)\n\t{\n\t\t*fsec = -(*fsec);\n\t\ttm->tm_sec = -tm->tm_sec;\n\t\ttm->tm_min = -tm->tm_min;\n\t\ttm->tm_hour = -tm->tm_hour;\n\t\ttm->tm_mday = -tm->tm_mday;\n\t\ttm->tm_mon = -tm->tm_mon;\n\t\ttm->tm_year = -tm->tm_year;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "const char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};",
            "const char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nconst char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};\nconst char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};\n\nint\nDecodeInterval(char **field, int *ftype, int nf, int range,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec)\n{\n\tbool\t\tis_before = false;\n\tchar\t   *cp;\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\ti;\n\tint\t\t\tdterr;\n\tint\t\t\tval;\n\tdouble\t\tfval;\n\n\t*dtype = DTK_DELTA;\n\ttype = IGNORE_DTF;\n\tClearPgTm(tm, fsec);\n\n\t/* read through list backwards to pick up units before values */\n\tfor (i = nf - 1; i >= 0; i--)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_TIME:\n\t\t\t\tdterr = DecodeTime(field[i], fmask, range,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\t\t\t\ttype = DTK_DAY;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\n\t\t\t\t/*\n\t\t\t\t * Timezone means a token with a leading sign character and at\n\t\t\t\t * least one digit; there could be ':', '.', '-' embedded in\n\t\t\t\t * it as well.\n\t\t\t\t */\n\t\t\t\tAssert(*field[i] == '-' || *field[i] == '+');\n\n\t\t\t\t/*\n\t\t\t\t * Check for signed hh:mm or hh:mm:ss.  If so, process exactly\n\t\t\t\t * like DTK_TIME case above, plus handling the sign.\n\t\t\t\t */\n\t\t\t\tif (strchr(field[i] + 1, ':') != NULL &&\n\t\t\t\t\tDecodeTime(field[i] + 1, fmask, range,\n\t\t\t\t\t\t\t   &tmask, tm, fsec) == 0)\n\t\t\t\t{\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* flip the sign on all fields */\n\t\t\t\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\t\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\t\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\t\t\t\t*fsec = -(*fsec);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set the next type to be a day, if units are not\n\t\t\t\t\t * specified. This handles the case of '1 +02:03' since we\n\t\t\t\t\t * are reading right to left.\n\t\t\t\t\t */\n\t\t\t\t\ttype = DTK_DAY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Otherwise, fall through to DTK_NUMBER case, which can\n\t\t\t\t * handle signed float numbers and signed year-month values.\n\t\t\t\t */\n\n\t\t\t\t/* FALLTHROUGH */\n\n\t\t\tcase DTK_DATE:\n\t\t\tcase DTK_NUMBER:\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t{\n\t\t\t\t\t/* use typmod to decide what rightmost field is */\n\t\t\t\t\tswitch (range)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase INTERVAL_MASK(YEAR):\n\t\t\t\t\t\t\ttype = DTK_YEAR;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(MONTH):\n\t\t\t\t\t\tcase INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):\n\t\t\t\t\t\t\ttype = DTK_MONTH;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY):\n\t\t\t\t\t\t\ttype = DTK_DAY;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):\n\t\t\t\t\t\t\ttype = DTK_HOUR;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\t\ttype = DTK_MINUTE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\t\ttype = DTK_SECOND;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ttype = DTK_SECOND;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\terrno = 0;\n\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\tif (*cp == '-')\n\t\t\t\t{\n\t\t\t\t\t/* SQL \"years-months\" syntax */\n\t\t\t\t\tint\t\t\tval2;\n\n\t\t\t\t\tval2 = strtoint(cp + 1, &cp, 10);\n\t\t\t\t\tif (errno == ERANGE || val2 < 0 || val2 >= MONTHS_PER_YEAR)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\tif (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\ttype = DTK_MONTH;\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t\tval2 = -val2;\n\t\t\t\t\tif (((double) val * MONTHS_PER_YEAR + val2) > INT_MAX ||\n\t\t\t\t\t\t((double) val * MONTHS_PER_YEAR + val2) < INT_MIN)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\tval = val * MONTHS_PER_YEAR + val2;\n\t\t\t\t\tfval = 0;\n\t\t\t\t}\n\t\t\t\telse if (*cp == '.')\n\t\t\t\t{\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tfval = strtod(cp, &cp);\n\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t\tfval = -fval;\n\t\t\t\t}\n\t\t\t\telse if (*cp == '\\0')\n\t\t\t\t\tfval = 0;\n\t\t\t\telse\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\ttmask = 0;\t\t/* DTK_M(type); */\n\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase DTK_MICROSEC:\n\t\t\t\t\t\t*fsec += rint(val + fval);\n\t\t\t\t\t\ttmask = DTK_M(MICROSECOND);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MILLISEC:\n\t\t\t\t\t\t/* avoid overflowing the fsec field */\n\t\t\t\t\t\ttm->tm_sec += val / 1000;\n\t\t\t\t\t\tval -= (val / 1000) * 1000;\n\t\t\t\t\t\t*fsec += rint((val + fval) * 1000);\n\t\t\t\t\t\ttmask = DTK_M(MILLISECOND);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\t\t*fsec += rint(fval * 1000000);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If any subseconds were specified, consider this\n\t\t\t\t\t\t * microsecond and millisecond input as well.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (fval == 0)\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\ttype = DTK_DAY; /* set for next field */\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_WEEK:\n\t\t\t\t\t\ttm->tm_mday += val * 7;\n\t\t\t\t\t\tAdjustFractDays(fval, tm, fsec, 7);\n\t\t\t\t\t\ttmask = DTK_M(WEEK);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MONTH:\n\t\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR;\n\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_DECADE:\n\t\t\t\t\t\ttm->tm_year += val * 10;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 10;\n\t\t\t\t\t\ttmask = DTK_M(DECADE);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_CENTURY:\n\t\t\t\t\t\ttm->tm_year += val * 100;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 100;\n\t\t\t\t\t\ttmask = DTK_M(CENTURY);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MILLENNIUM:\n\t\t\t\t\t\ttm->tm_year += val * 1000;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 1000;\n\t\t\t\t\t\ttmask = DTK_M(MILLENNIUM);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\ttype = DecodeUnits(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = 0;\t\t/* DTK_M(type); */\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AGO:\n\t\t\t\t\t\tis_before = true;\n\t\t\t\t\t\ttype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\ttmask = (DTK_DATE_M | DTK_TIME_M);\n\t\t\t\t\t\t*dtype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\n\n\t/* ensure that at least one time field has been found */\n\tif (fmask == 0)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* ensure fractional seconds are fractional */\n\tif (*fsec != 0)\n\t{\n\t\tint\t\t\tsec;\n\n\t\tsec = *fsec / USECS_PER_SEC;\n\t\t*fsec -= sec * USECS_PER_SEC;\n\t\ttm->tm_sec += sec;\n\t}\n\n\t/*----------\n\t * The SQL standard defines the interval literal\n\t *\t '-1 1:00:00'\n\t * to mean \"negative 1 days and negative 1 hours\", while Postgres\n\t * traditionally treats this as meaning \"negative 1 days and positive\n\t * 1 hours\".  In SQL_STANDARD intervalstyle, we apply the leading sign\n\t * to all fields if there are no other explicit signs.\n\t *\n\t * We leave the signs alone if there are additional explicit signs.\n\t * This protects us against misinterpreting postgres-style dump output,\n\t * since the postgres-style output code has always put an explicit sign on\n\t * all fields following a negative field.  But note that SQL-spec output\n\t * is ambiguous and can be misinterpreted on load!\t(So it's best practice\n\t * to dump in postgres style, not SQL style.)\n\t *----------\n\t */\n\tif (IntervalStyle == INTSTYLE_SQL_STANDARD && *field[0] == '-')\n\t{\n\t\t/* Check for additional explicit signs */\n\t\tbool\t\tmore_signs = false;\n\n\t\tfor (i = 1; i < nf; i++)\n\t\t{\n\t\t\tif (*field[i] == '-' || *field[i] == '+')\n\t\t\t{\n\t\t\t\tmore_signs = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!more_signs)\n\t\t{\n\t\t\t/*\n\t\t\t * Rather than re-determining which field was field[0], just force\n\t\t\t * 'em all negative.\n\t\t\t */\n\t\t\tif (*fsec > 0)\n\t\t\t\t*fsec = -(*fsec);\n\t\t\tif (tm->tm_sec > 0)\n\t\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\tif (tm->tm_min > 0)\n\t\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\tif (tm->tm_hour > 0)\n\t\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\tif (tm->tm_mday > 0)\n\t\t\t\ttm->tm_mday = -tm->tm_mday;\n\t\t\tif (tm->tm_mon > 0)\n\t\t\t\ttm->tm_mon = -tm->tm_mon;\n\t\t\tif (tm->tm_year > 0)\n\t\t\t\ttm->tm_year = -tm->tm_year;\n\t\t}\n\t}\n\n\t/* finally, AGO negates everything */\n\tif (is_before)\n\t{\n\t\t*fsec = -(*fsec);\n\t\ttm->tm_sec = -tm->tm_sec;\n\t\ttm->tm_min = -tm->tm_min;\n\t\ttm->tm_hour = -tm->tm_hour;\n\t\ttm->tm_mday = -tm->tm_mday;\n\t\ttm->tm_mon = -tm->tm_mon;\n\t\ttm->tm_year = -tm->tm_year;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseDateTime",
          "args": [
            "str",
            "workbuf",
            "sizeof(workbuf)",
            "field",
            "ftype",
            "MAXDATEFIELDS",
            "&nf"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "ParseDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "545-739",
          "snippet": "int\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
            "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\n\nint\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INTERVAL_RANGE",
          "args": [
            "typmod"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nDatum\ninterval_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tInterval   *result;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tint\t\t\trange;\n\tint\t\t\tdterr;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tworkbuf[256];\n\n\ttm->tm_year = 0;\n\ttm->tm_mon = 0;\n\ttm->tm_mday = 0;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\tfsec = 0;\n\n\tif (typmod >= 0)\n\t\trange = INTERVAL_RANGE(typmod);\n\telse\n\t\trange = INTERVAL_FULL_RANGE;\n\n\tdterr = ParseDateTime(str, workbuf, sizeof(workbuf), field,\n\t\t\t\t\t\t  ftype, MAXDATEFIELDS, &nf);\n\tif (dterr == 0)\n\t\tdterr = DecodeInterval(field, ftype, nf, range,\n\t\t\t\t\t\t\t   &dtype, tm, &fsec);\n\n\t/* if those functions think it's a bad format, try ISO8601 style */\n\tif (dterr == DTERR_BAD_FORMAT)\n\t\tdterr = DecodeISO8601Interval(str,\n\t\t\t\t\t\t\t\t\t  &dtype, tm, &fsec);\n\n\tif (dterr != 0)\n\t{\n\t\tif (dterr == DTERR_FIELD_OVERFLOW)\n\t\t\tdterr = DTERR_INTERVAL_OVERFLOW;\n\t\tDateTimeParseError(dterr, str, \"interval\");\n\t}\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DELTA:\n\t\t\tif (tm2interval(tm, fsec, result) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"interval out of range\")));\n\t\t\tbreak;\n\n\t\tcase DTK_INVALID:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"date/time value \\\"%s\\\" is no longer supported\", str)));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected dtype %d while parsing interval \\\"%s\\\"\",\n\t\t\t\t dtype, str);\n\t}\n\n\tAdjustIntervalForTypmod(result, typmod);\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "timestamptz_scale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "854-866",
    "snippet": "Datum\ntimestamptz_scale(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tTimestampTz result;\n\n\tresult = timestamp;\n\n\tAdjustTimestampForTypmod(&result, typmod);\n\n\tPG_RETURN_TIMESTAMPTZ(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "result"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustTimestampForTypmod",
          "args": [
            "&result",
            "typmod"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustTimestampForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "333-376",
          "snippet": "static void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
            "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamptz_scale(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tTimestampTz result;\n\n\tresult = timestamp;\n\n\tAdjustTimestampForTypmod(&result, typmod);\n\n\tPG_RETURN_TIMESTAMPTZ(result);\n}"
  },
  {
    "function_name": "timestamptztypmodout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "841-847",
    "snippet": "Datum\ntimestamptztypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\n\tPG_RETURN_CSTRING(anytimestamp_typmodout(true, typmod));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "anytimestamp_typmodout(true, typmod)"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anytimestamp_typmodout",
          "args": [
            "true",
            "typmod"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "anytimestamp_typmodout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "123-132",
          "snippet": "static char *\nanytimestamp_typmodout(bool istz, int32 typmod)\n{\n\tconst char *tz = istz ? \" with time zone\" : \" without time zone\";\n\n\tif (typmod >= 0)\n\t\treturn psprintf(\"(%d)%s\", (int) typmod, tz);\n\telse\n\t\treturn psprintf(\"%s\", tz);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
            "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nstatic char *\nanytimestamp_typmodout(bool istz, int32 typmod)\n{\n\tconst char *tz = istz ? \" with time zone\" : \" without time zone\";\n\n\tif (typmod >= 0)\n\t\treturn psprintf(\"(%d)%s\", (int) typmod, tz);\n\telse\n\t\treturn psprintf(\"%s\", tz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nDatum\ntimestamptztypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\n\tPG_RETURN_CSTRING(anytimestamp_typmodout(true, typmod));\n}"
  },
  {
    "function_name": "timestamptztypmodin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "833-839",
    "snippet": "Datum\ntimestamptztypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\n\tPG_RETURN_INT32(anytimestamp_typmodin(true, ta));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "anytimestamp_typmodin(true, ta)"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anytimestamp_typmodin",
          "args": [
            "true",
            "ta"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "anytimestamp_typmodin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "80-98",
          "snippet": "static int32\nanytimestamp_typmodin(bool istz, ArrayType *ta)\n{\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for TIMESTAMP\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\treturn anytimestamp_typmod_check(istz, tl[0]);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32\nanytimestamp_typmodin(bool istz, ArrayType *ta)\n{\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for TIMESTAMP\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\treturn anytimestamp_typmod_check(istz, tl[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamptztypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\n\tPG_RETURN_INT32(anytimestamp_typmodin(true, ta));\n}"
  },
  {
    "function_name": "timestamptz_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "822-831",
    "snippet": "Datum\ntimestamptz_send(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint64(&buf, timestamp);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint64",
          "args": [
            "&buf",
            "timestamp"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamptz_send(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint64(&buf, timestamp);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "timestamptz_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "788-817",
    "snippet": "Datum\ntimestamptz_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tTimestampTz timestamp;\n\tint\t\t\ttz;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\n\ttimestamp = (TimestampTz) pq_getmsgint64(buf);\n\n\t/* range check: see if timestamptz_out would like it */\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t /* ok */ ;\n\telse if (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0 ||\n\t\t\t !IS_VALID_TIMESTAMP(timestamp))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tAdjustTimestampForTypmod(&timestamp, typmod);\n\n\tPG_RETURN_TIMESTAMPTZ(timestamp);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "timestamp"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustTimestampForTypmod",
          "args": [
            "&timestamp",
            "typmod"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustTimestampForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "333-376",
          "snippet": "static void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
            "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_TIMESTAMP",
          "args": [
            "timestamp"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "&tz",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint64",
          "args": [
            "buf"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamptz_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tTimestampTz timestamp;\n\tint\t\t\ttz;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\n\ttimestamp = (TimestampTz) pq_getmsgint64(buf);\n\n\t/* range check: see if timestamptz_out would like it */\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t /* ok */ ;\n\telse if (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0 ||\n\t\t\t !IS_VALID_TIMESTAMP(timestamp))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tAdjustTimestampForTypmod(&timestamp, typmod);\n\n\tPG_RETURN_TIMESTAMPTZ(timestamp);\n}"
  },
  {
    "function_name": "timestamptz_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "760-783",
    "snippet": "Datum\ntimestamptz_out(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt = PG_GETARG_TIMESTAMPTZ(0);\n\tchar\t   *result;\n\tint\t\t\ttz;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tconst char *tzn;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\n\tif (TIMESTAMP_NOT_FINITE(dt))\n\t\tEncodeSpecialTimestamp(dt, buf);\n\telse if (timestamp2tm(dt, &tz, tm, &fsec, &tzn, NULL) == 0)\n\t\tEncodeDateTime(tm, fsec, true, tz, tzn, DateStyle, buf);\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tresult = pstrdup(buf);\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "buf"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeDateTime",
          "args": [
            "tm",
            "fsec",
            "true",
            "tz",
            "tzn",
            "DateStyle",
            "buf"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3987-4149",
          "snippet": "void\nEncodeDateTime(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str)\n{\n\tint\t\t\tday;\n\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\t/*\n\t * Negative tm_isdst means we have no valid time zone translation.\n\t */\n\tif (tm->tm_isdst < 0)\n\t\tprint_tz = false;\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* Compatible with ISO-8601 date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = (style == USE_ISO_DATES) ? ' ' : 'T';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\tif (print_tz)\n\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* Compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\t/*\n\t\t\t * Note: the uses of %.*s in this function would be risky if the\n\t\t\t * timezone names ever contain non-ASCII characters.  However, all\n\t\t\t * TZ abbreviations in the IANA database are plain ASCII.\n\t\t\t */\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German variant on European style */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* Backward-compatible with traditional Postgres abstime dates */\n\t\t\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\ttm->tm_wday = j2day(day);\n\t\t\tmemcpy(str, days[tm->tm_wday], 3);\n\t\t\tstr += 3;\n\t\t\t*str++ = ' ';\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = ' ';\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t\t*str++ = ' ';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We have a time zone, but no string version. Use the\n\t\t\t\t\t * numeric form, but be sure to include a leading space to\n\t\t\t\t\t * avoid formatting something which would be rejected by\n\t\t\t\t\t * the date/time parser later. - thomas 2001-10-19\n\t\t\t\t\t */\n\t\t\t\t\t*str++ = ' ';\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "const char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};",
            "const char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nconst char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};\nconst char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};\n\nvoid\nEncodeDateTime(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str)\n{\n\tint\t\t\tday;\n\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\t/*\n\t * Negative tm_isdst means we have no valid time zone translation.\n\t */\n\tif (tm->tm_isdst < 0)\n\t\tprint_tz = false;\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* Compatible with ISO-8601 date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = (style == USE_ISO_DATES) ? ' ' : 'T';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\tif (print_tz)\n\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* Compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\t/*\n\t\t\t * Note: the uses of %.*s in this function would be risky if the\n\t\t\t * timezone names ever contain non-ASCII characters.  However, all\n\t\t\t * TZ abbreviations in the IANA database are plain ASCII.\n\t\t\t */\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German variant on European style */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* Backward-compatible with traditional Postgres abstime dates */\n\t\t\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\ttm->tm_wday = j2day(day);\n\t\t\tmemcpy(str, days[tm->tm_wday], 3);\n\t\t\tstr += 3;\n\t\t\t*str++ = ' ';\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = ' ';\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t\t*str++ = ' ';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We have a time zone, but no string version. Use the\n\t\t\t\t\t * numeric form, but be sure to include a leading space to\n\t\t\t\t\t * avoid formatting something which would be rejected by\n\t\t\t\t\t * the date/time parser later. - thomas 2001-10-19\n\t\t\t\t\t */\n\t\t\t\t\t*str++ = ' ';\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "dt",
            "&tz",
            "tm",
            "&fsec",
            "&tzn",
            "NULL"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeSpecialTimestamp",
          "args": [
            "dt",
            "buf"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeSpecialTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1522-1531",
          "snippet": "void\nEncodeSpecialTimestamp(Timestamp dt, char *str)\n{\n\tif (TIMESTAMP_IS_NOBEGIN(dt))\n\t\tstrcpy(str, EARLY);\n\telse if (TIMESTAMP_IS_NOEND(dt))\n\t\tstrcpy(str, LATE);\n\telse\t\t\t\t\t\t/* shouldn't happen */\n\t\telog(ERROR, \"invalid argument for EncodeSpecialTimestamp\");\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nEncodeSpecialTimestamp(Timestamp dt, char *str)\n{\n\tif (TIMESTAMP_IS_NOBEGIN(dt))\n\t\tstrcpy(str, EARLY);\n\telse if (TIMESTAMP_IS_NOEND(dt))\n\t\tstrcpy(str, LATE);\n\telse\t\t\t\t\t\t/* shouldn't happen */\n\t\telog(ERROR, \"invalid argument for EncodeSpecialTimestamp\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "dt"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamptz_out(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt = PG_GETARG_TIMESTAMPTZ(0);\n\tchar\t   *result;\n\tint\t\t\ttz;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tconst char *tzn;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\n\tif (TIMESTAMP_NOT_FINITE(dt))\n\t\tEncodeSpecialTimestamp(dt, buf);\n\telse if (timestamp2tm(dt, &tz, tm, &fsec, &tzn, NULL) == 0)\n\t\tEncodeDateTime(tm, fsec, true, tz, tzn, DateStyle, buf);\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tresult = pstrdup(buf);\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "float8_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "710-755",
    "snippet": "Datum\nfloat8_timestamptz(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tseconds = PG_GETARG_FLOAT8(0);\n\tTimestampTz result;\n\n\t/* Deal with NaN and infinite inputs ... */\n\tif (isnan(seconds))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp cannot be NaN\")));\n\n\tif (isinf(seconds))\n\t{\n\t\tif (seconds < 0)\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\telse\n\t\t\tTIMESTAMP_NOEND(result);\n\t}\n\telse\n\t{\n\t\t/* Out of range? */\n\t\tif (seconds <\n\t\t\t(float8) SECS_PER_DAY * (DATETIME_MIN_JULIAN - UNIX_EPOCH_JDATE)\n\t\t\t|| seconds >=\n\t\t\t(float8) SECS_PER_DAY * (TIMESTAMP_END_JULIAN - UNIX_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range: \\\"%g\\\"\", seconds)));\n\n\t\t/* Convert UNIX epoch to Postgres epoch */\n\t\tseconds -= ((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\n\t\tseconds = rint(seconds * USECS_PER_SEC);\n\t\tresult = (int64) seconds;\n\n\t\t/* Recheck in case roundoff produces something just out of range */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range: \\\"%g\\\"\",\n\t\t\t\t\t\t\tPG_GETARG_FLOAT8(0))));\n\t}\n\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range: \\\"%g\\\"\",\n\t\t\t\t\t\t\tPG_GETARG_FLOAT8(0)))"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range: \\\"%g\\\"\"",
            "PG_GETARG_FLOAT8(0)"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "seconds * USECS_PER_SEC"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range: \\\"%g\\\"\", seconds))"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOEND",
          "args": [
            "result"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOBEGIN",
          "args": [
            "result"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "seconds"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp cannot be NaN\"))"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "seconds"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\nfloat8_timestamptz(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tseconds = PG_GETARG_FLOAT8(0);\n\tTimestampTz result;\n\n\t/* Deal with NaN and infinite inputs ... */\n\tif (isnan(seconds))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp cannot be NaN\")));\n\n\tif (isinf(seconds))\n\t{\n\t\tif (seconds < 0)\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\telse\n\t\t\tTIMESTAMP_NOEND(result);\n\t}\n\telse\n\t{\n\t\t/* Out of range? */\n\t\tif (seconds <\n\t\t\t(float8) SECS_PER_DAY * (DATETIME_MIN_JULIAN - UNIX_EPOCH_JDATE)\n\t\t\t|| seconds >=\n\t\t\t(float8) SECS_PER_DAY * (TIMESTAMP_END_JULIAN - UNIX_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range: \\\"%g\\\"\", seconds)));\n\n\t\t/* Convert UNIX epoch to Postgres epoch */\n\t\tseconds -= ((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\n\t\tseconds = rint(seconds * USECS_PER_SEC);\n\t\tresult = (int64) seconds;\n\n\t\t/* Recheck in case roundoff produces something just out of range */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range: \\\"%g\\\"\",\n\t\t\t\t\t\t\tPG_GETARG_FLOAT8(0))));\n\t}\n\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "make_timestamptz_at_timezone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "670-704",
    "snippet": "Datum\nmake_timestamptz_at_timezone(PG_FUNCTION_ARGS)\n{\n\tint32\t\tyear = PG_GETARG_INT32(0);\n\tint32\t\tmonth = PG_GETARG_INT32(1);\n\tint32\t\tmday = PG_GETARG_INT32(2);\n\tint32\t\thour = PG_GETARG_INT32(3);\n\tint32\t\tmin = PG_GETARG_INT32(4);\n\tfloat8\t\tsec = PG_GETARG_FLOAT8(5);\n\ttext\t   *zone = PG_GETARG_TEXT_PP(6);\n\tTimestampTz result;\n\tTimestamp\ttimestamp;\n\tstruct pg_tm tt;\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\ttimestamp = make_timestamp_internal(year, month, mday,\n\t\t\t\t\t\t\t\t\t\thour, min, sec);\n\n\tif (timestamp2tm(timestamp, NULL, &tt, &fsec, NULL, NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\ttz = parse_sane_timezone(&tt, zone);\n\n\tresult = dt2local(timestamp, -tz);\n\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tPG_RETURN_TIMESTAMPTZ(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "result"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt2local",
          "args": [
            "timestamp",
            "-tz"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "dt2local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1951-1956",
          "snippet": "static Timestamp\ndt2local(Timestamp dt, int tz)\n{\n\tdt -= (tz * USECS_PER_SEC);\n\treturn dt;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Timestamp\ndt2local(Timestamp dt, int tz)\n{\n\tdt -= (tz * USECS_PER_SEC);\n\treturn dt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_sane_timezone",
          "args": [
            "&tt",
            "zone"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "parse_sane_timezone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "457-535",
          "snippet": "static int\nparse_sane_timezone(struct pg_tm *tm, text *zone)\n{\n\tchar\t\ttzname[TZ_STRLEN_MAX + 1];\n\tint\t\t\trt;\n\tint\t\t\ttz;\n\n\ttext_to_cstring_buffer(zone, tzname, sizeof(tzname));\n\n\t/*\n\t * Look up the requested timezone.  First we try to interpret it as a\n\t * numeric timezone specification; if DecodeTimezone decides it doesn't\n\t * like the format, we look in the timezone abbreviation table (to handle\n\t * cases like \"EST\"), and if that also fails, we look in the timezone\n\t * database (to handle cases like \"America/New_York\").  (This matches the\n\t * order in which timestamp input checks the cases; it's important because\n\t * the timezone database unwisely uses a few zone names that are identical\n\t * to offset abbreviations.)\n\t *\n\t * Note pg_tzset happily parses numeric input that DecodeTimezone would\n\t * reject.  To avoid having it accept input that would otherwise be seen\n\t * as invalid, it's enough to disallow having a digit in the first\n\t * position of our input string.\n\t */\n\tif (isdigit((unsigned char) *tzname))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid input syntax for numeric time zone: \\\"%s\\\"\",\n\t\t\t\t\t\ttzname),\n\t\t\t\t errhint(\"Numeric time zones must have \\\"-\\\" or \\\"+\\\" as first character.\")));\n\n\trt = DecodeTimezone(tzname, &tz);\n\tif (rt != 0)\n\t{\n\t\tchar\t   *lowzone;\n\t\tint\t\t\ttype,\n\t\t\t\t\tval;\n\t\tpg_tz\t   *tzp;\n\n\t\tif (rt == DTERR_TZDISP_OVERFLOW)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"numeric time zone \\\"%s\\\" out of range\", tzname)));\n\t\telse if (rt != DTERR_BAD_FORMAT)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname)));\n\n\t\t/* DecodeTimezoneAbbrev requires lowercase input */\n\t\tlowzone = downcase_truncate_identifier(tzname,\n\t\t\t\t\t\t\t\t\t\t\t   strlen(tzname),\n\t\t\t\t\t\t\t\t\t\t\t   false);\n\t\ttype = DecodeTimezoneAbbrev(0, lowzone, &val, &tzp);\n\n\t\tif (type == TZ || type == DTZ)\n\t\t{\n\t\t\t/* fixed-offset abbreviation */\n\t\t\ttz = -val;\n\t\t}\n\t\telse if (type == DYNTZ)\n\t\t{\n\t\t\t/* dynamic-offset abbreviation, resolve using specified time */\n\t\t\ttz = DetermineTimeZoneAbbrevOffset(tm, tzname, tzp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* try it as a full zone name */\n\t\t\ttzp = pg_tzset(tzname);\n\t\t\tif (tzp)\n\t\t\t\ttz = DetermineTimeZoneOffset(tm, tzp);\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname)));\n\t\t}\n\t}\n\n\treturn tz;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic int\nparse_sane_timezone(struct pg_tm *tm, text *zone)\n{\n\tchar\t\ttzname[TZ_STRLEN_MAX + 1];\n\tint\t\t\trt;\n\tint\t\t\ttz;\n\n\ttext_to_cstring_buffer(zone, tzname, sizeof(tzname));\n\n\t/*\n\t * Look up the requested timezone.  First we try to interpret it as a\n\t * numeric timezone specification; if DecodeTimezone decides it doesn't\n\t * like the format, we look in the timezone abbreviation table (to handle\n\t * cases like \"EST\"), and if that also fails, we look in the timezone\n\t * database (to handle cases like \"America/New_York\").  (This matches the\n\t * order in which timestamp input checks the cases; it's important because\n\t * the timezone database unwisely uses a few zone names that are identical\n\t * to offset abbreviations.)\n\t *\n\t * Note pg_tzset happily parses numeric input that DecodeTimezone would\n\t * reject.  To avoid having it accept input that would otherwise be seen\n\t * as invalid, it's enough to disallow having a digit in the first\n\t * position of our input string.\n\t */\n\tif (isdigit((unsigned char) *tzname))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid input syntax for numeric time zone: \\\"%s\\\"\",\n\t\t\t\t\t\ttzname),\n\t\t\t\t errhint(\"Numeric time zones must have \\\"-\\\" or \\\"+\\\" as first character.\")));\n\n\trt = DecodeTimezone(tzname, &tz);\n\tif (rt != 0)\n\t{\n\t\tchar\t   *lowzone;\n\t\tint\t\t\ttype,\n\t\t\t\t\tval;\n\t\tpg_tz\t   *tzp;\n\n\t\tif (rt == DTERR_TZDISP_OVERFLOW)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"numeric time zone \\\"%s\\\" out of range\", tzname)));\n\t\telse if (rt != DTERR_BAD_FORMAT)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname)));\n\n\t\t/* DecodeTimezoneAbbrev requires lowercase input */\n\t\tlowzone = downcase_truncate_identifier(tzname,\n\t\t\t\t\t\t\t\t\t\t\t   strlen(tzname),\n\t\t\t\t\t\t\t\t\t\t\t   false);\n\t\ttype = DecodeTimezoneAbbrev(0, lowzone, &val, &tzp);\n\n\t\tif (type == TZ || type == DTZ)\n\t\t{\n\t\t\t/* fixed-offset abbreviation */\n\t\t\ttz = -val;\n\t\t}\n\t\telse if (type == DYNTZ)\n\t\t{\n\t\t\t/* dynamic-offset abbreviation, resolve using specified time */\n\t\t\ttz = DetermineTimeZoneAbbrevOffset(tm, tzname, tzp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* try it as a full zone name */\n\t\t\ttzp = pg_tzset(tzname);\n\t\t\tif (tzp)\n\t\t\t\ttz = DetermineTimeZoneOffset(tm, tzp);\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname)));\n\t\t}\n\t}\n\n\treturn tz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "NULL",
            "&tt",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_timestamp_internal",
          "args": [
            "year",
            "month",
            "mday",
            "hour",
            "min",
            "sec"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "make_timestamp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "541-624",
          "snippet": "static Timestamp\nmake_timestamp_internal(int year, int month, int day,\n\t\t\t\t\t\tint hour, int min, double sec)\n{\n\tstruct pg_tm tm;\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\tint\t\t\tdterr;\n\tTimestamp\tresult;\n\n\ttm.tm_year = year;\n\ttm.tm_mon = month;\n\ttm.tm_mday = day;\n\n\t/*\n\t * Note: we'll reject zero or negative year values.  Perhaps negatives\n\t * should be allowed to represent BC years?\n\t */\n\tdterr = ValidateDate(DTK_DATE_M, false, false, false, &tm);\n\n\tif (dterr != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"date field value out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day)));\n\n\tif (!IS_VALID_JULIAN(tm.tm_year, tm.tm_mon, tm.tm_mday))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day)));\n\n\tdate = date2j(tm.tm_year, tm.tm_mon, tm.tm_mday) - POSTGRES_EPOCH_JDATE;\n\n\t/*\n\t * This should match the checks in DecodeTimeOnly, except that since we're\n\t * dealing with a float \"sec\" value, we also explicitly reject NaN.  (An\n\t * infinity input should get rejected by the range comparisons, but we\n\t * can't be sure how those will treat a NaN.)\n\t */\n\tif (hour < 0 || min < 0 || min > MINS_PER_HOUR - 1 ||\n\t\tisnan(sec) ||\n\t\tsec < 0 || sec > SECS_PER_MINUTE ||\n\t\thour > HOURS_PER_DAY ||\n\t/* test for > 24:00:00 */\n\t\t(hour == HOURS_PER_DAY && (min > 0 || sec > 0)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"time field value out of range: %d:%02d:%02g\",\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* This should match tm2time */\n\ttime = (((hour * MINS_PER_HOUR + min) * SECS_PER_MINUTE)\n\t\t\t* USECS_PER_SEC) + rint(sec * USECS_PER_SEC);\n\n\tresult = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((result - time) / USECS_PER_DAY != date)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((result < 0 && date > 0) ||\n\t\t(result > 0 && date < -1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic Timestamp\nmake_timestamp_internal(int year, int month, int day,\n\t\t\t\t\t\tint hour, int min, double sec)\n{\n\tstruct pg_tm tm;\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\tint\t\t\tdterr;\n\tTimestamp\tresult;\n\n\ttm.tm_year = year;\n\ttm.tm_mon = month;\n\ttm.tm_mday = day;\n\n\t/*\n\t * Note: we'll reject zero or negative year values.  Perhaps negatives\n\t * should be allowed to represent BC years?\n\t */\n\tdterr = ValidateDate(DTK_DATE_M, false, false, false, &tm);\n\n\tif (dterr != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"date field value out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day)));\n\n\tif (!IS_VALID_JULIAN(tm.tm_year, tm.tm_mon, tm.tm_mday))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day)));\n\n\tdate = date2j(tm.tm_year, tm.tm_mon, tm.tm_mday) - POSTGRES_EPOCH_JDATE;\n\n\t/*\n\t * This should match the checks in DecodeTimeOnly, except that since we're\n\t * dealing with a float \"sec\" value, we also explicitly reject NaN.  (An\n\t * infinity input should get rejected by the range comparisons, but we\n\t * can't be sure how those will treat a NaN.)\n\t */\n\tif (hour < 0 || min < 0 || min > MINS_PER_HOUR - 1 ||\n\t\tisnan(sec) ||\n\t\tsec < 0 || sec > SECS_PER_MINUTE ||\n\t\thour > HOURS_PER_DAY ||\n\t/* test for > 24:00:00 */\n\t\t(hour == HOURS_PER_DAY && (min > 0 || sec > 0)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"time field value out of range: %d:%02d:%02g\",\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* This should match tm2time */\n\ttime = (((hour * MINS_PER_HOUR + min) * SECS_PER_MINUTE)\n\t\t\t* USECS_PER_SEC) + rint(sec * USECS_PER_SEC);\n\n\tresult = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((result - time) / USECS_PER_DAY != date)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((result < 0 && date > 0) ||\n\t\t(result > 0 && date < -1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "6"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "5"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "4"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\nmake_timestamptz_at_timezone(PG_FUNCTION_ARGS)\n{\n\tint32\t\tyear = PG_GETARG_INT32(0);\n\tint32\t\tmonth = PG_GETARG_INT32(1);\n\tint32\t\tmday = PG_GETARG_INT32(2);\n\tint32\t\thour = PG_GETARG_INT32(3);\n\tint32\t\tmin = PG_GETARG_INT32(4);\n\tfloat8\t\tsec = PG_GETARG_FLOAT8(5);\n\ttext\t   *zone = PG_GETARG_TEXT_PP(6);\n\tTimestampTz result;\n\tTimestamp\ttimestamp;\n\tstruct pg_tm tt;\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\ttimestamp = make_timestamp_internal(year, month, mday,\n\t\t\t\t\t\t\t\t\t\thour, min, sec);\n\n\tif (timestamp2tm(timestamp, NULL, &tt, &fsec, NULL, NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\ttz = parse_sane_timezone(&tt, zone);\n\n\tresult = dt2local(timestamp, -tz);\n\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tPG_RETURN_TIMESTAMPTZ(result);\n}"
  },
  {
    "function_name": "make_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "649-664",
    "snippet": "Datum\nmake_timestamptz(PG_FUNCTION_ARGS)\n{\n\tint32\t\tyear = PG_GETARG_INT32(0);\n\tint32\t\tmonth = PG_GETARG_INT32(1);\n\tint32\t\tmday = PG_GETARG_INT32(2);\n\tint32\t\thour = PG_GETARG_INT32(3);\n\tint32\t\tmin = PG_GETARG_INT32(4);\n\tfloat8\t\tsec = PG_GETARG_FLOAT8(5);\n\tTimestamp\tresult;\n\n\tresult = make_timestamp_internal(year, month, mday,\n\t\t\t\t\t\t\t\t\t hour, min, sec);\n\n\tPG_RETURN_TIMESTAMPTZ(timestamp2timestamptz(result));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "timestamp2timestamptz(result)"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2timestamptz",
          "args": [
            "result"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "5089-5116",
          "snippet": "static TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic TimestampTz\ntimestamp2timestamptz(Timestamp timestamp)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tresult = timestamp;\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_timestamp_internal",
          "args": [
            "year",
            "month",
            "mday",
            "hour",
            "min",
            "sec"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "make_timestamp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "541-624",
          "snippet": "static Timestamp\nmake_timestamp_internal(int year, int month, int day,\n\t\t\t\t\t\tint hour, int min, double sec)\n{\n\tstruct pg_tm tm;\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\tint\t\t\tdterr;\n\tTimestamp\tresult;\n\n\ttm.tm_year = year;\n\ttm.tm_mon = month;\n\ttm.tm_mday = day;\n\n\t/*\n\t * Note: we'll reject zero or negative year values.  Perhaps negatives\n\t * should be allowed to represent BC years?\n\t */\n\tdterr = ValidateDate(DTK_DATE_M, false, false, false, &tm);\n\n\tif (dterr != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"date field value out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day)));\n\n\tif (!IS_VALID_JULIAN(tm.tm_year, tm.tm_mon, tm.tm_mday))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day)));\n\n\tdate = date2j(tm.tm_year, tm.tm_mon, tm.tm_mday) - POSTGRES_EPOCH_JDATE;\n\n\t/*\n\t * This should match the checks in DecodeTimeOnly, except that since we're\n\t * dealing with a float \"sec\" value, we also explicitly reject NaN.  (An\n\t * infinity input should get rejected by the range comparisons, but we\n\t * can't be sure how those will treat a NaN.)\n\t */\n\tif (hour < 0 || min < 0 || min > MINS_PER_HOUR - 1 ||\n\t\tisnan(sec) ||\n\t\tsec < 0 || sec > SECS_PER_MINUTE ||\n\t\thour > HOURS_PER_DAY ||\n\t/* test for > 24:00:00 */\n\t\t(hour == HOURS_PER_DAY && (min > 0 || sec > 0)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"time field value out of range: %d:%02d:%02g\",\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* This should match tm2time */\n\ttime = (((hour * MINS_PER_HOUR + min) * SECS_PER_MINUTE)\n\t\t\t* USECS_PER_SEC) + rint(sec * USECS_PER_SEC);\n\n\tresult = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((result - time) / USECS_PER_DAY != date)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((result < 0 && date > 0) ||\n\t\t(result > 0 && date < -1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic Timestamp\nmake_timestamp_internal(int year, int month, int day,\n\t\t\t\t\t\tint hour, int min, double sec)\n{\n\tstruct pg_tm tm;\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\tint\t\t\tdterr;\n\tTimestamp\tresult;\n\n\ttm.tm_year = year;\n\ttm.tm_mon = month;\n\ttm.tm_mday = day;\n\n\t/*\n\t * Note: we'll reject zero or negative year values.  Perhaps negatives\n\t * should be allowed to represent BC years?\n\t */\n\tdterr = ValidateDate(DTK_DATE_M, false, false, false, &tm);\n\n\tif (dterr != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"date field value out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day)));\n\n\tif (!IS_VALID_JULIAN(tm.tm_year, tm.tm_mon, tm.tm_mday))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day)));\n\n\tdate = date2j(tm.tm_year, tm.tm_mon, tm.tm_mday) - POSTGRES_EPOCH_JDATE;\n\n\t/*\n\t * This should match the checks in DecodeTimeOnly, except that since we're\n\t * dealing with a float \"sec\" value, we also explicitly reject NaN.  (An\n\t * infinity input should get rejected by the range comparisons, but we\n\t * can't be sure how those will treat a NaN.)\n\t */\n\tif (hour < 0 || min < 0 || min > MINS_PER_HOUR - 1 ||\n\t\tisnan(sec) ||\n\t\tsec < 0 || sec > SECS_PER_MINUTE ||\n\t\thour > HOURS_PER_DAY ||\n\t/* test for > 24:00:00 */\n\t\t(hour == HOURS_PER_DAY && (min > 0 || sec > 0)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"time field value out of range: %d:%02d:%02g\",\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* This should match tm2time */\n\ttime = (((hour * MINS_PER_HOUR + min) * SECS_PER_MINUTE)\n\t\t\t* USECS_PER_SEC) + rint(sec * USECS_PER_SEC);\n\n\tresult = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((result - time) / USECS_PER_DAY != date)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((result < 0 && date > 0) ||\n\t\t(result > 0 && date < -1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "5"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "4"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nmake_timestamptz(PG_FUNCTION_ARGS)\n{\n\tint32\t\tyear = PG_GETARG_INT32(0);\n\tint32\t\tmonth = PG_GETARG_INT32(1);\n\tint32\t\tmday = PG_GETARG_INT32(2);\n\tint32\t\thour = PG_GETARG_INT32(3);\n\tint32\t\tmin = PG_GETARG_INT32(4);\n\tfloat8\t\tsec = PG_GETARG_FLOAT8(5);\n\tTimestamp\tresult;\n\n\tresult = make_timestamp_internal(year, month, mday,\n\t\t\t\t\t\t\t\t\t hour, min, sec);\n\n\tPG_RETURN_TIMESTAMPTZ(timestamp2timestamptz(result));\n}"
  },
  {
    "function_name": "make_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "629-644",
    "snippet": "Datum\nmake_timestamp(PG_FUNCTION_ARGS)\n{\n\tint32\t\tyear = PG_GETARG_INT32(0);\n\tint32\t\tmonth = PG_GETARG_INT32(1);\n\tint32\t\tmday = PG_GETARG_INT32(2);\n\tint32\t\thour = PG_GETARG_INT32(3);\n\tint32\t\tmin = PG_GETARG_INT32(4);\n\tfloat8\t\tsec = PG_GETARG_FLOAT8(5);\n\tTimestamp\tresult;\n\n\tresult = make_timestamp_internal(year, month, mday,\n\t\t\t\t\t\t\t\t\t hour, min, sec);\n\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_timestamp_internal",
          "args": [
            "year",
            "month",
            "mday",
            "hour",
            "min",
            "sec"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "make_timestamp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "541-624",
          "snippet": "static Timestamp\nmake_timestamp_internal(int year, int month, int day,\n\t\t\t\t\t\tint hour, int min, double sec)\n{\n\tstruct pg_tm tm;\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\tint\t\t\tdterr;\n\tTimestamp\tresult;\n\n\ttm.tm_year = year;\n\ttm.tm_mon = month;\n\ttm.tm_mday = day;\n\n\t/*\n\t * Note: we'll reject zero or negative year values.  Perhaps negatives\n\t * should be allowed to represent BC years?\n\t */\n\tdterr = ValidateDate(DTK_DATE_M, false, false, false, &tm);\n\n\tif (dterr != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"date field value out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day)));\n\n\tif (!IS_VALID_JULIAN(tm.tm_year, tm.tm_mon, tm.tm_mday))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day)));\n\n\tdate = date2j(tm.tm_year, tm.tm_mon, tm.tm_mday) - POSTGRES_EPOCH_JDATE;\n\n\t/*\n\t * This should match the checks in DecodeTimeOnly, except that since we're\n\t * dealing with a float \"sec\" value, we also explicitly reject NaN.  (An\n\t * infinity input should get rejected by the range comparisons, but we\n\t * can't be sure how those will treat a NaN.)\n\t */\n\tif (hour < 0 || min < 0 || min > MINS_PER_HOUR - 1 ||\n\t\tisnan(sec) ||\n\t\tsec < 0 || sec > SECS_PER_MINUTE ||\n\t\thour > HOURS_PER_DAY ||\n\t/* test for > 24:00:00 */\n\t\t(hour == HOURS_PER_DAY && (min > 0 || sec > 0)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"time field value out of range: %d:%02d:%02g\",\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* This should match tm2time */\n\ttime = (((hour * MINS_PER_HOUR + min) * SECS_PER_MINUTE)\n\t\t\t* USECS_PER_SEC) + rint(sec * USECS_PER_SEC);\n\n\tresult = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((result - time) / USECS_PER_DAY != date)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((result < 0 && date > 0) ||\n\t\t(result > 0 && date < -1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic Timestamp\nmake_timestamp_internal(int year, int month, int day,\n\t\t\t\t\t\tint hour, int min, double sec)\n{\n\tstruct pg_tm tm;\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\tint\t\t\tdterr;\n\tTimestamp\tresult;\n\n\ttm.tm_year = year;\n\ttm.tm_mon = month;\n\ttm.tm_mday = day;\n\n\t/*\n\t * Note: we'll reject zero or negative year values.  Perhaps negatives\n\t * should be allowed to represent BC years?\n\t */\n\tdterr = ValidateDate(DTK_DATE_M, false, false, false, &tm);\n\n\tif (dterr != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"date field value out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day)));\n\n\tif (!IS_VALID_JULIAN(tm.tm_year, tm.tm_mon, tm.tm_mday))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day)));\n\n\tdate = date2j(tm.tm_year, tm.tm_mon, tm.tm_mday) - POSTGRES_EPOCH_JDATE;\n\n\t/*\n\t * This should match the checks in DecodeTimeOnly, except that since we're\n\t * dealing with a float \"sec\" value, we also explicitly reject NaN.  (An\n\t * infinity input should get rejected by the range comparisons, but we\n\t * can't be sure how those will treat a NaN.)\n\t */\n\tif (hour < 0 || min < 0 || min > MINS_PER_HOUR - 1 ||\n\t\tisnan(sec) ||\n\t\tsec < 0 || sec > SECS_PER_MINUTE ||\n\t\thour > HOURS_PER_DAY ||\n\t/* test for > 24:00:00 */\n\t\t(hour == HOURS_PER_DAY && (min > 0 || sec > 0)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"time field value out of range: %d:%02d:%02g\",\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* This should match tm2time */\n\ttime = (((hour * MINS_PER_HOUR + min) * SECS_PER_MINUTE)\n\t\t\t* USECS_PER_SEC) + rint(sec * USECS_PER_SEC);\n\n\tresult = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((result - time) / USECS_PER_DAY != date)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((result < 0 && date > 0) ||\n\t\t(result > 0 && date < -1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "5"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "4"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nmake_timestamp(PG_FUNCTION_ARGS)\n{\n\tint32\t\tyear = PG_GETARG_INT32(0);\n\tint32\t\tmonth = PG_GETARG_INT32(1);\n\tint32\t\tmday = PG_GETARG_INT32(2);\n\tint32\t\thour = PG_GETARG_INT32(3);\n\tint32\t\tmin = PG_GETARG_INT32(4);\n\tfloat8\t\tsec = PG_GETARG_FLOAT8(5);\n\tTimestamp\tresult;\n\n\tresult = make_timestamp_internal(year, month, mday,\n\t\t\t\t\t\t\t\t\t hour, min, sec);\n\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "make_timestamp_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "541-624",
    "snippet": "static Timestamp\nmake_timestamp_internal(int year, int month, int day,\n\t\t\t\t\t\tint hour, int min, double sec)\n{\n\tstruct pg_tm tm;\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\tint\t\t\tdterr;\n\tTimestamp\tresult;\n\n\ttm.tm_year = year;\n\ttm.tm_mon = month;\n\ttm.tm_mday = day;\n\n\t/*\n\t * Note: we'll reject zero or negative year values.  Perhaps negatives\n\t * should be allowed to represent BC years?\n\t */\n\tdterr = ValidateDate(DTK_DATE_M, false, false, false, &tm);\n\n\tif (dterr != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"date field value out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day)));\n\n\tif (!IS_VALID_JULIAN(tm.tm_year, tm.tm_mon, tm.tm_mday))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day)));\n\n\tdate = date2j(tm.tm_year, tm.tm_mon, tm.tm_mday) - POSTGRES_EPOCH_JDATE;\n\n\t/*\n\t * This should match the checks in DecodeTimeOnly, except that since we're\n\t * dealing with a float \"sec\" value, we also explicitly reject NaN.  (An\n\t * infinity input should get rejected by the range comparisons, but we\n\t * can't be sure how those will treat a NaN.)\n\t */\n\tif (hour < 0 || min < 0 || min > MINS_PER_HOUR - 1 ||\n\t\tisnan(sec) ||\n\t\tsec < 0 || sec > SECS_PER_MINUTE ||\n\t\thour > HOURS_PER_DAY ||\n\t/* test for > 24:00:00 */\n\t\t(hour == HOURS_PER_DAY && (min > 0 || sec > 0)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"time field value out of range: %d:%02d:%02g\",\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* This should match tm2time */\n\ttime = (((hour * MINS_PER_HOUR + min) * SECS_PER_MINUTE)\n\t\t\t* USECS_PER_SEC) + rint(sec * USECS_PER_SEC);\n\n\tresult = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((result - time) / USECS_PER_DAY != date)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((result < 0 && date > 0) ||\n\t\t(result > 0 && date < -1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec))"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\"",
            "year",
            "month",
            "day",
            "hour",
            "min",
            "sec"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec))"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec))"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "sec * USECS_PER_SEC"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"time field value out of range: %d:%02d:%02g\",\n\t\t\t\t\t\thour, min, sec))"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "sec"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm.tm_year",
            "tm.tm_mon",
            "tm.tm_mday"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day))"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_VALID_JULIAN",
          "args": [
            "tm.tm_year",
            "tm.tm_mon",
            "tm.tm_mday"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"date field value out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day))"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ValidateDate",
          "args": [
            "DTK_DATE_M",
            "false",
            "false",
            "false",
            "&tm"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "ValidateDate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2465-2534",
          "snippet": "int\nValidateDate(int fmask, bool isjulian, bool is2digits, bool bc,\n\t\t\t struct pg_tm *tm)\n{\n\tif (fmask & DTK_M(YEAR))\n\t{\n\t\tif (isjulian)\n\t\t{\n\t\t\t/* tm_year is correct and should not be touched */\n\t\t}\n\t\telse if (bc)\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t/* internally, we represent 1 BC as year zero, 2 BC as -1, etc */\n\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\telse if (is2digits)\n\t\t{\n\t\t\t/* process 1 or 2-digit input as 1970-2069 AD, allow '0' and '00' */\n\t\t\tif (tm->tm_year < 0)\t/* just paranoia */\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\tif (tm->tm_year < 70)\n\t\t\t\ttm->tm_year += 2000;\n\t\t\telse if (tm->tm_year < 100)\n\t\t\t\ttm->tm_year += 1900;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t}\n\t}\n\n\t/* now that we have correct year, decode DOY */\n\tif (fmask & DTK_M(DOY))\n\t{\n\t\tj2date(date2j(tm->tm_year, 1, 1) + tm->tm_yday - 1,\n\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t}\n\n\t/* check for valid month */\n\tif (fmask & DTK_M(MONTH))\n\t{\n\t\tif (tm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\t/* minimal check for valid day */\n\tif (fmask & DTK_M(DAY))\n\t{\n\t\tif (tm->tm_mday < 1 || tm->tm_mday > 31)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\tif ((fmask & DTK_DATE_M) == DTK_DATE_M)\n\t{\n\t\t/*\n\t\t * Check for valid day of month, now that we know for sure the month\n\t\t * and year.  Note we don't use MD_FIELD_OVERFLOW here, since it seems\n\t\t * unlikely that \"Feb 29\" is a YMD-order error.\n\t\t */\n\t\tif (tm->tm_mday > day_tab[isleap(tm->tm_year)][tm->tm_mon - 1])\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "const int\tday_tab[2][13] =\n{\n\t{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0},\n\t{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nconst int\tday_tab[2][13] =\n{\n\t{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0},\n\t{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0}\n};\n\nint\nValidateDate(int fmask, bool isjulian, bool is2digits, bool bc,\n\t\t\t struct pg_tm *tm)\n{\n\tif (fmask & DTK_M(YEAR))\n\t{\n\t\tif (isjulian)\n\t\t{\n\t\t\t/* tm_year is correct and should not be touched */\n\t\t}\n\t\telse if (bc)\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t/* internally, we represent 1 BC as year zero, 2 BC as -1, etc */\n\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\telse if (is2digits)\n\t\t{\n\t\t\t/* process 1 or 2-digit input as 1970-2069 AD, allow '0' and '00' */\n\t\t\tif (tm->tm_year < 0)\t/* just paranoia */\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\tif (tm->tm_year < 70)\n\t\t\t\ttm->tm_year += 2000;\n\t\t\telse if (tm->tm_year < 100)\n\t\t\t\ttm->tm_year += 1900;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t}\n\t}\n\n\t/* now that we have correct year, decode DOY */\n\tif (fmask & DTK_M(DOY))\n\t{\n\t\tj2date(date2j(tm->tm_year, 1, 1) + tm->tm_yday - 1,\n\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t}\n\n\t/* check for valid month */\n\tif (fmask & DTK_M(MONTH))\n\t{\n\t\tif (tm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\t/* minimal check for valid day */\n\tif (fmask & DTK_M(DAY))\n\t{\n\t\tif (tm->tm_mday < 1 || tm->tm_mday > 31)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\tif ((fmask & DTK_DATE_M) == DTK_DATE_M)\n\t{\n\t\t/*\n\t\t * Check for valid day of month, now that we know for sure the month\n\t\t * and year.  Note we don't use MD_FIELD_OVERFLOW here, since it seems\n\t\t * unlikely that \"Feb 29\" is a YMD-order error.\n\t\t */\n\t\tif (tm->tm_mday > day_tab[isleap(tm->tm_year)][tm->tm_mon - 1])\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic Timestamp\nmake_timestamp_internal(int year, int month, int day,\n\t\t\t\t\t\tint hour, int min, double sec)\n{\n\tstruct pg_tm tm;\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\tint\t\t\tdterr;\n\tTimestamp\tresult;\n\n\ttm.tm_year = year;\n\ttm.tm_mon = month;\n\ttm.tm_mday = day;\n\n\t/*\n\t * Note: we'll reject zero or negative year values.  Perhaps negatives\n\t * should be allowed to represent BC years?\n\t */\n\tdterr = ValidateDate(DTK_DATE_M, false, false, false, &tm);\n\n\tif (dterr != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"date field value out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day)));\n\n\tif (!IS_VALID_JULIAN(tm.tm_year, tm.tm_mon, tm.tm_mday))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: %d-%02d-%02d\",\n\t\t\t\t\t\tyear, month, day)));\n\n\tdate = date2j(tm.tm_year, tm.tm_mon, tm.tm_mday) - POSTGRES_EPOCH_JDATE;\n\n\t/*\n\t * This should match the checks in DecodeTimeOnly, except that since we're\n\t * dealing with a float \"sec\" value, we also explicitly reject NaN.  (An\n\t * infinity input should get rejected by the range comparisons, but we\n\t * can't be sure how those will treat a NaN.)\n\t */\n\tif (hour < 0 || min < 0 || min > MINS_PER_HOUR - 1 ||\n\t\tisnan(sec) ||\n\t\tsec < 0 || sec > SECS_PER_MINUTE ||\n\t\thour > HOURS_PER_DAY ||\n\t/* test for > 24:00:00 */\n\t\t(hour == HOURS_PER_DAY && (min > 0 || sec > 0)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"time field value out of range: %d:%02d:%02g\",\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* This should match tm2time */\n\ttime = (((hour * MINS_PER_HOUR + min) * SECS_PER_MINUTE)\n\t\t\t* USECS_PER_SEC) + rint(sec * USECS_PER_SEC);\n\n\tresult = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((result - time) / USECS_PER_DAY != date)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((result < 0 && date > 0) ||\n\t\t(result > 0 && date < -1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range: %d-%02d-%02d %d:%02d:%02g\",\n\t\t\t\t\t\tyear, month, day,\n\t\t\t\t\t\thour, min, sec)));\n\n\treturn result;\n}"
  },
  {
    "function_name": "parse_sane_timezone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "457-535",
    "snippet": "static int\nparse_sane_timezone(struct pg_tm *tm, text *zone)\n{\n\tchar\t\ttzname[TZ_STRLEN_MAX + 1];\n\tint\t\t\trt;\n\tint\t\t\ttz;\n\n\ttext_to_cstring_buffer(zone, tzname, sizeof(tzname));\n\n\t/*\n\t * Look up the requested timezone.  First we try to interpret it as a\n\t * numeric timezone specification; if DecodeTimezone decides it doesn't\n\t * like the format, we look in the timezone abbreviation table (to handle\n\t * cases like \"EST\"), and if that also fails, we look in the timezone\n\t * database (to handle cases like \"America/New_York\").  (This matches the\n\t * order in which timestamp input checks the cases; it's important because\n\t * the timezone database unwisely uses a few zone names that are identical\n\t * to offset abbreviations.)\n\t *\n\t * Note pg_tzset happily parses numeric input that DecodeTimezone would\n\t * reject.  To avoid having it accept input that would otherwise be seen\n\t * as invalid, it's enough to disallow having a digit in the first\n\t * position of our input string.\n\t */\n\tif (isdigit((unsigned char) *tzname))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid input syntax for numeric time zone: \\\"%s\\\"\",\n\t\t\t\t\t\ttzname),\n\t\t\t\t errhint(\"Numeric time zones must have \\\"-\\\" or \\\"+\\\" as first character.\")));\n\n\trt = DecodeTimezone(tzname, &tz);\n\tif (rt != 0)\n\t{\n\t\tchar\t   *lowzone;\n\t\tint\t\t\ttype,\n\t\t\t\t\tval;\n\t\tpg_tz\t   *tzp;\n\n\t\tif (rt == DTERR_TZDISP_OVERFLOW)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"numeric time zone \\\"%s\\\" out of range\", tzname)));\n\t\telse if (rt != DTERR_BAD_FORMAT)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname)));\n\n\t\t/* DecodeTimezoneAbbrev requires lowercase input */\n\t\tlowzone = downcase_truncate_identifier(tzname,\n\t\t\t\t\t\t\t\t\t\t\t   strlen(tzname),\n\t\t\t\t\t\t\t\t\t\t\t   false);\n\t\ttype = DecodeTimezoneAbbrev(0, lowzone, &val, &tzp);\n\n\t\tif (type == TZ || type == DTZ)\n\t\t{\n\t\t\t/* fixed-offset abbreviation */\n\t\t\ttz = -val;\n\t\t}\n\t\telse if (type == DYNTZ)\n\t\t{\n\t\t\t/* dynamic-offset abbreviation, resolve using specified time */\n\t\t\ttz = DetermineTimeZoneAbbrevOffset(tm, tzname, tzp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* try it as a full zone name */\n\t\t\ttzp = pg_tzset(tzname);\n\t\t\tif (tzp)\n\t\t\t\ttz = DetermineTimeZoneOffset(tm, tzp);\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname)));\n\t\t}\n\t}\n\n\treturn tz;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Timestamp dt2local(Timestamp dt, int timezone);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname))"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"time zone \\\"%s\\\" not recognized\"",
            "tzname"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneOffset",
          "args": [
            "tm",
            "tzp"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1454-1460",
          "snippet": "int\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_tzset",
          "args": [
            "tzname"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneAbbrevOffset",
          "args": [
            "tm",
            "tzname",
            "tzp"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneAbbrevOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1615-1645",
          "snippet": "int\nDetermineTimeZoneAbbrevOffset(struct pg_tm *tm, const char *abbr, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\tabbr_isdst;\n\n\t/*\n\t * Compute the UTC time we want to probe at.  (In event of overflow, we'll\n\t * probe at the epoch, which is a bit random but probably doesn't matter.)\n\t */\n\tzone_offset = DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n\n\t/*\n\t * Try to match the abbreviation to something in the zone definition.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, &abbr_isdst))\n\t{\n\t\t/* Success, so use the abbrev-specific answers. */\n\t\ttm->tm_isdst = abbr_isdst;\n\t\treturn abbr_offset;\n\t}\n\n\t/*\n\t * No match, so use the answers we already got from\n\t * DetermineTimeZoneOffsetInternal.\n\t */\n\treturn zone_offset;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneAbbrevOffset(struct pg_tm *tm, const char *abbr, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\tabbr_isdst;\n\n\t/*\n\t * Compute the UTC time we want to probe at.  (In event of overflow, we'll\n\t * probe at the epoch, which is a bit random but probably doesn't matter.)\n\t */\n\tzone_offset = DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n\n\t/*\n\t * Try to match the abbreviation to something in the zone definition.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, &abbr_isdst))\n\t{\n\t\t/* Success, so use the abbrev-specific answers. */\n\t\ttm->tm_isdst = abbr_isdst;\n\t\treturn abbr_offset;\n\t}\n\n\t/*\n\t * No match, so use the answers we already got from\n\t * DetermineTimeZoneOffsetInternal.\n\t */\n\treturn zone_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeTimezoneAbbrev",
          "args": [
            "0",
            "lowzone",
            "&val",
            "&tzp"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeTimezoneAbbrev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2970-3010",
          "snippet": "int\nDecodeTimezoneAbbrev(int field, char *lowtoken,\n\t\t\t\t\t int *offset, pg_tz **tz)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = abbrevcache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\tif (zoneabbrevtbl)\n\t\t\ttp = datebsearch(lowtoken, zoneabbrevtbl->abbrevs,\n\t\t\t\t\t\t\t zoneabbrevtbl->numabbrevs);\n\t\telse\n\t\t\ttp = NULL;\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*offset = 0;\n\t\t*tz = NULL;\n\t}\n\telse\n\t{\n\t\tabbrevcache[field] = tp;\n\t\ttype = tp->type;\n\t\tif (type == DYNTZ)\n\t\t{\n\t\t\t*offset = 0;\n\t\t\t*tz = FetchDynamicTimeZone(zoneabbrevtbl, tp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*offset = tp->value;\n\t\t\t*tz = NULL;\n\t\t}\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static TimeZoneAbbrevTable *zoneabbrevtbl = NULL;",
            "static const datetkn *abbrevcache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic TimeZoneAbbrevTable *zoneabbrevtbl = NULL;\nstatic const datetkn *abbrevcache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeTimezoneAbbrev(int field, char *lowtoken,\n\t\t\t\t\t int *offset, pg_tz **tz)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = abbrevcache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\tif (zoneabbrevtbl)\n\t\t\ttp = datebsearch(lowtoken, zoneabbrevtbl->abbrevs,\n\t\t\t\t\t\t\t zoneabbrevtbl->numabbrevs);\n\t\telse\n\t\t\ttp = NULL;\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*offset = 0;\n\t\t*tz = NULL;\n\t}\n\telse\n\t{\n\t\tabbrevcache[field] = tp;\n\t\ttype = tp->type;\n\t\tif (type == DYNTZ)\n\t\t{\n\t\t\t*offset = 0;\n\t\t\t*tz = FetchDynamicTimeZone(zoneabbrevtbl, tp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*offset = tp->value;\n\t\t\t*tz = NULL;\n\t\t}\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcase_truncate_identifier",
          "args": [
            "tzname",
            "strlen(tzname)",
            "false"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tzname"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname))"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"numeric time zone \\\"%s\\\" out of range\", tzname))"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeTimezone",
          "args": [
            "tzname",
            "&tz"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeTimezone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2892-2953",
          "snippet": "int\nDecodeTimezone(char *str, int *tzp)\n{\n\tint\t\t\ttz;\n\tint\t\t\thr,\n\t\t\t\tmin,\n\t\t\t\tsec = 0;\n\tchar\t   *cp;\n\n\t/* leading character must be \"+\" or \"-\" */\n\tif (*str != '+' && *str != '-')\n\t\treturn DTERR_BAD_FORMAT;\n\n\terrno = 0;\n\thr = strtoint(str + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\t/* explicit delimiter? */\n\tif (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\tmin = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\tif (*cp == ':')\n\t\t{\n\t\t\terrno = 0;\n\t\t\tsec = strtoint(cp + 1, &cp, 10);\n\t\t\tif (errno == ERANGE)\n\t\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\t}\n\t}\n\t/* otherwise, might have run things together... */\n\telse if (*cp == '\\0' && strlen(str) > 3)\n\t{\n\t\tmin = hr % 100;\n\t\thr = hr / 100;\n\t\t/* we could, but don't, support a run-together hhmmss format */\n\t}\n\telse\n\t\tmin = 0;\n\n\t/* Range-check the values; see notes in datatype/timestamp.h */\n\tif (hr < 0 || hr > MAX_TZDISP_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (min < 0 || min >= MINS_PER_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (sec < 0 || sec >= SECS_PER_MINUTE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\ttz = (hr * MINS_PER_HOUR + min) * SECS_PER_MINUTE + sec;\n\tif (*str == '-')\n\t\ttz = -tz;\n\n\t*tzp = -tz;\n\n\tif (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nDecodeTimezone(char *str, int *tzp)\n{\n\tint\t\t\ttz;\n\tint\t\t\thr,\n\t\t\t\tmin,\n\t\t\t\tsec = 0;\n\tchar\t   *cp;\n\n\t/* leading character must be \"+\" or \"-\" */\n\tif (*str != '+' && *str != '-')\n\t\treturn DTERR_BAD_FORMAT;\n\n\terrno = 0;\n\thr = strtoint(str + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\t/* explicit delimiter? */\n\tif (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\tmin = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\tif (*cp == ':')\n\t\t{\n\t\t\terrno = 0;\n\t\t\tsec = strtoint(cp + 1, &cp, 10);\n\t\t\tif (errno == ERANGE)\n\t\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\t}\n\t}\n\t/* otherwise, might have run things together... */\n\telse if (*cp == '\\0' && strlen(str) > 3)\n\t{\n\t\tmin = hr % 100;\n\t\thr = hr / 100;\n\t\t/* we could, but don't, support a run-together hhmmss format */\n\t}\n\telse\n\t\tmin = 0;\n\n\t/* Range-check the values; see notes in datatype/timestamp.h */\n\tif (hr < 0 || hr > MAX_TZDISP_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (min < 0 || min >= MINS_PER_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (sec < 0 || sec >= SECS_PER_MINUTE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\ttz = (hr * MINS_PER_HOUR + min) * SECS_PER_MINUTE + sec;\n\tif (*str == '-')\n\t\ttz = -tz;\n\n\t*tzp = -tz;\n\n\tif (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid input syntax for numeric time zone: \\\"%s\\\"\",\n\t\t\t\t\t\ttzname),\n\t\t\t\t errhint(\"Numeric time zones must have \\\"-\\\" or \\\"+\\\" as first character.\"))"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Numeric time zones must have \\\"-\\\" or \\\"+\\\" as first character.\""
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *tzname"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring_buffer",
          "args": [
            "zone",
            "tzname",
            "sizeof(tzname)"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "212-232",
          "snippet": "void\ntext_to_cstring_buffer(const text *src, char *dst, size_t dst_len)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *srcunpacked = pg_detoast_datum_packed((struct varlena *) src);\n\tsize_t\t\tsrc_len = VARSIZE_ANY_EXHDR(srcunpacked);\n\n\tif (dst_len > 0)\n\t{\n\t\tdst_len--;\n\t\tif (dst_len >= src_len)\n\t\t\tdst_len = src_len;\n\t\telse\t\t\t\t\t/* ensure truncation is encoding-safe */\n\t\t\tdst_len = pg_mbcliplen(VARDATA_ANY(srcunpacked), src_len, dst_len);\n\t\tmemcpy(dst, VARDATA_ANY(srcunpacked), dst_len);\n\t\tdst[dst_len] = '\\0';\n\t}\n\n\tif (srcunpacked != src)\n\t\tpfree(srcunpacked);\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\ntext_to_cstring_buffer(const text *src, char *dst, size_t dst_len)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *srcunpacked = pg_detoast_datum_packed((struct varlena *) src);\n\tsize_t\t\tsrc_len = VARSIZE_ANY_EXHDR(srcunpacked);\n\n\tif (dst_len > 0)\n\t{\n\t\tdst_len--;\n\t\tif (dst_len >= src_len)\n\t\t\tdst_len = src_len;\n\t\telse\t\t\t\t\t/* ensure truncation is encoding-safe */\n\t\t\tdst_len = pg_mbcliplen(VARDATA_ANY(srcunpacked), src_len, dst_len);\n\t\tmemcpy(dst, VARDATA_ANY(srcunpacked), dst_len);\n\t\tdst[dst_len] = '\\0';\n\t}\n\n\tif (srcunpacked != src)\n\t\tpfree(srcunpacked);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic int\nparse_sane_timezone(struct pg_tm *tm, text *zone)\n{\n\tchar\t\ttzname[TZ_STRLEN_MAX + 1];\n\tint\t\t\trt;\n\tint\t\t\ttz;\n\n\ttext_to_cstring_buffer(zone, tzname, sizeof(tzname));\n\n\t/*\n\t * Look up the requested timezone.  First we try to interpret it as a\n\t * numeric timezone specification; if DecodeTimezone decides it doesn't\n\t * like the format, we look in the timezone abbreviation table (to handle\n\t * cases like \"EST\"), and if that also fails, we look in the timezone\n\t * database (to handle cases like \"America/New_York\").  (This matches the\n\t * order in which timestamp input checks the cases; it's important because\n\t * the timezone database unwisely uses a few zone names that are identical\n\t * to offset abbreviations.)\n\t *\n\t * Note pg_tzset happily parses numeric input that DecodeTimezone would\n\t * reject.  To avoid having it accept input that would otherwise be seen\n\t * as invalid, it's enough to disallow having a digit in the first\n\t * position of our input string.\n\t */\n\tif (isdigit((unsigned char) *tzname))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid input syntax for numeric time zone: \\\"%s\\\"\",\n\t\t\t\t\t\ttzname),\n\t\t\t\t errhint(\"Numeric time zones must have \\\"-\\\" or \\\"+\\\" as first character.\")));\n\n\trt = DecodeTimezone(tzname, &tz);\n\tif (rt != 0)\n\t{\n\t\tchar\t   *lowzone;\n\t\tint\t\t\ttype,\n\t\t\t\t\tval;\n\t\tpg_tz\t   *tzp;\n\n\t\tif (rt == DTERR_TZDISP_OVERFLOW)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"numeric time zone \\\"%s\\\" out of range\", tzname)));\n\t\telse if (rt != DTERR_BAD_FORMAT)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname)));\n\n\t\t/* DecodeTimezoneAbbrev requires lowercase input */\n\t\tlowzone = downcase_truncate_identifier(tzname,\n\t\t\t\t\t\t\t\t\t\t\t   strlen(tzname),\n\t\t\t\t\t\t\t\t\t\t\t   false);\n\t\ttype = DecodeTimezoneAbbrev(0, lowzone, &val, &tzp);\n\n\t\tif (type == TZ || type == DTZ)\n\t\t{\n\t\t\t/* fixed-offset abbreviation */\n\t\t\ttz = -val;\n\t\t}\n\t\telse if (type == DYNTZ)\n\t\t{\n\t\t\t/* dynamic-offset abbreviation, resolve using specified time */\n\t\t\ttz = DetermineTimeZoneAbbrevOffset(tm, tzname, tzp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* try it as a full zone name */\n\t\t\ttzp = pg_tzset(tzname);\n\t\t\tif (tzp)\n\t\t\t\ttz = DetermineTimeZoneOffset(tm, tzp);\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname)));\n\t\t}\n\t}\n\n\treturn tz;\n}"
  },
  {
    "function_name": "timestamptz_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "382-448",
    "snippet": "Datum\ntimestamptz_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tTimestampTz result;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tint\t\t\tdterr;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tworkbuf[MAXDATELEN + MAXDATEFIELDS];\n\n\tdterr = ParseDateTime(str, workbuf, sizeof(workbuf),\n\t\t\t\t\t\t  field, ftype, MAXDATEFIELDS, &nf);\n\tif (dterr == 0)\n\t\tdterr = DecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, &tz);\n\tif (dterr != 0)\n\t\tDateTimeParseError(dterr, str, \"timestamp with time zone\");\n\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range: \\\"%s\\\"\", str)));\n\t\t\tbreak;\n\n\t\tcase DTK_EPOCH:\n\t\t\tresult = SetEpochTimestamp();\n\t\t\tbreak;\n\n\t\tcase DTK_LATE:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\n\t\tcase DTK_EARLY:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\n\t\tcase DTK_INVALID:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"date/time value \\\"%s\\\" is no longer supported\", str)));\n\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected dtype %d while parsing timestamptz \\\"%s\\\"\",\n\t\t\t\t dtype, str);\n\t\t\tTIMESTAMP_NOEND(result);\n\t}\n\n\tAdjustTimestampForTypmod(&result, typmod);\n\n\tPG_RETURN_TIMESTAMPTZ(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMPTZ",
          "args": [
            "result"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustTimestampForTypmod",
          "args": [
            "&result",
            "typmod"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustTimestampForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "333-376",
          "snippet": "static void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
            "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOEND",
          "args": [
            "result"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected dtype %d while parsing timestamptz \\\"%s\\\"\"",
            "dtype",
            "str"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOEND",
          "args": [
            "result"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"date/time value \\\"%s\\\" is no longer supported\", str))"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"date/time value \\\"%s\\\" is no longer supported\"",
            "str"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOBEGIN",
          "args": [
            "result"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOEND",
          "args": [
            "result"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetEpochTimestamp",
          "args": [],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "SetEpochTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2005-2017",
          "snippet": "Timestamp\nSetEpochTimestamp(void)\n{\n\tTimestamp\tdt;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tGetEpochTime(tm);\n\t/* we don't bother to test for failure ... */\n\ttm2timestamp(tm, 0, NULL, &dt);\n\n\treturn dt;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestamp\nSetEpochTimestamp(void)\n{\n\tTimestamp\tdt;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tGetEpochTime(tm);\n\t/* we don't bother to test for failure ... */\n\ttm2timestamp(tm, 0, NULL, &dt);\n\n\treturn dt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range: \\\"%s\\\"\", str))"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm2timestamp",
          "args": [
            "tm",
            "fsec",
            "&tz",
            "&result"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1853-1895",
          "snippet": "int\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DateTimeParseError",
          "args": [
            "dterr",
            "str",
            "\"timestamp with time zone\""
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeParseError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3753-3792",
          "snippet": "void\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeDateTime",
          "args": [
            "field",
            "ftype",
            "nf",
            "&dtype",
            "tm",
            "&fsec",
            "&tz"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "766-1439",
          "snippet": "int\nDecodeDateTime(char **field, int *ftype, int nf,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\tptype = 0;\t\t/* \"prefix type\" for ISO y2001m02d04 format */\n\tint\t\t\ti;\n\tint\t\t\tval;\n\tint\t\t\tdterr;\n\tint\t\t\tmer = HR24;\n\tbool\t\thaveTextMonth = false;\n\tbool\t\tisjulian = false;\n\tbool\t\tis2digits = false;\n\tbool\t\tbc = false;\n\tpg_tz\t   *namedTz = NULL;\n\tpg_tz\t   *abbrevTz = NULL;\n\tpg_tz\t   *valtz;\n\tchar\t   *abbrev = NULL;\n\tstruct pg_tm cur_tm;\n\n\t/*\n\t * We'll insist on at least all of the date fields, but initialize the\n\t * remaining fields in case they are not set later...\n\t */\n\t*dtype = DTK_DATE;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n\t/* don't know daylight savings time status apriori */\n\ttm->tm_isdst = -1;\n\tif (tzp != NULL)\n\t\t*tzp = 0;\n\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_DATE:\n\n\t\t\t\t/*\n\t\t\t\t * Integral julian day with attached time zone? All other\n\t\t\t\t * forms with JD will be separated into distinct fields, so we\n\t\t\t\t * handle just this case here.\n\t\t\t\t */\n\t\t\t\tif (ptype == DTK_JULIAN)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE || val < 0)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\ttmask = DTK_DATE_M | DTK_TIME_M | DTK_M(TZ);\n\t\t\t\t\tptype = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Already have a date? Then this might be a time zone name\n\t\t\t\t * with embedded punctuation (e.g. \"America/New_York\") or a\n\t\t\t\t * run-together time with trailing time zone (e.g. hhmmss-zz).\n\t\t\t\t * - thomas 2001-12-25\n\t\t\t\t *\n\t\t\t\t * We consider it a time zone if we already have month & day.\n\t\t\t\t * This is to allow the form \"mmm dd hhmmss tz year\", which\n\t\t\t\t * we've historically accepted.\n\t\t\t\t */\n\t\t\t\telse if (ptype != 0 ||\n\t\t\t\t\t\t ((fmask & (DTK_M(MONTH) | DTK_M(DAY))) ==\n\t\t\t\t\t\t  (DTK_M(MONTH) | DTK_M(DAY))))\n\t\t\t\t{\n\t\t\t\t\t/* No time zone accepted? Then quit... */\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tif (isdigit((unsigned char) *field[i]) || ptype != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t   *cp;\n\n\t\t\t\t\t\tif (ptype != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tptype = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Starts with a digit but we already have a time\n\t\t\t\t\t\t * field? Then we are in trouble with a date and time\n\t\t\t\t\t\t * already...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tif ((cp = strchr(field[i], '-')) == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t*cp = '\\0';\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Then read the rest of the field as a concatenated\n\t\t\t\t\t\t * time\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * modify tmask after returning from\n\t\t\t\t\t\t * DecodeNumberField()\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We should return an error code instead of\n\t\t\t\t\t\t\t * ereport'ing directly, but then there is no way\n\t\t\t\t\t\t\t * to report the bad time zone name.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TIME:\n\n\t\t\t\t/*\n\t\t\t\t * This might be an ISO time following a \"t\" field.\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tptype = 0;\n\t\t\t\t}\n\t\t\t\tdterr = DecodeTime(field[i], fmask, INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\n\t\t\t\t/*\n\t\t\t\t * Check upper limit on hours; other limits checked in\n\t\t\t\t * DecodeTime()\n\t\t\t\t */\n\t\t\t\t/* test for > 24:00:00 */\n\t\t\t\tif (tm->tm_hour > HOURS_PER_DAY ||\n\t\t\t\t\t(tm->tm_hour == HOURS_PER_DAY &&\n\t\t\t\t\t (tm->tm_min > 0 || tm->tm_sec > 0 || *fsec > 0)))\n\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tdterr = DecodeTimezone(field[i], &tz);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t*tzp = tz;\n\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_NUMBER:\n\n\t\t\t\t/*\n\t\t\t\t * Was this an \"ISO date\" with embedded field labels? An\n\t\t\t\t * example is \"y2001m02d04\" - thomas 2001-02-04\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only a few kinds are allowed to have an embedded\n\t\t\t\t\t * decimal\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MONTH:\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * already have a month and hour? then assume\n\t\t\t\t\t\t\t * minutes\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) != 0 &&\n\t\t\t\t\t\t\t\t(fmask & DTK_M(HOUR)) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\t\ttm->tm_hour = val;\n\t\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\ttm->tm_sec = val;\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TZ:\n\t\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\t\tdterr = DecodeTimezone(field[i], tzp);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\t/* previous field was a label for \"julian date\" */\n\t\t\t\t\t\t\tif (val < 0)\n\t\t\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t\t\t/* fractional Julian Day? */\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdouble\t\ttime;\n\n\t\t\t\t\t\t\t\terrno = 0;\n\t\t\t\t\t\t\t\ttime = strtod(cp, &cp);\n\t\t\t\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\ttime *= USECS_PER_DAY;\n\t\t\t\t\t\t\t\tdt2time(time,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_hour, &tm->tm_min,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_sec, fsec);\n\t\t\t\t\t\t\t\ttmask |= DTK_TIME_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\t/* previous field was \"t\" for ISO time */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tif (tmask != DTK_TIME_M)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tptype = 0;\n\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tflen;\n\n\t\t\t\t\tflen = strlen(field[i]);\n\t\t\t\t\tcp = strchr(field[i], '.');\n\n\t\t\t\t\t/* Embedded decimal and no date yet? */\n\t\t\t\t\tif (cp != NULL && !(fmask & DTK_DATE_M))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* embedded decimal and several digits before? */\n\t\t\t\t\telse if (cp != NULL && flen - strlen(cp) > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Interpret as a concatenated date or time Set the\n\t\t\t\t\t\t * type field to allow decoding other fields later.\n\t\t\t\t\t\t * Example: 20011223 or 040506\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Is this a YMD or HMS specification, or a year number?\n\t\t\t\t\t * YMD and HMS are required to be six digits or more, so\n\t\t\t\t\t * if it is 5 digits, it is a year.  If it is six or more\n\t\t\t\t\t * more digits, we assume it is YMD or HMS unless no date\n\t\t\t\t\t * and no time values have been specified.  This forces 6+\n\t\t\t\t\t * digit years to be at the end of the string, or to use\n\t\t\t\t\t * the ISO date specification.\n\t\t\t\t\t */\n\t\t\t\t\telse if (flen >= 6 && (!(fmask & DTK_DATE_M) ||\n\t\t\t\t\t\t\t\t\t\t   !(fmask & DTK_TIME_M)))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* otherwise it is a single date/time field... */\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumber(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t haveTextMonth, fmask,\n\t\t\t\t\t\t\t\t\t\t\t &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t fsec, &is2digits);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\t/* timezone abbrevs take precedence over built-in tokens */\n\t\t\t\ttype = DecodeTimezoneAbbrev(i, field[i], &val, &valtz);\n\t\t\t\tif (type == UNKNOWN_FIELD)\n\t\t\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = DTK_M(type);\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\tswitch (val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_CURRENT:\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_NOW:\n\t\t\t\t\t\t\t\ttmask = (DTK_DATE_M | DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentTimeUsec(tm, fsec, tzp);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_YESTERDAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) - 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TODAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\ttm->tm_year = cur_tm.tm_year;\n\t\t\t\t\t\t\t\ttm->tm_mon = cur_tm.tm_mon;\n\t\t\t\t\t\t\t\ttm->tm_mday = cur_tm.tm_mday;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TOMORROW:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) + 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_ZULU:\n\t\t\t\t\t\t\t\ttmask = (DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t\t\t\tif (tzp != NULL)\n\t\t\t\t\t\t\t\t\t*tzp = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t*dtype = val;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MONTH:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * already have a (numeric) month? then see if we can\n\t\t\t\t\t\t * substitute...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) && !haveTextMonth &&\n\t\t\t\t\t\t\t!(fmask & DTK_M(DAY)) && tm->tm_mon >= 1 &&\n\t\t\t\t\t\t\ttm->tm_mon <= 31)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttm->tm_mday = tm->tm_mon;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thaveTextMonth = true;\n\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZMOD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * daylight savings time modifier (solves \"MET DST\"\n\t\t\t\t\t\t * syntax)\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(DTZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp -= val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZ:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * set mask for TZ here _or_ check for DTZ later when\n\t\t\t\t\t\t * getting default timezone\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TZ:\n\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DYNTZ:\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll determine the actual offset later */\n\t\t\t\t\t\tabbrevTz = valtz;\n\t\t\t\t\t\tabbrev = field[i];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AMPM:\n\t\t\t\t\t\tmer = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ADBC:\n\t\t\t\t\t\tbc = (val == BC);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DOW:\n\t\t\t\t\t\ttm->tm_wday = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttmask = 0;\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ISOTIME:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is a filler field \"t\" indicating that the next\n\t\t\t\t\t\t * field is time. Try to verify that this is sensible.\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask = 0;\n\n\t\t\t\t\t\t/* No preceding date? Then quit... */\n\t\t\t\t\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/***\n\t\t\t\t\t\t * We will need one of the following fields:\n\t\t\t\t\t\t *\tDTK_NUMBER should be hhmmss.fff\n\t\t\t\t\t\t *\tDTK_TIME should be hh:mm:ss.fff\n\t\t\t\t\t\t *\tDTK_DATE should be hhmmss-zz\n\t\t\t\t\t\t ***/\n\t\t\t\t\t\tif (i >= nf - 1 ||\n\t\t\t\t\t\t\t(ftype[i + 1] != DTK_NUMBER &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_TIME &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_DATE))\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNKNOWN_FIELD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Before giving up and declaring error, check to see\n\t\t\t\t\t\t * if it is an all-alpha timezone name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\t\t\t\t\t\t\t/* end loop over fields */\n\n\t/* do final checking/adjustment of Y/M/D fields */\n\tdterr = ValidateDate(fmask, isjulian, is2digits, bc, tm);\n\tif (dterr)\n\t\treturn dterr;\n\n\t/* handle AM/PM */\n\tif (mer != HR24 && tm->tm_hour > HOURS_PER_DAY / 2)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (mer == AM && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\ttm->tm_hour = 0;\n\telse if (mer == PM && tm->tm_hour != HOURS_PER_DAY / 2)\n\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\n\t/* do additional checking for full date specs... */\n\tif (*dtype == DTK_DATE)\n\t{\n\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t{\n\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\treturn 1;\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\t/*\n\t\t * If we had a full timezone spec, compute the offset (we could not do\n\t\t * it before, because we need the date to resolve DST status).\n\t\t */\n\t\tif (namedTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with full TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, namedTz);\n\t\t}\n\n\t\t/*\n\t\t * Likewise, if we had a dynamic timezone abbreviation, resolve it\n\t\t * now.\n\t\t */\n\t\tif (abbrevTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with dynamic TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneAbbrevOffset(tm, abbrev, abbrevTz);\n\t\t}\n\n\t\t/* timezone not specified? then use session timezone */\n\t\tif (tzp != NULL && !(fmask & DTK_M(TZ)))\n\t\t{\n\t\t\t/*\n\t\t\t * daylight savings time modifier but no standard timezone? then\n\t\t\t * error\n\t\t\t */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, session_timezone);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDecodeDateTime(char **field, int *ftype, int nf,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\tptype = 0;\t\t/* \"prefix type\" for ISO y2001m02d04 format */\n\tint\t\t\ti;\n\tint\t\t\tval;\n\tint\t\t\tdterr;\n\tint\t\t\tmer = HR24;\n\tbool\t\thaveTextMonth = false;\n\tbool\t\tisjulian = false;\n\tbool\t\tis2digits = false;\n\tbool\t\tbc = false;\n\tpg_tz\t   *namedTz = NULL;\n\tpg_tz\t   *abbrevTz = NULL;\n\tpg_tz\t   *valtz;\n\tchar\t   *abbrev = NULL;\n\tstruct pg_tm cur_tm;\n\n\t/*\n\t * We'll insist on at least all of the date fields, but initialize the\n\t * remaining fields in case they are not set later...\n\t */\n\t*dtype = DTK_DATE;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n\t/* don't know daylight savings time status apriori */\n\ttm->tm_isdst = -1;\n\tif (tzp != NULL)\n\t\t*tzp = 0;\n\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_DATE:\n\n\t\t\t\t/*\n\t\t\t\t * Integral julian day with attached time zone? All other\n\t\t\t\t * forms with JD will be separated into distinct fields, so we\n\t\t\t\t * handle just this case here.\n\t\t\t\t */\n\t\t\t\tif (ptype == DTK_JULIAN)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE || val < 0)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\ttmask = DTK_DATE_M | DTK_TIME_M | DTK_M(TZ);\n\t\t\t\t\tptype = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Already have a date? Then this might be a time zone name\n\t\t\t\t * with embedded punctuation (e.g. \"America/New_York\") or a\n\t\t\t\t * run-together time with trailing time zone (e.g. hhmmss-zz).\n\t\t\t\t * - thomas 2001-12-25\n\t\t\t\t *\n\t\t\t\t * We consider it a time zone if we already have month & day.\n\t\t\t\t * This is to allow the form \"mmm dd hhmmss tz year\", which\n\t\t\t\t * we've historically accepted.\n\t\t\t\t */\n\t\t\t\telse if (ptype != 0 ||\n\t\t\t\t\t\t ((fmask & (DTK_M(MONTH) | DTK_M(DAY))) ==\n\t\t\t\t\t\t  (DTK_M(MONTH) | DTK_M(DAY))))\n\t\t\t\t{\n\t\t\t\t\t/* No time zone accepted? Then quit... */\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tif (isdigit((unsigned char) *field[i]) || ptype != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t   *cp;\n\n\t\t\t\t\t\tif (ptype != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tptype = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Starts with a digit but we already have a time\n\t\t\t\t\t\t * field? Then we are in trouble with a date and time\n\t\t\t\t\t\t * already...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tif ((cp = strchr(field[i], '-')) == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t*cp = '\\0';\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Then read the rest of the field as a concatenated\n\t\t\t\t\t\t * time\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * modify tmask after returning from\n\t\t\t\t\t\t * DecodeNumberField()\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We should return an error code instead of\n\t\t\t\t\t\t\t * ereport'ing directly, but then there is no way\n\t\t\t\t\t\t\t * to report the bad time zone name.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TIME:\n\n\t\t\t\t/*\n\t\t\t\t * This might be an ISO time following a \"t\" field.\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tptype = 0;\n\t\t\t\t}\n\t\t\t\tdterr = DecodeTime(field[i], fmask, INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\n\t\t\t\t/*\n\t\t\t\t * Check upper limit on hours; other limits checked in\n\t\t\t\t * DecodeTime()\n\t\t\t\t */\n\t\t\t\t/* test for > 24:00:00 */\n\t\t\t\tif (tm->tm_hour > HOURS_PER_DAY ||\n\t\t\t\t\t(tm->tm_hour == HOURS_PER_DAY &&\n\t\t\t\t\t (tm->tm_min > 0 || tm->tm_sec > 0 || *fsec > 0)))\n\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tdterr = DecodeTimezone(field[i], &tz);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t*tzp = tz;\n\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_NUMBER:\n\n\t\t\t\t/*\n\t\t\t\t * Was this an \"ISO date\" with embedded field labels? An\n\t\t\t\t * example is \"y2001m02d04\" - thomas 2001-02-04\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only a few kinds are allowed to have an embedded\n\t\t\t\t\t * decimal\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MONTH:\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * already have a month and hour? then assume\n\t\t\t\t\t\t\t * minutes\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) != 0 &&\n\t\t\t\t\t\t\t\t(fmask & DTK_M(HOUR)) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\t\ttm->tm_hour = val;\n\t\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\ttm->tm_sec = val;\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TZ:\n\t\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\t\tdterr = DecodeTimezone(field[i], tzp);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\t/* previous field was a label for \"julian date\" */\n\t\t\t\t\t\t\tif (val < 0)\n\t\t\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t\t\t/* fractional Julian Day? */\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdouble\t\ttime;\n\n\t\t\t\t\t\t\t\terrno = 0;\n\t\t\t\t\t\t\t\ttime = strtod(cp, &cp);\n\t\t\t\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\ttime *= USECS_PER_DAY;\n\t\t\t\t\t\t\t\tdt2time(time,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_hour, &tm->tm_min,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_sec, fsec);\n\t\t\t\t\t\t\t\ttmask |= DTK_TIME_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\t/* previous field was \"t\" for ISO time */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tif (tmask != DTK_TIME_M)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tptype = 0;\n\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tflen;\n\n\t\t\t\t\tflen = strlen(field[i]);\n\t\t\t\t\tcp = strchr(field[i], '.');\n\n\t\t\t\t\t/* Embedded decimal and no date yet? */\n\t\t\t\t\tif (cp != NULL && !(fmask & DTK_DATE_M))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* embedded decimal and several digits before? */\n\t\t\t\t\telse if (cp != NULL && flen - strlen(cp) > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Interpret as a concatenated date or time Set the\n\t\t\t\t\t\t * type field to allow decoding other fields later.\n\t\t\t\t\t\t * Example: 20011223 or 040506\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Is this a YMD or HMS specification, or a year number?\n\t\t\t\t\t * YMD and HMS are required to be six digits or more, so\n\t\t\t\t\t * if it is 5 digits, it is a year.  If it is six or more\n\t\t\t\t\t * more digits, we assume it is YMD or HMS unless no date\n\t\t\t\t\t * and no time values have been specified.  This forces 6+\n\t\t\t\t\t * digit years to be at the end of the string, or to use\n\t\t\t\t\t * the ISO date specification.\n\t\t\t\t\t */\n\t\t\t\t\telse if (flen >= 6 && (!(fmask & DTK_DATE_M) ||\n\t\t\t\t\t\t\t\t\t\t   !(fmask & DTK_TIME_M)))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* otherwise it is a single date/time field... */\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumber(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t haveTextMonth, fmask,\n\t\t\t\t\t\t\t\t\t\t\t &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t fsec, &is2digits);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\t/* timezone abbrevs take precedence over built-in tokens */\n\t\t\t\ttype = DecodeTimezoneAbbrev(i, field[i], &val, &valtz);\n\t\t\t\tif (type == UNKNOWN_FIELD)\n\t\t\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = DTK_M(type);\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\tswitch (val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_CURRENT:\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_NOW:\n\t\t\t\t\t\t\t\ttmask = (DTK_DATE_M | DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentTimeUsec(tm, fsec, tzp);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_YESTERDAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) - 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TODAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\ttm->tm_year = cur_tm.tm_year;\n\t\t\t\t\t\t\t\ttm->tm_mon = cur_tm.tm_mon;\n\t\t\t\t\t\t\t\ttm->tm_mday = cur_tm.tm_mday;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TOMORROW:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) + 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_ZULU:\n\t\t\t\t\t\t\t\ttmask = (DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t\t\t\tif (tzp != NULL)\n\t\t\t\t\t\t\t\t\t*tzp = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t*dtype = val;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MONTH:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * already have a (numeric) month? then see if we can\n\t\t\t\t\t\t * substitute...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) && !haveTextMonth &&\n\t\t\t\t\t\t\t!(fmask & DTK_M(DAY)) && tm->tm_mon >= 1 &&\n\t\t\t\t\t\t\ttm->tm_mon <= 31)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttm->tm_mday = tm->tm_mon;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thaveTextMonth = true;\n\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZMOD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * daylight savings time modifier (solves \"MET DST\"\n\t\t\t\t\t\t * syntax)\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(DTZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp -= val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZ:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * set mask for TZ here _or_ check for DTZ later when\n\t\t\t\t\t\t * getting default timezone\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TZ:\n\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DYNTZ:\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll determine the actual offset later */\n\t\t\t\t\t\tabbrevTz = valtz;\n\t\t\t\t\t\tabbrev = field[i];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AMPM:\n\t\t\t\t\t\tmer = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ADBC:\n\t\t\t\t\t\tbc = (val == BC);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DOW:\n\t\t\t\t\t\ttm->tm_wday = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttmask = 0;\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ISOTIME:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is a filler field \"t\" indicating that the next\n\t\t\t\t\t\t * field is time. Try to verify that this is sensible.\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask = 0;\n\n\t\t\t\t\t\t/* No preceding date? Then quit... */\n\t\t\t\t\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/***\n\t\t\t\t\t\t * We will need one of the following fields:\n\t\t\t\t\t\t *\tDTK_NUMBER should be hhmmss.fff\n\t\t\t\t\t\t *\tDTK_TIME should be hh:mm:ss.fff\n\t\t\t\t\t\t *\tDTK_DATE should be hhmmss-zz\n\t\t\t\t\t\t ***/\n\t\t\t\t\t\tif (i >= nf - 1 ||\n\t\t\t\t\t\t\t(ftype[i + 1] != DTK_NUMBER &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_TIME &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_DATE))\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNKNOWN_FIELD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Before giving up and declaring error, check to see\n\t\t\t\t\t\t * if it is an all-alpha timezone name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\t\t\t\t\t\t\t/* end loop over fields */\n\n\t/* do final checking/adjustment of Y/M/D fields */\n\tdterr = ValidateDate(fmask, isjulian, is2digits, bc, tm);\n\tif (dterr)\n\t\treturn dterr;\n\n\t/* handle AM/PM */\n\tif (mer != HR24 && tm->tm_hour > HOURS_PER_DAY / 2)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (mer == AM && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\ttm->tm_hour = 0;\n\telse if (mer == PM && tm->tm_hour != HOURS_PER_DAY / 2)\n\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\n\t/* do additional checking for full date specs... */\n\tif (*dtype == DTK_DATE)\n\t{\n\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t{\n\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\treturn 1;\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\t/*\n\t\t * If we had a full timezone spec, compute the offset (we could not do\n\t\t * it before, because we need the date to resolve DST status).\n\t\t */\n\t\tif (namedTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with full TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, namedTz);\n\t\t}\n\n\t\t/*\n\t\t * Likewise, if we had a dynamic timezone abbreviation, resolve it\n\t\t * now.\n\t\t */\n\t\tif (abbrevTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with dynamic TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneAbbrevOffset(tm, abbrev, abbrevTz);\n\t\t}\n\n\t\t/* timezone not specified? then use session timezone */\n\t\tif (tzp != NULL && !(fmask & DTK_M(TZ)))\n\t\t{\n\t\t\t/*\n\t\t\t * daylight savings time modifier but no standard timezone? then\n\t\t\t * error\n\t\t\t */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, session_timezone);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseDateTime",
          "args": [
            "str",
            "workbuf",
            "sizeof(workbuf)",
            "field",
            "ftype",
            "MAXDATEFIELDS",
            "&nf"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "ParseDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "545-739",
          "snippet": "int\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
            "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\n\nint\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamptz_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tTimestampTz result;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tint\t\t\tdterr;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tworkbuf[MAXDATELEN + MAXDATEFIELDS];\n\n\tdterr = ParseDateTime(str, workbuf, sizeof(workbuf),\n\t\t\t\t\t\t  field, ftype, MAXDATEFIELDS, &nf);\n\tif (dterr == 0)\n\t\tdterr = DecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, &tz);\n\tif (dterr != 0)\n\t\tDateTimeParseError(dterr, str, \"timestamp with time zone\");\n\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tif (tm2timestamp(tm, fsec, &tz, &result) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range: \\\"%s\\\"\", str)));\n\t\t\tbreak;\n\n\t\tcase DTK_EPOCH:\n\t\t\tresult = SetEpochTimestamp();\n\t\t\tbreak;\n\n\t\tcase DTK_LATE:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\n\t\tcase DTK_EARLY:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\n\t\tcase DTK_INVALID:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"date/time value \\\"%s\\\" is no longer supported\", str)));\n\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected dtype %d while parsing timestamptz \\\"%s\\\"\",\n\t\t\t\t dtype, str);\n\t\t\tTIMESTAMP_NOEND(result);\n\t}\n\n\tAdjustTimestampForTypmod(&result, typmod);\n\n\tPG_RETURN_TIMESTAMPTZ(result);\n}"
  },
  {
    "function_name": "AdjustTimestampForTypmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "333-376",
    "snippet": "static void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION))"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp(%d) precision must be between %d and %d\"",
            "typmod",
            "0",
            "MAX_TIMESTAMP_PRECISION"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "*time"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "5"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "50"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "500"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "5000"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "50000"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "500000"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "1"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "10"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "100"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "1000"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "10000"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "100000"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "1000000"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "timestamp_scale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "315-327",
    "snippet": "Datum\ntimestamp_scale(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tTimestamp\tresult;\n\n\tresult = timestamp;\n\n\tAdjustTimestampForTypmod(&result, typmod);\n\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustTimestampForTypmod",
          "args": [
            "&result",
            "typmod"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustTimestampForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "333-376",
          "snippet": "static void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
            "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamp_scale(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tTimestamp\tresult;\n\n\tresult = timestamp;\n\n\tAdjustTimestampForTypmod(&result, typmod);\n\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "timestamp_transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "304-309",
    "snippet": "Datum\ntimestamp_transform(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_POINTER(TemporalTransform(MAX_TIMESTAMP_PRECISION,\n\t\t\t\t\t\t\t\t\t\t(Node *) PG_GETARG_POINTER(0)));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "TemporalTransform(MAX_TIMESTAMP_PRECISION,\n\t\t\t\t\t\t\t\t\t\t(Node *) PG_GETARG_POINTER(0))"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TemporalTransform",
          "args": [
            "MAX_TIMESTAMP_PRECISION",
            "(Node *) PG_GETARG_POINTER(0)"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "TemporalTransform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "4474-4497",
          "snippet": "Node *\nTemporalTransform(int32 max_precis, Node *node)\n{\n\tFuncExpr   *expr = castNode(FuncExpr, node);\n\tNode\t   *ret = NULL;\n\tNode\t   *typmod;\n\n\tAssert(list_length(expr->args) >= 2);\n\n\ttypmod = (Node *) lsecond(expr->args);\n\n\tif (IsA(typmod, Const) &&!((Const *) typmod)->constisnull)\n\t{\n\t\tNode\t   *source = (Node *) linitial(expr->args);\n\t\tint32\t\told_precis = exprTypmod(source);\n\t\tint32\t\tnew_precis = DatumGetInt32(((Const *) typmod)->constvalue);\n\n\t\tif (new_precis < 0 || new_precis == max_precis ||\n\t\t\t(old_precis >= 0 && new_precis >= old_precis))\n\t\t\tret = relabel_to_typmod(source, new_precis);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nNode *\nTemporalTransform(int32 max_precis, Node *node)\n{\n\tFuncExpr   *expr = castNode(FuncExpr, node);\n\tNode\t   *ret = NULL;\n\tNode\t   *typmod;\n\n\tAssert(list_length(expr->args) >= 2);\n\n\ttypmod = (Node *) lsecond(expr->args);\n\n\tif (IsA(typmod, Const) &&!((Const *) typmod)->constisnull)\n\t{\n\t\tNode\t   *source = (Node *) linitial(expr->args);\n\t\tint32\t\told_precis = exprTypmod(source);\n\t\tint32\t\tnew_precis = DatumGetInt32(((Const *) typmod)->constvalue);\n\n\t\tif (new_precis < 0 || new_precis == max_precis ||\n\t\t\t(old_precis >= 0 && new_precis >= old_precis))\n\t\t\tret = relabel_to_typmod(source, new_precis);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_transform(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_POINTER(TemporalTransform(MAX_TIMESTAMP_PRECISION,\n\t\t\t\t\t\t\t\t\t\t(Node *) PG_GETARG_POINTER(0)));\n}"
  },
  {
    "function_name": "timestamptypmodout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "291-297",
    "snippet": "Datum\ntimestamptypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\n\tPG_RETURN_CSTRING(anytimestamp_typmodout(false, typmod));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "anytimestamp_typmodout(false, typmod)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anytimestamp_typmodout",
          "args": [
            "false",
            "typmod"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "anytimestamp_typmodout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "123-132",
          "snippet": "static char *\nanytimestamp_typmodout(bool istz, int32 typmod)\n{\n\tconst char *tz = istz ? \" with time zone\" : \" without time zone\";\n\n\tif (typmod >= 0)\n\t\treturn psprintf(\"(%d)%s\", (int) typmod, tz);\n\telse\n\t\treturn psprintf(\"%s\", tz);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
            "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nstatic char *\nanytimestamp_typmodout(bool istz, int32 typmod)\n{\n\tconst char *tz = istz ? \" with time zone\" : \" without time zone\";\n\n\tif (typmod >= 0)\n\t\treturn psprintf(\"(%d)%s\", (int) typmod, tz);\n\telse\n\t\treturn psprintf(\"%s\", tz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nDatum\ntimestamptypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\n\tPG_RETURN_CSTRING(anytimestamp_typmodout(false, typmod));\n}"
  },
  {
    "function_name": "timestamptypmodin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "283-289",
    "snippet": "Datum\ntimestamptypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\n\tPG_RETURN_INT32(anytimestamp_typmodin(false, ta));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "anytimestamp_typmodin(false, ta)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anytimestamp_typmodin",
          "args": [
            "false",
            "ta"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "anytimestamp_typmodin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "80-98",
          "snippet": "static int32\nanytimestamp_typmodin(bool istz, ArrayType *ta)\n{\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for TIMESTAMP\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\treturn anytimestamp_typmod_check(istz, tl[0]);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32\nanytimestamp_typmodin(bool istz, ArrayType *ta)\n{\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for TIMESTAMP\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\treturn anytimestamp_typmod_check(istz, tl[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamptypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\n\tPG_RETURN_INT32(anytimestamp_typmodin(false, ta));\n}"
  },
  {
    "function_name": "timestamp_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "272-281",
    "snippet": "Datum\ntimestamp_send(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint64(&buf, timestamp);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint64",
          "args": [
            "&buf",
            "timestamp"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamp_send(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint64(&buf, timestamp);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "timestamp_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "239-267",
    "snippet": "Datum\ntimestamp_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tTimestamp\ttimestamp;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\n\ttimestamp = (Timestamp) pq_getmsgint64(buf);\n\n\t/* range check: see if timestamp_out would like it */\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t /* ok */ ;\n\telse if (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0 ||\n\t\t\t !IS_VALID_TIMESTAMP(timestamp))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tAdjustTimestampForTypmod(&timestamp, typmod);\n\n\tPG_RETURN_TIMESTAMP(timestamp);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "timestamp"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustTimestampForTypmod",
          "args": [
            "&timestamp",
            "typmod"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustTimestampForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "333-376",
          "snippet": "static void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
            "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_TIMESTAMP",
          "args": [
            "timestamp"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "NULL",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint64",
          "args": [
            "buf"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamp_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tTimestamp\ttimestamp;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\n\ttimestamp = (Timestamp) pq_getmsgint64(buf);\n\n\t/* range check: see if timestamp_out would like it */\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t /* ok */ ;\n\telse if (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0 ||\n\t\t\t !IS_VALID_TIMESTAMP(timestamp))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tAdjustTimestampForTypmod(&timestamp, typmod);\n\n\tPG_RETURN_TIMESTAMP(timestamp);\n}"
  },
  {
    "function_name": "timestamp_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "213-234",
    "snippet": "Datum\ntimestamp_out(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\tchar\t   *result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tEncodeSpecialTimestamp(timestamp, buf);\n\telse if (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) == 0)\n\t\tEncodeDateTime(tm, fsec, false, 0, NULL, DateStyle, buf);\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tresult = pstrdup(buf);\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "buf"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeDateTime",
          "args": [
            "tm",
            "fsec",
            "false",
            "0",
            "NULL",
            "DateStyle",
            "buf"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3987-4149",
          "snippet": "void\nEncodeDateTime(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str)\n{\n\tint\t\t\tday;\n\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\t/*\n\t * Negative tm_isdst means we have no valid time zone translation.\n\t */\n\tif (tm->tm_isdst < 0)\n\t\tprint_tz = false;\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* Compatible with ISO-8601 date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = (style == USE_ISO_DATES) ? ' ' : 'T';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\tif (print_tz)\n\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* Compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\t/*\n\t\t\t * Note: the uses of %.*s in this function would be risky if the\n\t\t\t * timezone names ever contain non-ASCII characters.  However, all\n\t\t\t * TZ abbreviations in the IANA database are plain ASCII.\n\t\t\t */\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German variant on European style */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* Backward-compatible with traditional Postgres abstime dates */\n\t\t\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\ttm->tm_wday = j2day(day);\n\t\t\tmemcpy(str, days[tm->tm_wday], 3);\n\t\t\tstr += 3;\n\t\t\t*str++ = ' ';\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = ' ';\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t\t*str++ = ' ';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We have a time zone, but no string version. Use the\n\t\t\t\t\t * numeric form, but be sure to include a leading space to\n\t\t\t\t\t * avoid formatting something which would be rejected by\n\t\t\t\t\t * the date/time parser later. - thomas 2001-10-19\n\t\t\t\t\t */\n\t\t\t\t\t*str++ = ' ';\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "const char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};",
            "const char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nconst char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};\nconst char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};\n\nvoid\nEncodeDateTime(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str)\n{\n\tint\t\t\tday;\n\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\t/*\n\t * Negative tm_isdst means we have no valid time zone translation.\n\t */\n\tif (tm->tm_isdst < 0)\n\t\tprint_tz = false;\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* Compatible with ISO-8601 date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = (style == USE_ISO_DATES) ? ' ' : 'T';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\tif (print_tz)\n\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* Compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\t/*\n\t\t\t * Note: the uses of %.*s in this function would be risky if the\n\t\t\t * timezone names ever contain non-ASCII characters.  However, all\n\t\t\t * TZ abbreviations in the IANA database are plain ASCII.\n\t\t\t */\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German variant on European style */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* Backward-compatible with traditional Postgres abstime dates */\n\t\t\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\ttm->tm_wday = j2day(day);\n\t\t\tmemcpy(str, days[tm->tm_wday], 3);\n\t\t\tstr += 3;\n\t\t\t*str++ = ' ';\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = ' ';\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t\t*str++ = ' ';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We have a time zone, but no string version. Use the\n\t\t\t\t\t * numeric form, but be sure to include a leading space to\n\t\t\t\t\t * avoid formatting something which would be rejected by\n\t\t\t\t\t * the date/time parser later. - thomas 2001-10-19\n\t\t\t\t\t */\n\t\t\t\t\t*str++ = ' ';\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "NULL",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeSpecialTimestamp",
          "args": [
            "timestamp",
            "buf"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeSpecialTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1522-1531",
          "snippet": "void\nEncodeSpecialTimestamp(Timestamp dt, char *str)\n{\n\tif (TIMESTAMP_IS_NOBEGIN(dt))\n\t\tstrcpy(str, EARLY);\n\telse if (TIMESTAMP_IS_NOEND(dt))\n\t\tstrcpy(str, LATE);\n\telse\t\t\t\t\t\t/* shouldn't happen */\n\t\telog(ERROR, \"invalid argument for EncodeSpecialTimestamp\");\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nEncodeSpecialTimestamp(Timestamp dt, char *str)\n{\n\tif (TIMESTAMP_IS_NOBEGIN(dt))\n\t\tstrcpy(str, EARLY);\n\telse if (TIMESTAMP_IS_NOEND(dt))\n\t\tstrcpy(str, LATE);\n\telse\t\t\t\t\t\t/* shouldn't happen */\n\t\telog(ERROR, \"invalid argument for EncodeSpecialTimestamp\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamp_out(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\tchar\t   *result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tEncodeSpecialTimestamp(timestamp, buf);\n\telse if (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) == 0)\n\t\tEncodeDateTime(tm, fsec, false, 0, NULL, DateStyle, buf);\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tresult = pstrdup(buf);\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "timestamp_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "142-208",
    "snippet": "Datum\ntimestamp_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tTimestamp\tresult;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tint\t\t\tdterr;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tworkbuf[MAXDATELEN + MAXDATEFIELDS];\n\n\tdterr = ParseDateTime(str, workbuf, sizeof(workbuf),\n\t\t\t\t\t\t  field, ftype, MAXDATEFIELDS, &nf);\n\tif (dterr == 0)\n\t\tdterr = DecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, &tz);\n\tif (dterr != 0)\n\t\tDateTimeParseError(dterr, str, \"timestamp\");\n\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range: \\\"%s\\\"\", str)));\n\t\t\tbreak;\n\n\t\tcase DTK_EPOCH:\n\t\t\tresult = SetEpochTimestamp();\n\t\t\tbreak;\n\n\t\tcase DTK_LATE:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\n\t\tcase DTK_EARLY:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\n\t\tcase DTK_INVALID:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"date/time value \\\"%s\\\" is no longer supported\", str)));\n\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected dtype %d while parsing timestamp \\\"%s\\\"\",\n\t\t\t\t dtype, str);\n\t\t\tTIMESTAMP_NOEND(result);\n\t}\n\n\tAdjustTimestampForTypmod(&result, typmod);\n\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);",
      "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
      "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustTimestampForTypmod",
          "args": [
            "&result",
            "typmod"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustTimestampForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "333-376",
          "snippet": "static void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
            "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nstatic void\nAdjustTimestampForTypmod(Timestamp *time, int32 typmod)\n{\n\tstatic const int64 TimestampScales[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (!TIMESTAMP_NOT_FINITE(*time)\n\t\t&& (typmod != -1) && (typmod != MAX_TIMESTAMP_PRECISION))\n\t{\n\t\tif (typmod < 0 || typmod > MAX_TIMESTAMP_PRECISION)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"timestamp(%d) precision must be between %d and %d\",\n\t\t\t\t\t\t\ttypmod, 0, MAX_TIMESTAMP_PRECISION)));\n\n\t\tif (*time >= INT64CONST(0))\n\t\t{\n\t\t\t*time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *\n\t\t\t\tTimestampScales[typmod];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])\n\t\t\t\t\t  * TimestampScales[typmod]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOEND",
          "args": [
            "result"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected dtype %d while parsing timestamp \\\"%s\\\"\"",
            "dtype",
            "str"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOEND",
          "args": [
            "result"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"date/time value \\\"%s\\\" is no longer supported\", str))"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"date/time value \\\"%s\\\" is no longer supported\"",
            "str"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOBEGIN",
          "args": [
            "result"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOEND",
          "args": [
            "result"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetEpochTimestamp",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "SetEpochTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2005-2017",
          "snippet": "Timestamp\nSetEpochTimestamp(void)\n{\n\tTimestamp\tdt;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tGetEpochTime(tm);\n\t/* we don't bother to test for failure ... */\n\ttm2timestamp(tm, 0, NULL, &dt);\n\n\treturn dt;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestamp\nSetEpochTimestamp(void)\n{\n\tTimestamp\tdt;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tGetEpochTime(tm);\n\t/* we don't bother to test for failure ... */\n\ttm2timestamp(tm, 0, NULL, &dt);\n\n\treturn dt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range: \\\"%s\\\"\", str))"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm2timestamp",
          "args": [
            "tm",
            "fsec",
            "NULL",
            "&result"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1853-1895",
          "snippet": "int\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DateTimeParseError",
          "args": [
            "dterr",
            "str",
            "\"timestamp\""
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeParseError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3753-3792",
          "snippet": "void\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeDateTime",
          "args": [
            "field",
            "ftype",
            "nf",
            "&dtype",
            "tm",
            "&fsec",
            "&tz"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "766-1439",
          "snippet": "int\nDecodeDateTime(char **field, int *ftype, int nf,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\tptype = 0;\t\t/* \"prefix type\" for ISO y2001m02d04 format */\n\tint\t\t\ti;\n\tint\t\t\tval;\n\tint\t\t\tdterr;\n\tint\t\t\tmer = HR24;\n\tbool\t\thaveTextMonth = false;\n\tbool\t\tisjulian = false;\n\tbool\t\tis2digits = false;\n\tbool\t\tbc = false;\n\tpg_tz\t   *namedTz = NULL;\n\tpg_tz\t   *abbrevTz = NULL;\n\tpg_tz\t   *valtz;\n\tchar\t   *abbrev = NULL;\n\tstruct pg_tm cur_tm;\n\n\t/*\n\t * We'll insist on at least all of the date fields, but initialize the\n\t * remaining fields in case they are not set later...\n\t */\n\t*dtype = DTK_DATE;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n\t/* don't know daylight savings time status apriori */\n\ttm->tm_isdst = -1;\n\tif (tzp != NULL)\n\t\t*tzp = 0;\n\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_DATE:\n\n\t\t\t\t/*\n\t\t\t\t * Integral julian day with attached time zone? All other\n\t\t\t\t * forms with JD will be separated into distinct fields, so we\n\t\t\t\t * handle just this case here.\n\t\t\t\t */\n\t\t\t\tif (ptype == DTK_JULIAN)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE || val < 0)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\ttmask = DTK_DATE_M | DTK_TIME_M | DTK_M(TZ);\n\t\t\t\t\tptype = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Already have a date? Then this might be a time zone name\n\t\t\t\t * with embedded punctuation (e.g. \"America/New_York\") or a\n\t\t\t\t * run-together time with trailing time zone (e.g. hhmmss-zz).\n\t\t\t\t * - thomas 2001-12-25\n\t\t\t\t *\n\t\t\t\t * We consider it a time zone if we already have month & day.\n\t\t\t\t * This is to allow the form \"mmm dd hhmmss tz year\", which\n\t\t\t\t * we've historically accepted.\n\t\t\t\t */\n\t\t\t\telse if (ptype != 0 ||\n\t\t\t\t\t\t ((fmask & (DTK_M(MONTH) | DTK_M(DAY))) ==\n\t\t\t\t\t\t  (DTK_M(MONTH) | DTK_M(DAY))))\n\t\t\t\t{\n\t\t\t\t\t/* No time zone accepted? Then quit... */\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tif (isdigit((unsigned char) *field[i]) || ptype != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t   *cp;\n\n\t\t\t\t\t\tif (ptype != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tptype = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Starts with a digit but we already have a time\n\t\t\t\t\t\t * field? Then we are in trouble with a date and time\n\t\t\t\t\t\t * already...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tif ((cp = strchr(field[i], '-')) == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t*cp = '\\0';\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Then read the rest of the field as a concatenated\n\t\t\t\t\t\t * time\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * modify tmask after returning from\n\t\t\t\t\t\t * DecodeNumberField()\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We should return an error code instead of\n\t\t\t\t\t\t\t * ereport'ing directly, but then there is no way\n\t\t\t\t\t\t\t * to report the bad time zone name.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TIME:\n\n\t\t\t\t/*\n\t\t\t\t * This might be an ISO time following a \"t\" field.\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tptype = 0;\n\t\t\t\t}\n\t\t\t\tdterr = DecodeTime(field[i], fmask, INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\n\t\t\t\t/*\n\t\t\t\t * Check upper limit on hours; other limits checked in\n\t\t\t\t * DecodeTime()\n\t\t\t\t */\n\t\t\t\t/* test for > 24:00:00 */\n\t\t\t\tif (tm->tm_hour > HOURS_PER_DAY ||\n\t\t\t\t\t(tm->tm_hour == HOURS_PER_DAY &&\n\t\t\t\t\t (tm->tm_min > 0 || tm->tm_sec > 0 || *fsec > 0)))\n\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tdterr = DecodeTimezone(field[i], &tz);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t*tzp = tz;\n\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_NUMBER:\n\n\t\t\t\t/*\n\t\t\t\t * Was this an \"ISO date\" with embedded field labels? An\n\t\t\t\t * example is \"y2001m02d04\" - thomas 2001-02-04\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only a few kinds are allowed to have an embedded\n\t\t\t\t\t * decimal\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MONTH:\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * already have a month and hour? then assume\n\t\t\t\t\t\t\t * minutes\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) != 0 &&\n\t\t\t\t\t\t\t\t(fmask & DTK_M(HOUR)) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\t\ttm->tm_hour = val;\n\t\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\ttm->tm_sec = val;\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TZ:\n\t\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\t\tdterr = DecodeTimezone(field[i], tzp);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\t/* previous field was a label for \"julian date\" */\n\t\t\t\t\t\t\tif (val < 0)\n\t\t\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t\t\t/* fractional Julian Day? */\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdouble\t\ttime;\n\n\t\t\t\t\t\t\t\terrno = 0;\n\t\t\t\t\t\t\t\ttime = strtod(cp, &cp);\n\t\t\t\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\ttime *= USECS_PER_DAY;\n\t\t\t\t\t\t\t\tdt2time(time,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_hour, &tm->tm_min,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_sec, fsec);\n\t\t\t\t\t\t\t\ttmask |= DTK_TIME_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\t/* previous field was \"t\" for ISO time */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tif (tmask != DTK_TIME_M)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tptype = 0;\n\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tflen;\n\n\t\t\t\t\tflen = strlen(field[i]);\n\t\t\t\t\tcp = strchr(field[i], '.');\n\n\t\t\t\t\t/* Embedded decimal and no date yet? */\n\t\t\t\t\tif (cp != NULL && !(fmask & DTK_DATE_M))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* embedded decimal and several digits before? */\n\t\t\t\t\telse if (cp != NULL && flen - strlen(cp) > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Interpret as a concatenated date or time Set the\n\t\t\t\t\t\t * type field to allow decoding other fields later.\n\t\t\t\t\t\t * Example: 20011223 or 040506\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Is this a YMD or HMS specification, or a year number?\n\t\t\t\t\t * YMD and HMS are required to be six digits or more, so\n\t\t\t\t\t * if it is 5 digits, it is a year.  If it is six or more\n\t\t\t\t\t * more digits, we assume it is YMD or HMS unless no date\n\t\t\t\t\t * and no time values have been specified.  This forces 6+\n\t\t\t\t\t * digit years to be at the end of the string, or to use\n\t\t\t\t\t * the ISO date specification.\n\t\t\t\t\t */\n\t\t\t\t\telse if (flen >= 6 && (!(fmask & DTK_DATE_M) ||\n\t\t\t\t\t\t\t\t\t\t   !(fmask & DTK_TIME_M)))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* otherwise it is a single date/time field... */\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumber(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t haveTextMonth, fmask,\n\t\t\t\t\t\t\t\t\t\t\t &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t fsec, &is2digits);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\t/* timezone abbrevs take precedence over built-in tokens */\n\t\t\t\ttype = DecodeTimezoneAbbrev(i, field[i], &val, &valtz);\n\t\t\t\tif (type == UNKNOWN_FIELD)\n\t\t\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = DTK_M(type);\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\tswitch (val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_CURRENT:\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_NOW:\n\t\t\t\t\t\t\t\ttmask = (DTK_DATE_M | DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentTimeUsec(tm, fsec, tzp);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_YESTERDAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) - 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TODAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\ttm->tm_year = cur_tm.tm_year;\n\t\t\t\t\t\t\t\ttm->tm_mon = cur_tm.tm_mon;\n\t\t\t\t\t\t\t\ttm->tm_mday = cur_tm.tm_mday;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TOMORROW:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) + 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_ZULU:\n\t\t\t\t\t\t\t\ttmask = (DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t\t\t\tif (tzp != NULL)\n\t\t\t\t\t\t\t\t\t*tzp = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t*dtype = val;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MONTH:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * already have a (numeric) month? then see if we can\n\t\t\t\t\t\t * substitute...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) && !haveTextMonth &&\n\t\t\t\t\t\t\t!(fmask & DTK_M(DAY)) && tm->tm_mon >= 1 &&\n\t\t\t\t\t\t\ttm->tm_mon <= 31)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttm->tm_mday = tm->tm_mon;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thaveTextMonth = true;\n\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZMOD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * daylight savings time modifier (solves \"MET DST\"\n\t\t\t\t\t\t * syntax)\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(DTZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp -= val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZ:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * set mask for TZ here _or_ check for DTZ later when\n\t\t\t\t\t\t * getting default timezone\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TZ:\n\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DYNTZ:\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll determine the actual offset later */\n\t\t\t\t\t\tabbrevTz = valtz;\n\t\t\t\t\t\tabbrev = field[i];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AMPM:\n\t\t\t\t\t\tmer = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ADBC:\n\t\t\t\t\t\tbc = (val == BC);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DOW:\n\t\t\t\t\t\ttm->tm_wday = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttmask = 0;\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ISOTIME:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is a filler field \"t\" indicating that the next\n\t\t\t\t\t\t * field is time. Try to verify that this is sensible.\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask = 0;\n\n\t\t\t\t\t\t/* No preceding date? Then quit... */\n\t\t\t\t\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/***\n\t\t\t\t\t\t * We will need one of the following fields:\n\t\t\t\t\t\t *\tDTK_NUMBER should be hhmmss.fff\n\t\t\t\t\t\t *\tDTK_TIME should be hh:mm:ss.fff\n\t\t\t\t\t\t *\tDTK_DATE should be hhmmss-zz\n\t\t\t\t\t\t ***/\n\t\t\t\t\t\tif (i >= nf - 1 ||\n\t\t\t\t\t\t\t(ftype[i + 1] != DTK_NUMBER &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_TIME &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_DATE))\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNKNOWN_FIELD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Before giving up and declaring error, check to see\n\t\t\t\t\t\t * if it is an all-alpha timezone name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\t\t\t\t\t\t\t/* end loop over fields */\n\n\t/* do final checking/adjustment of Y/M/D fields */\n\tdterr = ValidateDate(fmask, isjulian, is2digits, bc, tm);\n\tif (dterr)\n\t\treturn dterr;\n\n\t/* handle AM/PM */\n\tif (mer != HR24 && tm->tm_hour > HOURS_PER_DAY / 2)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (mer == AM && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\ttm->tm_hour = 0;\n\telse if (mer == PM && tm->tm_hour != HOURS_PER_DAY / 2)\n\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\n\t/* do additional checking for full date specs... */\n\tif (*dtype == DTK_DATE)\n\t{\n\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t{\n\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\treturn 1;\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\t/*\n\t\t * If we had a full timezone spec, compute the offset (we could not do\n\t\t * it before, because we need the date to resolve DST status).\n\t\t */\n\t\tif (namedTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with full TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, namedTz);\n\t\t}\n\n\t\t/*\n\t\t * Likewise, if we had a dynamic timezone abbreviation, resolve it\n\t\t * now.\n\t\t */\n\t\tif (abbrevTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with dynamic TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneAbbrevOffset(tm, abbrev, abbrevTz);\n\t\t}\n\n\t\t/* timezone not specified? then use session timezone */\n\t\tif (tzp != NULL && !(fmask & DTK_M(TZ)))\n\t\t{\n\t\t\t/*\n\t\t\t * daylight savings time modifier but no standard timezone? then\n\t\t\t * error\n\t\t\t */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, session_timezone);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDecodeDateTime(char **field, int *ftype, int nf,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\tptype = 0;\t\t/* \"prefix type\" for ISO y2001m02d04 format */\n\tint\t\t\ti;\n\tint\t\t\tval;\n\tint\t\t\tdterr;\n\tint\t\t\tmer = HR24;\n\tbool\t\thaveTextMonth = false;\n\tbool\t\tisjulian = false;\n\tbool\t\tis2digits = false;\n\tbool\t\tbc = false;\n\tpg_tz\t   *namedTz = NULL;\n\tpg_tz\t   *abbrevTz = NULL;\n\tpg_tz\t   *valtz;\n\tchar\t   *abbrev = NULL;\n\tstruct pg_tm cur_tm;\n\n\t/*\n\t * We'll insist on at least all of the date fields, but initialize the\n\t * remaining fields in case they are not set later...\n\t */\n\t*dtype = DTK_DATE;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n\t/* don't know daylight savings time status apriori */\n\ttm->tm_isdst = -1;\n\tif (tzp != NULL)\n\t\t*tzp = 0;\n\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_DATE:\n\n\t\t\t\t/*\n\t\t\t\t * Integral julian day with attached time zone? All other\n\t\t\t\t * forms with JD will be separated into distinct fields, so we\n\t\t\t\t * handle just this case here.\n\t\t\t\t */\n\t\t\t\tif (ptype == DTK_JULIAN)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE || val < 0)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\ttmask = DTK_DATE_M | DTK_TIME_M | DTK_M(TZ);\n\t\t\t\t\tptype = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Already have a date? Then this might be a time zone name\n\t\t\t\t * with embedded punctuation (e.g. \"America/New_York\") or a\n\t\t\t\t * run-together time with trailing time zone (e.g. hhmmss-zz).\n\t\t\t\t * - thomas 2001-12-25\n\t\t\t\t *\n\t\t\t\t * We consider it a time zone if we already have month & day.\n\t\t\t\t * This is to allow the form \"mmm dd hhmmss tz year\", which\n\t\t\t\t * we've historically accepted.\n\t\t\t\t */\n\t\t\t\telse if (ptype != 0 ||\n\t\t\t\t\t\t ((fmask & (DTK_M(MONTH) | DTK_M(DAY))) ==\n\t\t\t\t\t\t  (DTK_M(MONTH) | DTK_M(DAY))))\n\t\t\t\t{\n\t\t\t\t\t/* No time zone accepted? Then quit... */\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tif (isdigit((unsigned char) *field[i]) || ptype != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t   *cp;\n\n\t\t\t\t\t\tif (ptype != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tptype = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Starts with a digit but we already have a time\n\t\t\t\t\t\t * field? Then we are in trouble with a date and time\n\t\t\t\t\t\t * already...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tif ((cp = strchr(field[i], '-')) == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t*cp = '\\0';\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Then read the rest of the field as a concatenated\n\t\t\t\t\t\t * time\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * modify tmask after returning from\n\t\t\t\t\t\t * DecodeNumberField()\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We should return an error code instead of\n\t\t\t\t\t\t\t * ereport'ing directly, but then there is no way\n\t\t\t\t\t\t\t * to report the bad time zone name.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TIME:\n\n\t\t\t\t/*\n\t\t\t\t * This might be an ISO time following a \"t\" field.\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tptype = 0;\n\t\t\t\t}\n\t\t\t\tdterr = DecodeTime(field[i], fmask, INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\n\t\t\t\t/*\n\t\t\t\t * Check upper limit on hours; other limits checked in\n\t\t\t\t * DecodeTime()\n\t\t\t\t */\n\t\t\t\t/* test for > 24:00:00 */\n\t\t\t\tif (tm->tm_hour > HOURS_PER_DAY ||\n\t\t\t\t\t(tm->tm_hour == HOURS_PER_DAY &&\n\t\t\t\t\t (tm->tm_min > 0 || tm->tm_sec > 0 || *fsec > 0)))\n\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tdterr = DecodeTimezone(field[i], &tz);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t*tzp = tz;\n\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_NUMBER:\n\n\t\t\t\t/*\n\t\t\t\t * Was this an \"ISO date\" with embedded field labels? An\n\t\t\t\t * example is \"y2001m02d04\" - thomas 2001-02-04\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only a few kinds are allowed to have an embedded\n\t\t\t\t\t * decimal\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MONTH:\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * already have a month and hour? then assume\n\t\t\t\t\t\t\t * minutes\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) != 0 &&\n\t\t\t\t\t\t\t\t(fmask & DTK_M(HOUR)) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\t\ttm->tm_hour = val;\n\t\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\ttm->tm_sec = val;\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TZ:\n\t\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\t\tdterr = DecodeTimezone(field[i], tzp);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\t/* previous field was a label for \"julian date\" */\n\t\t\t\t\t\t\tif (val < 0)\n\t\t\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t\t\t/* fractional Julian Day? */\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdouble\t\ttime;\n\n\t\t\t\t\t\t\t\terrno = 0;\n\t\t\t\t\t\t\t\ttime = strtod(cp, &cp);\n\t\t\t\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\ttime *= USECS_PER_DAY;\n\t\t\t\t\t\t\t\tdt2time(time,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_hour, &tm->tm_min,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_sec, fsec);\n\t\t\t\t\t\t\t\ttmask |= DTK_TIME_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\t/* previous field was \"t\" for ISO time */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tif (tmask != DTK_TIME_M)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tptype = 0;\n\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tflen;\n\n\t\t\t\t\tflen = strlen(field[i]);\n\t\t\t\t\tcp = strchr(field[i], '.');\n\n\t\t\t\t\t/* Embedded decimal and no date yet? */\n\t\t\t\t\tif (cp != NULL && !(fmask & DTK_DATE_M))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* embedded decimal and several digits before? */\n\t\t\t\t\telse if (cp != NULL && flen - strlen(cp) > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Interpret as a concatenated date or time Set the\n\t\t\t\t\t\t * type field to allow decoding other fields later.\n\t\t\t\t\t\t * Example: 20011223 or 040506\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Is this a YMD or HMS specification, or a year number?\n\t\t\t\t\t * YMD and HMS are required to be six digits or more, so\n\t\t\t\t\t * if it is 5 digits, it is a year.  If it is six or more\n\t\t\t\t\t * more digits, we assume it is YMD or HMS unless no date\n\t\t\t\t\t * and no time values have been specified.  This forces 6+\n\t\t\t\t\t * digit years to be at the end of the string, or to use\n\t\t\t\t\t * the ISO date specification.\n\t\t\t\t\t */\n\t\t\t\t\telse if (flen >= 6 && (!(fmask & DTK_DATE_M) ||\n\t\t\t\t\t\t\t\t\t\t   !(fmask & DTK_TIME_M)))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* otherwise it is a single date/time field... */\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumber(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t haveTextMonth, fmask,\n\t\t\t\t\t\t\t\t\t\t\t &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t fsec, &is2digits);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\t/* timezone abbrevs take precedence over built-in tokens */\n\t\t\t\ttype = DecodeTimezoneAbbrev(i, field[i], &val, &valtz);\n\t\t\t\tif (type == UNKNOWN_FIELD)\n\t\t\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = DTK_M(type);\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\tswitch (val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_CURRENT:\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_NOW:\n\t\t\t\t\t\t\t\ttmask = (DTK_DATE_M | DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentTimeUsec(tm, fsec, tzp);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_YESTERDAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) - 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TODAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\ttm->tm_year = cur_tm.tm_year;\n\t\t\t\t\t\t\t\ttm->tm_mon = cur_tm.tm_mon;\n\t\t\t\t\t\t\t\ttm->tm_mday = cur_tm.tm_mday;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TOMORROW:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) + 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_ZULU:\n\t\t\t\t\t\t\t\ttmask = (DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t\t\t\tif (tzp != NULL)\n\t\t\t\t\t\t\t\t\t*tzp = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t*dtype = val;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MONTH:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * already have a (numeric) month? then see if we can\n\t\t\t\t\t\t * substitute...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) && !haveTextMonth &&\n\t\t\t\t\t\t\t!(fmask & DTK_M(DAY)) && tm->tm_mon >= 1 &&\n\t\t\t\t\t\t\ttm->tm_mon <= 31)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttm->tm_mday = tm->tm_mon;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thaveTextMonth = true;\n\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZMOD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * daylight savings time modifier (solves \"MET DST\"\n\t\t\t\t\t\t * syntax)\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(DTZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp -= val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZ:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * set mask for TZ here _or_ check for DTZ later when\n\t\t\t\t\t\t * getting default timezone\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TZ:\n\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DYNTZ:\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll determine the actual offset later */\n\t\t\t\t\t\tabbrevTz = valtz;\n\t\t\t\t\t\tabbrev = field[i];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AMPM:\n\t\t\t\t\t\tmer = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ADBC:\n\t\t\t\t\t\tbc = (val == BC);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DOW:\n\t\t\t\t\t\ttm->tm_wday = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttmask = 0;\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ISOTIME:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is a filler field \"t\" indicating that the next\n\t\t\t\t\t\t * field is time. Try to verify that this is sensible.\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask = 0;\n\n\t\t\t\t\t\t/* No preceding date? Then quit... */\n\t\t\t\t\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/***\n\t\t\t\t\t\t * We will need one of the following fields:\n\t\t\t\t\t\t *\tDTK_NUMBER should be hhmmss.fff\n\t\t\t\t\t\t *\tDTK_TIME should be hh:mm:ss.fff\n\t\t\t\t\t\t *\tDTK_DATE should be hhmmss-zz\n\t\t\t\t\t\t ***/\n\t\t\t\t\t\tif (i >= nf - 1 ||\n\t\t\t\t\t\t\t(ftype[i + 1] != DTK_NUMBER &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_TIME &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_DATE))\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNKNOWN_FIELD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Before giving up and declaring error, check to see\n\t\t\t\t\t\t * if it is an all-alpha timezone name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\t\t\t\t\t\t\t/* end loop over fields */\n\n\t/* do final checking/adjustment of Y/M/D fields */\n\tdterr = ValidateDate(fmask, isjulian, is2digits, bc, tm);\n\tif (dterr)\n\t\treturn dterr;\n\n\t/* handle AM/PM */\n\tif (mer != HR24 && tm->tm_hour > HOURS_PER_DAY / 2)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (mer == AM && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\ttm->tm_hour = 0;\n\telse if (mer == PM && tm->tm_hour != HOURS_PER_DAY / 2)\n\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\n\t/* do additional checking for full date specs... */\n\tif (*dtype == DTK_DATE)\n\t{\n\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t{\n\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\treturn 1;\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\t/*\n\t\t * If we had a full timezone spec, compute the offset (we could not do\n\t\t * it before, because we need the date to resolve DST status).\n\t\t */\n\t\tif (namedTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with full TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, namedTz);\n\t\t}\n\n\t\t/*\n\t\t * Likewise, if we had a dynamic timezone abbreviation, resolve it\n\t\t * now.\n\t\t */\n\t\tif (abbrevTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with dynamic TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneAbbrevOffset(tm, abbrev, abbrevTz);\n\t\t}\n\n\t\t/* timezone not specified? then use session timezone */\n\t\tif (tzp != NULL && !(fmask & DTK_M(TZ)))\n\t\t{\n\t\t\t/*\n\t\t\t * daylight savings time modifier but no standard timezone? then\n\t\t\t * error\n\t\t\t */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, session_timezone);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseDateTime",
          "args": [
            "str",
            "workbuf",
            "sizeof(workbuf)",
            "field",
            "ftype",
            "MAXDATEFIELDS",
            "&nf"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "ParseDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "545-739",
          "snippet": "int\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
            "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\n\nint\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nDatum\ntimestamp_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tTimestamp\tresult;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tint\t\t\tdterr;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tworkbuf[MAXDATELEN + MAXDATEFIELDS];\n\n\tdterr = ParseDateTime(str, workbuf, sizeof(workbuf),\n\t\t\t\t\t\t  field, ftype, MAXDATEFIELDS, &nf);\n\tif (dterr == 0)\n\t\tdterr = DecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, &tz);\n\tif (dterr != 0)\n\t\tDateTimeParseError(dterr, str, \"timestamp\");\n\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range: \\\"%s\\\"\", str)));\n\t\t\tbreak;\n\n\t\tcase DTK_EPOCH:\n\t\t\tresult = SetEpochTimestamp();\n\t\t\tbreak;\n\n\t\tcase DTK_LATE:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\n\t\tcase DTK_EARLY:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\n\t\tcase DTK_INVALID:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"date/time value \\\"%s\\\" is no longer supported\", str)));\n\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected dtype %d while parsing timestamp \\\"%s\\\"\",\n\t\t\t\t dtype, str);\n\t\t\tTIMESTAMP_NOEND(result);\n\t}\n\n\tAdjustTimestampForTypmod(&result, typmod);\n\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "anytimestamp_typmodout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "123-132",
    "snippet": "static char *\nanytimestamp_typmodout(bool istz, int32 typmod)\n{\n\tconst char *tz = istz ? \" with time zone\" : \" without time zone\";\n\n\tif (typmod >= 0)\n\t\treturn psprintf(\"(%d)%s\", (int) typmod, tz);\n\telse\n\t\treturn psprintf(\"%s\", tz);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s\"",
            "tz"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"(%d)%s\"",
            "(int) typmod",
            "tz"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nstatic char *\nanytimestamp_typmodout(bool istz, int32 typmod)\n{\n\tconst char *tz = istz ? \" with time zone\" : \" without time zone\";\n\n\tif (typmod >= 0)\n\t\treturn psprintf(\"(%d)%s\", (int) typmod, tz);\n\telse\n\t\treturn psprintf(\"%s\", tz);\n}"
  },
  {
    "function_name": "anytimestamp_typmod_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "101-120",
    "snippet": "int32\nanytimestamp_typmod_check(bool istz, int32 typmod)\n{\n\tif (typmod < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIMESTAMP(%d)%s precision must not be negative\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"))));\n\tif (typmod > MAX_TIMESTAMP_PRECISION)\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIMESTAMP(%d)%s precision reduced to maximum allowed, %d\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"),\n\t\t\t\t\t\tMAX_TIMESTAMP_PRECISION)));\n\t\ttypmod = MAX_TIMESTAMP_PRECISION;\n\t}\n\n\treturn typmod;\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
      "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "WARNING",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIMESTAMP(%d)%s precision reduced to maximum allowed, %d\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"),\n\t\t\t\t\t\tMAX_TIMESTAMP_PRECISION))"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"TIMESTAMP(%d)%s precision reduced to maximum allowed, %d\"",
            "typmod",
            "(istz ? \" WITH TIME ZONE\" : \"\")",
            "MAX_TIMESTAMP_PRECISION"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIMESTAMP(%d)%s precision must not be negative\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\")))"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nint32\nanytimestamp_typmod_check(bool istz, int32 typmod)\n{\n\tif (typmod < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIMESTAMP(%d)%s precision must not be negative\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"))));\n\tif (typmod > MAX_TIMESTAMP_PRECISION)\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIMESTAMP(%d)%s precision reduced to maximum allowed, %d\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"),\n\t\t\t\t\t\tMAX_TIMESTAMP_PRECISION)));\n\t\ttypmod = MAX_TIMESTAMP_PRECISION;\n\t}\n\n\treturn typmod;\n}"
  },
  {
    "function_name": "anytimestamp_typmodin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
    "lines": "80-98",
    "snippet": "static int32\nanytimestamp_typmodin(bool istz, ArrayType *ta)\n{\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for TIMESTAMP\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\treturn anytimestamp_typmod_check(istz, tl[0]);\n}",
    "includes": [
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/int128.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <sys/time.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "anytimestamp_typmod_check",
          "args": [
            "istz",
            "tl[0]"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "anytimestamp_typmod_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "101-120",
          "snippet": "int32\nanytimestamp_typmod_check(bool istz, int32 typmod)\n{\n\tif (typmod < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIMESTAMP(%d)%s precision must not be negative\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"))));\n\tif (typmod > MAX_TIMESTAMP_PRECISION)\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIMESTAMP(%d)%s precision reduced to maximum allowed, %d\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"),\n\t\t\t\t\t\tMAX_TIMESTAMP_PRECISION)));\n\t\ttypmod = MAX_TIMESTAMP_PRECISION;\n\t}\n\n\treturn typmod;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);",
            "static void AdjustIntervalForTypmod(Interval *interval, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimestampForTypmod(Timestamp *time, int32 typmod);\nstatic void AdjustIntervalForTypmod(Interval *interval, int32 typmod);\n\nint32\nanytimestamp_typmod_check(bool istz, int32 typmod)\n{\n\tif (typmod < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIMESTAMP(%d)%s precision must not be negative\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"))));\n\tif (typmod > MAX_TIMESTAMP_PRECISION)\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIMESTAMP(%d)%s precision reduced to maximum allowed, %d\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"),\n\t\t\t\t\t\tMAX_TIMESTAMP_PRECISION)));\n\t\ttypmod = MAX_TIMESTAMP_PRECISION;\n\t}\n\n\treturn typmod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\"))"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid type modifier\""
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetIntegerTypmods",
          "args": [
            "ta",
            "&n"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetIntegerTypmods",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "199-235",
          "snippet": "int32 *\nArrayGetIntegerTypmods(ArrayType *arr, int *n)\n{\n\tint32\t   *result;\n\tDatum\t   *elem_values;\n\tint\t\t\ti;\n\n\tif (ARR_ELEMTYPE(arr) != CSTRINGOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_ELEMENT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be type cstring[]\")));\n\n\tif (ARR_NDIM(arr) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be one-dimensional\")));\n\n\tif (array_contains_nulls(arr))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"typmod array must not contain nulls\")));\n\n\t/* hardwired knowledge about cstring's representation details here */\n\tdeconstruct_array(arr, CSTRINGOID,\n\t\t\t\t\t  -2, false, 'c',\n\t\t\t\t\t  &elem_values, NULL, n);\n\n\tresult = (int32 *) palloc(*n * sizeof(int32));\n\n\tfor (i = 0; i < *n; i++)\n\t\tresult[i] = pg_atoi(DatumGetCString(elem_values[i]),\n\t\t\t\t\t\t\tsizeof(int32), '\\0');\n\n\tpfree(elem_values);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint32 *\nArrayGetIntegerTypmods(ArrayType *arr, int *n)\n{\n\tint32\t   *result;\n\tDatum\t   *elem_values;\n\tint\t\t\ti;\n\n\tif (ARR_ELEMTYPE(arr) != CSTRINGOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_ELEMENT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be type cstring[]\")));\n\n\tif (ARR_NDIM(arr) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be one-dimensional\")));\n\n\tif (array_contains_nulls(arr))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"typmod array must not contain nulls\")));\n\n\t/* hardwired knowledge about cstring's representation details here */\n\tdeconstruct_array(arr, CSTRINGOID,\n\t\t\t\t\t  -2, false, 'c',\n\t\t\t\t\t  &elem_values, NULL, n);\n\n\tresult = (int32 *) palloc(*n * sizeof(int32));\n\n\tfor (i = 0; i < *n; i++)\n\t\tresult[i] = pg_atoi(DatumGetCString(elem_values[i]),\n\t\t\t\t\t\t\tsizeof(int32), '\\0');\n\n\tpfree(elem_values);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32\nanytimestamp_typmodin(bool istz, ArrayType *ta)\n{\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for TIMESTAMP\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\treturn anytimestamp_typmod_check(istz, tl[0]);\n}"
  }
]