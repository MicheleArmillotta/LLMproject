[
  {
    "function_name": "ThereIsAtLeastOneRole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
    "lines": "1214-1230",
    "snippet": "static bool\nThereIsAtLeastOneRole(void)\n{\n\tRelation\tpg_authid_rel;\n\tHeapScanDesc scan;\n\tbool\t\tresult;\n\n\tpg_authid_rel = heap_open(AuthIdRelationId, AccessShareLock);\n\n\tscan = heap_beginscan_catalog(pg_authid_rel, 0, NULL);\n\tresult = (heap_getnext(scan, ForwardScanDirection) != NULL);\n\n\theap_endscan(scan);\n\theap_close(pg_authid_rel, AccessShareLock);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"utils/portal.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/procsignal.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"replication/walsender.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq-be.h\"",
      "#include \"libpq/auth.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_db_role_setting.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/session.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool ThereIsAtLeastOneRole(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "pg_authid_rel",
            "AccessShareLock"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_endscan",
          "args": [
            "scan"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getnext",
          "args": [
            "scan",
            "ForwardScanDirection"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_beginscan_catalog",
          "args": [
            "pg_authid_rel",
            "0",
            "NULL"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "AuthIdRelationId",
            "AccessShareLock"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool ThereIsAtLeastOneRole(void);\n\nstatic bool\nThereIsAtLeastOneRole(void)\n{\n\tRelation\tpg_authid_rel;\n\tHeapScanDesc scan;\n\tbool\t\tresult;\n\n\tpg_authid_rel = heap_open(AuthIdRelationId, AccessShareLock);\n\n\tscan = heap_beginscan_catalog(pg_authid_rel, 0, NULL);\n\tresult = (heap_getnext(scan, ForwardScanDirection) != NULL);\n\n\theap_endscan(scan);\n\theap_close(pg_authid_rel, AccessShareLock);\n\n\treturn result;\n}"
  },
  {
    "function_name": "IdleInTransactionSessionTimeoutHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
    "lines": "1203-1209",
    "snippet": "static void\nIdleInTransactionSessionTimeoutHandler(void)\n{\n\tIdleInTransactionSessionTimeoutPending = true;\n\tInterruptPending = true;\n\tSetLatch(MyLatch);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"utils/portal.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/procsignal.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"replication/walsender.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq-be.h\"",
      "#include \"libpq/auth.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_db_role_setting.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/session.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void IdleInTransactionSessionTimeoutHandler(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetLatch",
          "args": [
            "MyLatch"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void IdleInTransactionSessionTimeoutHandler(void);\n\nstatic void\nIdleInTransactionSessionTimeoutHandler(void)\n{\n\tIdleInTransactionSessionTimeoutPending = true;\n\tInterruptPending = true;\n\tSetLatch(MyLatch);\n}"
  },
  {
    "function_name": "LockTimeoutHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
    "lines": "1193-1201",
    "snippet": "static void\nLockTimeoutHandler(void)\n{\n#ifdef HAVE_SETSID\n\t/* try to signal whole process group */\n\tkill(-MyProcPid, SIGINT);\n#endif\n\tkill(MyProcPid, SIGINT);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"utils/portal.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/procsignal.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"replication/walsender.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq-be.h\"",
      "#include \"libpq/auth.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_db_role_setting.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/session.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void LockTimeoutHandler(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "MyProcPid",
            "SIGINT"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "-MyProcPid",
            "SIGINT"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void LockTimeoutHandler(void);\n\nstatic void\nLockTimeoutHandler(void)\n{\n#ifdef HAVE_SETSID\n\t/* try to signal whole process group */\n\tkill(-MyProcPid, SIGINT);\n#endif\n\tkill(MyProcPid, SIGINT);\n}"
  },
  {
    "function_name": "StatementTimeoutHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
    "lines": "1171-1188",
    "snippet": "static void\nStatementTimeoutHandler(void)\n{\n\tint\t\t\tsig = SIGINT;\n\n\t/*\n\t * During authentication the timeout is used to deal with\n\t * authentication_timeout - we want to quit in response to such timeouts.\n\t */\n\tif (ClientAuthInProgress)\n\t\tsig = SIGTERM;\n\n#ifdef HAVE_SETSID\n\t/* try to signal whole process group */\n\tkill(-MyProcPid, sig);\n#endif\n\tkill(MyProcPid, sig);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"utils/portal.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/procsignal.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"replication/walsender.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq-be.h\"",
      "#include \"libpq/auth.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_db_role_setting.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/session.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void StatementTimeoutHandler(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "MyProcPid",
            "sig"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "-MyProcPid",
            "sig"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void StatementTimeoutHandler(void);\n\nstatic void\nStatementTimeoutHandler(void)\n{\n\tint\t\t\tsig = SIGINT;\n\n\t/*\n\t * During authentication the timeout is used to deal with\n\t * authentication_timeout - we want to quit in response to such timeouts.\n\t */\n\tif (ClientAuthInProgress)\n\t\tsig = SIGTERM;\n\n#ifdef HAVE_SETSID\n\t/* try to signal whole process group */\n\tkill(-MyProcPid, sig);\n#endif\n\tkill(MyProcPid, sig);\n}"
  },
  {
    "function_name": "ShutdownPostgres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
    "lines": "1154-1165",
    "snippet": "static void\nShutdownPostgres(int code, Datum arg)\n{\n\t/* Make sure we've killed any active transaction */\n\tAbortOutOfAnyTransaction();\n\n\t/*\n\t * User locks are not released by transaction end, so be sure to release\n\t * them explicitly.\n\t */\n\tLockReleaseAll(USER_LOCKMETHOD, true);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"utils/portal.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/procsignal.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"replication/walsender.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq-be.h\"",
      "#include \"libpq/auth.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_db_role_setting.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/session.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ShutdownPostgres(int code, Datum arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LockReleaseAll",
          "args": [
            "USER_LOCKMETHOD",
            "true"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbortOutOfAnyTransaction",
          "args": [],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ShutdownPostgres(int code, Datum arg);\n\nstatic void\nShutdownPostgres(int code, Datum arg)\n{\n\t/* Make sure we've killed any active transaction */\n\tAbortOutOfAnyTransaction();\n\n\t/*\n\t * User locks are not released by transaction end, so be sure to release\n\t * them explicitly.\n\t */\n\tLockReleaseAll(USER_LOCKMETHOD, true);\n}"
  },
  {
    "function_name": "process_settings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
    "lines": "1120-1142",
    "snippet": "static void\nprocess_settings(Oid databaseid, Oid roleid)\n{\n\tRelation\trelsetting;\n\tSnapshot\tsnapshot;\n\n\tif (!IsUnderPostmaster)\n\t\treturn;\n\n\trelsetting = heap_open(DbRoleSettingRelationId, AccessShareLock);\n\n\t/* read all the settings under the same snapshot for efficiency */\n\tsnapshot = RegisterSnapshot(GetCatalogSnapshot(DbRoleSettingRelationId));\n\n\t/* Later settings are ignored if set earlier. */\n\tApplySetting(snapshot, databaseid, roleid, relsetting, PGC_S_DATABASE_USER);\n\tApplySetting(snapshot, InvalidOid, roleid, relsetting, PGC_S_USER);\n\tApplySetting(snapshot, databaseid, InvalidOid, relsetting, PGC_S_DATABASE);\n\tApplySetting(snapshot, InvalidOid, InvalidOid, relsetting, PGC_S_GLOBAL);\n\n\tUnregisterSnapshot(snapshot);\n\theap_close(relsetting, AccessShareLock);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"utils/portal.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/procsignal.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"replication/walsender.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq-be.h\"",
      "#include \"libpq/auth.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_db_role_setting.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/session.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void process_settings(Oid databaseid, Oid roleid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "relsetting",
            "AccessShareLock"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnregisterSnapshot",
          "args": [
            "snapshot"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "UnregisterSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "904-911",
          "snippet": "void\nUnregisterSnapshot(Snapshot snapshot)\n{\n\tif (snapshot == NULL)\n\t\treturn;\n\n\tUnregisterSnapshotFromOwner(snapshot, CurrentResourceOwner);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nvoid\nUnregisterSnapshot(Snapshot snapshot)\n{\n\tif (snapshot == NULL)\n\t\treturn;\n\n\tUnregisterSnapshotFromOwner(snapshot, CurrentResourceOwner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ApplySetting",
          "args": [
            "snapshot",
            "InvalidOid",
            "InvalidOid",
            "relsetting",
            "PGC_S_GLOBAL"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ApplySetting",
          "args": [
            "snapshot",
            "databaseid",
            "InvalidOid",
            "relsetting",
            "PGC_S_DATABASE"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ApplySetting",
          "args": [
            "snapshot",
            "InvalidOid",
            "roleid",
            "relsetting",
            "PGC_S_USER"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ApplySetting",
          "args": [
            "snapshot",
            "databaseid",
            "roleid",
            "relsetting",
            "PGC_S_DATABASE_USER"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RegisterSnapshot",
          "args": [
            "GetCatalogSnapshot(DbRoleSettingRelationId)"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "RegisterSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "862-869",
          "snippet": "Snapshot\nRegisterSnapshot(Snapshot snapshot)\n{\n\tif (snapshot == InvalidSnapshot)\n\t\treturn InvalidSnapshot;\n\n\treturn RegisterSnapshotOnOwner(snapshot, CurrentResourceOwner);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nRegisterSnapshot(Snapshot snapshot)\n{\n\tif (snapshot == InvalidSnapshot)\n\t\treturn InvalidSnapshot;\n\n\treturn RegisterSnapshotOnOwner(snapshot, CurrentResourceOwner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCatalogSnapshot",
          "args": [
            "DbRoleSettingRelationId"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "GetCatalogSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "439-453",
          "snippet": "Snapshot\nGetCatalogSnapshot(Oid relid)\n{\n\t/*\n\t * Return historic snapshot while we're doing logical decoding, so we can\n\t * see the appropriate state of the catalog.\n\t *\n\t * This is the primary reason for needing to reset the system caches after\n\t * finishing decoding.\n\t */\n\tif (HistoricSnapshotActive())\n\t\treturn HistoricSnapshot;\n\n\treturn GetNonHistoricCatalogSnapshot(relid);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot HistoricSnapshot = NULL;",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot HistoricSnapshot = NULL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nGetCatalogSnapshot(Oid relid)\n{\n\t/*\n\t * Return historic snapshot while we're doing logical decoding, so we can\n\t * see the appropriate state of the catalog.\n\t *\n\t * This is the primary reason for needing to reset the system caches after\n\t * finishing decoding.\n\t */\n\tif (HistoricSnapshotActive())\n\t\treturn HistoricSnapshot;\n\n\treturn GetNonHistoricCatalogSnapshot(relid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "DbRoleSettingRelationId",
            "AccessShareLock"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void process_settings(Oid databaseid, Oid roleid);\n\nstatic void\nprocess_settings(Oid databaseid, Oid roleid)\n{\n\tRelation\trelsetting;\n\tSnapshot\tsnapshot;\n\n\tif (!IsUnderPostmaster)\n\t\treturn;\n\n\trelsetting = heap_open(DbRoleSettingRelationId, AccessShareLock);\n\n\t/* read all the settings under the same snapshot for efficiency */\n\tsnapshot = RegisterSnapshot(GetCatalogSnapshot(DbRoleSettingRelationId));\n\n\t/* Later settings are ignored if set earlier. */\n\tApplySetting(snapshot, databaseid, roleid, relsetting, PGC_S_DATABASE_USER);\n\tApplySetting(snapshot, InvalidOid, roleid, relsetting, PGC_S_USER);\n\tApplySetting(snapshot, databaseid, InvalidOid, relsetting, PGC_S_DATABASE);\n\tApplySetting(snapshot, InvalidOid, InvalidOid, relsetting, PGC_S_GLOBAL);\n\n\tUnregisterSnapshot(snapshot);\n\theap_close(relsetting, AccessShareLock);\n}"
  },
  {
    "function_name": "process_startup_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
    "lines": "1055-1112",
    "snippet": "static void\nprocess_startup_options(Port *port, bool am_superuser)\n{\n\tGucContext\tgucctx;\n\tListCell   *gucopts;\n\n\tgucctx = am_superuser ? PGC_SU_BACKEND : PGC_BACKEND;\n\n\t/*\n\t * First process any command-line switches that were included in the\n\t * startup packet, if we are in a regular backend.\n\t */\n\tif (port->cmdline_options != NULL)\n\t{\n\t\t/*\n\t\t * The maximum possible number of commandline arguments that could\n\t\t * come from port->cmdline_options is (strlen + 1) / 2; see\n\t\t * pg_split_opts().\n\t\t */\n\t\tchar\t  **av;\n\t\tint\t\t\tmaxac;\n\t\tint\t\t\tac;\n\n\t\tmaxac = 2 + (strlen(port->cmdline_options) + 1) / 2;\n\n\t\tav = (char **) palloc(maxac * sizeof(char *));\n\t\tac = 0;\n\n\t\tav[ac++] = \"postgres\";\n\n\t\tpg_split_opts(av, &ac, port->cmdline_options);\n\n\t\tav[ac] = NULL;\n\n\t\tAssert(ac < maxac);\n\n\t\t(void) process_postgres_switches(ac, av, gucctx, NULL);\n\t}\n\n\t/*\n\t * Process any additional GUC variable settings passed in startup packet.\n\t * These are handled exactly like command-line variables.\n\t */\n\tgucopts = list_head(port->guc_options);\n\twhile (gucopts)\n\t{\n\t\tchar\t   *name;\n\t\tchar\t   *value;\n\n\t\tname = lfirst(gucopts);\n\t\tgucopts = lnext(gucopts);\n\n\t\tvalue = lfirst(gucopts);\n\t\tgucopts = lnext(gucopts);\n\n\t\tSetConfigOption(name, value, gucctx, PGC_S_CLIENT);\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"utils/portal.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/procsignal.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"replication/walsender.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq-be.h\"",
      "#include \"libpq/auth.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_db_role_setting.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/session.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PerformAuthentication(Port *port);",
      "static void process_startup_options(Port *port, bool am_superuser);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetConfigOption",
          "args": [
            "name",
            "value",
            "gucctx",
            "PGC_S_CLIENT"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "SetConfigOption",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "6930-6936",
          "snippet": "void\nSetConfigOption(const char *name, const char *value,\n\t\t\t\tGucContext context, GucSource source)\n{\n\t(void) set_config_option(name, value, context, source,\n\t\t\t\t\t\t\t GUC_ACTION_SET, true, 0, false);\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool check_log_destination(char **newval, void **extra, GucSource source);",
            "static bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);",
            "static bool check_client_min_messages(int *newval, void **extra, GucSource source);",
            "static bool check_temp_buffers(int *newval, void **extra, GucSource source);",
            "static bool check_bonjour(bool *newval, void **extra, GucSource source);",
            "static bool check_ssl(bool *newval, void **extra, GucSource source);",
            "static bool check_stage_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_canonical_path(char **newval, void **extra, GucSource source);",
            "static bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);",
            "static bool check_maxconnections(int *newval, void **extra, GucSource source);",
            "static bool check_max_worker_processes(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);",
            "static bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);",
            "static bool check_application_name(char **newval, void **extra, GucSource source);",
            "static bool check_cluster_name(char **newval, void **extra, GucSource source);",
            "static void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool check_log_destination(char **newval, void **extra, GucSource source);\nstatic bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);\nstatic bool check_client_min_messages(int *newval, void **extra, GucSource source);\nstatic bool check_temp_buffers(int *newval, void **extra, GucSource source);\nstatic bool check_bonjour(bool *newval, void **extra, GucSource source);\nstatic bool check_ssl(bool *newval, void **extra, GucSource source);\nstatic bool check_stage_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_canonical_path(char **newval, void **extra, GucSource source);\nstatic bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);\nstatic bool check_maxconnections(int *newval, void **extra, GucSource source);\nstatic bool check_max_worker_processes(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);\nstatic bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);\nstatic bool check_application_name(char **newval, void **extra, GucSource source);\nstatic bool check_cluster_name(char **newval, void **extra, GucSource source);\nstatic void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);\n\nvoid\nSetConfigOption(const char *name, const char *value,\n\t\t\t\tGucContext context, GucSource source)\n{\n\t(void) set_config_option(name, value, context, source,\n\t\t\t\t\t\t\t GUC_ACTION_SET, true, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lnext",
          "args": [
            "gucopts"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "gucopts"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnext",
          "args": [
            "gucopts"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "gucopts"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_head",
          "args": [
            "port->guc_options"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_postgres_switches",
          "args": [
            "ac",
            "av",
            "gucctx",
            "NULL"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ac < maxac"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_split_opts",
          "args": [
            "av",
            "&ac",
            "port->cmdline_options"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "pg_split_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
          "lines": "444-489",
          "snippet": "void\npg_split_opts(char **argv, int *argcp, const char *optstr)\n{\n\tStringInfoData s;\n\n\tinitStringInfo(&s);\n\n\twhile (*optstr)\n\t{\n\t\tbool\t\tlast_was_escape = false;\n\n\t\tresetStringInfo(&s);\n\n\t\t/* skip over leading space */\n\t\twhile (isspace((unsigned char) *optstr))\n\t\t\toptstr++;\n\n\t\tif (*optstr == '\\0')\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Parse a single option, stopping at the first space, unless it's\n\t\t * escaped.\n\t\t */\n\t\twhile (*optstr)\n\t\t{\n\t\t\tif (isspace((unsigned char) *optstr) && !last_was_escape)\n\t\t\t\tbreak;\n\n\t\t\tif (!last_was_escape && *optstr == '\\\\')\n\t\t\t\tlast_was_escape = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tlast_was_escape = false;\n\t\t\t\tappendStringInfoChar(&s, *optstr);\n\t\t\t}\n\n\t\t\toptstr++;\n\t\t}\n\n\t\t/* now store the option in the next argv[] position */\n\t\targv[(*argcp)++] = pstrdup(s.data);\n\t}\n\n\tpfree(s.data);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/procsignal.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/session.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\npg_split_opts(char **argv, int *argcp, const char *optstr)\n{\n\tStringInfoData s;\n\n\tinitStringInfo(&s);\n\n\twhile (*optstr)\n\t{\n\t\tbool\t\tlast_was_escape = false;\n\n\t\tresetStringInfo(&s);\n\n\t\t/* skip over leading space */\n\t\twhile (isspace((unsigned char) *optstr))\n\t\t\toptstr++;\n\n\t\tif (*optstr == '\\0')\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Parse a single option, stopping at the first space, unless it's\n\t\t * escaped.\n\t\t */\n\t\twhile (*optstr)\n\t\t{\n\t\t\tif (isspace((unsigned char) *optstr) && !last_was_escape)\n\t\t\t\tbreak;\n\n\t\t\tif (!last_was_escape && *optstr == '\\\\')\n\t\t\t\tlast_was_escape = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tlast_was_escape = false;\n\t\t\t\tappendStringInfoChar(&s, *optstr);\n\t\t\t}\n\n\t\t\toptstr++;\n\t\t}\n\n\t\t/* now store the option in the next argv[] position */\n\t\targv[(*argcp)++] = pstrdup(s.data);\n\t}\n\n\tpfree(s.data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "maxac * sizeof(char *)"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "port->cmdline_options"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void PerformAuthentication(Port *port);\nstatic void process_startup_options(Port *port, bool am_superuser);\n\nstatic void\nprocess_startup_options(Port *port, bool am_superuser)\n{\n\tGucContext\tgucctx;\n\tListCell   *gucopts;\n\n\tgucctx = am_superuser ? PGC_SU_BACKEND : PGC_BACKEND;\n\n\t/*\n\t * First process any command-line switches that were included in the\n\t * startup packet, if we are in a regular backend.\n\t */\n\tif (port->cmdline_options != NULL)\n\t{\n\t\t/*\n\t\t * The maximum possible number of commandline arguments that could\n\t\t * come from port->cmdline_options is (strlen + 1) / 2; see\n\t\t * pg_split_opts().\n\t\t */\n\t\tchar\t  **av;\n\t\tint\t\t\tmaxac;\n\t\tint\t\t\tac;\n\n\t\tmaxac = 2 + (strlen(port->cmdline_options) + 1) / 2;\n\n\t\tav = (char **) palloc(maxac * sizeof(char *));\n\t\tac = 0;\n\n\t\tav[ac++] = \"postgres\";\n\n\t\tpg_split_opts(av, &ac, port->cmdline_options);\n\n\t\tav[ac] = NULL;\n\n\t\tAssert(ac < maxac);\n\n\t\t(void) process_postgres_switches(ac, av, gucctx, NULL);\n\t}\n\n\t/*\n\t * Process any additional GUC variable settings passed in startup packet.\n\t * These are handled exactly like command-line variables.\n\t */\n\tgucopts = list_head(port->guc_options);\n\twhile (gucopts)\n\t{\n\t\tchar\t   *name;\n\t\tchar\t   *value;\n\n\t\tname = lfirst(gucopts);\n\t\tgucopts = lnext(gucopts);\n\n\t\tvalue = lfirst(gucopts);\n\t\tgucopts = lnext(gucopts);\n\n\t\tSetConfigOption(name, value, gucctx, PGC_S_CLIENT);\n\t}\n}"
  },
  {
    "function_name": "InitPostgres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
    "lines": "566-1049",
    "snippet": "void\nInitPostgres(const char *in_dbname, Oid dboid, const char *username,\n\t\t\t Oid useroid, char *out_dbname, bool override_allow_connections)\n{\n\tbool\t\tbootstrap = IsBootstrapProcessingMode();\n\tbool\t\tam_superuser;\n\tchar\t   *fullpath;\n\tchar\t\tdbname[NAMEDATALEN];\n\n\telog(DEBUG3, \"InitPostgres\");\n\n\t/*\n\t * Add my PGPROC struct to the ProcArray.\n\t *\n\t * Once I have done this, I am visible to other backends!\n\t */\n\tInitProcessPhase2();\n\n\t/*\n\t * Initialize my entry in the shared-invalidation manager's array of\n\t * per-backend data.\n\t *\n\t * Sets up MyBackendId, a unique backend identifier.\n\t */\n\tMyBackendId = InvalidBackendId;\n\n\tSharedInvalBackendInit(false);\n\n\tif (MyBackendId > MaxBackends || MyBackendId <= 0)\n\t\telog(FATAL, \"bad backend ID: %d\", MyBackendId);\n\n\t/* Now that we have a BackendId, we can participate in ProcSignal */\n\tProcSignalInit(MyBackendId);\n\n\t/*\n\t * Also set up timeout handlers needed for backend operation.  We need\n\t * these in every case except bootstrap.\n\t */\n\tif (!bootstrap)\n\t{\n\t\tRegisterTimeout(DEADLOCK_TIMEOUT, CheckDeadLockAlert);\n\t\tRegisterTimeout(STATEMENT_TIMEOUT, StatementTimeoutHandler);\n\t\tRegisterTimeout(LOCK_TIMEOUT, LockTimeoutHandler);\n\t\tRegisterTimeout(IDLE_IN_TRANSACTION_SESSION_TIMEOUT,\n\t\t\t\t\t\tIdleInTransactionSessionTimeoutHandler);\n\t}\n\n\t/*\n\t * bufmgr needs another initialization call too\n\t */\n\tInitBufferPoolBackend();\n\n\t/*\n\t * Initialize local process's access to XLOG.\n\t */\n\tif (IsUnderPostmaster)\n\t{\n\t\t/*\n\t\t * The postmaster already started the XLOG machinery, but we need to\n\t\t * call InitXLOGAccess(), if the system isn't in hot-standby mode.\n\t\t * This is handled by calling RecoveryInProgress and ignoring the\n\t\t * result.\n\t\t */\n\t\t(void) RecoveryInProgress();\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We are either a bootstrap process or a standalone backend. Either\n\t\t * way, start up the XLOG machinery, and register to have it closed\n\t\t * down at exit.\n\t\t */\n\t\tStartupXLOG();\n\t\ton_shmem_exit(ShutdownXLOG, 0);\n\t}\n\n\t/*\n\t * Initialize the relation cache and the system catalog caches.  Note that\n\t * no catalog access happens here; we only set up the hashtable structure.\n\t * We must do this before starting a transaction because transaction abort\n\t * would try to touch these hashtables.\n\t */\n\tRelationCacheInitialize();\n\tInitCatalogCache();\n\tInitPlanCache();\n\n\t/* Initialize portal manager */\n\tEnablePortalManager();\n\n\t/* Initialize stats collection --- must happen before first xact */\n\tif (!bootstrap)\n\t\tpgstat_initialize();\n\n\t/*\n\t * Load relcache entries for the shared system catalogs.  This must create\n\t * at least entries for pg_database and catalogs used for authentication.\n\t */\n\tRelationCacheInitializePhase2();\n\n\t/*\n\t * Set up process-exit callback to do pre-shutdown cleanup.  This is the\n\t * first before_shmem_exit callback we register; thus, this will be the\n\t * last thing we do before low-level modules like the buffer manager begin\n\t * to close down.  We need to have this in place before we begin our first\n\t * transaction --- if we fail during the initialization transaction, as is\n\t * entirely possible, we need the AbortTransaction call to clean up.\n\t */\n\tbefore_shmem_exit(ShutdownPostgres, 0);\n\n\t/* The autovacuum launcher is done here */\n\tif (IsAutoVacuumLauncherProcess())\n\t{\n\t\t/* report this backend in the PgBackendStatus array */\n\t\tpgstat_bestart();\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Start a new transaction here before first access to db, and get a\n\t * snapshot.  We don't have a use for the snapshot itself, but we're\n\t * interested in the secondary effect that it sets RecentGlobalXmin. (This\n\t * is critical for anything that reads heap pages, because HOT may decide\n\t * to prune them even if the process doesn't attempt to modify any\n\t * tuples.)\n\t */\n\tif (!bootstrap)\n\t{\n\t\t/* statement_timestamp must be set for timeouts to work correctly */\n\t\tSetCurrentStatementStartTimestamp();\n\t\tStartTransactionCommand();\n\n\t\t/*\n\t\t * transaction_isolation will have been set to the default by the\n\t\t * above.  If the default is \"serializable\", and we are in hot\n\t\t * standby, we will fail if we don't change it to something lower.\n\t\t * Fortunately, \"read committed\" is plenty good enough.\n\t\t */\n\t\tXactIsoLevel = XACT_READ_COMMITTED;\n\n\t\t(void) GetTransactionSnapshot();\n\t}\n\n\t/*\n\t * Perform client authentication if necessary, then figure out our\n\t * postgres user ID, and see if we are a superuser.\n\t *\n\t * In standalone mode and in autovacuum worker processes, we use a fixed\n\t * ID, otherwise we figure it out from the authenticated user name.\n\t */\n\tif (bootstrap || IsAutoVacuumWorkerProcess())\n\t{\n\t\tInitializeSessionUserIdStandalone();\n\t\tam_superuser = true;\n\t}\n\telse if (!IsUnderPostmaster)\n\t{\n\t\tInitializeSessionUserIdStandalone();\n\t\tam_superuser = true;\n\t\tif (!ThereIsAtLeastOneRole())\n\t\t\tereport(WARNING,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"no roles are defined in this database system\"),\n\t\t\t\t\t errhint(\"You should immediately run CREATE USER \\\"%s\\\" SUPERUSER;.\",\n\t\t\t\t\t\t\t username != NULL ? username : \"postgres\")));\n\t}\n\telse if (IsBackgroundWorker)\n\t{\n\t\tif (username == NULL && !OidIsValid(useroid))\n\t\t{\n\t\t\tInitializeSessionUserIdStandalone();\n\t\t\tam_superuser = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tInitializeSessionUserId(username, useroid);\n\t\t\tam_superuser = superuser();\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* normal multiuser case */\n\t\tAssert(MyProcPort != NULL);\n\t\tPerformAuthentication(MyProcPort);\n\t\tInitializeSessionUserId(username, useroid);\n\t\tam_superuser = superuser();\n\t}\n\n\t/*\n\t * If we're trying to shut down, only superusers can connect, and new\n\t * replication connections are not allowed.\n\t */\n\tif ((!am_superuser || am_walsender) &&\n\t\tMyProcPort != NULL &&\n\t\tMyProcPort->canAcceptConnections == CAC_WAITBACKUP)\n\t{\n\t\tif (am_walsender)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"new replication connections are not allowed during database shutdown\")));\n\t\telse\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"must be superuser to connect during database shutdown\")));\n\t}\n\n\t/*\n\t * Binary upgrades only allowed super-user connections\n\t */\n\tif (IsBinaryUpgrade && !am_superuser)\n\t{\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"must be superuser to connect in binary upgrade mode\")));\n\t}\n\n\t/*\n\t * The last few connection slots are reserved for superusers.  Although\n\t * replication connections currently require superuser privileges, we\n\t * don't allow them to consume the reserved slots, which are intended for\n\t * interactive use.\n\t */\n\tif ((!am_superuser || am_walsender) &&\n\t\tReservedBackends > 0 &&\n\t\t!HaveNFreeProcs(ReservedBackends))\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t errmsg(\"remaining connection slots are reserved for non-replication superuser connections\")));\n\n\t/* Check replication permissions needed for walsender processes. */\n\tif (am_walsender)\n\t{\n\t\tAssert(!bootstrap);\n\n\t\tif (!superuser() && !has_rolreplication(GetUserId()))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"must be superuser or replication role to start walsender\")));\n\t}\n\n\t/*\n\t * If this is a plain walsender only supporting physical replication, we\n\t * don't want to connect to any particular database. Just finish the\n\t * backend startup by processing any options from the startup packet, and\n\t * we're done.\n\t */\n\tif (am_walsender && !am_db_walsender)\n\t{\n\t\t/* process any options passed in the startup packet */\n\t\tif (MyProcPort != NULL)\n\t\t\tprocess_startup_options(MyProcPort, am_superuser);\n\n\t\t/* Apply PostAuthDelay as soon as we've read all options */\n\t\tif (PostAuthDelay > 0)\n\t\t\tpg_usleep(PostAuthDelay * 1000000L);\n\n\t\t/* initialize client encoding */\n\t\tInitializeClientEncoding();\n\n\t\t/* report this backend in the PgBackendStatus array */\n\t\tpgstat_bestart();\n\n\t\t/* close the transaction we started above */\n\t\tCommitTransactionCommand();\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Set up the global variables holding database id and default tablespace.\n\t * But note we won't actually try to touch the database just yet.\n\t *\n\t * We take a shortcut in the bootstrap case, otherwise we have to look up\n\t * the db's entry in pg_database.\n\t */\n\tif (bootstrap)\n\t{\n\t\tMyDatabaseId = TemplateDbOid;\n\t\tMyDatabaseTableSpace = DEFAULTTABLESPACE_OID;\n\t}\n\telse if (in_dbname != NULL)\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_database dbform;\n\n\t\ttuple = GetDatabaseTuple(in_dbname);\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t\t errmsg(\"database \\\"%s\\\" does not exist\", in_dbname)));\n\t\tdbform = (Form_pg_database) GETSTRUCT(tuple);\n\t\tMyDatabaseId = HeapTupleGetOid(tuple);\n\t\tMyDatabaseTableSpace = dbform->dattablespace;\n\t\t/* take database name from the caller, just for paranoia */\n\t\tstrlcpy(dbname, in_dbname, sizeof(dbname));\n\t}\n\telse if (OidIsValid(dboid))\n\t{\n\t\t/* caller specified database by OID */\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_database dbform;\n\n\t\ttuple = GetDatabaseTupleByOid(dboid);\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t\t errmsg(\"database %u does not exist\", dboid)));\n\t\tdbform = (Form_pg_database) GETSTRUCT(tuple);\n\t\tMyDatabaseId = HeapTupleGetOid(tuple);\n\t\tMyDatabaseTableSpace = dbform->dattablespace;\n\t\tAssert(MyDatabaseId == dboid);\n\t\tstrlcpy(dbname, NameStr(dbform->datname), sizeof(dbname));\n\t\t/* pass the database name back to the caller */\n\t\tif (out_dbname)\n\t\t\tstrcpy(out_dbname, dbname);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If this is a background worker not bound to any particular\n\t\t * database, we're done now.  Everything that follows only makes sense\n\t\t * if we are bound to a specific database.  We do need to close the\n\t\t * transaction we started before returning.\n\t\t */\n\t\tif (!bootstrap)\n\t\t{\n\t\t\tpgstat_bestart();\n\t\t\tCommitTransactionCommand();\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * Now, take a writer's lock on the database we are trying to connect to.\n\t * If there is a concurrently running DROP DATABASE on that database, this\n\t * will block us until it finishes (and has committed its update of\n\t * pg_database).\n\t *\n\t * Note that the lock is not held long, only until the end of this startup\n\t * transaction.  This is OK since we will advertise our use of the\n\t * database in the ProcArray before dropping the lock (in fact, that's the\n\t * next thing to do).  Anyone trying a DROP DATABASE after this point will\n\t * see us in the array once they have the lock.  Ordering is important for\n\t * this because we don't want to advertise ourselves as being in this\n\t * database until we have the lock; otherwise we create what amounts to a\n\t * deadlock with CountOtherDBBackends().\n\t *\n\t * Note: use of RowExclusiveLock here is reasonable because we envision\n\t * our session as being a concurrent writer of the database.  If we had a\n\t * way of declaring a session as being guaranteed-read-only, we could use\n\t * AccessShareLock for such sessions and thereby not conflict against\n\t * CREATE DATABASE.\n\t */\n\tif (!bootstrap)\n\t\tLockSharedObject(DatabaseRelationId, MyDatabaseId, 0,\n\t\t\t\t\t\t RowExclusiveLock);\n\n\t/*\n\t * Now we can mark our PGPROC entry with the database ID.\n\t *\n\t * We assume this is an atomic store so no lock is needed; though actually\n\t * things would work fine even if it weren't atomic.  Anyone searching the\n\t * ProcArray for this database's ID should hold the database lock, so they\n\t * would not be executing concurrently with this store.  A process looking\n\t * for another database's ID could in theory see a chance match if it read\n\t * a partially-updated databaseId value; but as long as all such searches\n\t * wait and retry, as in CountOtherDBBackends(), they will certainly see\n\t * the correct value on their next try.\n\t */\n\tMyProc->databaseId = MyDatabaseId;\n\n\t/*\n\t * We established a catalog snapshot while reading pg_authid and/or\n\t * pg_database; but until we have set up MyDatabaseId, we won't react to\n\t * incoming sinval messages for unshared catalogs, so we won't realize it\n\t * if the snapshot has been invalidated.  Assume it's no good anymore.\n\t */\n\tInvalidateCatalogSnapshot();\n\n\t/*\n\t * Recheck pg_database to make sure the target database hasn't gone away.\n\t * If there was a concurrent DROP DATABASE, this ensures we will die\n\t * cleanly without creating a mess.\n\t */\n\tif (!bootstrap)\n\t{\n\t\tHeapTuple\ttuple;\n\n\t\ttuple = GetDatabaseTuple(dbname);\n\t\tif (!HeapTupleIsValid(tuple) ||\n\t\t\tMyDatabaseId != HeapTupleGetOid(tuple) ||\n\t\t\tMyDatabaseTableSpace != ((Form_pg_database) GETSTRUCT(tuple))->dattablespace)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t\t errmsg(\"database \\\"%s\\\" does not exist\", dbname),\n\t\t\t\t\t errdetail(\"It seems to have just been dropped or renamed.\")));\n\t}\n\n\t/*\n\t * Now we should be able to access the database directory safely. Verify\n\t * it's there and looks reasonable.\n\t */\n\tfullpath = GetDatabasePath(MyDatabaseId, MyDatabaseTableSpace);\n\n\tif (!bootstrap)\n\t{\n\t\tif (access(fullpath, F_OK) == -1)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t\t\t errmsg(\"database \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\t\tdbname),\n\t\t\t\t\t\t errdetail(\"The database subdirectory \\\"%s\\\" is missing.\",\n\t\t\t\t\t\t\t\t   fullpath)));\n\t\t\telse\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not access directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\tfullpath)));\n\t\t}\n\n\t\tValidatePgVersion(fullpath);\n\t}\n\n\tSetDatabasePath(fullpath);\n\n\t/*\n\t * It's now possible to do real access to the system catalogs.\n\t *\n\t * Load relcache entries for the system catalogs.  This must create at\n\t * least the minimum set of \"nailed-in\" cache entries.\n\t */\n\tRelationCacheInitializePhase3();\n\n\t/* set up ACL framework (so CheckMyDatabase can check permissions) */\n\tinitialize_acl();\n\n\t/*\n\t * Re-read the pg_database row for our database, check permissions and set\n\t * up database-specific GUC settings.  We can't do this until all the\n\t * database-access infrastructure is up.  (Also, it wants to know if the\n\t * user is a superuser, so the above stuff has to happen first.)\n\t */\n\tif (!bootstrap)\n\t\tCheckMyDatabase(dbname, am_superuser, override_allow_connections);\n\n\t/*\n\t * Now process any command-line switches and any additional GUC variable\n\t * settings passed in the startup packet.   We couldn't do this before\n\t * because we didn't know if client is a superuser.\n\t */\n\tif (MyProcPort != NULL)\n\t\tprocess_startup_options(MyProcPort, am_superuser);\n\n\t/* Process pg_db_role_setting options */\n\tprocess_settings(MyDatabaseId, GetSessionUserId());\n\n\t/* Apply PostAuthDelay as soon as we've read all options */\n\tif (PostAuthDelay > 0)\n\t\tpg_usleep(PostAuthDelay * 1000000L);\n\n\t/*\n\t * Initialize various default states that can't be set up until we've\n\t * selected the active user and gotten the right GUC settings.\n\t */\n\n\t/* set default namespace search path */\n\tInitializeSearchPath();\n\n\t/* initialize client encoding */\n\tInitializeClientEncoding();\n\n\t/* Initialize this backend's session state. */\n\tInitializeSession();\n\n\t/* report this backend in the PgBackendStatus array */\n\tif (!bootstrap)\n\t\tpgstat_bestart();\n\n\t/* close the transaction we started above */\n\tif (!bootstrap)\n\t\tCommitTransactionCommand();\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"utils/portal.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/procsignal.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"replication/walsender.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq-be.h\"",
      "#include \"libpq/auth.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_db_role_setting.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/session.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HeapTuple GetDatabaseTuple(const char *dbname);",
      "static HeapTuple GetDatabaseTupleByOid(Oid dboid);",
      "static void CheckMyDatabase(const char *name, bool am_superuser, bool override_allow_connections);",
      "static void StatementTimeoutHandler(void);",
      "static void LockTimeoutHandler(void);",
      "static void IdleInTransactionSessionTimeoutHandler(void);",
      "static bool ThereIsAtLeastOneRole(void);",
      "static void process_startup_options(Port *port, bool am_superuser);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CommitTransactionCommand",
          "args": [],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_bestart",
          "args": [],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitializeSession",
          "args": [],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "InitializeSessionUserIdStandalone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "681-697",
          "snippet": "void\nInitializeSessionUserIdStandalone(void)\n{\n\t/*\n\t * This function should only be called in single-user mode, in autovacuum\n\t * workers, and in background workers.\n\t */\n\tAssertState(!IsUnderPostmaster || IsAutoVacuumWorkerProcess() || IsBackgroundWorker);\n\n\t/* call only once */\n\tAssertState(!OidIsValid(AuthenticatedUserId));\n\n\tAuthenticatedUserId = BOOTSTRAP_SUPERUSERID;\n\tAuthenticatedUserIsSuperuser = true;\n\n\tSetSessionUserId(BOOTSTRAP_SUPERUSERID, true);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tAuthenticatedUserId = InvalidOid;",
            "static bool AuthenticatedUserIsSuperuser = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tAuthenticatedUserId = InvalidOid;\nstatic bool AuthenticatedUserIsSuperuser = false;\n\nvoid\nInitializeSessionUserIdStandalone(void)\n{\n\t/*\n\t * This function should only be called in single-user mode, in autovacuum\n\t * workers, and in background workers.\n\t */\n\tAssertState(!IsUnderPostmaster || IsAutoVacuumWorkerProcess() || IsBackgroundWorker);\n\n\t/* call only once */\n\tAssertState(!OidIsValid(AuthenticatedUserId));\n\n\tAuthenticatedUserId = BOOTSTRAP_SUPERUSERID;\n\tAuthenticatedUserIsSuperuser = true;\n\n\tSetSessionUserId(BOOTSTRAP_SUPERUSERID, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitializeClientEncoding",
          "args": [],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "InitializeClientEncoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "281-300",
          "snippet": "void\nInitializeClientEncoding(void)\n{\n\tAssert(!backend_startup_complete);\n\tbackend_startup_complete = true;\n\n\tif (PrepareClientEncoding(pending_client_encoding) < 0 ||\n\t\tSetClientEncoding(pending_client_encoding) < 0)\n\t{\n\t\t/*\n\t\t * Oops, the requested conversion is not available. We couldn't fail\n\t\t * before, but we can now.\n\t\t */\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"conversion between %s and %s is not supported\",\n\t\t\t\t\t\tpg_enc2name_tbl[pending_client_encoding].name,\n\t\t\t\t\t\tGetDatabaseEncodingName())));\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool backend_startup_complete = false;",
            "static int\tpending_client_encoding = PG_SQL_ASCII;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic bool backend_startup_complete = false;\nstatic int\tpending_client_encoding = PG_SQL_ASCII;\n\nvoid\nInitializeClientEncoding(void)\n{\n\tAssert(!backend_startup_complete);\n\tbackend_startup_complete = true;\n\n\tif (PrepareClientEncoding(pending_client_encoding) < 0 ||\n\t\tSetClientEncoding(pending_client_encoding) < 0)\n\t{\n\t\t/*\n\t\t * Oops, the requested conversion is not available. We couldn't fail\n\t\t * before, but we can now.\n\t\t */\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"conversion between %s and %s is not supported\",\n\t\t\t\t\t\tpg_enc2name_tbl[pending_client_encoding].name,\n\t\t\t\t\t\tGetDatabaseEncodingName())));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitializeSearchPath",
          "args": [],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_usleep",
          "args": [
            "PostAuthDelay * 1000000L"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_settings",
          "args": [
            "MyDatabaseId",
            "GetSessionUserId()"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "process_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
          "lines": "1120-1142",
          "snippet": "static void\nprocess_settings(Oid databaseid, Oid roleid)\n{\n\tRelation\trelsetting;\n\tSnapshot\tsnapshot;\n\n\tif (!IsUnderPostmaster)\n\t\treturn;\n\n\trelsetting = heap_open(DbRoleSettingRelationId, AccessShareLock);\n\n\t/* read all the settings under the same snapshot for efficiency */\n\tsnapshot = RegisterSnapshot(GetCatalogSnapshot(DbRoleSettingRelationId));\n\n\t/* Later settings are ignored if set earlier. */\n\tApplySetting(snapshot, databaseid, roleid, relsetting, PGC_S_DATABASE_USER);\n\tApplySetting(snapshot, InvalidOid, roleid, relsetting, PGC_S_USER);\n\tApplySetting(snapshot, databaseid, InvalidOid, relsetting, PGC_S_DATABASE);\n\tApplySetting(snapshot, InvalidOid, InvalidOid, relsetting, PGC_S_GLOBAL);\n\n\tUnregisterSnapshot(snapshot);\n\theap_close(relsetting, AccessShareLock);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/procsignal.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/session.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void process_settings(Oid databaseid, Oid roleid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void process_settings(Oid databaseid, Oid roleid);\n\nstatic void\nprocess_settings(Oid databaseid, Oid roleid)\n{\n\tRelation\trelsetting;\n\tSnapshot\tsnapshot;\n\n\tif (!IsUnderPostmaster)\n\t\treturn;\n\n\trelsetting = heap_open(DbRoleSettingRelationId, AccessShareLock);\n\n\t/* read all the settings under the same snapshot for efficiency */\n\tsnapshot = RegisterSnapshot(GetCatalogSnapshot(DbRoleSettingRelationId));\n\n\t/* Later settings are ignored if set earlier. */\n\tApplySetting(snapshot, databaseid, roleid, relsetting, PGC_S_DATABASE_USER);\n\tApplySetting(snapshot, InvalidOid, roleid, relsetting, PGC_S_USER);\n\tApplySetting(snapshot, databaseid, InvalidOid, relsetting, PGC_S_DATABASE);\n\tApplySetting(snapshot, InvalidOid, InvalidOid, relsetting, PGC_S_GLOBAL);\n\n\tUnregisterSnapshot(snapshot);\n\theap_close(relsetting, AccessShareLock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetSessionUserId",
          "args": [],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "GetSessionUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "420-425",
          "snippet": "Oid\nGetSessionUserId(void)\n{\n\tAssertState(OidIsValid(SessionUserId));\n\treturn SessionUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tSessionUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tSessionUserId = InvalidOid;\n\nOid\nGetSessionUserId(void)\n{\n\tAssertState(OidIsValid(SessionUserId));\n\treturn SessionUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_startup_options",
          "args": [
            "MyProcPort",
            "am_superuser"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "process_startup_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
          "lines": "1055-1112",
          "snippet": "static void\nprocess_startup_options(Port *port, bool am_superuser)\n{\n\tGucContext\tgucctx;\n\tListCell   *gucopts;\n\n\tgucctx = am_superuser ? PGC_SU_BACKEND : PGC_BACKEND;\n\n\t/*\n\t * First process any command-line switches that were included in the\n\t * startup packet, if we are in a regular backend.\n\t */\n\tif (port->cmdline_options != NULL)\n\t{\n\t\t/*\n\t\t * The maximum possible number of commandline arguments that could\n\t\t * come from port->cmdline_options is (strlen + 1) / 2; see\n\t\t * pg_split_opts().\n\t\t */\n\t\tchar\t  **av;\n\t\tint\t\t\tmaxac;\n\t\tint\t\t\tac;\n\n\t\tmaxac = 2 + (strlen(port->cmdline_options) + 1) / 2;\n\n\t\tav = (char **) palloc(maxac * sizeof(char *));\n\t\tac = 0;\n\n\t\tav[ac++] = \"postgres\";\n\n\t\tpg_split_opts(av, &ac, port->cmdline_options);\n\n\t\tav[ac] = NULL;\n\n\t\tAssert(ac < maxac);\n\n\t\t(void) process_postgres_switches(ac, av, gucctx, NULL);\n\t}\n\n\t/*\n\t * Process any additional GUC variable settings passed in startup packet.\n\t * These are handled exactly like command-line variables.\n\t */\n\tgucopts = list_head(port->guc_options);\n\twhile (gucopts)\n\t{\n\t\tchar\t   *name;\n\t\tchar\t   *value;\n\n\t\tname = lfirst(gucopts);\n\t\tgucopts = lnext(gucopts);\n\n\t\tvalue = lfirst(gucopts);\n\t\tgucopts = lnext(gucopts);\n\n\t\tSetConfigOption(name, value, gucctx, PGC_S_CLIENT);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/procsignal.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/session.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PerformAuthentication(Port *port);",
            "static void process_startup_options(Port *port, bool am_superuser);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void PerformAuthentication(Port *port);\nstatic void process_startup_options(Port *port, bool am_superuser);\n\nstatic void\nprocess_startup_options(Port *port, bool am_superuser)\n{\n\tGucContext\tgucctx;\n\tListCell   *gucopts;\n\n\tgucctx = am_superuser ? PGC_SU_BACKEND : PGC_BACKEND;\n\n\t/*\n\t * First process any command-line switches that were included in the\n\t * startup packet, if we are in a regular backend.\n\t */\n\tif (port->cmdline_options != NULL)\n\t{\n\t\t/*\n\t\t * The maximum possible number of commandline arguments that could\n\t\t * come from port->cmdline_options is (strlen + 1) / 2; see\n\t\t * pg_split_opts().\n\t\t */\n\t\tchar\t  **av;\n\t\tint\t\t\tmaxac;\n\t\tint\t\t\tac;\n\n\t\tmaxac = 2 + (strlen(port->cmdline_options) + 1) / 2;\n\n\t\tav = (char **) palloc(maxac * sizeof(char *));\n\t\tac = 0;\n\n\t\tav[ac++] = \"postgres\";\n\n\t\tpg_split_opts(av, &ac, port->cmdline_options);\n\n\t\tav[ac] = NULL;\n\n\t\tAssert(ac < maxac);\n\n\t\t(void) process_postgres_switches(ac, av, gucctx, NULL);\n\t}\n\n\t/*\n\t * Process any additional GUC variable settings passed in startup packet.\n\t * These are handled exactly like command-line variables.\n\t */\n\tgucopts = list_head(port->guc_options);\n\twhile (gucopts)\n\t{\n\t\tchar\t   *name;\n\t\tchar\t   *value;\n\n\t\tname = lfirst(gucopts);\n\t\tgucopts = lnext(gucopts);\n\n\t\tvalue = lfirst(gucopts);\n\t\tgucopts = lnext(gucopts);\n\n\t\tSetConfigOption(name, value, gucctx, PGC_S_CLIENT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckMyDatabase",
          "args": [
            "dbname",
            "am_superuser",
            "override_allow_connections"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "CheckMyDatabase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
          "lines": "292-404",
          "snippet": "static void\nCheckMyDatabase(const char *name, bool am_superuser, bool override_allow_connections)\n{\n\tHeapTuple\ttup;\n\tForm_pg_database dbform;\n\tchar\t   *collate;\n\tchar\t   *ctype;\n\n\t/* Fetch our pg_database row normally, via syscache */\n\ttup = SearchSysCache1(DATABASEOID, ObjectIdGetDatum(MyDatabaseId));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for database %u\", MyDatabaseId);\n\tdbform = (Form_pg_database) GETSTRUCT(tup);\n\n\t/* This recheck is strictly paranoia */\n\tif (strcmp(name, NameStr(dbform->datname)) != 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t errmsg(\"database \\\"%s\\\" has disappeared from pg_database\",\n\t\t\t\t\t\tname),\n\t\t\t\t errdetail(\"Database OID %u now seems to belong to \\\"%s\\\".\",\n\t\t\t\t\t\t   MyDatabaseId, NameStr(dbform->datname))));\n\n\t/*\n\t * Check permissions to connect to the database.\n\t *\n\t * These checks are not enforced when in standalone mode, so that there is\n\t * a way to recover from disabling all access to all databases, for\n\t * example \"UPDATE pg_database SET datallowconn = false;\".\n\t *\n\t * We do not enforce them for autovacuum worker processes either.\n\t */\n\tif (IsUnderPostmaster && !IsAutoVacuumWorkerProcess())\n\t{\n\t\t/*\n\t\t * Check that the database is currently allowing connections.\n\t\t */\n\t\tif (!dbform->datallowconn && !override_allow_connections)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t errmsg(\"database \\\"%s\\\" is not currently accepting connections\",\n\t\t\t\t\t\t\tname)));\n\n\t\t/*\n\t\t * Check privilege to connect to the database.  (The am_superuser test\n\t\t * is redundant, but since we have the flag, might as well check it\n\t\t * and save a few cycles.)\n\t\t */\n\t\tif (!am_superuser &&\n\t\t\tpg_database_aclcheck(MyDatabaseId, GetUserId(),\n\t\t\t\t\t\t\t\t ACL_CONNECT) != ACLCHECK_OK)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"permission denied for database \\\"%s\\\"\", name),\n\t\t\t\t\t errdetail(\"User does not have CONNECT privilege.\")));\n\n\t\t/*\n\t\t * Check connection limit for this database.\n\t\t *\n\t\t * There is a race condition here --- we create our PGPROC before\n\t\t * checking for other PGPROCs.  If two backends did this at about the\n\t\t * same time, they might both think they were over the limit, while\n\t\t * ideally one should succeed and one fail.  Getting that to work\n\t\t * exactly seems more trouble than it is worth, however; instead we\n\t\t * just document that the connection limit is approximate.\n\t\t */\n\t\tif (dbform->datconnlimit >= 0 &&\n\t\t\t!am_superuser &&\n\t\t\tCountDBConnections(MyDatabaseId) > dbform->datconnlimit)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"too many connections for database \\\"%s\\\"\",\n\t\t\t\t\t\t\tname)));\n\t}\n\n\t/*\n\t * OK, we're golden.  Next to-do item is to save the encoding info out of\n\t * the pg_database tuple.\n\t */\n\tSetDatabaseEncoding(dbform->encoding);\n\t/* Record it as a GUC internal option, too */\n\tSetConfigOption(\"server_encoding\", GetDatabaseEncodingName(),\n\t\t\t\t\tPGC_INTERNAL, PGC_S_OVERRIDE);\n\t/* If we have no other source of client_encoding, use server encoding */\n\tSetConfigOption(\"client_encoding\", GetDatabaseEncodingName(),\n\t\t\t\t\tPGC_BACKEND, PGC_S_DYNAMIC_DEFAULT);\n\n\t/* assign locale variables */\n\tcollate = NameStr(dbform->datcollate);\n\tctype = NameStr(dbform->datctype);\n\n\tif (pg_perm_setlocale(LC_COLLATE, collate) == NULL)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"database locale is incompatible with operating system\"),\n\t\t\t\t errdetail(\"The database was initialized with LC_COLLATE \\\"%s\\\", \"\n\t\t\t\t\t\t   \" which is not recognized by setlocale().\", collate),\n\t\t\t\t errhint(\"Recreate the database with another locale or install the missing locale.\")));\n\n\tif (pg_perm_setlocale(LC_CTYPE, ctype) == NULL)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"database locale is incompatible with operating system\"),\n\t\t\t\t errdetail(\"The database was initialized with LC_CTYPE \\\"%s\\\", \"\n\t\t\t\t\t\t   \" which is not recognized by setlocale().\", ctype),\n\t\t\t\t errhint(\"Recreate the database with another locale or install the missing locale.\")));\n\n\t/* Make the locale settings visible as GUC variables, too */\n\tSetConfigOption(\"lc_collate\", collate, PGC_INTERNAL, PGC_S_OVERRIDE);\n\tSetConfigOption(\"lc_ctype\", ctype, PGC_INTERNAL, PGC_S_OVERRIDE);\n\n\tcheck_strxfrm_bug();\n\n\tReleaseSysCache(tup);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/procsignal.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/session.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CheckMyDatabase(const char *name, bool am_superuser, bool override_allow_connections);",
            "static void process_startup_options(Port *port, bool am_superuser);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void CheckMyDatabase(const char *name, bool am_superuser, bool override_allow_connections);\nstatic void process_startup_options(Port *port, bool am_superuser);\n\nstatic void\nCheckMyDatabase(const char *name, bool am_superuser, bool override_allow_connections)\n{\n\tHeapTuple\ttup;\n\tForm_pg_database dbform;\n\tchar\t   *collate;\n\tchar\t   *ctype;\n\n\t/* Fetch our pg_database row normally, via syscache */\n\ttup = SearchSysCache1(DATABASEOID, ObjectIdGetDatum(MyDatabaseId));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for database %u\", MyDatabaseId);\n\tdbform = (Form_pg_database) GETSTRUCT(tup);\n\n\t/* This recheck is strictly paranoia */\n\tif (strcmp(name, NameStr(dbform->datname)) != 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t errmsg(\"database \\\"%s\\\" has disappeared from pg_database\",\n\t\t\t\t\t\tname),\n\t\t\t\t errdetail(\"Database OID %u now seems to belong to \\\"%s\\\".\",\n\t\t\t\t\t\t   MyDatabaseId, NameStr(dbform->datname))));\n\n\t/*\n\t * Check permissions to connect to the database.\n\t *\n\t * These checks are not enforced when in standalone mode, so that there is\n\t * a way to recover from disabling all access to all databases, for\n\t * example \"UPDATE pg_database SET datallowconn = false;\".\n\t *\n\t * We do not enforce them for autovacuum worker processes either.\n\t */\n\tif (IsUnderPostmaster && !IsAutoVacuumWorkerProcess())\n\t{\n\t\t/*\n\t\t * Check that the database is currently allowing connections.\n\t\t */\n\t\tif (!dbform->datallowconn && !override_allow_connections)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t errmsg(\"database \\\"%s\\\" is not currently accepting connections\",\n\t\t\t\t\t\t\tname)));\n\n\t\t/*\n\t\t * Check privilege to connect to the database.  (The am_superuser test\n\t\t * is redundant, but since we have the flag, might as well check it\n\t\t * and save a few cycles.)\n\t\t */\n\t\tif (!am_superuser &&\n\t\t\tpg_database_aclcheck(MyDatabaseId, GetUserId(),\n\t\t\t\t\t\t\t\t ACL_CONNECT) != ACLCHECK_OK)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"permission denied for database \\\"%s\\\"\", name),\n\t\t\t\t\t errdetail(\"User does not have CONNECT privilege.\")));\n\n\t\t/*\n\t\t * Check connection limit for this database.\n\t\t *\n\t\t * There is a race condition here --- we create our PGPROC before\n\t\t * checking for other PGPROCs.  If two backends did this at about the\n\t\t * same time, they might both think they were over the limit, while\n\t\t * ideally one should succeed and one fail.  Getting that to work\n\t\t * exactly seems more trouble than it is worth, however; instead we\n\t\t * just document that the connection limit is approximate.\n\t\t */\n\t\tif (dbform->datconnlimit >= 0 &&\n\t\t\t!am_superuser &&\n\t\t\tCountDBConnections(MyDatabaseId) > dbform->datconnlimit)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"too many connections for database \\\"%s\\\"\",\n\t\t\t\t\t\t\tname)));\n\t}\n\n\t/*\n\t * OK, we're golden.  Next to-do item is to save the encoding info out of\n\t * the pg_database tuple.\n\t */\n\tSetDatabaseEncoding(dbform->encoding);\n\t/* Record it as a GUC internal option, too */\n\tSetConfigOption(\"server_encoding\", GetDatabaseEncodingName(),\n\t\t\t\t\tPGC_INTERNAL, PGC_S_OVERRIDE);\n\t/* If we have no other source of client_encoding, use server encoding */\n\tSetConfigOption(\"client_encoding\", GetDatabaseEncodingName(),\n\t\t\t\t\tPGC_BACKEND, PGC_S_DYNAMIC_DEFAULT);\n\n\t/* assign locale variables */\n\tcollate = NameStr(dbform->datcollate);\n\tctype = NameStr(dbform->datctype);\n\n\tif (pg_perm_setlocale(LC_COLLATE, collate) == NULL)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"database locale is incompatible with operating system\"),\n\t\t\t\t errdetail(\"The database was initialized with LC_COLLATE \\\"%s\\\", \"\n\t\t\t\t\t\t   \" which is not recognized by setlocale().\", collate),\n\t\t\t\t errhint(\"Recreate the database with another locale or install the missing locale.\")));\n\n\tif (pg_perm_setlocale(LC_CTYPE, ctype) == NULL)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"database locale is incompatible with operating system\"),\n\t\t\t\t errdetail(\"The database was initialized with LC_CTYPE \\\"%s\\\", \"\n\t\t\t\t\t\t   \" which is not recognized by setlocale().\", ctype),\n\t\t\t\t errhint(\"Recreate the database with another locale or install the missing locale.\")));\n\n\t/* Make the locale settings visible as GUC variables, too */\n\tSetConfigOption(\"lc_collate\", collate, PGC_INTERNAL, PGC_S_OVERRIDE);\n\tSetConfigOption(\"lc_ctype\", ctype, PGC_INTERNAL, PGC_S_OVERRIDE);\n\n\tcheck_strxfrm_bug();\n\n\tReleaseSysCache(tup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_acl",
          "args": [],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/acl.c",
          "lines": "4688-4701",
          "snippet": "void\ninitialize_acl(void)\n{\n\tif (!IsBootstrapProcessingMode())\n\t{\n\t\t/*\n\t\t * In normal mode, set a callback on any syscache invalidation of\n\t\t * pg_auth_members rows\n\t\t */\n\t\tCacheRegisterSyscacheCallback(AUTHMEMROLEMEM,\n\t\t\t\t\t\t\t\t\t  RoleMembershipCacheCallback,\n\t\t\t\t\t\t\t\t\t  (Datum) 0);\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"foreign/foreign.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/proclang.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static AclResult pg_role_aclcheck(Oid role_oid, Oid roleid, AclMode mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"foreign/foreign.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/proclang.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic AclResult pg_role_aclcheck(Oid role_oid, Oid roleid, AclMode mode);\n\nvoid\ninitialize_acl(void)\n{\n\tif (!IsBootstrapProcessingMode())\n\t{\n\t\t/*\n\t\t * In normal mode, set a callback on any syscache invalidation of\n\t\t * pg_auth_members rows\n\t\t */\n\t\tCacheRegisterSyscacheCallback(AUTHMEMROLEMEM,\n\t\t\t\t\t\t\t\t\t  RoleMembershipCacheCallback,\n\t\t\t\t\t\t\t\t\t  (Datum) 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationCacheInitializePhase3",
          "args": [],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "RelationCacheInitializePhase3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "3573-3860",
          "snippet": "void\nRelationCacheInitializePhase3(void)\n{\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tMemoryContext oldcxt;\n\tbool\t\tneedNewCacheFile = !criticalSharedRelcachesBuilt;\n\n\t/*\n\t * relation mapper needs initialized too\n\t */\n\tRelationMapInitializePhase3();\n\n\t/*\n\t * switch to cache memory context\n\t */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * Try to load the local relcache cache file.  If unsuccessful, bootstrap\n\t * the cache with pre-made descriptors for the critical \"nailed-in\" system\n\t * catalogs.\n\t */\n\tif (IsBootstrapProcessingMode() ||\n\t\t!load_relcache_init_file(false))\n\t{\n\t\tneedNewCacheFile = true;\n\n\t\tformrdesc(\"pg_class\", RelationRelation_Rowtype_Id, false,\n\t\t\t\t  true, Natts_pg_class, Desc_pg_class);\n\t\tformrdesc(\"pg_attribute\", AttributeRelation_Rowtype_Id, false,\n\t\t\t\t  false, Natts_pg_attribute, Desc_pg_attribute);\n\t\tformrdesc(\"pg_proc\", ProcedureRelation_Rowtype_Id, false,\n\t\t\t\t  true, Natts_pg_proc, Desc_pg_proc);\n\t\tformrdesc(\"pg_type\", TypeRelation_Rowtype_Id, false,\n\t\t\t\t  true, Natts_pg_type, Desc_pg_type);\n\n#define NUM_CRITICAL_LOCAL_RELS 4\t/* fix if you change list above */\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* In bootstrap mode, the faked-up formrdesc info is all we'll have */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * If we didn't get the critical system indexes loaded into relcache, do\n\t * so now.  These are critical because the catcache and/or opclass cache\n\t * depend on them for fetches done during relcache load.  Thus, we have an\n\t * infinite-recursion problem.  We can break the recursion by doing\n\t * heapscans instead of indexscans at certain key spots. To avoid hobbling\n\t * performance, we only want to do that until we have the critical indexes\n\t * loaded into relcache.  Thus, the flag criticalRelcachesBuilt is used to\n\t * decide whether to do heapscan or indexscan at the key spots, and we set\n\t * it true after we've loaded the critical indexes.\n\t *\n\t * The critical indexes are marked as \"nailed in cache\", partly to make it\n\t * easy for load_relcache_init_file to count them, but mainly because we\n\t * cannot flush and rebuild them once we've set criticalRelcachesBuilt to\n\t * true.  (NOTE: perhaps it would be possible to reload them by\n\t * temporarily setting criticalRelcachesBuilt to false again.  For now,\n\t * though, we just nail 'em in.)\n\t *\n\t * RewriteRelRulenameIndexId and TriggerRelidNameIndexId are not critical\n\t * in the same way as the others, because the critical catalogs don't\n\t * (currently) have any rules or triggers, and so these indexes can be\n\t * rebuilt without inducing recursion.  However they are used during\n\t * relcache load when a rel does have rules or triggers, so we choose to\n\t * nail them for performance reasons.\n\t */\n\tif (!criticalRelcachesBuilt)\n\t{\n\t\tload_critical_index(ClassOidIndexId,\n\t\t\t\t\t\t\tRelationRelationId);\n\t\tload_critical_index(AttributeRelidNumIndexId,\n\t\t\t\t\t\t\tAttributeRelationId);\n\t\tload_critical_index(IndexRelidIndexId,\n\t\t\t\t\t\t\tIndexRelationId);\n\t\tload_critical_index(OpclassOidIndexId,\n\t\t\t\t\t\t\tOperatorClassRelationId);\n\t\tload_critical_index(AccessMethodProcedureIndexId,\n\t\t\t\t\t\t\tAccessMethodProcedureRelationId);\n\t\tload_critical_index(RewriteRelRulenameIndexId,\n\t\t\t\t\t\t\tRewriteRelationId);\n\t\tload_critical_index(TriggerRelidNameIndexId,\n\t\t\t\t\t\t\tTriggerRelationId);\n\n#define NUM_CRITICAL_LOCAL_INDEXES\t7\t/* fix if you change list above */\n\n\t\tcriticalRelcachesBuilt = true;\n\t}\n\n\t/*\n\t * Process critical shared indexes too.\n\t *\n\t * DatabaseNameIndexId isn't critical for relcache loading, but rather for\n\t * initial lookup of MyDatabaseId, without which we'll never find any\n\t * non-shared catalogs at all.  Autovacuum calls InitPostgres with a\n\t * database OID, so it instead depends on DatabaseOidIndexId.  We also\n\t * need to nail up some indexes on pg_authid and pg_auth_members for use\n\t * during client authentication.  SharedSecLabelObjectIndexId isn't\n\t * critical for the core system, but authentication hooks might be\n\t * interested in it.\n\t */\n\tif (!criticalSharedRelcachesBuilt)\n\t{\n\t\tload_critical_index(DatabaseNameIndexId,\n\t\t\t\t\t\t\tDatabaseRelationId);\n\t\tload_critical_index(DatabaseOidIndexId,\n\t\t\t\t\t\t\tDatabaseRelationId);\n\t\tload_critical_index(AuthIdRolnameIndexId,\n\t\t\t\t\t\t\tAuthIdRelationId);\n\t\tload_critical_index(AuthIdOidIndexId,\n\t\t\t\t\t\t\tAuthIdRelationId);\n\t\tload_critical_index(AuthMemMemRoleIndexId,\n\t\t\t\t\t\t\tAuthMemRelationId);\n\t\tload_critical_index(SharedSecLabelObjectIndexId,\n\t\t\t\t\t\t\tSharedSecLabelRelationId);\n\n#define NUM_CRITICAL_SHARED_INDEXES 6\t/* fix if you change list above */\n\n\t\tcriticalSharedRelcachesBuilt = true;\n\t}\n\n\t/*\n\t * Now, scan all the relcache entries and update anything that might be\n\t * wrong in the results from formrdesc or the relcache cache file. If we\n\t * faked up relcache entries using formrdesc, then read the real pg_class\n\t * rows and replace the fake entries with them. Also, if any of the\n\t * relcache entries have rules, triggers, or security policies, load that\n\t * info the hard way since it isn't recorded in the cache file.\n\t *\n\t * Whenever we access the catalogs to read data, there is a possibility of\n\t * a shared-inval cache flush causing relcache entries to be removed.\n\t * Since hash_seq_search only guarantees to still work after the *current*\n\t * entry is removed, it's unsafe to continue the hashtable scan afterward.\n\t * We handle this by restarting the scan from scratch after each access.\n\t * This is theoretically O(N^2), but the number of entries that actually\n\t * need to be fixed is small enough that it doesn't matter.\n\t */\n\thash_seq_init(&status, RelationIdCache);\n\n\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tRelation\trelation = idhentry->reldesc;\n\t\tbool\t\trestart = false;\n\n\t\t/*\n\t\t * Make sure *this* entry doesn't get flushed while we work with it.\n\t\t */\n\t\tRelationIncrementReferenceCount(relation);\n\n\t\t/*\n\t\t * If it's a faked-up entry, read the real pg_class tuple.\n\t\t */\n\t\tif (relation->rd_rel->relowner == InvalidOid)\n\t\t{\n\t\t\tHeapTuple\thtup;\n\t\t\tForm_pg_class relp;\n\n\t\t\thtup = SearchSysCache1(RELOID,\n\t\t\t\t\t\t\t\t   ObjectIdGetDatum(RelationGetRelid(relation)));\n\t\t\tif (!HeapTupleIsValid(htup))\n\t\t\t\telog(FATAL, \"cache lookup failed for relation %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\trelp = (Form_pg_class) GETSTRUCT(htup);\n\n\t\t\t/*\n\t\t\t * Copy tuple to relation->rd_rel. (See notes in\n\t\t\t * AllocateRelationDesc())\n\t\t\t */\n\t\t\tmemcpy((char *) relation->rd_rel, (char *) relp, CLASS_TUPLE_SIZE);\n\n\t\t\t/* Update rd_options while we have the tuple */\n\t\t\tif (relation->rd_options)\n\t\t\t\tpfree(relation->rd_options);\n\t\t\tRelationParseRelOptions(relation, htup);\n\n\t\t\t/*\n\t\t\t * Check the values in rd_att were set up correctly.  (We cannot\n\t\t\t * just copy them over now: formrdesc must have set up the rd_att\n\t\t\t * data correctly to start with, because it may already have been\n\t\t\t * copied into one or more catcache entries.)\n\t\t\t */\n\t\t\tAssert(relation->rd_att->tdtypeid == relp->reltype);\n\t\t\tAssert(relation->rd_att->tdtypmod == -1);\n\t\t\tAssert(relation->rd_att->tdhasoid == relp->relhasoids);\n\n\t\t\tReleaseSysCache(htup);\n\n\t\t\t/* relowner had better be OK now, else we'll loop forever */\n\t\t\tif (relation->rd_rel->relowner == InvalidOid)\n\t\t\t\telog(ERROR, \"invalid relowner in pg_class entry for \\\"%s\\\"\",\n\t\t\t\t\t RelationGetRelationName(relation));\n\n\t\t\trestart = true;\n\t\t}\n\n\t\t/*\n\t\t * Fix data that isn't saved in relcache cache file.\n\t\t *\n\t\t * relhasrules or relhastriggers could possibly be wrong or out of\n\t\t * date.  If we don't actually find any rules or triggers, clear the\n\t\t * local copy of the flag so that we don't get into an infinite loop\n\t\t * here.  We don't make any attempt to fix the pg_class entry, though.\n\t\t */\n\t\tif (relation->rd_rel->relhasrules && relation->rd_rules == NULL)\n\t\t{\n\t\t\tRelationBuildRuleLock(relation);\n\t\t\tif (relation->rd_rules == NULL)\n\t\t\t\trelation->rd_rel->relhasrules = false;\n\t\t\trestart = true;\n\t\t}\n\t\tif (relation->rd_rel->relhastriggers && relation->trigdesc == NULL)\n\t\t{\n\t\t\tRelationBuildTriggers(relation);\n\t\t\tif (relation->trigdesc == NULL)\n\t\t\t\trelation->rd_rel->relhastriggers = false;\n\t\t\trestart = true;\n\t\t}\n\n\t\t/*\n\t\t * Re-load the row security policies if the relation has them, since\n\t\t * they are not preserved in the cache.  Note that we can never NOT\n\t\t * have a policy while relrowsecurity is true,\n\t\t * RelationBuildRowSecurity will create a single default-deny policy\n\t\t * if there is no policy defined in pg_policy.\n\t\t */\n\t\tif (relation->rd_rel->relrowsecurity && relation->rd_rsdesc == NULL)\n\t\t{\n\t\t\tRelationBuildRowSecurity(relation);\n\n\t\t\tAssert(relation->rd_rsdesc != NULL);\n\t\t\trestart = true;\n\t\t}\n\n\t\t/*\n\t\t * Reload the partition key and descriptor for a partitioned table.\n\t\t */\n\t\tif (relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE &&\n\t\t\trelation->rd_partkey == NULL)\n\t\t{\n\t\t\tRelationBuildPartitionKey(relation);\n\t\t\tAssert(relation->rd_partkey != NULL);\n\n\t\t\trestart = true;\n\t\t}\n\n\t\tif (relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE &&\n\t\t\trelation->rd_partdesc == NULL)\n\t\t{\n\t\t\tRelationBuildPartitionDesc(relation);\n\t\t\tAssert(relation->rd_partdesc != NULL);\n\n\t\t\trestart = true;\n\t\t}\n\n\t\t/* Release hold on the relation */\n\t\tRelationDecrementReferenceCount(relation);\n\n\t\t/* Now, restart the hashtable scan if needed */\n\t\tif (restart)\n\t\t{\n\t\t\thash_seq_term(&status);\n\t\t\thash_seq_init(&status, RelationIdCache);\n\t\t}\n\t}\n\n\t/*\n\t * Lastly, write out new relcache cache files if needed.  We don't bother\n\t * to distinguish cases where only one of the two needs an update.\n\t */\n\tif (needNewCacheFile)\n\t{\n\t\t/*\n\t\t * Force all the catcaches to finish initializing and thereby open the\n\t\t * catalogs and indexes they use.  This will preload the relcache with\n\t\t * entries for all the most important system catalogs and indexes, so\n\t\t * that the init files will be most useful for future backends.\n\t\t */\n\t\tInitCatalogCachePhase2();\n\n\t\t/* now write the files */\n\t\twrite_relcache_init_file(true);\n\t\twrite_relcache_init_file(false);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_CRITICAL_SHARED_INDEXES 6\t/* fix if you change list above */",
            "#define NUM_CRITICAL_LOCAL_INDEXES\t7\t/* fix if you change list above */",
            "#define NUM_CRITICAL_LOCAL_RELS 4\t/* fix if you change list above */"
          ],
          "globals_used": [
            "static const FormData_pg_attribute Desc_pg_class[Natts_pg_class] = {Schema_pg_class};",
            "static const FormData_pg_attribute Desc_pg_attribute[Natts_pg_attribute] = {Schema_pg_attribute};",
            "static const FormData_pg_attribute Desc_pg_proc[Natts_pg_proc] = {Schema_pg_proc};",
            "static const FormData_pg_attribute Desc_pg_type[Natts_pg_type] = {Schema_pg_type};",
            "static HTAB *RelationIdCache;",
            "bool\t\tcriticalRelcachesBuilt = false;",
            "bool\t\tcriticalSharedRelcachesBuilt = false;",
            "static void RelationClearRelation(Relation relation, bool rebuild);",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static bool load_relcache_init_file(bool shared);",
            "static void write_relcache_init_file(bool shared);",
            "static Relation AllocateRelationDesc(Form_pg_class relp);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define NUM_CRITICAL_SHARED_INDEXES 6\t/* fix if you change list above */\n#define NUM_CRITICAL_LOCAL_INDEXES\t7\t/* fix if you change list above */\n#define NUM_CRITICAL_LOCAL_RELS 4\t/* fix if you change list above */\n\nstatic const FormData_pg_attribute Desc_pg_class[Natts_pg_class] = {Schema_pg_class};\nstatic const FormData_pg_attribute Desc_pg_attribute[Natts_pg_attribute] = {Schema_pg_attribute};\nstatic const FormData_pg_attribute Desc_pg_proc[Natts_pg_proc] = {Schema_pg_proc};\nstatic const FormData_pg_attribute Desc_pg_type[Natts_pg_type] = {Schema_pg_type};\nstatic HTAB *RelationIdCache;\nbool\t\tcriticalRelcachesBuilt = false;\nbool\t\tcriticalSharedRelcachesBuilt = false;\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic Relation AllocateRelationDesc(Form_pg_class relp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationCacheInitializePhase3(void)\n{\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tMemoryContext oldcxt;\n\tbool\t\tneedNewCacheFile = !criticalSharedRelcachesBuilt;\n\n\t/*\n\t * relation mapper needs initialized too\n\t */\n\tRelationMapInitializePhase3();\n\n\t/*\n\t * switch to cache memory context\n\t */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * Try to load the local relcache cache file.  If unsuccessful, bootstrap\n\t * the cache with pre-made descriptors for the critical \"nailed-in\" system\n\t * catalogs.\n\t */\n\tif (IsBootstrapProcessingMode() ||\n\t\t!load_relcache_init_file(false))\n\t{\n\t\tneedNewCacheFile = true;\n\n\t\tformrdesc(\"pg_class\", RelationRelation_Rowtype_Id, false,\n\t\t\t\t  true, Natts_pg_class, Desc_pg_class);\n\t\tformrdesc(\"pg_attribute\", AttributeRelation_Rowtype_Id, false,\n\t\t\t\t  false, Natts_pg_attribute, Desc_pg_attribute);\n\t\tformrdesc(\"pg_proc\", ProcedureRelation_Rowtype_Id, false,\n\t\t\t\t  true, Natts_pg_proc, Desc_pg_proc);\n\t\tformrdesc(\"pg_type\", TypeRelation_Rowtype_Id, false,\n\t\t\t\t  true, Natts_pg_type, Desc_pg_type);\n\n#define NUM_CRITICAL_LOCAL_RELS 4\t/* fix if you change list above */\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* In bootstrap mode, the faked-up formrdesc info is all we'll have */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * If we didn't get the critical system indexes loaded into relcache, do\n\t * so now.  These are critical because the catcache and/or opclass cache\n\t * depend on them for fetches done during relcache load.  Thus, we have an\n\t * infinite-recursion problem.  We can break the recursion by doing\n\t * heapscans instead of indexscans at certain key spots. To avoid hobbling\n\t * performance, we only want to do that until we have the critical indexes\n\t * loaded into relcache.  Thus, the flag criticalRelcachesBuilt is used to\n\t * decide whether to do heapscan or indexscan at the key spots, and we set\n\t * it true after we've loaded the critical indexes.\n\t *\n\t * The critical indexes are marked as \"nailed in cache\", partly to make it\n\t * easy for load_relcache_init_file to count them, but mainly because we\n\t * cannot flush and rebuild them once we've set criticalRelcachesBuilt to\n\t * true.  (NOTE: perhaps it would be possible to reload them by\n\t * temporarily setting criticalRelcachesBuilt to false again.  For now,\n\t * though, we just nail 'em in.)\n\t *\n\t * RewriteRelRulenameIndexId and TriggerRelidNameIndexId are not critical\n\t * in the same way as the others, because the critical catalogs don't\n\t * (currently) have any rules or triggers, and so these indexes can be\n\t * rebuilt without inducing recursion.  However they are used during\n\t * relcache load when a rel does have rules or triggers, so we choose to\n\t * nail them for performance reasons.\n\t */\n\tif (!criticalRelcachesBuilt)\n\t{\n\t\tload_critical_index(ClassOidIndexId,\n\t\t\t\t\t\t\tRelationRelationId);\n\t\tload_critical_index(AttributeRelidNumIndexId,\n\t\t\t\t\t\t\tAttributeRelationId);\n\t\tload_critical_index(IndexRelidIndexId,\n\t\t\t\t\t\t\tIndexRelationId);\n\t\tload_critical_index(OpclassOidIndexId,\n\t\t\t\t\t\t\tOperatorClassRelationId);\n\t\tload_critical_index(AccessMethodProcedureIndexId,\n\t\t\t\t\t\t\tAccessMethodProcedureRelationId);\n\t\tload_critical_index(RewriteRelRulenameIndexId,\n\t\t\t\t\t\t\tRewriteRelationId);\n\t\tload_critical_index(TriggerRelidNameIndexId,\n\t\t\t\t\t\t\tTriggerRelationId);\n\n#define NUM_CRITICAL_LOCAL_INDEXES\t7\t/* fix if you change list above */\n\n\t\tcriticalRelcachesBuilt = true;\n\t}\n\n\t/*\n\t * Process critical shared indexes too.\n\t *\n\t * DatabaseNameIndexId isn't critical for relcache loading, but rather for\n\t * initial lookup of MyDatabaseId, without which we'll never find any\n\t * non-shared catalogs at all.  Autovacuum calls InitPostgres with a\n\t * database OID, so it instead depends on DatabaseOidIndexId.  We also\n\t * need to nail up some indexes on pg_authid and pg_auth_members for use\n\t * during client authentication.  SharedSecLabelObjectIndexId isn't\n\t * critical for the core system, but authentication hooks might be\n\t * interested in it.\n\t */\n\tif (!criticalSharedRelcachesBuilt)\n\t{\n\t\tload_critical_index(DatabaseNameIndexId,\n\t\t\t\t\t\t\tDatabaseRelationId);\n\t\tload_critical_index(DatabaseOidIndexId,\n\t\t\t\t\t\t\tDatabaseRelationId);\n\t\tload_critical_index(AuthIdRolnameIndexId,\n\t\t\t\t\t\t\tAuthIdRelationId);\n\t\tload_critical_index(AuthIdOidIndexId,\n\t\t\t\t\t\t\tAuthIdRelationId);\n\t\tload_critical_index(AuthMemMemRoleIndexId,\n\t\t\t\t\t\t\tAuthMemRelationId);\n\t\tload_critical_index(SharedSecLabelObjectIndexId,\n\t\t\t\t\t\t\tSharedSecLabelRelationId);\n\n#define NUM_CRITICAL_SHARED_INDEXES 6\t/* fix if you change list above */\n\n\t\tcriticalSharedRelcachesBuilt = true;\n\t}\n\n\t/*\n\t * Now, scan all the relcache entries and update anything that might be\n\t * wrong in the results from formrdesc or the relcache cache file. If we\n\t * faked up relcache entries using formrdesc, then read the real pg_class\n\t * rows and replace the fake entries with them. Also, if any of the\n\t * relcache entries have rules, triggers, or security policies, load that\n\t * info the hard way since it isn't recorded in the cache file.\n\t *\n\t * Whenever we access the catalogs to read data, there is a possibility of\n\t * a shared-inval cache flush causing relcache entries to be removed.\n\t * Since hash_seq_search only guarantees to still work after the *current*\n\t * entry is removed, it's unsafe to continue the hashtable scan afterward.\n\t * We handle this by restarting the scan from scratch after each access.\n\t * This is theoretically O(N^2), but the number of entries that actually\n\t * need to be fixed is small enough that it doesn't matter.\n\t */\n\thash_seq_init(&status, RelationIdCache);\n\n\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tRelation\trelation = idhentry->reldesc;\n\t\tbool\t\trestart = false;\n\n\t\t/*\n\t\t * Make sure *this* entry doesn't get flushed while we work with it.\n\t\t */\n\t\tRelationIncrementReferenceCount(relation);\n\n\t\t/*\n\t\t * If it's a faked-up entry, read the real pg_class tuple.\n\t\t */\n\t\tif (relation->rd_rel->relowner == InvalidOid)\n\t\t{\n\t\t\tHeapTuple\thtup;\n\t\t\tForm_pg_class relp;\n\n\t\t\thtup = SearchSysCache1(RELOID,\n\t\t\t\t\t\t\t\t   ObjectIdGetDatum(RelationGetRelid(relation)));\n\t\t\tif (!HeapTupleIsValid(htup))\n\t\t\t\telog(FATAL, \"cache lookup failed for relation %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\trelp = (Form_pg_class) GETSTRUCT(htup);\n\n\t\t\t/*\n\t\t\t * Copy tuple to relation->rd_rel. (See notes in\n\t\t\t * AllocateRelationDesc())\n\t\t\t */\n\t\t\tmemcpy((char *) relation->rd_rel, (char *) relp, CLASS_TUPLE_SIZE);\n\n\t\t\t/* Update rd_options while we have the tuple */\n\t\t\tif (relation->rd_options)\n\t\t\t\tpfree(relation->rd_options);\n\t\t\tRelationParseRelOptions(relation, htup);\n\n\t\t\t/*\n\t\t\t * Check the values in rd_att were set up correctly.  (We cannot\n\t\t\t * just copy them over now: formrdesc must have set up the rd_att\n\t\t\t * data correctly to start with, because it may already have been\n\t\t\t * copied into one or more catcache entries.)\n\t\t\t */\n\t\t\tAssert(relation->rd_att->tdtypeid == relp->reltype);\n\t\t\tAssert(relation->rd_att->tdtypmod == -1);\n\t\t\tAssert(relation->rd_att->tdhasoid == relp->relhasoids);\n\n\t\t\tReleaseSysCache(htup);\n\n\t\t\t/* relowner had better be OK now, else we'll loop forever */\n\t\t\tif (relation->rd_rel->relowner == InvalidOid)\n\t\t\t\telog(ERROR, \"invalid relowner in pg_class entry for \\\"%s\\\"\",\n\t\t\t\t\t RelationGetRelationName(relation));\n\n\t\t\trestart = true;\n\t\t}\n\n\t\t/*\n\t\t * Fix data that isn't saved in relcache cache file.\n\t\t *\n\t\t * relhasrules or relhastriggers could possibly be wrong or out of\n\t\t * date.  If we don't actually find any rules or triggers, clear the\n\t\t * local copy of the flag so that we don't get into an infinite loop\n\t\t * here.  We don't make any attempt to fix the pg_class entry, though.\n\t\t */\n\t\tif (relation->rd_rel->relhasrules && relation->rd_rules == NULL)\n\t\t{\n\t\t\tRelationBuildRuleLock(relation);\n\t\t\tif (relation->rd_rules == NULL)\n\t\t\t\trelation->rd_rel->relhasrules = false;\n\t\t\trestart = true;\n\t\t}\n\t\tif (relation->rd_rel->relhastriggers && relation->trigdesc == NULL)\n\t\t{\n\t\t\tRelationBuildTriggers(relation);\n\t\t\tif (relation->trigdesc == NULL)\n\t\t\t\trelation->rd_rel->relhastriggers = false;\n\t\t\trestart = true;\n\t\t}\n\n\t\t/*\n\t\t * Re-load the row security policies if the relation has them, since\n\t\t * they are not preserved in the cache.  Note that we can never NOT\n\t\t * have a policy while relrowsecurity is true,\n\t\t * RelationBuildRowSecurity will create a single default-deny policy\n\t\t * if there is no policy defined in pg_policy.\n\t\t */\n\t\tif (relation->rd_rel->relrowsecurity && relation->rd_rsdesc == NULL)\n\t\t{\n\t\t\tRelationBuildRowSecurity(relation);\n\n\t\t\tAssert(relation->rd_rsdesc != NULL);\n\t\t\trestart = true;\n\t\t}\n\n\t\t/*\n\t\t * Reload the partition key and descriptor for a partitioned table.\n\t\t */\n\t\tif (relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE &&\n\t\t\trelation->rd_partkey == NULL)\n\t\t{\n\t\t\tRelationBuildPartitionKey(relation);\n\t\t\tAssert(relation->rd_partkey != NULL);\n\n\t\t\trestart = true;\n\t\t}\n\n\t\tif (relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE &&\n\t\t\trelation->rd_partdesc == NULL)\n\t\t{\n\t\t\tRelationBuildPartitionDesc(relation);\n\t\t\tAssert(relation->rd_partdesc != NULL);\n\n\t\t\trestart = true;\n\t\t}\n\n\t\t/* Release hold on the relation */\n\t\tRelationDecrementReferenceCount(relation);\n\n\t\t/* Now, restart the hashtable scan if needed */\n\t\tif (restart)\n\t\t{\n\t\t\thash_seq_term(&status);\n\t\t\thash_seq_init(&status, RelationIdCache);\n\t\t}\n\t}\n\n\t/*\n\t * Lastly, write out new relcache cache files if needed.  We don't bother\n\t * to distinguish cases where only one of the two needs an update.\n\t */\n\tif (needNewCacheFile)\n\t{\n\t\t/*\n\t\t * Force all the catcaches to finish initializing and thereby open the\n\t\t * catalogs and indexes they use.  This will preload the relcache with\n\t\t * entries for all the most important system catalogs and indexes, so\n\t\t * that the init files will be most useful for future backends.\n\t\t */\n\t\tInitCatalogCachePhase2();\n\n\t\t/* now write the files */\n\t\twrite_relcache_init_file(true);\n\t\twrite_relcache_init_file(false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetDatabasePath",
          "args": [
            "fullpath"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "SetDatabasePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "83-89",
          "snippet": "void\nSetDatabasePath(const char *path)\n{\n\t/* This should happen only once per process */\n\tAssert(!DatabasePath);\n\tDatabasePath = MemoryContextStrdup(TopMemoryContext, path);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nvoid\nSetDatabasePath(const char *path)\n{\n\t/* This should happen only once per process */\n\tAssert(!DatabasePath);\n\tDatabasePath = MemoryContextStrdup(TopMemoryContext, path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ValidatePgVersion",
          "args": [
            "fullpath"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "ValidatePgVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "1453-1506",
          "snippet": "void\nValidatePgVersion(const char *path)\n{\n\tchar\t\tfull_path[MAXPGPATH];\n\tFILE\t   *file;\n\tint\t\t\tret;\n\tlong\t\tfile_major;\n\tlong\t\tmy_major;\n\tchar\t   *endptr;\n\tchar\t\tfile_version_string[64];\n\tconst char *my_version_string = PG_VERSION;\n\n\tmy_major = strtol(my_version_string, &endptr, 10);\n\n\tsnprintf(full_path, sizeof(full_path), \"%s/PG_VERSION\", path);\n\n\tfile = AllocateFile(full_path, \"r\");\n\tif (!file)\n\t{\n\t\tif (errno == ENOENT)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"\\\"%s\\\" is not a valid data directory\",\n\t\t\t\t\t\t\tpath),\n\t\t\t\t\t errdetail(\"File \\\"%s\\\" is missing.\", full_path)));\n\t\telse\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", full_path)));\n\t}\n\n\tfile_version_string[0] = '\\0';\n\tret = fscanf(file, \"%63s\", file_version_string);\n\tfile_major = strtol(file_version_string, &endptr, 10);\n\n\tif (ret != 1 || endptr == file_version_string)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"\\\"%s\\\" is not a valid data directory\",\n\t\t\t\t\t\tpath),\n\t\t\t\t errdetail(\"File \\\"%s\\\" does not contain valid data.\",\n\t\t\t\t\t\t   full_path),\n\t\t\t\t errhint(\"You might need to initdb.\")));\n\n\tFreeFile(file);\n\n\tif (my_major != file_major)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"database files are incompatible with server\"),\n\t\t\t\t errdetail(\"The data directory was initialized by PostgreSQL version %s, \"\n\t\t\t\t\t\t   \"which is not compatible with this version %s.\",\n\t\t\t\t\t\t   file_version_string, my_version_string)));\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nvoid\nValidatePgVersion(const char *path)\n{\n\tchar\t\tfull_path[MAXPGPATH];\n\tFILE\t   *file;\n\tint\t\t\tret;\n\tlong\t\tfile_major;\n\tlong\t\tmy_major;\n\tchar\t   *endptr;\n\tchar\t\tfile_version_string[64];\n\tconst char *my_version_string = PG_VERSION;\n\n\tmy_major = strtol(my_version_string, &endptr, 10);\n\n\tsnprintf(full_path, sizeof(full_path), \"%s/PG_VERSION\", path);\n\n\tfile = AllocateFile(full_path, \"r\");\n\tif (!file)\n\t{\n\t\tif (errno == ENOENT)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"\\\"%s\\\" is not a valid data directory\",\n\t\t\t\t\t\t\tpath),\n\t\t\t\t\t errdetail(\"File \\\"%s\\\" is missing.\", full_path)));\n\t\telse\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", full_path)));\n\t}\n\n\tfile_version_string[0] = '\\0';\n\tret = fscanf(file, \"%63s\", file_version_string);\n\tfile_major = strtol(file_version_string, &endptr, 10);\n\n\tif (ret != 1 || endptr == file_version_string)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"\\\"%s\\\" is not a valid data directory\",\n\t\t\t\t\t\tpath),\n\t\t\t\t errdetail(\"File \\\"%s\\\" does not contain valid data.\",\n\t\t\t\t\t\t   full_path),\n\t\t\t\t errhint(\"You might need to initdb.\")));\n\n\tFreeFile(file);\n\n\tif (my_major != file_major)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"database files are incompatible with server\"),\n\t\t\t\t errdetail(\"The data directory was initialized by PostgreSQL version %s, \"\n\t\t\t\t\t\t   \"which is not compatible with this version %s.\",\n\t\t\t\t\t\t   file_version_string, my_version_string)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not access directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\tfullpath))"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not access directory \\\"%s\\\": %m\"",
            "fullpath"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t\t\t errmsg(\"database \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\t\tdbname),\n\t\t\t\t\t\t errdetail(\"The database subdirectory \\\"%s\\\" is missing.\",\n\t\t\t\t\t\t\t\t   fullpath))"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"The database subdirectory \\\"%s\\\" is missing.\"",
            "fullpath"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_DATABASE"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "fullpath",
            "F_OK"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDatabasePath",
          "args": [
            "MyDatabaseId",
            "MyDatabaseTableSpace"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t\t errmsg(\"database \\\"%s\\\" does not exist\", dbname),\n\t\t\t\t\t errdetail(\"It seems to have just been dropped or renamed.\"))"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "tuple"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDatabaseTuple",
          "args": [
            "dbname"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseTupleByOid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
          "lines": "137-175",
          "snippet": "static HeapTuple\nGetDatabaseTupleByOid(Oid dboid)\n{\n\tHeapTuple\ttuple;\n\tRelation\trelation;\n\tSysScanDesc scan;\n\tScanKeyData key[1];\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(dboid));\n\n\t/*\n\t * Open pg_database and fetch a tuple.  Force heap scan if we haven't yet\n\t * built the critical shared relcache entries (i.e., we're starting up\n\t * without a shared relcache cache file).\n\t */\n\trelation = heap_open(DatabaseRelationId, AccessShareLock);\n\tscan = systable_beginscan(relation, DatabaseOidIndexId,\n\t\t\t\t\t\t\t  criticalSharedRelcachesBuilt,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  1, key);\n\n\ttuple = systable_getnext(scan);\n\n\t/* Must copy tuple before releasing buffer */\n\tif (HeapTupleIsValid(tuple))\n\t\ttuple = heap_copytuple(tuple);\n\n\t/* all done */\n\tsystable_endscan(scan);\n\theap_close(relation, AccessShareLock);\n\n\treturn tuple;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/procsignal.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/session.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HeapTuple GetDatabaseTupleByOid(Oid dboid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic HeapTuple GetDatabaseTupleByOid(Oid dboid);\n\nstatic HeapTuple\nGetDatabaseTupleByOid(Oid dboid)\n{\n\tHeapTuple\ttuple;\n\tRelation\trelation;\n\tSysScanDesc scan;\n\tScanKeyData key[1];\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(dboid));\n\n\t/*\n\t * Open pg_database and fetch a tuple.  Force heap scan if we haven't yet\n\t * built the critical shared relcache entries (i.e., we're starting up\n\t * without a shared relcache cache file).\n\t */\n\trelation = heap_open(DatabaseRelationId, AccessShareLock);\n\tscan = systable_beginscan(relation, DatabaseOidIndexId,\n\t\t\t\t\t\t\t  criticalSharedRelcachesBuilt,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  1, key);\n\n\ttuple = systable_getnext(scan);\n\n\t/* Must copy tuple before releasing buffer */\n\tif (HeapTupleIsValid(tuple))\n\t\ttuple = heap_copytuple(tuple);\n\n\t/* all done */\n\tsystable_endscan(scan);\n\theap_close(relation, AccessShareLock);\n\n\treturn tuple;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidateCatalogSnapshot",
          "args": [],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "InvalidateCatalogSnapshotConditionally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "530-537",
          "snippet": "void\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CatalogSnapshot = NULL;",
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CatalogSnapshot = NULL;\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\n\nvoid\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}"
        }
      },
      {
        "call_info": {
          "callee": "LockSharedObject",
          "args": [
            "DatabaseRelationId",
            "MyDatabaseId",
            "0",
            "RowExclusiveLock"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CommitTransactionCommand",
          "args": [],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_bestart",
          "args": [],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "out_dbname",
            "dbname"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "dbname",
            "NameStr(dbform->datname)",
            "sizeof(dbname)"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_safe_strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ascii.c",
          "lines": "172-198",
          "snippet": "void\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/ascii.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/ascii.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "dbform->datname"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "MyDatabaseId == dboid"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "tuple"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t\t errmsg(\"database %u does not exist\", dboid))"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "dboid"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "tuple"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t\t errmsg(\"database \\\"%s\\\" does not exist\", in_dbname))"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CommitTransactionCommand",
          "args": [],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_bestart",
          "args": [],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_usleep",
          "args": [
            "PostAuthDelay * 1000000L"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"must be superuser or replication role to start walsender\"))"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_rolreplication",
          "args": [
            "GetUserId()"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "has_rolreplication",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "567-580",
          "snippet": "bool\nhas_rolreplication(Oid roleid)\n{\n\tbool\t\tresult = false;\n\tHeapTuple\tutup;\n\n\tutup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\tif (HeapTupleIsValid(utup))\n\t{\n\t\tresult = ((Form_pg_authid) GETSTRUCT(utup))->rolreplication;\n\t\tReleaseSysCache(utup);\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nbool\nhas_rolreplication(Oid roleid)\n{\n\tbool\t\tresult = false;\n\tHeapTuple\tutup;\n\n\tutup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\tif (HeapTupleIsValid(utup))\n\t{\n\t\tresult = ((Form_pg_authid) GETSTRUCT(utup))->rolreplication;\n\t\tReleaseSysCache(utup);\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "superuser",
          "args": [],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "superuser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/superuser.c",
          "lines": "46-50",
          "snippet": "bool\nsuperuser(void)\n{\n\treturn superuser_arg(GetUserId());\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/syscache.h\"\n#include \"utils/inval.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nsuperuser(void)\n{\n\treturn superuser_arg(GetUserId());\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!bootstrap"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t errmsg(\"remaining connection slots are reserved for non-replication superuser connections\"))"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HaveNFreeProcs",
          "args": [
            "ReservedBackends"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"must be superuser to connect in binary upgrade mode\"))"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"must be superuser to connect during database shutdown\"))"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"new replication connections are not allowed during database shutdown\"))"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitializeSessionUserId",
          "args": [
            "username",
            "useroid"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "InitializeSessionUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "585-675",
          "snippet": "void\nInitializeSessionUserId(const char *rolename, Oid roleid)\n{\n\tHeapTuple\troleTup;\n\tForm_pg_authid rform;\n\tchar\t   *rname;\n\n\t/*\n\t * Don't do scans if we're bootstrapping, none of the system catalogs\n\t * exist yet, and they should be owned by postgres anyway.\n\t */\n\tAssertState(!IsBootstrapProcessingMode());\n\n\t/* call only once */\n\tAssertState(!OidIsValid(AuthenticatedUserId));\n\n\tif (rolename != NULL)\n\t{\n\t\troleTup = SearchSysCache1(AUTHNAME, PointerGetDatum(rolename));\n\t\tif (!HeapTupleIsValid(roleTup))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t\t errmsg(\"role \\\"%s\\\" does not exist\", rolename)));\n\t}\n\telse\n\t{\n\t\troleTup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\t\tif (!HeapTupleIsValid(roleTup))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t\t errmsg(\"role with OID %u does not exist\", roleid)));\n\t}\n\n\trform = (Form_pg_authid) GETSTRUCT(roleTup);\n\troleid = HeapTupleGetOid(roleTup);\n\trname = NameStr(rform->rolname);\n\n\tAuthenticatedUserId = roleid;\n\tAuthenticatedUserIsSuperuser = rform->rolsuper;\n\n\t/* This sets OuterUserId/CurrentUserId too */\n\tSetSessionUserId(roleid, AuthenticatedUserIsSuperuser);\n\n\t/* Also mark our PGPROC entry with the authenticated user id */\n\t/* (We assume this is an atomic store so no lock is needed) */\n\tMyProc->roleId = roleid;\n\n\t/*\n\t * These next checks are not enforced when in standalone mode, so that\n\t * there is a way to recover from sillinesses like \"UPDATE pg_authid SET\n\t * rolcanlogin = false;\".\n\t */\n\tif (IsUnderPostmaster)\n\t{\n\t\t/*\n\t\t * Is role allowed to login at all?\n\t\t */\n\t\tif (!rform->rolcanlogin)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t\t errmsg(\"role \\\"%s\\\" is not permitted to log in\",\n\t\t\t\t\t\t\trname)));\n\n\t\t/*\n\t\t * Check connection limit for this role.\n\t\t *\n\t\t * There is a race condition here --- we create our PGPROC before\n\t\t * checking for other PGPROCs.  If two backends did this at about the\n\t\t * same time, they might both think they were over the limit, while\n\t\t * ideally one should succeed and one fail.  Getting that to work\n\t\t * exactly seems more trouble than it is worth, however; instead we\n\t\t * just document that the connection limit is approximate.\n\t\t */\n\t\tif (rform->rolconnlimit >= 0 &&\n\t\t\t!AuthenticatedUserIsSuperuser &&\n\t\t\tCountUserBackends(roleid) > rform->rolconnlimit)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"too many connections for role \\\"%s\\\"\",\n\t\t\t\t\t\t\trname)));\n\t}\n\n\t/* Record username and superuser status as GUC settings too */\n\tSetConfigOption(\"session_authorization\", rname,\n\t\t\t\t\tPGC_BACKEND, PGC_S_OVERRIDE);\n\tSetConfigOption(\"is_superuser\",\n\t\t\t\t\tAuthenticatedUserIsSuperuser ? \"on\" : \"off\",\n\t\t\t\t\tPGC_INTERNAL, PGC_S_OVERRIDE);\n\n\tReleaseSysCache(roleTup);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tAuthenticatedUserId = InvalidOid;",
            "static Oid\tOuterUserId = InvalidOid;",
            "static Oid\tCurrentUserId = InvalidOid;",
            "static bool AuthenticatedUserIsSuperuser = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tAuthenticatedUserId = InvalidOid;\nstatic Oid\tOuterUserId = InvalidOid;\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic bool AuthenticatedUserIsSuperuser = false;\n\nvoid\nInitializeSessionUserId(const char *rolename, Oid roleid)\n{\n\tHeapTuple\troleTup;\n\tForm_pg_authid rform;\n\tchar\t   *rname;\n\n\t/*\n\t * Don't do scans if we're bootstrapping, none of the system catalogs\n\t * exist yet, and they should be owned by postgres anyway.\n\t */\n\tAssertState(!IsBootstrapProcessingMode());\n\n\t/* call only once */\n\tAssertState(!OidIsValid(AuthenticatedUserId));\n\n\tif (rolename != NULL)\n\t{\n\t\troleTup = SearchSysCache1(AUTHNAME, PointerGetDatum(rolename));\n\t\tif (!HeapTupleIsValid(roleTup))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t\t errmsg(\"role \\\"%s\\\" does not exist\", rolename)));\n\t}\n\telse\n\t{\n\t\troleTup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\t\tif (!HeapTupleIsValid(roleTup))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t\t errmsg(\"role with OID %u does not exist\", roleid)));\n\t}\n\n\trform = (Form_pg_authid) GETSTRUCT(roleTup);\n\troleid = HeapTupleGetOid(roleTup);\n\trname = NameStr(rform->rolname);\n\n\tAuthenticatedUserId = roleid;\n\tAuthenticatedUserIsSuperuser = rform->rolsuper;\n\n\t/* This sets OuterUserId/CurrentUserId too */\n\tSetSessionUserId(roleid, AuthenticatedUserIsSuperuser);\n\n\t/* Also mark our PGPROC entry with the authenticated user id */\n\t/* (We assume this is an atomic store so no lock is needed) */\n\tMyProc->roleId = roleid;\n\n\t/*\n\t * These next checks are not enforced when in standalone mode, so that\n\t * there is a way to recover from sillinesses like \"UPDATE pg_authid SET\n\t * rolcanlogin = false;\".\n\t */\n\tif (IsUnderPostmaster)\n\t{\n\t\t/*\n\t\t * Is role allowed to login at all?\n\t\t */\n\t\tif (!rform->rolcanlogin)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t\t errmsg(\"role \\\"%s\\\" is not permitted to log in\",\n\t\t\t\t\t\t\trname)));\n\n\t\t/*\n\t\t * Check connection limit for this role.\n\t\t *\n\t\t * There is a race condition here --- we create our PGPROC before\n\t\t * checking for other PGPROCs.  If two backends did this at about the\n\t\t * same time, they might both think they were over the limit, while\n\t\t * ideally one should succeed and one fail.  Getting that to work\n\t\t * exactly seems more trouble than it is worth, however; instead we\n\t\t * just document that the connection limit is approximate.\n\t\t */\n\t\tif (rform->rolconnlimit >= 0 &&\n\t\t\t!AuthenticatedUserIsSuperuser &&\n\t\t\tCountUserBackends(roleid) > rform->rolconnlimit)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"too many connections for role \\\"%s\\\"\",\n\t\t\t\t\t\t\trname)));\n\t}\n\n\t/* Record username and superuser status as GUC settings too */\n\tSetConfigOption(\"session_authorization\", rname,\n\t\t\t\t\tPGC_BACKEND, PGC_S_OVERRIDE);\n\tSetConfigOption(\"is_superuser\",\n\t\t\t\t\tAuthenticatedUserIsSuperuser ? \"on\" : \"off\",\n\t\t\t\t\tPGC_INTERNAL, PGC_S_OVERRIDE);\n\n\tReleaseSysCache(roleTup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PerformAuthentication",
          "args": [
            "MyProcPort"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "PerformAuthentication",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
          "lines": "183-286",
          "snippet": "static void\nPerformAuthentication(Port *port)\n{\n\t/* This should be set already, but let's make sure */\n\tClientAuthInProgress = true;\t/* limit visibility of log messages */\n\n\t/*\n\t * In EXEC_BACKEND case, we didn't inherit the contents of pg_hba.conf\n\t * etcetera from the postmaster, and have to load them ourselves.\n\t *\n\t * FIXME: [fork/exec] Ugh.  Is there a way around this overhead?\n\t */\n#ifdef EXEC_BACKEND\n\n\t/*\n\t * load_hba() and load_ident() want to work within the PostmasterContext,\n\t * so create that if it doesn't exist (which it won't).  We'll delete it\n\t * again later, in PostgresMain.\n\t */\n\tif (PostmasterContext == NULL)\n\t\tPostmasterContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"Postmaster\",\n\t\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\n\tif (!load_hba())\n\t{\n\t\t/*\n\t\t * It makes no sense to continue if we fail to load the HBA file,\n\t\t * since there is no way to connect to the database in this case.\n\t\t */\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"could not load pg_hba.conf\")));\n\t}\n\n\tif (!load_ident())\n\t{\n\t\t/*\n\t\t * It is ok to continue if we fail to load the IDENT file, although it\n\t\t * means that you cannot log in using any of the authentication\n\t\t * methods that need a user name mapping. load_ident() already logged\n\t\t * the details of error to the log.\n\t\t */\n\t}\n#endif\n\n\t/*\n\t * Set up a timeout in case a buggy or malicious client fails to respond\n\t * during authentication.  Since we're inside a transaction and might do\n\t * database access, we have to use the statement_timeout infrastructure.\n\t */\n\tenable_timeout_after(STATEMENT_TIMEOUT, AuthenticationTimeout * 1000);\n\n\t/*\n\t * Now perform authentication exchange.\n\t */\n\tClientAuthentication(port); /* might not return, if failure */\n\n\t/*\n\t * Done with authentication.  Disable the timeout, and log if needed.\n\t */\n\tdisable_timeout(STATEMENT_TIMEOUT, false);\n\n\tif (Log_connections)\n\t{\n\t\tif (am_walsender)\n\t\t{\n#ifdef USE_SSL\n\t\t\tif (port->ssl_in_use)\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"replication connection authorized: user=%s SSL enabled (protocol=%s, cipher=%s, bits=%d, compression=%s)\",\n\t\t\t\t\t\t\t\tport->user_name,\n\t\t\t\t\t\t\t\tbe_tls_get_version(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher_bits(port),\n\t\t\t\t\t\t\t\tbe_tls_get_compression(port) ? _(\"on\") : _(\"off\"))));\n\t\t\telse\n#endif\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"replication connection authorized: user=%s\",\n\t\t\t\t\t\t\t\tport->user_name)));\n\t\t}\n\t\telse\n\t\t{\n#ifdef USE_SSL\n\t\t\tif (port->ssl_in_use)\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"connection authorized: user=%s database=%s SSL enabled (protocol=%s, cipher=%s, bits=%d, compression=%s)\",\n\t\t\t\t\t\t\t\tport->user_name, port->database_name,\n\t\t\t\t\t\t\t\tbe_tls_get_version(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher_bits(port),\n\t\t\t\t\t\t\t\tbe_tls_get_compression(port) ? _(\"on\") : _(\"off\"))));\n\t\t\telse\n#endif\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"connection authorized: user=%s database=%s\",\n\t\t\t\t\t\t\t\tport->user_name, port->database_name)));\n\t\t}\n\t}\n\n\tset_ps_display(\"startup\", false);\n\n\tClientAuthInProgress = false;\t/* client_min_messages is active now */\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/procsignal.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/session.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PerformAuthentication(Port *port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void PerformAuthentication(Port *port);\n\nstatic void\nPerformAuthentication(Port *port)\n{\n\t/* This should be set already, but let's make sure */\n\tClientAuthInProgress = true;\t/* limit visibility of log messages */\n\n\t/*\n\t * In EXEC_BACKEND case, we didn't inherit the contents of pg_hba.conf\n\t * etcetera from the postmaster, and have to load them ourselves.\n\t *\n\t * FIXME: [fork/exec] Ugh.  Is there a way around this overhead?\n\t */\n#ifdef EXEC_BACKEND\n\n\t/*\n\t * load_hba() and load_ident() want to work within the PostmasterContext,\n\t * so create that if it doesn't exist (which it won't).  We'll delete it\n\t * again later, in PostgresMain.\n\t */\n\tif (PostmasterContext == NULL)\n\t\tPostmasterContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"Postmaster\",\n\t\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\n\tif (!load_hba())\n\t{\n\t\t/*\n\t\t * It makes no sense to continue if we fail to load the HBA file,\n\t\t * since there is no way to connect to the database in this case.\n\t\t */\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"could not load pg_hba.conf\")));\n\t}\n\n\tif (!load_ident())\n\t{\n\t\t/*\n\t\t * It is ok to continue if we fail to load the IDENT file, although it\n\t\t * means that you cannot log in using any of the authentication\n\t\t * methods that need a user name mapping. load_ident() already logged\n\t\t * the details of error to the log.\n\t\t */\n\t}\n#endif\n\n\t/*\n\t * Set up a timeout in case a buggy or malicious client fails to respond\n\t * during authentication.  Since we're inside a transaction and might do\n\t * database access, we have to use the statement_timeout infrastructure.\n\t */\n\tenable_timeout_after(STATEMENT_TIMEOUT, AuthenticationTimeout * 1000);\n\n\t/*\n\t * Now perform authentication exchange.\n\t */\n\tClientAuthentication(port); /* might not return, if failure */\n\n\t/*\n\t * Done with authentication.  Disable the timeout, and log if needed.\n\t */\n\tdisable_timeout(STATEMENT_TIMEOUT, false);\n\n\tif (Log_connections)\n\t{\n\t\tif (am_walsender)\n\t\t{\n#ifdef USE_SSL\n\t\t\tif (port->ssl_in_use)\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"replication connection authorized: user=%s SSL enabled (protocol=%s, cipher=%s, bits=%d, compression=%s)\",\n\t\t\t\t\t\t\t\tport->user_name,\n\t\t\t\t\t\t\t\tbe_tls_get_version(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher_bits(port),\n\t\t\t\t\t\t\t\tbe_tls_get_compression(port) ? _(\"on\") : _(\"off\"))));\n\t\t\telse\n#endif\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"replication connection authorized: user=%s\",\n\t\t\t\t\t\t\t\tport->user_name)));\n\t\t}\n\t\telse\n\t\t{\n#ifdef USE_SSL\n\t\t\tif (port->ssl_in_use)\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"connection authorized: user=%s database=%s SSL enabled (protocol=%s, cipher=%s, bits=%d, compression=%s)\",\n\t\t\t\t\t\t\t\tport->user_name, port->database_name,\n\t\t\t\t\t\t\t\tbe_tls_get_version(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher_bits(port),\n\t\t\t\t\t\t\t\tbe_tls_get_compression(port) ? _(\"on\") : _(\"off\"))));\n\t\t\telse\n#endif\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"connection authorized: user=%s database=%s\",\n\t\t\t\t\t\t\t\tport->user_name, port->database_name)));\n\t\t}\n\t}\n\n\tset_ps_display(\"startup\", false);\n\n\tClientAuthInProgress = false;\t/* client_min_messages is active now */\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "MyProcPort != NULL"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "useroid"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "WARNING",
            "(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"no roles are defined in this database system\"),\n\t\t\t\t\t errhint(\"You should immediately run CREATE USER \\\"%s\\\" SUPERUSER;.\",\n\t\t\t\t\t\t\t username != NULL ? username : \"postgres\"))"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"You should immediately run CREATE USER \\\"%s\\\" SUPERUSER;.\"",
            "username != NULL ? username : \"postgres\""
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThereIsAtLeastOneRole",
          "args": [],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "ThereIsAtLeastOneRole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
          "lines": "1214-1230",
          "snippet": "static bool\nThereIsAtLeastOneRole(void)\n{\n\tRelation\tpg_authid_rel;\n\tHeapScanDesc scan;\n\tbool\t\tresult;\n\n\tpg_authid_rel = heap_open(AuthIdRelationId, AccessShareLock);\n\n\tscan = heap_beginscan_catalog(pg_authid_rel, 0, NULL);\n\tresult = (heap_getnext(scan, ForwardScanDirection) != NULL);\n\n\theap_endscan(scan);\n\theap_close(pg_authid_rel, AccessShareLock);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/procsignal.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/session.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ThereIsAtLeastOneRole(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool ThereIsAtLeastOneRole(void);\n\nstatic bool\nThereIsAtLeastOneRole(void)\n{\n\tRelation\tpg_authid_rel;\n\tHeapScanDesc scan;\n\tbool\t\tresult;\n\n\tpg_authid_rel = heap_open(AuthIdRelationId, AccessShareLock);\n\n\tscan = heap_beginscan_catalog(pg_authid_rel, 0, NULL);\n\tresult = (heap_getnext(scan, ForwardScanDirection) != NULL);\n\n\theap_endscan(scan);\n\theap_close(pg_authid_rel, AccessShareLock);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsAutoVacuumWorkerProcess",
          "args": [],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTransactionSnapshot",
          "args": [],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "GetTransactionSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "303-371",
          "snippet": "Snapshot\nGetTransactionSnapshot(void)\n{\n\t/*\n\t * Return historic snapshot if doing logical decoding. We'll never need a\n\t * non-historic transaction snapshot in this (sub-)transaction, so there's\n\t * no need to be careful to set one up for later calls to\n\t * GetTransactionSnapshot().\n\t */\n\tif (HistoricSnapshotActive())\n\t{\n\t\tAssert(!FirstSnapshotSet);\n\t\treturn HistoricSnapshot;\n\t}\n\n\t/* First call in transaction? */\n\tif (!FirstSnapshotSet)\n\t{\n\t\t/*\n\t\t * Don't allow catalog snapshot to be older than xact snapshot.  Must\n\t\t * do this first to allow the empty-heap Assert to succeed.\n\t\t */\n\t\tInvalidateCatalogSnapshot();\n\n\t\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\t\tAssert(FirstXactSnapshot == NULL);\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR,\n\t\t\t\t \"cannot take query snapshot during a parallel operation\");\n\n\t\t/*\n\t\t * In transaction-snapshot mode, the first snapshot must live until\n\t\t * end of xact regardless of what the caller does with it, so we must\n\t\t * make a copy of it rather than returning CurrentSnapshotData\n\t\t * directly.  Furthermore, if we're running in serializable mode,\n\t\t * predicate.c needs to wrap the snapshot fetch in its own processing.\n\t\t */\n\t\tif (IsolationUsesXactSnapshot())\n\t\t{\n\t\t\t/* First, create the snapshot in CurrentSnapshotData */\n\t\t\tif (IsolationIsSerializable())\n\t\t\t\tCurrentSnapshot = GetSerializableTransactionSnapshot(&CurrentSnapshotData);\n\t\t\telse\n\t\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\t\t\t/* Make a saved copy */\n\t\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\t\tFirstXactSnapshot->regd_count++;\n\t\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t\t}\n\t\telse\n\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t\tFirstSnapshotSet = true;\n\t\treturn CurrentSnapshot;\n\t}\n\n\tif (IsolationUsesXactSnapshot())\n\t\treturn CurrentSnapshot;\n\n\t/* Don't allow catalog snapshot to be older than xact snapshot. */\n\tInvalidateCatalogSnapshot();\n\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\treturn CurrentSnapshot;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};",
            "static Snapshot CurrentSnapshot = NULL;",
            "static Snapshot HistoricSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "bool\t\tFirstSnapshotSet = false;",
            "static Snapshot FirstXactSnapshot = NULL;",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};\nstatic Snapshot CurrentSnapshot = NULL;\nstatic Snapshot HistoricSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nbool\t\tFirstSnapshotSet = false;\nstatic Snapshot FirstXactSnapshot = NULL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nGetTransactionSnapshot(void)\n{\n\t/*\n\t * Return historic snapshot if doing logical decoding. We'll never need a\n\t * non-historic transaction snapshot in this (sub-)transaction, so there's\n\t * no need to be careful to set one up for later calls to\n\t * GetTransactionSnapshot().\n\t */\n\tif (HistoricSnapshotActive())\n\t{\n\t\tAssert(!FirstSnapshotSet);\n\t\treturn HistoricSnapshot;\n\t}\n\n\t/* First call in transaction? */\n\tif (!FirstSnapshotSet)\n\t{\n\t\t/*\n\t\t * Don't allow catalog snapshot to be older than xact snapshot.  Must\n\t\t * do this first to allow the empty-heap Assert to succeed.\n\t\t */\n\t\tInvalidateCatalogSnapshot();\n\n\t\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\t\tAssert(FirstXactSnapshot == NULL);\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR,\n\t\t\t\t \"cannot take query snapshot during a parallel operation\");\n\n\t\t/*\n\t\t * In transaction-snapshot mode, the first snapshot must live until\n\t\t * end of xact regardless of what the caller does with it, so we must\n\t\t * make a copy of it rather than returning CurrentSnapshotData\n\t\t * directly.  Furthermore, if we're running in serializable mode,\n\t\t * predicate.c needs to wrap the snapshot fetch in its own processing.\n\t\t */\n\t\tif (IsolationUsesXactSnapshot())\n\t\t{\n\t\t\t/* First, create the snapshot in CurrentSnapshotData */\n\t\t\tif (IsolationIsSerializable())\n\t\t\t\tCurrentSnapshot = GetSerializableTransactionSnapshot(&CurrentSnapshotData);\n\t\t\telse\n\t\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\t\t\t/* Make a saved copy */\n\t\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\t\tFirstXactSnapshot->regd_count++;\n\t\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t\t}\n\t\telse\n\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t\tFirstSnapshotSet = true;\n\t\treturn CurrentSnapshot;\n\t}\n\n\tif (IsolationUsesXactSnapshot())\n\t\treturn CurrentSnapshot;\n\n\t/* Don't allow catalog snapshot to be older than xact snapshot. */\n\tInvalidateCatalogSnapshot();\n\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\treturn CurrentSnapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "StartTransactionCommand",
          "args": [],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetCurrentStatementStartTimestamp",
          "args": [],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_bestart",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAutoVacuumLauncherProcess",
          "args": [],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "before_shmem_exit",
          "args": [
            "ShutdownPostgres",
            "0"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationCacheInitializePhase2",
          "args": [],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "RelationCacheInitializePhase2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "3514-3557",
          "snippet": "void\nRelationCacheInitializePhase2(void)\n{\n\tMemoryContext oldcxt;\n\n\t/*\n\t * relation mapper needs initialized too\n\t */\n\tRelationMapInitializePhase2();\n\n\t/*\n\t * In bootstrap mode, the shared catalogs aren't there yet anyway, so do\n\t * nothing.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * switch to cache memory context\n\t */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * Try to load the shared relcache cache file.  If unsuccessful, bootstrap\n\t * the cache with pre-made descriptors for the critical shared catalogs.\n\t */\n\tif (!load_relcache_init_file(true))\n\t{\n\t\tformrdesc(\"pg_database\", DatabaseRelation_Rowtype_Id, true,\n\t\t\t\t  true, Natts_pg_database, Desc_pg_database);\n\t\tformrdesc(\"pg_authid\", AuthIdRelation_Rowtype_Id, true,\n\t\t\t\t  true, Natts_pg_authid, Desc_pg_authid);\n\t\tformrdesc(\"pg_auth_members\", AuthMemRelation_Rowtype_Id, true,\n\t\t\t\t  false, Natts_pg_auth_members, Desc_pg_auth_members);\n\t\tformrdesc(\"pg_shseclabel\", SharedSecLabelRelation_Rowtype_Id, true,\n\t\t\t\t  false, Natts_pg_shseclabel, Desc_pg_shseclabel);\n\t\tformrdesc(\"pg_subscription\", SubscriptionRelation_Rowtype_Id, true,\n\t\t\t\t  true, Natts_pg_subscription, Desc_pg_subscription);\n\n#define NUM_CRITICAL_SHARED_RELS\t5\t/* fix if you change list above */\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_CRITICAL_SHARED_RELS\t5\t/* fix if you change list above */"
          ],
          "globals_used": [
            "static const FormData_pg_attribute Desc_pg_database[Natts_pg_database] = {Schema_pg_database};",
            "static const FormData_pg_attribute Desc_pg_authid[Natts_pg_authid] = {Schema_pg_authid};",
            "static const FormData_pg_attribute Desc_pg_auth_members[Natts_pg_auth_members] = {Schema_pg_auth_members};",
            "static const FormData_pg_attribute Desc_pg_shseclabel[Natts_pg_shseclabel] = {Schema_pg_shseclabel};",
            "static const FormData_pg_attribute Desc_pg_subscription[Natts_pg_subscription] = {Schema_pg_subscription};",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static bool load_relcache_init_file(bool shared);",
            "static void write_relcache_init_file(bool shared);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define NUM_CRITICAL_SHARED_RELS\t5\t/* fix if you change list above */\n\nstatic const FormData_pg_attribute Desc_pg_database[Natts_pg_database] = {Schema_pg_database};\nstatic const FormData_pg_attribute Desc_pg_authid[Natts_pg_authid] = {Schema_pg_authid};\nstatic const FormData_pg_attribute Desc_pg_auth_members[Natts_pg_auth_members] = {Schema_pg_auth_members};\nstatic const FormData_pg_attribute Desc_pg_shseclabel[Natts_pg_shseclabel] = {Schema_pg_shseclabel};\nstatic const FormData_pg_attribute Desc_pg_subscription[Natts_pg_subscription] = {Schema_pg_subscription};\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationCacheInitializePhase2(void)\n{\n\tMemoryContext oldcxt;\n\n\t/*\n\t * relation mapper needs initialized too\n\t */\n\tRelationMapInitializePhase2();\n\n\t/*\n\t * In bootstrap mode, the shared catalogs aren't there yet anyway, so do\n\t * nothing.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * switch to cache memory context\n\t */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * Try to load the shared relcache cache file.  If unsuccessful, bootstrap\n\t * the cache with pre-made descriptors for the critical shared catalogs.\n\t */\n\tif (!load_relcache_init_file(true))\n\t{\n\t\tformrdesc(\"pg_database\", DatabaseRelation_Rowtype_Id, true,\n\t\t\t\t  true, Natts_pg_database, Desc_pg_database);\n\t\tformrdesc(\"pg_authid\", AuthIdRelation_Rowtype_Id, true,\n\t\t\t\t  true, Natts_pg_authid, Desc_pg_authid);\n\t\tformrdesc(\"pg_auth_members\", AuthMemRelation_Rowtype_Id, true,\n\t\t\t\t  false, Natts_pg_auth_members, Desc_pg_auth_members);\n\t\tformrdesc(\"pg_shseclabel\", SharedSecLabelRelation_Rowtype_Id, true,\n\t\t\t\t  false, Natts_pg_shseclabel, Desc_pg_shseclabel);\n\t\tformrdesc(\"pg_subscription\", SubscriptionRelation_Rowtype_Id, true,\n\t\t\t\t  true, Natts_pg_subscription, Desc_pg_subscription);\n\n#define NUM_CRITICAL_SHARED_RELS\t5\t/* fix if you change list above */\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgstat_initialize",
          "args": [],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EnablePortalManager",
          "args": [],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "EnablePortalManager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "103-123",
          "snippet": "void\nEnablePortalManager(void)\n{\n\tHASHCTL\t\tctl;\n\n\tAssert(TopPortalContext == NULL);\n\n\tTopPortalContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t \"TopPortalContext\",\n\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\tctl.keysize = MAX_PORTALNAME_LEN;\n\tctl.entrysize = sizeof(PortalHashEnt);\n\n\t/*\n\t * use PORTALS_PER_USER as a guess of how many hash table entries to\n\t * create, initially\n\t */\n\tPortalHashTable = hash_create(\"Portal hash\", PORTALS_PER_USER,\n\t\t\t\t\t\t\t\t  &ctl, HASH_ELEM);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_PORTALNAME_LEN\t\tNAMEDATALEN",
            "#define PORTALS_PER_USER\t   16"
          ],
          "globals_used": [
            "static HTAB *PortalHashTable = NULL;",
            "static MemoryContext TopPortalContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\n#define MAX_PORTALNAME_LEN\t\tNAMEDATALEN\n#define PORTALS_PER_USER\t   16\n\nstatic HTAB *PortalHashTable = NULL;\nstatic MemoryContext TopPortalContext = NULL;\n\nvoid\nEnablePortalManager(void)\n{\n\tHASHCTL\t\tctl;\n\n\tAssert(TopPortalContext == NULL);\n\n\tTopPortalContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t \"TopPortalContext\",\n\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\tctl.keysize = MAX_PORTALNAME_LEN;\n\tctl.entrysize = sizeof(PortalHashEnt);\n\n\t/*\n\t * use PORTALS_PER_USER as a guess of how many hash table entries to\n\t * create, initially\n\t */\n\tPortalHashTable = hash_create(\"Portal hash\", PORTALS_PER_USER,\n\t\t\t\t\t\t\t\t  &ctl, HASH_ELEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitPlanCache",
          "args": [],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "InitPlanCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "115-125",
          "snippet": "void\nInitPlanCache(void)\n{\n\tCacheRegisterRelcacheCallback(PlanCacheRelCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(PROCOID, PlanCacheFuncCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(NAMESPACEOID, PlanCacheSysCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(OPEROID, PlanCacheSysCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(AMOPOPID, PlanCacheSysCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(FOREIGNSERVEROID, PlanCacheSysCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(FOREIGNDATAWRAPPEROID, PlanCacheSysCallback, (Datum) 0);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nInitPlanCache(void)\n{\n\tCacheRegisterRelcacheCallback(PlanCacheRelCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(PROCOID, PlanCacheFuncCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(NAMESPACEOID, PlanCacheSysCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(OPEROID, PlanCacheSysCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(AMOPOPID, PlanCacheSysCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(FOREIGNSERVEROID, PlanCacheSysCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(FOREIGNDATAWRAPPEROID, PlanCacheSysCallback, (Datum) 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitCatalogCache",
          "args": [],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "InitCatalogCachePhase2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1070-1079",
          "snippet": "void\nInitCatalogCachePhase2(void)\n{\n\tint\t\t\tcacheId;\n\n\tAssert(CacheInitialized);\n\n\tfor (cacheId = 0; cacheId < SysCacheSize; cacheId++)\n\t\tInitCatCachePhase2(SysCache[cacheId], true);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];",
            "static bool CacheInitialized = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\nstatic bool CacheInitialized = false;\n\nvoid\nInitCatalogCachePhase2(void)\n{\n\tint\t\t\tcacheId;\n\n\tAssert(CacheInitialized);\n\n\tfor (cacheId = 0; cacheId < SysCacheSize; cacheId++)\n\t\tInitCatCachePhase2(SysCache[cacheId], true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_shmem_exit",
          "args": [
            "ShutdownXLOG",
            "0"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_on_shmem_exit_release_in_place",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "585-589",
          "snippet": "void\ndsa_on_shmem_exit_release_in_place(int code, Datum place)\n{\n\tdsa_release_in_place(DatumGetPointer(place));\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nvoid\ndsa_on_shmem_exit_release_in_place(int code, Datum place)\n{\n\tdsa_release_in_place(DatumGetPointer(place));\n}"
        }
      },
      {
        "call_info": {
          "callee": "StartupXLOG",
          "args": [],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RecoveryInProgress",
          "args": [],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitBufferPoolBackend",
          "args": [],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RegisterTimeout",
          "args": [
            "IDLE_IN_TRANSACTION_SESSION_TIMEOUT",
            "IdleInTransactionSessionTimeoutHandler"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "RegisterTimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "372-396",
          "snippet": "TimeoutId\nRegisterTimeout(TimeoutId id, timeout_handler_proc handler)\n{\n\tAssert(all_timeouts_initialized);\n\n\t/* There's no need to disable the signal handler here. */\n\n\tif (id >= USER_TIMEOUT)\n\t{\n\t\t/* Allocate a user-defined timeout reason */\n\t\tfor (id = USER_TIMEOUT; id < MAX_TIMEOUTS; id++)\n\t\t\tif (all_timeouts[id].timeout_handler == NULL)\n\t\t\t\tbreak;\n\t\tif (id >= MAX_TIMEOUTS)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"cannot add more timeout reasons\")));\n\t}\n\n\tAssert(all_timeouts[id].timeout_handler == NULL);\n\n\tall_timeouts[id].timeout_handler = handler;\n\n\treturn id;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static timeout_params all_timeouts[MAX_TIMEOUTS];",
            "static bool all_timeouts_initialized = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic timeout_params all_timeouts[MAX_TIMEOUTS];\nstatic bool all_timeouts_initialized = false;\n\nTimeoutId\nRegisterTimeout(TimeoutId id, timeout_handler_proc handler)\n{\n\tAssert(all_timeouts_initialized);\n\n\t/* There's no need to disable the signal handler here. */\n\n\tif (id >= USER_TIMEOUT)\n\t{\n\t\t/* Allocate a user-defined timeout reason */\n\t\tfor (id = USER_TIMEOUT; id < MAX_TIMEOUTS; id++)\n\t\t\tif (all_timeouts[id].timeout_handler == NULL)\n\t\t\t\tbreak;\n\t\tif (id >= MAX_TIMEOUTS)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"cannot add more timeout reasons\")));\n\t}\n\n\tAssert(all_timeouts[id].timeout_handler == NULL);\n\n\tall_timeouts[id].timeout_handler = handler;\n\n\treturn id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ProcSignalInit",
          "args": [
            "MyBackendId"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"bad backend ID: %d\"",
            "MyBackendId"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SharedInvalBackendInit",
          "args": [
            "false"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitProcessPhase2",
          "args": [],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic HeapTuple GetDatabaseTuple(const char *dbname);\nstatic HeapTuple GetDatabaseTupleByOid(Oid dboid);\nstatic void CheckMyDatabase(const char *name, bool am_superuser, bool override_allow_connections);\nstatic void StatementTimeoutHandler(void);\nstatic void LockTimeoutHandler(void);\nstatic void IdleInTransactionSessionTimeoutHandler(void);\nstatic bool ThereIsAtLeastOneRole(void);\nstatic void process_startup_options(Port *port, bool am_superuser);\n\nvoid\nInitPostgres(const char *in_dbname, Oid dboid, const char *username,\n\t\t\t Oid useroid, char *out_dbname, bool override_allow_connections)\n{\n\tbool\t\tbootstrap = IsBootstrapProcessingMode();\n\tbool\t\tam_superuser;\n\tchar\t   *fullpath;\n\tchar\t\tdbname[NAMEDATALEN];\n\n\telog(DEBUG3, \"InitPostgres\");\n\n\t/*\n\t * Add my PGPROC struct to the ProcArray.\n\t *\n\t * Once I have done this, I am visible to other backends!\n\t */\n\tInitProcessPhase2();\n\n\t/*\n\t * Initialize my entry in the shared-invalidation manager's array of\n\t * per-backend data.\n\t *\n\t * Sets up MyBackendId, a unique backend identifier.\n\t */\n\tMyBackendId = InvalidBackendId;\n\n\tSharedInvalBackendInit(false);\n\n\tif (MyBackendId > MaxBackends || MyBackendId <= 0)\n\t\telog(FATAL, \"bad backend ID: %d\", MyBackendId);\n\n\t/* Now that we have a BackendId, we can participate in ProcSignal */\n\tProcSignalInit(MyBackendId);\n\n\t/*\n\t * Also set up timeout handlers needed for backend operation.  We need\n\t * these in every case except bootstrap.\n\t */\n\tif (!bootstrap)\n\t{\n\t\tRegisterTimeout(DEADLOCK_TIMEOUT, CheckDeadLockAlert);\n\t\tRegisterTimeout(STATEMENT_TIMEOUT, StatementTimeoutHandler);\n\t\tRegisterTimeout(LOCK_TIMEOUT, LockTimeoutHandler);\n\t\tRegisterTimeout(IDLE_IN_TRANSACTION_SESSION_TIMEOUT,\n\t\t\t\t\t\tIdleInTransactionSessionTimeoutHandler);\n\t}\n\n\t/*\n\t * bufmgr needs another initialization call too\n\t */\n\tInitBufferPoolBackend();\n\n\t/*\n\t * Initialize local process's access to XLOG.\n\t */\n\tif (IsUnderPostmaster)\n\t{\n\t\t/*\n\t\t * The postmaster already started the XLOG machinery, but we need to\n\t\t * call InitXLOGAccess(), if the system isn't in hot-standby mode.\n\t\t * This is handled by calling RecoveryInProgress and ignoring the\n\t\t * result.\n\t\t */\n\t\t(void) RecoveryInProgress();\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We are either a bootstrap process or a standalone backend. Either\n\t\t * way, start up the XLOG machinery, and register to have it closed\n\t\t * down at exit.\n\t\t */\n\t\tStartupXLOG();\n\t\ton_shmem_exit(ShutdownXLOG, 0);\n\t}\n\n\t/*\n\t * Initialize the relation cache and the system catalog caches.  Note that\n\t * no catalog access happens here; we only set up the hashtable structure.\n\t * We must do this before starting a transaction because transaction abort\n\t * would try to touch these hashtables.\n\t */\n\tRelationCacheInitialize();\n\tInitCatalogCache();\n\tInitPlanCache();\n\n\t/* Initialize portal manager */\n\tEnablePortalManager();\n\n\t/* Initialize stats collection --- must happen before first xact */\n\tif (!bootstrap)\n\t\tpgstat_initialize();\n\n\t/*\n\t * Load relcache entries for the shared system catalogs.  This must create\n\t * at least entries for pg_database and catalogs used for authentication.\n\t */\n\tRelationCacheInitializePhase2();\n\n\t/*\n\t * Set up process-exit callback to do pre-shutdown cleanup.  This is the\n\t * first before_shmem_exit callback we register; thus, this will be the\n\t * last thing we do before low-level modules like the buffer manager begin\n\t * to close down.  We need to have this in place before we begin our first\n\t * transaction --- if we fail during the initialization transaction, as is\n\t * entirely possible, we need the AbortTransaction call to clean up.\n\t */\n\tbefore_shmem_exit(ShutdownPostgres, 0);\n\n\t/* The autovacuum launcher is done here */\n\tif (IsAutoVacuumLauncherProcess())\n\t{\n\t\t/* report this backend in the PgBackendStatus array */\n\t\tpgstat_bestart();\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Start a new transaction here before first access to db, and get a\n\t * snapshot.  We don't have a use for the snapshot itself, but we're\n\t * interested in the secondary effect that it sets RecentGlobalXmin. (This\n\t * is critical for anything that reads heap pages, because HOT may decide\n\t * to prune them even if the process doesn't attempt to modify any\n\t * tuples.)\n\t */\n\tif (!bootstrap)\n\t{\n\t\t/* statement_timestamp must be set for timeouts to work correctly */\n\t\tSetCurrentStatementStartTimestamp();\n\t\tStartTransactionCommand();\n\n\t\t/*\n\t\t * transaction_isolation will have been set to the default by the\n\t\t * above.  If the default is \"serializable\", and we are in hot\n\t\t * standby, we will fail if we don't change it to something lower.\n\t\t * Fortunately, \"read committed\" is plenty good enough.\n\t\t */\n\t\tXactIsoLevel = XACT_READ_COMMITTED;\n\n\t\t(void) GetTransactionSnapshot();\n\t}\n\n\t/*\n\t * Perform client authentication if necessary, then figure out our\n\t * postgres user ID, and see if we are a superuser.\n\t *\n\t * In standalone mode and in autovacuum worker processes, we use a fixed\n\t * ID, otherwise we figure it out from the authenticated user name.\n\t */\n\tif (bootstrap || IsAutoVacuumWorkerProcess())\n\t{\n\t\tInitializeSessionUserIdStandalone();\n\t\tam_superuser = true;\n\t}\n\telse if (!IsUnderPostmaster)\n\t{\n\t\tInitializeSessionUserIdStandalone();\n\t\tam_superuser = true;\n\t\tif (!ThereIsAtLeastOneRole())\n\t\t\tereport(WARNING,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"no roles are defined in this database system\"),\n\t\t\t\t\t errhint(\"You should immediately run CREATE USER \\\"%s\\\" SUPERUSER;.\",\n\t\t\t\t\t\t\t username != NULL ? username : \"postgres\")));\n\t}\n\telse if (IsBackgroundWorker)\n\t{\n\t\tif (username == NULL && !OidIsValid(useroid))\n\t\t{\n\t\t\tInitializeSessionUserIdStandalone();\n\t\t\tam_superuser = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tInitializeSessionUserId(username, useroid);\n\t\t\tam_superuser = superuser();\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* normal multiuser case */\n\t\tAssert(MyProcPort != NULL);\n\t\tPerformAuthentication(MyProcPort);\n\t\tInitializeSessionUserId(username, useroid);\n\t\tam_superuser = superuser();\n\t}\n\n\t/*\n\t * If we're trying to shut down, only superusers can connect, and new\n\t * replication connections are not allowed.\n\t */\n\tif ((!am_superuser || am_walsender) &&\n\t\tMyProcPort != NULL &&\n\t\tMyProcPort->canAcceptConnections == CAC_WAITBACKUP)\n\t{\n\t\tif (am_walsender)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"new replication connections are not allowed during database shutdown\")));\n\t\telse\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"must be superuser to connect during database shutdown\")));\n\t}\n\n\t/*\n\t * Binary upgrades only allowed super-user connections\n\t */\n\tif (IsBinaryUpgrade && !am_superuser)\n\t{\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"must be superuser to connect in binary upgrade mode\")));\n\t}\n\n\t/*\n\t * The last few connection slots are reserved for superusers.  Although\n\t * replication connections currently require superuser privileges, we\n\t * don't allow them to consume the reserved slots, which are intended for\n\t * interactive use.\n\t */\n\tif ((!am_superuser || am_walsender) &&\n\t\tReservedBackends > 0 &&\n\t\t!HaveNFreeProcs(ReservedBackends))\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t errmsg(\"remaining connection slots are reserved for non-replication superuser connections\")));\n\n\t/* Check replication permissions needed for walsender processes. */\n\tif (am_walsender)\n\t{\n\t\tAssert(!bootstrap);\n\n\t\tif (!superuser() && !has_rolreplication(GetUserId()))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"must be superuser or replication role to start walsender\")));\n\t}\n\n\t/*\n\t * If this is a plain walsender only supporting physical replication, we\n\t * don't want to connect to any particular database. Just finish the\n\t * backend startup by processing any options from the startup packet, and\n\t * we're done.\n\t */\n\tif (am_walsender && !am_db_walsender)\n\t{\n\t\t/* process any options passed in the startup packet */\n\t\tif (MyProcPort != NULL)\n\t\t\tprocess_startup_options(MyProcPort, am_superuser);\n\n\t\t/* Apply PostAuthDelay as soon as we've read all options */\n\t\tif (PostAuthDelay > 0)\n\t\t\tpg_usleep(PostAuthDelay * 1000000L);\n\n\t\t/* initialize client encoding */\n\t\tInitializeClientEncoding();\n\n\t\t/* report this backend in the PgBackendStatus array */\n\t\tpgstat_bestart();\n\n\t\t/* close the transaction we started above */\n\t\tCommitTransactionCommand();\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Set up the global variables holding database id and default tablespace.\n\t * But note we won't actually try to touch the database just yet.\n\t *\n\t * We take a shortcut in the bootstrap case, otherwise we have to look up\n\t * the db's entry in pg_database.\n\t */\n\tif (bootstrap)\n\t{\n\t\tMyDatabaseId = TemplateDbOid;\n\t\tMyDatabaseTableSpace = DEFAULTTABLESPACE_OID;\n\t}\n\telse if (in_dbname != NULL)\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_database dbform;\n\n\t\ttuple = GetDatabaseTuple(in_dbname);\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t\t errmsg(\"database \\\"%s\\\" does not exist\", in_dbname)));\n\t\tdbform = (Form_pg_database) GETSTRUCT(tuple);\n\t\tMyDatabaseId = HeapTupleGetOid(tuple);\n\t\tMyDatabaseTableSpace = dbform->dattablespace;\n\t\t/* take database name from the caller, just for paranoia */\n\t\tstrlcpy(dbname, in_dbname, sizeof(dbname));\n\t}\n\telse if (OidIsValid(dboid))\n\t{\n\t\t/* caller specified database by OID */\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_database dbform;\n\n\t\ttuple = GetDatabaseTupleByOid(dboid);\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t\t errmsg(\"database %u does not exist\", dboid)));\n\t\tdbform = (Form_pg_database) GETSTRUCT(tuple);\n\t\tMyDatabaseId = HeapTupleGetOid(tuple);\n\t\tMyDatabaseTableSpace = dbform->dattablespace;\n\t\tAssert(MyDatabaseId == dboid);\n\t\tstrlcpy(dbname, NameStr(dbform->datname), sizeof(dbname));\n\t\t/* pass the database name back to the caller */\n\t\tif (out_dbname)\n\t\t\tstrcpy(out_dbname, dbname);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If this is a background worker not bound to any particular\n\t\t * database, we're done now.  Everything that follows only makes sense\n\t\t * if we are bound to a specific database.  We do need to close the\n\t\t * transaction we started before returning.\n\t\t */\n\t\tif (!bootstrap)\n\t\t{\n\t\t\tpgstat_bestart();\n\t\t\tCommitTransactionCommand();\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * Now, take a writer's lock on the database we are trying to connect to.\n\t * If there is a concurrently running DROP DATABASE on that database, this\n\t * will block us until it finishes (and has committed its update of\n\t * pg_database).\n\t *\n\t * Note that the lock is not held long, only until the end of this startup\n\t * transaction.  This is OK since we will advertise our use of the\n\t * database in the ProcArray before dropping the lock (in fact, that's the\n\t * next thing to do).  Anyone trying a DROP DATABASE after this point will\n\t * see us in the array once they have the lock.  Ordering is important for\n\t * this because we don't want to advertise ourselves as being in this\n\t * database until we have the lock; otherwise we create what amounts to a\n\t * deadlock with CountOtherDBBackends().\n\t *\n\t * Note: use of RowExclusiveLock here is reasonable because we envision\n\t * our session as being a concurrent writer of the database.  If we had a\n\t * way of declaring a session as being guaranteed-read-only, we could use\n\t * AccessShareLock for such sessions and thereby not conflict against\n\t * CREATE DATABASE.\n\t */\n\tif (!bootstrap)\n\t\tLockSharedObject(DatabaseRelationId, MyDatabaseId, 0,\n\t\t\t\t\t\t RowExclusiveLock);\n\n\t/*\n\t * Now we can mark our PGPROC entry with the database ID.\n\t *\n\t * We assume this is an atomic store so no lock is needed; though actually\n\t * things would work fine even if it weren't atomic.  Anyone searching the\n\t * ProcArray for this database's ID should hold the database lock, so they\n\t * would not be executing concurrently with this store.  A process looking\n\t * for another database's ID could in theory see a chance match if it read\n\t * a partially-updated databaseId value; but as long as all such searches\n\t * wait and retry, as in CountOtherDBBackends(), they will certainly see\n\t * the correct value on their next try.\n\t */\n\tMyProc->databaseId = MyDatabaseId;\n\n\t/*\n\t * We established a catalog snapshot while reading pg_authid and/or\n\t * pg_database; but until we have set up MyDatabaseId, we won't react to\n\t * incoming sinval messages for unshared catalogs, so we won't realize it\n\t * if the snapshot has been invalidated.  Assume it's no good anymore.\n\t */\n\tInvalidateCatalogSnapshot();\n\n\t/*\n\t * Recheck pg_database to make sure the target database hasn't gone away.\n\t * If there was a concurrent DROP DATABASE, this ensures we will die\n\t * cleanly without creating a mess.\n\t */\n\tif (!bootstrap)\n\t{\n\t\tHeapTuple\ttuple;\n\n\t\ttuple = GetDatabaseTuple(dbname);\n\t\tif (!HeapTupleIsValid(tuple) ||\n\t\t\tMyDatabaseId != HeapTupleGetOid(tuple) ||\n\t\t\tMyDatabaseTableSpace != ((Form_pg_database) GETSTRUCT(tuple))->dattablespace)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t\t errmsg(\"database \\\"%s\\\" does not exist\", dbname),\n\t\t\t\t\t errdetail(\"It seems to have just been dropped or renamed.\")));\n\t}\n\n\t/*\n\t * Now we should be able to access the database directory safely. Verify\n\t * it's there and looks reasonable.\n\t */\n\tfullpath = GetDatabasePath(MyDatabaseId, MyDatabaseTableSpace);\n\n\tif (!bootstrap)\n\t{\n\t\tif (access(fullpath, F_OK) == -1)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t\t\t errmsg(\"database \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\t\tdbname),\n\t\t\t\t\t\t errdetail(\"The database subdirectory \\\"%s\\\" is missing.\",\n\t\t\t\t\t\t\t\t   fullpath)));\n\t\t\telse\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not access directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\tfullpath)));\n\t\t}\n\n\t\tValidatePgVersion(fullpath);\n\t}\n\n\tSetDatabasePath(fullpath);\n\n\t/*\n\t * It's now possible to do real access to the system catalogs.\n\t *\n\t * Load relcache entries for the system catalogs.  This must create at\n\t * least the minimum set of \"nailed-in\" cache entries.\n\t */\n\tRelationCacheInitializePhase3();\n\n\t/* set up ACL framework (so CheckMyDatabase can check permissions) */\n\tinitialize_acl();\n\n\t/*\n\t * Re-read the pg_database row for our database, check permissions and set\n\t * up database-specific GUC settings.  We can't do this until all the\n\t * database-access infrastructure is up.  (Also, it wants to know if the\n\t * user is a superuser, so the above stuff has to happen first.)\n\t */\n\tif (!bootstrap)\n\t\tCheckMyDatabase(dbname, am_superuser, override_allow_connections);\n\n\t/*\n\t * Now process any command-line switches and any additional GUC variable\n\t * settings passed in the startup packet.   We couldn't do this before\n\t * because we didn't know if client is a superuser.\n\t */\n\tif (MyProcPort != NULL)\n\t\tprocess_startup_options(MyProcPort, am_superuser);\n\n\t/* Process pg_db_role_setting options */\n\tprocess_settings(MyDatabaseId, GetSessionUserId());\n\n\t/* Apply PostAuthDelay as soon as we've read all options */\n\tif (PostAuthDelay > 0)\n\t\tpg_usleep(PostAuthDelay * 1000000L);\n\n\t/*\n\t * Initialize various default states that can't be set up until we've\n\t * selected the active user and gotten the right GUC settings.\n\t */\n\n\t/* set default namespace search path */\n\tInitializeSearchPath();\n\n\t/* initialize client encoding */\n\tInitializeClientEncoding();\n\n\t/* Initialize this backend's session state. */\n\tInitializeSession();\n\n\t/* report this backend in the PgBackendStatus array */\n\tif (!bootstrap)\n\t\tpgstat_bestart();\n\n\t/* close the transaction we started above */\n\tif (!bootstrap)\n\t\tCommitTransactionCommand();\n}"
  },
  {
    "function_name": "BaseInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
    "lines": "525-539",
    "snippet": "void\nBaseInit(void)\n{\n\t/*\n\t * Attach to shared memory and semaphores, and initialize our\n\t * input/output/debugging file descriptors.\n\t */\n\tInitCommunication();\n\tDebugFileOpen();\n\n\t/* Do local initialization of file, storage and buffer managers */\n\tInitFileAccess();\n\tsmgrinit();\n\tInitBufferPoolAccess();\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"utils/portal.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/procsignal.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"replication/walsender.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq-be.h\"",
      "#include \"libpq/auth.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_db_role_setting.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/session.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void InitCommunication(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "InitBufferPoolAccess",
          "args": [],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smgrinit",
          "args": [],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFileAccess",
          "args": [],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DebugFileOpen",
          "args": [],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "DebugFileOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1855-1898",
          "snippet": "void\nDebugFileOpen(void)\n{\n\tint\t\t\tfd,\n\t\t\t\tistty;\n\n\tif (OutputFileName[0])\n\t{\n\t\t/*\n\t\t * A debug-output file name was given.\n\t\t *\n\t\t * Make sure we can write the file, and find out if it's a tty.\n\t\t */\n\t\tif ((fd = open(OutputFileName, O_CREAT | O_APPEND | O_WRONLY,\n\t\t\t\t\t   0666)) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", OutputFileName)));\n\t\tistty = isatty(fd);\n\t\tclose(fd);\n\n\t\t/*\n\t\t * Redirect our stderr to the debug output file.\n\t\t */\n\t\tif (!freopen(OutputFileName, \"a\", stderr))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not reopen file \\\"%s\\\" as stderr: %m\",\n\t\t\t\t\t\t\tOutputFileName)));\n\n\t\t/*\n\t\t * If the file is a tty and we're running under the postmaster, try to\n\t\t * send stdout there as well (if it isn't a tty then stderr will block\n\t\t * out stdout, so we may as well let stdout go wherever it was going\n\t\t * before).\n\t\t */\n\t\tif (istty && IsUnderPostmaster)\n\t\t\tif (!freopen(OutputFileName, \"a\", stdout))\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not reopen file \\\"%s\\\" as stdout: %m\",\n\t\t\t\t\t\t\t\tOutputFileName)));\n\t}\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nDebugFileOpen(void)\n{\n\tint\t\t\tfd,\n\t\t\t\tistty;\n\n\tif (OutputFileName[0])\n\t{\n\t\t/*\n\t\t * A debug-output file name was given.\n\t\t *\n\t\t * Make sure we can write the file, and find out if it's a tty.\n\t\t */\n\t\tif ((fd = open(OutputFileName, O_CREAT | O_APPEND | O_WRONLY,\n\t\t\t\t\t   0666)) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", OutputFileName)));\n\t\tistty = isatty(fd);\n\t\tclose(fd);\n\n\t\t/*\n\t\t * Redirect our stderr to the debug output file.\n\t\t */\n\t\tif (!freopen(OutputFileName, \"a\", stderr))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not reopen file \\\"%s\\\" as stderr: %m\",\n\t\t\t\t\t\t\tOutputFileName)));\n\n\t\t/*\n\t\t * If the file is a tty and we're running under the postmaster, try to\n\t\t * send stdout there as well (if it isn't a tty then stderr will block\n\t\t * out stdout, so we may as well let stdout go wherever it was going\n\t\t * before).\n\t\t */\n\t\tif (istty && IsUnderPostmaster)\n\t\t\tif (!freopen(OutputFileName, \"a\", stdout))\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not reopen file \\\"%s\\\" as stdout: %m\",\n\t\t\t\t\t\t\t\tOutputFileName)));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitCommunication",
          "args": [],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "InitCommunication",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
          "lines": "415-431",
          "snippet": "static void\nInitCommunication(void)\n{\n\t/*\n\t * initialize shared memory and semaphores appropriately.\n\t */\n\tif (!IsUnderPostmaster)\t\t/* postmaster already did this */\n\t{\n\t\t/*\n\t\t * We're running a postgres bootstrap process or a standalone backend.\n\t\t * Though we won't listen on PostPortNumber, use it to select a shmem\n\t\t * key.  This increases the chance of detecting a leftover live\n\t\t * backend of this DataDir.\n\t\t */\n\t\tCreateSharedMemoryAndSemaphores(PostPortNumber);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/procsignal.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/session.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void InitCommunication(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void InitCommunication(void);\n\nstatic void\nInitCommunication(void)\n{\n\t/*\n\t * initialize shared memory and semaphores appropriately.\n\t */\n\tif (!IsUnderPostmaster)\t\t/* postmaster already did this */\n\t{\n\t\t/*\n\t\t * We're running a postgres bootstrap process or a standalone backend.\n\t\t * Though we won't listen on PostPortNumber, use it to select a shmem\n\t\t * key.  This increases the chance of detecting a leftover live\n\t\t * backend of this DataDir.\n\t\t */\n\t\tCreateSharedMemoryAndSemaphores(PostPortNumber);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void InitCommunication(void);\n\nvoid\nBaseInit(void)\n{\n\t/*\n\t * Attach to shared memory and semaphores, and initialize our\n\t * input/output/debugging file descriptors.\n\t */\n\tInitCommunication();\n\tDebugFileOpen();\n\n\t/* Do local initialization of file, storage and buffer managers */\n\tInitFileAccess();\n\tsmgrinit();\n\tInitBufferPoolAccess();\n}"
  },
  {
    "function_name": "InitializeMaxBackends",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
    "lines": "503-515",
    "snippet": "void\nInitializeMaxBackends(void)\n{\n\tAssert(MaxBackends == 0);\n\n\t/* the extra unit accounts for the autovacuum launcher */\n\tMaxBackends = MaxConnections + autovacuum_max_workers + 1 +\n\t\tmax_worker_processes;\n\n\t/* internal error because the values were all checked previously */\n\tif (MaxBackends > MAX_BACKENDS)\n\t\telog(ERROR, \"too many backends configured\");\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"utils/portal.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/procsignal.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"replication/walsender.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq-be.h\"",
      "#include \"libpq/auth.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_db_role_setting.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/session.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"too many backends configured\""
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "MaxBackends == 0"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nInitializeMaxBackends(void)\n{\n\tAssert(MaxBackends == 0);\n\n\t/* the extra unit accounts for the autovacuum launcher */\n\tMaxBackends = MaxConnections + autovacuum_max_workers + 1 +\n\t\tmax_worker_processes;\n\n\t/* internal error because the values were all checked previously */\n\tif (MaxBackends > MAX_BACKENDS)\n\t\telog(ERROR, \"too many backends configured\");\n}"
  },
  {
    "function_name": "pg_split_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
    "lines": "444-489",
    "snippet": "void\npg_split_opts(char **argv, int *argcp, const char *optstr)\n{\n\tStringInfoData s;\n\n\tinitStringInfo(&s);\n\n\twhile (*optstr)\n\t{\n\t\tbool\t\tlast_was_escape = false;\n\n\t\tresetStringInfo(&s);\n\n\t\t/* skip over leading space */\n\t\twhile (isspace((unsigned char) *optstr))\n\t\t\toptstr++;\n\n\t\tif (*optstr == '\\0')\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Parse a single option, stopping at the first space, unless it's\n\t\t * escaped.\n\t\t */\n\t\twhile (*optstr)\n\t\t{\n\t\t\tif (isspace((unsigned char) *optstr) && !last_was_escape)\n\t\t\t\tbreak;\n\n\t\t\tif (!last_was_escape && *optstr == '\\\\')\n\t\t\t\tlast_was_escape = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tlast_was_escape = false;\n\t\t\t\tappendStringInfoChar(&s, *optstr);\n\t\t\t}\n\n\t\t\toptstr++;\n\t\t}\n\n\t\t/* now store the option in the next argv[] position */\n\t\targv[(*argcp)++] = pstrdup(s.data);\n\t}\n\n\tpfree(s.data);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"utils/portal.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/procsignal.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"replication/walsender.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq-be.h\"",
      "#include \"libpq/auth.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_db_role_setting.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/session.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "s.data"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "s.data"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&s",
            "*optstr"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *optstr"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "resetStringInfo",
          "args": [
            "&s"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&s"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\npg_split_opts(char **argv, int *argcp, const char *optstr)\n{\n\tStringInfoData s;\n\n\tinitStringInfo(&s);\n\n\twhile (*optstr)\n\t{\n\t\tbool\t\tlast_was_escape = false;\n\n\t\tresetStringInfo(&s);\n\n\t\t/* skip over leading space */\n\t\twhile (isspace((unsigned char) *optstr))\n\t\t\toptstr++;\n\n\t\tif (*optstr == '\\0')\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Parse a single option, stopping at the first space, unless it's\n\t\t * escaped.\n\t\t */\n\t\twhile (*optstr)\n\t\t{\n\t\t\tif (isspace((unsigned char) *optstr) && !last_was_escape)\n\t\t\t\tbreak;\n\n\t\t\tif (!last_was_escape && *optstr == '\\\\')\n\t\t\t\tlast_was_escape = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tlast_was_escape = false;\n\t\t\t\tappendStringInfoChar(&s, *optstr);\n\t\t\t}\n\n\t\t\toptstr++;\n\t\t}\n\n\t\t/* now store the option in the next argv[] position */\n\t\targv[(*argcp)++] = pstrdup(s.data);\n\t}\n\n\tpfree(s.data);\n}"
  },
  {
    "function_name": "InitCommunication",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
    "lines": "415-431",
    "snippet": "static void\nInitCommunication(void)\n{\n\t/*\n\t * initialize shared memory and semaphores appropriately.\n\t */\n\tif (!IsUnderPostmaster)\t\t/* postmaster already did this */\n\t{\n\t\t/*\n\t\t * We're running a postgres bootstrap process or a standalone backend.\n\t\t * Though we won't listen on PostPortNumber, use it to select a shmem\n\t\t * key.  This increases the chance of detecting a leftover live\n\t\t * backend of this DataDir.\n\t\t */\n\t\tCreateSharedMemoryAndSemaphores(PostPortNumber);\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"utils/portal.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/procsignal.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"replication/walsender.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq-be.h\"",
      "#include \"libpq/auth.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_db_role_setting.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/session.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void InitCommunication(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CreateSharedMemoryAndSemaphores",
          "args": [
            "PostPortNumber"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void InitCommunication(void);\n\nstatic void\nInitCommunication(void)\n{\n\t/*\n\t * initialize shared memory and semaphores appropriately.\n\t */\n\tif (!IsUnderPostmaster)\t\t/* postmaster already did this */\n\t{\n\t\t/*\n\t\t * We're running a postgres bootstrap process or a standalone backend.\n\t\t * Though we won't listen on PostPortNumber, use it to select a shmem\n\t\t * key.  This increases the chance of detecting a leftover live\n\t\t * backend of this DataDir.\n\t\t */\n\t\tCreateSharedMemoryAndSemaphores(PostPortNumber);\n\t}\n}"
  },
  {
    "function_name": "CheckMyDatabase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
    "lines": "292-404",
    "snippet": "static void\nCheckMyDatabase(const char *name, bool am_superuser, bool override_allow_connections)\n{\n\tHeapTuple\ttup;\n\tForm_pg_database dbform;\n\tchar\t   *collate;\n\tchar\t   *ctype;\n\n\t/* Fetch our pg_database row normally, via syscache */\n\ttup = SearchSysCache1(DATABASEOID, ObjectIdGetDatum(MyDatabaseId));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for database %u\", MyDatabaseId);\n\tdbform = (Form_pg_database) GETSTRUCT(tup);\n\n\t/* This recheck is strictly paranoia */\n\tif (strcmp(name, NameStr(dbform->datname)) != 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t errmsg(\"database \\\"%s\\\" has disappeared from pg_database\",\n\t\t\t\t\t\tname),\n\t\t\t\t errdetail(\"Database OID %u now seems to belong to \\\"%s\\\".\",\n\t\t\t\t\t\t   MyDatabaseId, NameStr(dbform->datname))));\n\n\t/*\n\t * Check permissions to connect to the database.\n\t *\n\t * These checks are not enforced when in standalone mode, so that there is\n\t * a way to recover from disabling all access to all databases, for\n\t * example \"UPDATE pg_database SET datallowconn = false;\".\n\t *\n\t * We do not enforce them for autovacuum worker processes either.\n\t */\n\tif (IsUnderPostmaster && !IsAutoVacuumWorkerProcess())\n\t{\n\t\t/*\n\t\t * Check that the database is currently allowing connections.\n\t\t */\n\t\tif (!dbform->datallowconn && !override_allow_connections)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t errmsg(\"database \\\"%s\\\" is not currently accepting connections\",\n\t\t\t\t\t\t\tname)));\n\n\t\t/*\n\t\t * Check privilege to connect to the database.  (The am_superuser test\n\t\t * is redundant, but since we have the flag, might as well check it\n\t\t * and save a few cycles.)\n\t\t */\n\t\tif (!am_superuser &&\n\t\t\tpg_database_aclcheck(MyDatabaseId, GetUserId(),\n\t\t\t\t\t\t\t\t ACL_CONNECT) != ACLCHECK_OK)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"permission denied for database \\\"%s\\\"\", name),\n\t\t\t\t\t errdetail(\"User does not have CONNECT privilege.\")));\n\n\t\t/*\n\t\t * Check connection limit for this database.\n\t\t *\n\t\t * There is a race condition here --- we create our PGPROC before\n\t\t * checking for other PGPROCs.  If two backends did this at about the\n\t\t * same time, they might both think they were over the limit, while\n\t\t * ideally one should succeed and one fail.  Getting that to work\n\t\t * exactly seems more trouble than it is worth, however; instead we\n\t\t * just document that the connection limit is approximate.\n\t\t */\n\t\tif (dbform->datconnlimit >= 0 &&\n\t\t\t!am_superuser &&\n\t\t\tCountDBConnections(MyDatabaseId) > dbform->datconnlimit)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"too many connections for database \\\"%s\\\"\",\n\t\t\t\t\t\t\tname)));\n\t}\n\n\t/*\n\t * OK, we're golden.  Next to-do item is to save the encoding info out of\n\t * the pg_database tuple.\n\t */\n\tSetDatabaseEncoding(dbform->encoding);\n\t/* Record it as a GUC internal option, too */\n\tSetConfigOption(\"server_encoding\", GetDatabaseEncodingName(),\n\t\t\t\t\tPGC_INTERNAL, PGC_S_OVERRIDE);\n\t/* If we have no other source of client_encoding, use server encoding */\n\tSetConfigOption(\"client_encoding\", GetDatabaseEncodingName(),\n\t\t\t\t\tPGC_BACKEND, PGC_S_DYNAMIC_DEFAULT);\n\n\t/* assign locale variables */\n\tcollate = NameStr(dbform->datcollate);\n\tctype = NameStr(dbform->datctype);\n\n\tif (pg_perm_setlocale(LC_COLLATE, collate) == NULL)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"database locale is incompatible with operating system\"),\n\t\t\t\t errdetail(\"The database was initialized with LC_COLLATE \\\"%s\\\", \"\n\t\t\t\t\t\t   \" which is not recognized by setlocale().\", collate),\n\t\t\t\t errhint(\"Recreate the database with another locale or install the missing locale.\")));\n\n\tif (pg_perm_setlocale(LC_CTYPE, ctype) == NULL)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"database locale is incompatible with operating system\"),\n\t\t\t\t errdetail(\"The database was initialized with LC_CTYPE \\\"%s\\\", \"\n\t\t\t\t\t\t   \" which is not recognized by setlocale().\", ctype),\n\t\t\t\t errhint(\"Recreate the database with another locale or install the missing locale.\")));\n\n\t/* Make the locale settings visible as GUC variables, too */\n\tSetConfigOption(\"lc_collate\", collate, PGC_INTERNAL, PGC_S_OVERRIDE);\n\tSetConfigOption(\"lc_ctype\", ctype, PGC_INTERNAL, PGC_S_OVERRIDE);\n\n\tcheck_strxfrm_bug();\n\n\tReleaseSysCache(tup);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"utils/portal.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/procsignal.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"replication/walsender.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq-be.h\"",
      "#include \"libpq/auth.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_db_role_setting.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/session.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void CheckMyDatabase(const char *name, bool am_superuser, bool override_allow_connections);",
      "static void process_startup_options(Port *port, bool am_superuser);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tup"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_strxfrm_bug",
          "args": [],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "check_strxfrm_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1051-1094",
          "snippet": "void\ncheck_strxfrm_bug(void)\n{\n\tchar\t\tbuf[32];\n\tconst int\tcanary = 0x7F;\n\tbool\t\tok = true;\n\n\t/*\n\t * Given a two-byte ASCII string and length limit 7, 8 or 9, Solaris 10\n\t * 05/08 returns 18 and modifies 10 bytes.  It respects limits above or\n\t * below that range.\n\t *\n\t * The bug is present in Solaris 8 as well; it is absent in Solaris 10\n\t * 01/13 and Solaris 11.2.  Affected locales include is_IS.ISO8859-1,\n\t * en_US.UTF-8, en_US.ISO8859-1, and ru_RU.KOI8-R.  Unaffected locales\n\t * include de_DE.UTF-8, de_DE.ISO8859-1, zh_TW.UTF-8, and C.\n\t */\n\tbuf[7] = canary;\n\t(void) strxfrm(buf, \"ab\", 7);\n\tif (buf[7] != canary)\n\t\tok = false;\n\n\t/*\n\t * illumos bug #1594 was present in the source tree from 2010-10-11 to\n\t * 2012-02-01.  Given an ASCII string of any length and length limit 1,\n\t * affected systems ignore the length limit and modify a number of bytes\n\t * one less than the return value.  The problem inputs for this bug do not\n\t * overlap those for the Solaris bug, hence a distinct test.\n\t *\n\t * Affected systems include smartos-20110926T021612Z.  Affected locales\n\t * include en_US.ISO8859-1 and en_US.UTF-8.  Unaffected locales include C.\n\t */\n\tbuf[1] = canary;\n\t(void) strxfrm(buf, \"a\", 1);\n\tif (buf[1] != canary)\n\t\tok = false;\n\n\tif (!ok)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYSTEM_ERROR),\n\t\t\t\t errmsg_internal(\"strxfrm(), in locale \\\"%s\\\", writes past the specified array length\",\n\t\t\t\t\t\t\t\t setlocale(LC_COLLATE, NULL)),\n\t\t\t\t errhint(\"Apply system library package updates.\")));\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nvoid\ncheck_strxfrm_bug(void)\n{\n\tchar\t\tbuf[32];\n\tconst int\tcanary = 0x7F;\n\tbool\t\tok = true;\n\n\t/*\n\t * Given a two-byte ASCII string and length limit 7, 8 or 9, Solaris 10\n\t * 05/08 returns 18 and modifies 10 bytes.  It respects limits above or\n\t * below that range.\n\t *\n\t * The bug is present in Solaris 8 as well; it is absent in Solaris 10\n\t * 01/13 and Solaris 11.2.  Affected locales include is_IS.ISO8859-1,\n\t * en_US.UTF-8, en_US.ISO8859-1, and ru_RU.KOI8-R.  Unaffected locales\n\t * include de_DE.UTF-8, de_DE.ISO8859-1, zh_TW.UTF-8, and C.\n\t */\n\tbuf[7] = canary;\n\t(void) strxfrm(buf, \"ab\", 7);\n\tif (buf[7] != canary)\n\t\tok = false;\n\n\t/*\n\t * illumos bug #1594 was present in the source tree from 2010-10-11 to\n\t * 2012-02-01.  Given an ASCII string of any length and length limit 1,\n\t * affected systems ignore the length limit and modify a number of bytes\n\t * one less than the return value.  The problem inputs for this bug do not\n\t * overlap those for the Solaris bug, hence a distinct test.\n\t *\n\t * Affected systems include smartos-20110926T021612Z.  Affected locales\n\t * include en_US.ISO8859-1 and en_US.UTF-8.  Unaffected locales include C.\n\t */\n\tbuf[1] = canary;\n\t(void) strxfrm(buf, \"a\", 1);\n\tif (buf[1] != canary)\n\t\tok = false;\n\n\tif (!ok)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYSTEM_ERROR),\n\t\t\t\t errmsg_internal(\"strxfrm(), in locale \\\"%s\\\", writes past the specified array length\",\n\t\t\t\t\t\t\t\t setlocale(LC_COLLATE, NULL)),\n\t\t\t\t errhint(\"Apply system library package updates.\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetConfigOption",
          "args": [
            "\"lc_ctype\"",
            "ctype",
            "PGC_INTERNAL",
            "PGC_S_OVERRIDE"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "SetConfigOption",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "6930-6936",
          "snippet": "void\nSetConfigOption(const char *name, const char *value,\n\t\t\t\tGucContext context, GucSource source)\n{\n\t(void) set_config_option(name, value, context, source,\n\t\t\t\t\t\t\t GUC_ACTION_SET, true, 0, false);\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool check_log_destination(char **newval, void **extra, GucSource source);",
            "static bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);",
            "static bool check_client_min_messages(int *newval, void **extra, GucSource source);",
            "static bool check_temp_buffers(int *newval, void **extra, GucSource source);",
            "static bool check_bonjour(bool *newval, void **extra, GucSource source);",
            "static bool check_ssl(bool *newval, void **extra, GucSource source);",
            "static bool check_stage_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_canonical_path(char **newval, void **extra, GucSource source);",
            "static bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);",
            "static bool check_maxconnections(int *newval, void **extra, GucSource source);",
            "static bool check_max_worker_processes(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);",
            "static bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);",
            "static bool check_application_name(char **newval, void **extra, GucSource source);",
            "static bool check_cluster_name(char **newval, void **extra, GucSource source);",
            "static void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool check_log_destination(char **newval, void **extra, GucSource source);\nstatic bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);\nstatic bool check_client_min_messages(int *newval, void **extra, GucSource source);\nstatic bool check_temp_buffers(int *newval, void **extra, GucSource source);\nstatic bool check_bonjour(bool *newval, void **extra, GucSource source);\nstatic bool check_ssl(bool *newval, void **extra, GucSource source);\nstatic bool check_stage_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_canonical_path(char **newval, void **extra, GucSource source);\nstatic bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);\nstatic bool check_maxconnections(int *newval, void **extra, GucSource source);\nstatic bool check_max_worker_processes(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);\nstatic bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);\nstatic bool check_application_name(char **newval, void **extra, GucSource source);\nstatic bool check_cluster_name(char **newval, void **extra, GucSource source);\nstatic void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);\n\nvoid\nSetConfigOption(const char *name, const char *value,\n\t\t\t\tGucContext context, GucSource source)\n{\n\t(void) set_config_option(name, value, context, source,\n\t\t\t\t\t\t\t GUC_ACTION_SET, true, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errmsg(\"database locale is incompatible with operating system\"),\n\t\t\t\t errdetail(\"The database was initialized with LC_CTYPE \\\"%s\\\", \"\n\t\t\t\t\t\t   \" which is not recognized by setlocale().\", ctype),\n\t\t\t\t errhint(\"Recreate the database with another locale or install the missing locale.\"))"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Recreate the database with another locale or install the missing locale.\""
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"The database was initialized with LC_CTYPE \\\"%s\\\", \"\n\t\t\t\t\t\t   \" which is not recognized by setlocale().\"",
            "ctype"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"database locale is incompatible with operating system\""
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_perm_setlocale",
          "args": [
            "LC_CTYPE",
            "ctype"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "pg_perm_setlocale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "151-251",
          "snippet": "char *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)"
          ],
          "globals_used": [
            "static char lc_collate_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_ctype_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_monetary_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_numeric_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_time_envbuf[LC_ENV_BUFSIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\n#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)\n\nstatic char lc_collate_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_ctype_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_monetary_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_numeric_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_time_envbuf[LC_ENV_BUFSIZE];\n\nchar *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errmsg(\"database locale is incompatible with operating system\"),\n\t\t\t\t errdetail(\"The database was initialized with LC_COLLATE \\\"%s\\\", \"\n\t\t\t\t\t\t   \" which is not recognized by setlocale().\", collate),\n\t\t\t\t errhint(\"Recreate the database with another locale or install the missing locale.\"))"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "dbform->datctype"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "dbform->datcollate"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncodingName",
          "args": [],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetDatabaseEncoding",
          "args": [
            "dbform->encoding"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "SetDatabaseEncoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "897-905",
          "snippet": "void\nSetDatabaseEncoding(int encoding)\n{\n\tif (!PG_VALID_BE_ENCODING(encoding))\n\t\telog(ERROR, \"invalid database encoding: %d\", encoding);\n\n\tDatabaseEncoding = &pg_enc2name_tbl[encoding];\n\tAssert(DatabaseEncoding->encoding == encoding);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nvoid\nSetDatabaseEncoding(int encoding)\n{\n\tif (!PG_VALID_BE_ENCODING(encoding))\n\t\telog(ERROR, \"invalid database encoding: %d\", encoding);\n\n\tDatabaseEncoding = &pg_enc2name_tbl[encoding];\n\tAssert(DatabaseEncoding->encoding == encoding);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"too many connections for database \\\"%s\\\"\",\n\t\t\t\t\t\t\tname))"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_TOO_MANY_CONNECTIONS"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "CountDBConnections",
          "args": [
            "MyDatabaseId"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"permission denied for database \\\"%s\\\"\", name),\n\t\t\t\t\t errdetail(\"User does not have CONNECT privilege.\"))"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_database_aclcheck",
          "args": [
            "MyDatabaseId",
            "GetUserId()",
            "ACL_CONNECT"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t errmsg(\"database \\\"%s\\\" is not currently accepting connections\",\n\t\t\t\t\t\t\tname))"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAutoVacuumWorkerProcess",
          "args": [],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t errmsg(\"database \\\"%s\\\" has disappeared from pg_database\",\n\t\t\t\t\t\tname),\n\t\t\t\t errdetail(\"Database OID %u now seems to belong to \\\"%s\\\".\",\n\t\t\t\t\t\t   MyDatabaseId, NameStr(dbform->datname)))"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "dbform->datname"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "NameStr(dbform->datname)"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "dbform->datname"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tup"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for database %u\"",
            "MyDatabaseId"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tup"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "DATABASEOID",
            "ObjectIdGetDatum(MyDatabaseId)"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "MyDatabaseId"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void CheckMyDatabase(const char *name, bool am_superuser, bool override_allow_connections);\nstatic void process_startup_options(Port *port, bool am_superuser);\n\nstatic void\nCheckMyDatabase(const char *name, bool am_superuser, bool override_allow_connections)\n{\n\tHeapTuple\ttup;\n\tForm_pg_database dbform;\n\tchar\t   *collate;\n\tchar\t   *ctype;\n\n\t/* Fetch our pg_database row normally, via syscache */\n\ttup = SearchSysCache1(DATABASEOID, ObjectIdGetDatum(MyDatabaseId));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for database %u\", MyDatabaseId);\n\tdbform = (Form_pg_database) GETSTRUCT(tup);\n\n\t/* This recheck is strictly paranoia */\n\tif (strcmp(name, NameStr(dbform->datname)) != 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t errmsg(\"database \\\"%s\\\" has disappeared from pg_database\",\n\t\t\t\t\t\tname),\n\t\t\t\t errdetail(\"Database OID %u now seems to belong to \\\"%s\\\".\",\n\t\t\t\t\t\t   MyDatabaseId, NameStr(dbform->datname))));\n\n\t/*\n\t * Check permissions to connect to the database.\n\t *\n\t * These checks are not enforced when in standalone mode, so that there is\n\t * a way to recover from disabling all access to all databases, for\n\t * example \"UPDATE pg_database SET datallowconn = false;\".\n\t *\n\t * We do not enforce them for autovacuum worker processes either.\n\t */\n\tif (IsUnderPostmaster && !IsAutoVacuumWorkerProcess())\n\t{\n\t\t/*\n\t\t * Check that the database is currently allowing connections.\n\t\t */\n\t\tif (!dbform->datallowconn && !override_allow_connections)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t errmsg(\"database \\\"%s\\\" is not currently accepting connections\",\n\t\t\t\t\t\t\tname)));\n\n\t\t/*\n\t\t * Check privilege to connect to the database.  (The am_superuser test\n\t\t * is redundant, but since we have the flag, might as well check it\n\t\t * and save a few cycles.)\n\t\t */\n\t\tif (!am_superuser &&\n\t\t\tpg_database_aclcheck(MyDatabaseId, GetUserId(),\n\t\t\t\t\t\t\t\t ACL_CONNECT) != ACLCHECK_OK)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"permission denied for database \\\"%s\\\"\", name),\n\t\t\t\t\t errdetail(\"User does not have CONNECT privilege.\")));\n\n\t\t/*\n\t\t * Check connection limit for this database.\n\t\t *\n\t\t * There is a race condition here --- we create our PGPROC before\n\t\t * checking for other PGPROCs.  If two backends did this at about the\n\t\t * same time, they might both think they were over the limit, while\n\t\t * ideally one should succeed and one fail.  Getting that to work\n\t\t * exactly seems more trouble than it is worth, however; instead we\n\t\t * just document that the connection limit is approximate.\n\t\t */\n\t\tif (dbform->datconnlimit >= 0 &&\n\t\t\t!am_superuser &&\n\t\t\tCountDBConnections(MyDatabaseId) > dbform->datconnlimit)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"too many connections for database \\\"%s\\\"\",\n\t\t\t\t\t\t\tname)));\n\t}\n\n\t/*\n\t * OK, we're golden.  Next to-do item is to save the encoding info out of\n\t * the pg_database tuple.\n\t */\n\tSetDatabaseEncoding(dbform->encoding);\n\t/* Record it as a GUC internal option, too */\n\tSetConfigOption(\"server_encoding\", GetDatabaseEncodingName(),\n\t\t\t\t\tPGC_INTERNAL, PGC_S_OVERRIDE);\n\t/* If we have no other source of client_encoding, use server encoding */\n\tSetConfigOption(\"client_encoding\", GetDatabaseEncodingName(),\n\t\t\t\t\tPGC_BACKEND, PGC_S_DYNAMIC_DEFAULT);\n\n\t/* assign locale variables */\n\tcollate = NameStr(dbform->datcollate);\n\tctype = NameStr(dbform->datctype);\n\n\tif (pg_perm_setlocale(LC_COLLATE, collate) == NULL)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"database locale is incompatible with operating system\"),\n\t\t\t\t errdetail(\"The database was initialized with LC_COLLATE \\\"%s\\\", \"\n\t\t\t\t\t\t   \" which is not recognized by setlocale().\", collate),\n\t\t\t\t errhint(\"Recreate the database with another locale or install the missing locale.\")));\n\n\tif (pg_perm_setlocale(LC_CTYPE, ctype) == NULL)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"database locale is incompatible with operating system\"),\n\t\t\t\t errdetail(\"The database was initialized with LC_CTYPE \\\"%s\\\", \"\n\t\t\t\t\t\t   \" which is not recognized by setlocale().\", ctype),\n\t\t\t\t errhint(\"Recreate the database with another locale or install the missing locale.\")));\n\n\t/* Make the locale settings visible as GUC variables, too */\n\tSetConfigOption(\"lc_collate\", collate, PGC_INTERNAL, PGC_S_OVERRIDE);\n\tSetConfigOption(\"lc_ctype\", ctype, PGC_INTERNAL, PGC_S_OVERRIDE);\n\n\tcheck_strxfrm_bug();\n\n\tReleaseSysCache(tup);\n}"
  },
  {
    "function_name": "PerformAuthentication",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
    "lines": "183-286",
    "snippet": "static void\nPerformAuthentication(Port *port)\n{\n\t/* This should be set already, but let's make sure */\n\tClientAuthInProgress = true;\t/* limit visibility of log messages */\n\n\t/*\n\t * In EXEC_BACKEND case, we didn't inherit the contents of pg_hba.conf\n\t * etcetera from the postmaster, and have to load them ourselves.\n\t *\n\t * FIXME: [fork/exec] Ugh.  Is there a way around this overhead?\n\t */\n#ifdef EXEC_BACKEND\n\n\t/*\n\t * load_hba() and load_ident() want to work within the PostmasterContext,\n\t * so create that if it doesn't exist (which it won't).  We'll delete it\n\t * again later, in PostgresMain.\n\t */\n\tif (PostmasterContext == NULL)\n\t\tPostmasterContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"Postmaster\",\n\t\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\n\tif (!load_hba())\n\t{\n\t\t/*\n\t\t * It makes no sense to continue if we fail to load the HBA file,\n\t\t * since there is no way to connect to the database in this case.\n\t\t */\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"could not load pg_hba.conf\")));\n\t}\n\n\tif (!load_ident())\n\t{\n\t\t/*\n\t\t * It is ok to continue if we fail to load the IDENT file, although it\n\t\t * means that you cannot log in using any of the authentication\n\t\t * methods that need a user name mapping. load_ident() already logged\n\t\t * the details of error to the log.\n\t\t */\n\t}\n#endif\n\n\t/*\n\t * Set up a timeout in case a buggy or malicious client fails to respond\n\t * during authentication.  Since we're inside a transaction and might do\n\t * database access, we have to use the statement_timeout infrastructure.\n\t */\n\tenable_timeout_after(STATEMENT_TIMEOUT, AuthenticationTimeout * 1000);\n\n\t/*\n\t * Now perform authentication exchange.\n\t */\n\tClientAuthentication(port); /* might not return, if failure */\n\n\t/*\n\t * Done with authentication.  Disable the timeout, and log if needed.\n\t */\n\tdisable_timeout(STATEMENT_TIMEOUT, false);\n\n\tif (Log_connections)\n\t{\n\t\tif (am_walsender)\n\t\t{\n#ifdef USE_SSL\n\t\t\tif (port->ssl_in_use)\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"replication connection authorized: user=%s SSL enabled (protocol=%s, cipher=%s, bits=%d, compression=%s)\",\n\t\t\t\t\t\t\t\tport->user_name,\n\t\t\t\t\t\t\t\tbe_tls_get_version(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher_bits(port),\n\t\t\t\t\t\t\t\tbe_tls_get_compression(port) ? _(\"on\") : _(\"off\"))));\n\t\t\telse\n#endif\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"replication connection authorized: user=%s\",\n\t\t\t\t\t\t\t\tport->user_name)));\n\t\t}\n\t\telse\n\t\t{\n#ifdef USE_SSL\n\t\t\tif (port->ssl_in_use)\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"connection authorized: user=%s database=%s SSL enabled (protocol=%s, cipher=%s, bits=%d, compression=%s)\",\n\t\t\t\t\t\t\t\tport->user_name, port->database_name,\n\t\t\t\t\t\t\t\tbe_tls_get_version(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher_bits(port),\n\t\t\t\t\t\t\t\tbe_tls_get_compression(port) ? _(\"on\") : _(\"off\"))));\n\t\t\telse\n#endif\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"connection authorized: user=%s database=%s\",\n\t\t\t\t\t\t\t\tport->user_name, port->database_name)));\n\t\t}\n\t}\n\n\tset_ps_display(\"startup\", false);\n\n\tClientAuthInProgress = false;\t/* client_min_messages is active now */\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"utils/portal.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/procsignal.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"replication/walsender.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq-be.h\"",
      "#include \"libpq/auth.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_db_role_setting.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/session.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PerformAuthentication(Port *port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ps_display",
          "args": [
            "\"startup\"",
            "false"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "set_ps_display",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/ps_status.c",
          "lines": "325-395",
          "snippet": "void\nset_ps_display(const char *activity, bool force)\n{\n#ifndef PS_USE_NONE\n\t/* update_process_title=off disables updates, unless force = true */\n\tif (!force && !update_process_title)\n\t\treturn;\n\n\t/* no ps display for stand-alone backend */\n\tif (!IsUnderPostmaster)\n\t\treturn;\n\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* If ps_buffer is a pointer, it might still be null */\n\tif (!ps_buffer)\n\t\treturn;\n#endif\n\n\t/* Update ps_buffer to contain both fixed part and activity */\n\tstrlcpy(ps_buffer + ps_buffer_fixed_size, activity,\n\t\t\tps_buffer_size - ps_buffer_fixed_size);\n\tps_buffer_cur_len = strlen(ps_buffer);\n\n\t/* Transmit new setting to kernel, if necessary */\n\n#ifdef PS_USE_SETPROCTITLE\n\tsetproctitle(\"%s\", ps_buffer);\n#endif\n\n#ifdef PS_USE_PSTAT\n\t{\n\t\tunion pstun pst;\n\n\t\tpst.pst_command = ps_buffer;\n\t\tpstat(PSTAT_SETCMD, pst, ps_buffer_cur_len, 0, 0);\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_PSTAT */\n\n#ifdef PS_USE_PS_STRINGS\n\tPS_STRINGS->ps_nargvstr = 1;\n\tPS_STRINGS->ps_argvstr = ps_buffer;\n#endif\t\t\t\t\t\t\t/* PS_USE_PS_STRINGS */\n\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* pad unused memory; need only clobber remainder of old status string */\n\tif (last_status_len > ps_buffer_cur_len)\n\t\tMemSet(ps_buffer + ps_buffer_cur_len, PS_PADDING,\n\t\t\t   last_status_len - ps_buffer_cur_len);\n\tlast_status_len = ps_buffer_cur_len;\n#endif\t\t\t\t\t\t\t/* PS_USE_CLOBBER_ARGV */\n\n#ifdef PS_USE_WIN32\n\t{\n\t\t/*\n\t\t * Win32 does not support showing any changed arguments. To make it at\n\t\t * all possible to track which backend is doing what, we create a\n\t\t * named object that can be viewed with for example Process Explorer.\n\t\t */\n\t\tstatic HANDLE ident_handle = INVALID_HANDLE_VALUE;\n\t\tchar\t\tname[PS_BUFFER_SIZE + 32];\n\n\t\tif (ident_handle != INVALID_HANDLE_VALUE)\n\t\t\tCloseHandle(ident_handle);\n\n\t\tsprintf(name, \"pgident(%d): %s\", MyProcPid, ps_buffer);\n\n\t\tident_handle = CreateEvent(NULL, TRUE, FALSE, name);\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_WIN32 */\n#endif\t\t\t\t\t\t\t/* not PS_USE_NONE */\n}",
          "includes": [
            "#include \"utils/guc.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/libpq.h\"",
            "#include <crt_externs.h>",
            "#include <sys/exec.h>",
            "#include <machine/vmparam.h>\t/* for old BSD */",
            "#include <sys/pstat.h>\t\t\t/* for HP-UX */",
            "#include <unistd.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PS_BUFFER_SIZE 256",
            "#define PS_PADDING ' '",
            "#define PS_PADDING '\\0'",
            "#define PS_USE_NONE",
            "#define PS_USE_WIN32",
            "#define PS_USE_CLOBBER_ARGV",
            "#define PS_USE_PS_STRINGS",
            "#define PS_USE_PSTAT",
            "#define PS_USE_SETPROCTITLE"
          ],
          "globals_used": [
            "bool\t\tupdate_process_title = true;",
            "static size_t ps_buffer_cur_len;",
            "static size_t ps_buffer_fixed_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/guc.h\"\n#include \"utils/ps_status.h\"\n#include \"miscadmin.h\"\n#include \"libpq/libpq.h\"\n#include <crt_externs.h>\n#include <sys/exec.h>\n#include <machine/vmparam.h>\t/* for old BSD */\n#include <sys/pstat.h>\t\t\t/* for HP-UX */\n#include <unistd.h>\n#include \"postgres.h\"\n\n#define PS_BUFFER_SIZE 256\n#define PS_PADDING ' '\n#define PS_PADDING '\\0'\n#define PS_USE_NONE\n#define PS_USE_WIN32\n#define PS_USE_CLOBBER_ARGV\n#define PS_USE_PS_STRINGS\n#define PS_USE_PSTAT\n#define PS_USE_SETPROCTITLE\n\nbool\t\tupdate_process_title = true;\nstatic size_t ps_buffer_cur_len;\nstatic size_t ps_buffer_fixed_size;\n\nvoid\nset_ps_display(const char *activity, bool force)\n{\n#ifndef PS_USE_NONE\n\t/* update_process_title=off disables updates, unless force = true */\n\tif (!force && !update_process_title)\n\t\treturn;\n\n\t/* no ps display for stand-alone backend */\n\tif (!IsUnderPostmaster)\n\t\treturn;\n\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* If ps_buffer is a pointer, it might still be null */\n\tif (!ps_buffer)\n\t\treturn;\n#endif\n\n\t/* Update ps_buffer to contain both fixed part and activity */\n\tstrlcpy(ps_buffer + ps_buffer_fixed_size, activity,\n\t\t\tps_buffer_size - ps_buffer_fixed_size);\n\tps_buffer_cur_len = strlen(ps_buffer);\n\n\t/* Transmit new setting to kernel, if necessary */\n\n#ifdef PS_USE_SETPROCTITLE\n\tsetproctitle(\"%s\", ps_buffer);\n#endif\n\n#ifdef PS_USE_PSTAT\n\t{\n\t\tunion pstun pst;\n\n\t\tpst.pst_command = ps_buffer;\n\t\tpstat(PSTAT_SETCMD, pst, ps_buffer_cur_len, 0, 0);\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_PSTAT */\n\n#ifdef PS_USE_PS_STRINGS\n\tPS_STRINGS->ps_nargvstr = 1;\n\tPS_STRINGS->ps_argvstr = ps_buffer;\n#endif\t\t\t\t\t\t\t/* PS_USE_PS_STRINGS */\n\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* pad unused memory; need only clobber remainder of old status string */\n\tif (last_status_len > ps_buffer_cur_len)\n\t\tMemSet(ps_buffer + ps_buffer_cur_len, PS_PADDING,\n\t\t\t   last_status_len - ps_buffer_cur_len);\n\tlast_status_len = ps_buffer_cur_len;\n#endif\t\t\t\t\t\t\t/* PS_USE_CLOBBER_ARGV */\n\n#ifdef PS_USE_WIN32\n\t{\n\t\t/*\n\t\t * Win32 does not support showing any changed arguments. To make it at\n\t\t * all possible to track which backend is doing what, we create a\n\t\t * named object that can be viewed with for example Process Explorer.\n\t\t */\n\t\tstatic HANDLE ident_handle = INVALID_HANDLE_VALUE;\n\t\tchar\t\tname[PS_BUFFER_SIZE + 32];\n\n\t\tif (ident_handle != INVALID_HANDLE_VALUE)\n\t\t\tCloseHandle(ident_handle);\n\n\t\tsprintf(name, \"pgident(%d): %s\", MyProcPid, ps_buffer);\n\n\t\tident_handle = CreateEvent(NULL, TRUE, FALSE, name);\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_WIN32 */\n#endif\t\t\t\t\t\t\t/* not PS_USE_NONE */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "LOG",
            "(errmsg(\"connection authorized: user=%s database=%s\",\n\t\t\t\t\t\t\t\tport->user_name, port->database_name))"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"connection authorized: user=%s database=%s\"",
            "port->user_name",
            "port->database_name"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "LOG",
            "(errmsg(\"connection authorized: user=%s database=%s SSL enabled (protocol=%s, cipher=%s, bits=%d, compression=%s)\",\n\t\t\t\t\t\t\t\tport->user_name, port->database_name,\n\t\t\t\t\t\t\t\tbe_tls_get_version(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher_bits(port),\n\t\t\t\t\t\t\t\tbe_tls_get_compression(port) ? _(\"on\") : _(\"off\")))"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"off\""
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "pg_bindtextdomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "1606-1619",
          "snippet": "void\npg_bindtextdomain(const char *domain)\n{\n#ifdef ENABLE_NLS\n\tif (my_exec_path[0] != '\\0')\n\t{\n\t\tchar\t\tlocale_path[MAXPGPATH];\n\n\t\tget_locale_path(my_exec_path, locale_path);\n\t\tbindtextdomain(domain, locale_path);\n\t\tpg_bind_textdomain_codeset(domain);\n\t}\n#endif\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nvoid\npg_bindtextdomain(const char *domain)\n{\n#ifdef ENABLE_NLS\n\tif (my_exec_path[0] != '\\0')\n\t{\n\t\tchar\t\tlocale_path[MAXPGPATH];\n\n\t\tget_locale_path(my_exec_path, locale_path);\n\t\tbindtextdomain(domain, locale_path);\n\t\tpg_bind_textdomain_codeset(domain);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "be_tls_get_compression",
          "args": [
            "port"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be_tls_get_cipher_bits",
          "args": [
            "port"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be_tls_get_cipher",
          "args": [
            "port"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be_tls_get_version",
          "args": [
            "port"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "LOG",
            "(errmsg(\"replication connection authorized: user=%s\",\n\t\t\t\t\t\t\t\tport->user_name))"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "LOG",
            "(errmsg(\"replication connection authorized: user=%s SSL enabled (protocol=%s, cipher=%s, bits=%d, compression=%s)\",\n\t\t\t\t\t\t\t\tport->user_name,\n\t\t\t\t\t\t\t\tbe_tls_get_version(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher_bits(port),\n\t\t\t\t\t\t\t\tbe_tls_get_compression(port) ? _(\"on\") : _(\"off\")))"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be_tls_get_compression",
          "args": [
            "port"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be_tls_get_cipher_bits",
          "args": [
            "port"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be_tls_get_cipher",
          "args": [
            "port"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be_tls_get_version",
          "args": [
            "port"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_timeout",
          "args": [
            "STATEMENT_TIMEOUT",
            "false"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "disable_timeouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "560-589",
          "snippet": "void\ndisable_timeouts(const DisableTimeoutParams *timeouts, int count)\n{\n\tint\t\t\ti;\n\n\tAssert(all_timeouts_initialized);\n\n\t/* Disable timeout interrupts for safety. */\n\tdisable_alarm();\n\n\t/* Cancel the timeout(s). */\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tTimeoutId\tid = timeouts[i].id;\n\t\tint\t\t\tidx;\n\n\t\tAssert(all_timeouts[id].timeout_handler != NULL);\n\n\t\tidx = find_active_timeout(id);\n\t\tif (idx >= 0)\n\t\t\tremove_timeout_index(idx);\n\n\t\tif (!timeouts[i].keep_indicator)\n\t\t\tall_timeouts[id].indicator = false;\n\t}\n\n\t/* Reschedule the interrupt, if any timeouts remain active. */\n\tif (num_active_timeouts > 0)\n\t\tschedule_alarm(GetCurrentTimestamp());\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static timeout_params all_timeouts[MAX_TIMEOUTS];",
            "static bool all_timeouts_initialized = false;",
            "static volatile int num_active_timeouts = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic timeout_params all_timeouts[MAX_TIMEOUTS];\nstatic bool all_timeouts_initialized = false;\nstatic volatile int num_active_timeouts = 0;\n\nvoid\ndisable_timeouts(const DisableTimeoutParams *timeouts, int count)\n{\n\tint\t\t\ti;\n\n\tAssert(all_timeouts_initialized);\n\n\t/* Disable timeout interrupts for safety. */\n\tdisable_alarm();\n\n\t/* Cancel the timeout(s). */\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tTimeoutId\tid = timeouts[i].id;\n\t\tint\t\t\tidx;\n\n\t\tAssert(all_timeouts[id].timeout_handler != NULL);\n\n\t\tidx = find_active_timeout(id);\n\t\tif (idx >= 0)\n\t\t\tremove_timeout_index(idx);\n\n\t\tif (!timeouts[i].keep_indicator)\n\t\t\tall_timeouts[id].indicator = false;\n\t}\n\n\t/* Reschedule the interrupt, if any timeouts remain active. */\n\tif (num_active_timeouts > 0)\n\t\tschedule_alarm(GetCurrentTimestamp());\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClientAuthentication",
          "args": [
            "port"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enable_timeout_after",
          "args": [
            "STATEMENT_TIMEOUT",
            "AuthenticationTimeout * 1000"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "enable_timeout_after",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "427-443",
          "snippet": "void\nenable_timeout_after(TimeoutId id, int delay_ms)\n{\n\tTimestampTz now;\n\tTimestampTz fin_time;\n\n\t/* Disable timeout interrupts for safety. */\n\tdisable_alarm();\n\n\t/* Queue the timeout at the appropriate time. */\n\tnow = GetCurrentTimestamp();\n\tfin_time = TimestampTzPlusMilliseconds(now, delay_ms);\n\tenable_timeout(id, now, fin_time);\n\n\t/* Set the timer interrupt. */\n\tschedule_alarm(now);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nvoid\nenable_timeout_after(TimeoutId id, int delay_ms)\n{\n\tTimestampTz now;\n\tTimestampTz fin_time;\n\n\t/* Disable timeout interrupts for safety. */\n\tdisable_alarm();\n\n\t/* Queue the timeout at the appropriate time. */\n\tnow = GetCurrentTimestamp();\n\tfin_time = TimestampTzPlusMilliseconds(now, delay_ms);\n\tenable_timeout(id, now, fin_time);\n\n\t/* Set the timer interrupt. */\n\tschedule_alarm(now);\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_ident",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errmsg(\"could not load pg_hba.conf\"))"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_hba",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "TopMemoryContext",
            "\"Postmaster\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void PerformAuthentication(Port *port);\n\nstatic void\nPerformAuthentication(Port *port)\n{\n\t/* This should be set already, but let's make sure */\n\tClientAuthInProgress = true;\t/* limit visibility of log messages */\n\n\t/*\n\t * In EXEC_BACKEND case, we didn't inherit the contents of pg_hba.conf\n\t * etcetera from the postmaster, and have to load them ourselves.\n\t *\n\t * FIXME: [fork/exec] Ugh.  Is there a way around this overhead?\n\t */\n#ifdef EXEC_BACKEND\n\n\t/*\n\t * load_hba() and load_ident() want to work within the PostmasterContext,\n\t * so create that if it doesn't exist (which it won't).  We'll delete it\n\t * again later, in PostgresMain.\n\t */\n\tif (PostmasterContext == NULL)\n\t\tPostmasterContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"Postmaster\",\n\t\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\n\tif (!load_hba())\n\t{\n\t\t/*\n\t\t * It makes no sense to continue if we fail to load the HBA file,\n\t\t * since there is no way to connect to the database in this case.\n\t\t */\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"could not load pg_hba.conf\")));\n\t}\n\n\tif (!load_ident())\n\t{\n\t\t/*\n\t\t * It is ok to continue if we fail to load the IDENT file, although it\n\t\t * means that you cannot log in using any of the authentication\n\t\t * methods that need a user name mapping. load_ident() already logged\n\t\t * the details of error to the log.\n\t\t */\n\t}\n#endif\n\n\t/*\n\t * Set up a timeout in case a buggy or malicious client fails to respond\n\t * during authentication.  Since we're inside a transaction and might do\n\t * database access, we have to use the statement_timeout infrastructure.\n\t */\n\tenable_timeout_after(STATEMENT_TIMEOUT, AuthenticationTimeout * 1000);\n\n\t/*\n\t * Now perform authentication exchange.\n\t */\n\tClientAuthentication(port); /* might not return, if failure */\n\n\t/*\n\t * Done with authentication.  Disable the timeout, and log if needed.\n\t */\n\tdisable_timeout(STATEMENT_TIMEOUT, false);\n\n\tif (Log_connections)\n\t{\n\t\tif (am_walsender)\n\t\t{\n#ifdef USE_SSL\n\t\t\tif (port->ssl_in_use)\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"replication connection authorized: user=%s SSL enabled (protocol=%s, cipher=%s, bits=%d, compression=%s)\",\n\t\t\t\t\t\t\t\tport->user_name,\n\t\t\t\t\t\t\t\tbe_tls_get_version(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher_bits(port),\n\t\t\t\t\t\t\t\tbe_tls_get_compression(port) ? _(\"on\") : _(\"off\"))));\n\t\t\telse\n#endif\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"replication connection authorized: user=%s\",\n\t\t\t\t\t\t\t\tport->user_name)));\n\t\t}\n\t\telse\n\t\t{\n#ifdef USE_SSL\n\t\t\tif (port->ssl_in_use)\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"connection authorized: user=%s database=%s SSL enabled (protocol=%s, cipher=%s, bits=%d, compression=%s)\",\n\t\t\t\t\t\t\t\tport->user_name, port->database_name,\n\t\t\t\t\t\t\t\tbe_tls_get_version(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher(port),\n\t\t\t\t\t\t\t\tbe_tls_get_cipher_bits(port),\n\t\t\t\t\t\t\t\tbe_tls_get_compression(port) ? _(\"on\") : _(\"off\"))));\n\t\t\telse\n#endif\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"connection authorized: user=%s database=%s\",\n\t\t\t\t\t\t\t\tport->user_name, port->database_name)));\n\t\t}\n\t}\n\n\tset_ps_display(\"startup\", false);\n\n\tClientAuthInProgress = false;\t/* client_min_messages is active now */\n}"
  },
  {
    "function_name": "GetDatabaseTupleByOid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
    "lines": "137-175",
    "snippet": "static HeapTuple\nGetDatabaseTupleByOid(Oid dboid)\n{\n\tHeapTuple\ttuple;\n\tRelation\trelation;\n\tSysScanDesc scan;\n\tScanKeyData key[1];\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(dboid));\n\n\t/*\n\t * Open pg_database and fetch a tuple.  Force heap scan if we haven't yet\n\t * built the critical shared relcache entries (i.e., we're starting up\n\t * without a shared relcache cache file).\n\t */\n\trelation = heap_open(DatabaseRelationId, AccessShareLock);\n\tscan = systable_beginscan(relation, DatabaseOidIndexId,\n\t\t\t\t\t\t\t  criticalSharedRelcachesBuilt,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  1, key);\n\n\ttuple = systable_getnext(scan);\n\n\t/* Must copy tuple before releasing buffer */\n\tif (HeapTupleIsValid(tuple))\n\t\ttuple = heap_copytuple(tuple);\n\n\t/* all done */\n\tsystable_endscan(scan);\n\theap_close(relation, AccessShareLock);\n\n\treturn tuple;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"utils/portal.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/procsignal.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"replication/walsender.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq-be.h\"",
      "#include \"libpq/auth.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_db_role_setting.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/session.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HeapTuple GetDatabaseTupleByOid(Oid dboid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "relation",
            "AccessShareLock"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "scan"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_copytuple",
          "args": [
            "tuple"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "scan"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "relation",
            "DatabaseOidIndexId",
            "criticalSharedRelcachesBuilt",
            "NULL",
            "1",
            "key"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "DatabaseRelationId",
            "AccessShareLock"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&key[0]",
            "ObjectIdAttributeNumber",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(dboid)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "dboid"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic HeapTuple GetDatabaseTupleByOid(Oid dboid);\n\nstatic HeapTuple\nGetDatabaseTupleByOid(Oid dboid)\n{\n\tHeapTuple\ttuple;\n\tRelation\trelation;\n\tSysScanDesc scan;\n\tScanKeyData key[1];\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(dboid));\n\n\t/*\n\t * Open pg_database and fetch a tuple.  Force heap scan if we haven't yet\n\t * built the critical shared relcache entries (i.e., we're starting up\n\t * without a shared relcache cache file).\n\t */\n\trelation = heap_open(DatabaseRelationId, AccessShareLock);\n\tscan = systable_beginscan(relation, DatabaseOidIndexId,\n\t\t\t\t\t\t\t  criticalSharedRelcachesBuilt,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  1, key);\n\n\ttuple = systable_getnext(scan);\n\n\t/* Must copy tuple before releasing buffer */\n\tif (HeapTupleIsValid(tuple))\n\t\ttuple = heap_copytuple(tuple);\n\n\t/* all done */\n\tsystable_endscan(scan);\n\theap_close(relation, AccessShareLock);\n\n\treturn tuple;\n}"
  },
  {
    "function_name": "GetDatabaseTuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/postinit.c",
    "lines": "94-132",
    "snippet": "static HeapTuple\nGetDatabaseTuple(const char *dbname)\n{\n\tHeapTuple\ttuple;\n\tRelation\trelation;\n\tSysScanDesc scan;\n\tScanKeyData key[1];\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key[0],\n\t\t\t\tAnum_pg_database_datname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\tCStringGetDatum(dbname));\n\n\t/*\n\t * Open pg_database and fetch a tuple.  Force heap scan if we haven't yet\n\t * built the critical shared relcache entries (i.e., we're starting up\n\t * without a shared relcache cache file).\n\t */\n\trelation = heap_open(DatabaseRelationId, AccessShareLock);\n\tscan = systable_beginscan(relation, DatabaseNameIndexId,\n\t\t\t\t\t\t\t  criticalSharedRelcachesBuilt,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  1, key);\n\n\ttuple = systable_getnext(scan);\n\n\t/* Must copy tuple before releasing buffer */\n\tif (HeapTupleIsValid(tuple))\n\t\ttuple = heap_copytuple(tuple);\n\n\t/* all done */\n\tsystable_endscan(scan);\n\theap_close(relation, AccessShareLock);\n\n\treturn tuple;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"utils/portal.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/procsignal.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"replication/walsender.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq-be.h\"",
      "#include \"libpq/auth.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_db_role_setting.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/session.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HeapTuple GetDatabaseTuple(const char *dbname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "relation",
            "AccessShareLock"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "scan"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_copytuple",
          "args": [
            "tuple"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "scan"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "relation",
            "DatabaseNameIndexId",
            "criticalSharedRelcachesBuilt",
            "NULL",
            "1",
            "key"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "DatabaseRelationId",
            "AccessShareLock"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&key[0]",
            "Anum_pg_database_datname",
            "BTEqualStrategyNumber",
            "F_NAMEEQ",
            "CStringGetDatum(dbname)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "dbname"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/timeout.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/proc.h\"\n#include \"storage/procsignal.h\"\n#include \"storage/procarray.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq-be.h\"\n#include \"libpq/auth.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/session.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic HeapTuple GetDatabaseTuple(const char *dbname);\n\nstatic HeapTuple\nGetDatabaseTuple(const char *dbname)\n{\n\tHeapTuple\ttuple;\n\tRelation\trelation;\n\tSysScanDesc scan;\n\tScanKeyData key[1];\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key[0],\n\t\t\t\tAnum_pg_database_datname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\tCStringGetDatum(dbname));\n\n\t/*\n\t * Open pg_database and fetch a tuple.  Force heap scan if we haven't yet\n\t * built the critical shared relcache entries (i.e., we're starting up\n\t * without a shared relcache cache file).\n\t */\n\trelation = heap_open(DatabaseRelationId, AccessShareLock);\n\tscan = systable_beginscan(relation, DatabaseNameIndexId,\n\t\t\t\t\t\t\t  criticalSharedRelcachesBuilt,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  1, key);\n\n\ttuple = systable_getnext(scan);\n\n\t/* Must copy tuple before releasing buffer */\n\tif (HeapTupleIsValid(tuple))\n\t\ttuple = heap_copytuple(tuple);\n\n\t/* all done */\n\tsystable_endscan(scan);\n\theap_close(relation, AccessShareLock);\n\n\treturn tuple;\n}"
  }
]