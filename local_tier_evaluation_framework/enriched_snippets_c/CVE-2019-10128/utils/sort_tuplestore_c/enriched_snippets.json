[
  {
    "function_name": "readtup_heap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "1535-1558",
    "snippet": "static void *\nreadtup_heap(Tuplestorestate *state, unsigned int len)\n{\n\tunsigned int tupbodylen = len - sizeof(int);\n\tunsigned int tuplen = tupbodylen + MINIMAL_TUPLE_DATA_OFFSET;\n\tMinimalTuple tuple = (MinimalTuple) palloc(tuplen);\n\tchar\t   *tupbody = (char *) tuple + MINIMAL_TUPLE_DATA_OFFSET;\n\n\tUSEMEM(state, GetMemoryChunkSpace(tuple));\n\t/* read in the tuple proper */\n\ttuple->t_len = tuplen;\n\tif (BufFileRead(state->myfile, (void *) tupbody,\n\t\t\t\t\ttupbodylen) != (size_t) tupbodylen)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from tuplestore temporary file: %m\")));\n\tif (state->backward)\t\t/* need trailing length word? */\n\t\tif (BufFileRead(state->myfile, (void *) &tuplen,\n\t\t\t\t\t\tsizeof(tuplen)) != sizeof(tuplen))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from tuplestore temporary file: %m\")));\n\treturn (void *) tuple;\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
      "static void dumptuples(Tuplestorestate *state);",
      "static void *readtup_heap(Tuplestorestate *state, unsigned int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from tuplestore temporary file: %m\"))"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not read from tuplestore temporary file: %m\""
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileRead",
          "args": [
            "state->myfile",
            "(void *) &tuplen",
            "sizeof(tuplen)"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from tuplestore temporary file: %m\"))"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileRead",
          "args": [
            "state->myfile",
            "(void *) tupbody",
            "tupbodylen"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(tuple)"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "tuple"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "tuplen"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\nstatic void *readtup_heap(Tuplestorestate *state, unsigned int len);\n\nstatic void *\nreadtup_heap(Tuplestorestate *state, unsigned int len)\n{\n\tunsigned int tupbodylen = len - sizeof(int);\n\tunsigned int tuplen = tupbodylen + MINIMAL_TUPLE_DATA_OFFSET;\n\tMinimalTuple tuple = (MinimalTuple) palloc(tuplen);\n\tchar\t   *tupbody = (char *) tuple + MINIMAL_TUPLE_DATA_OFFSET;\n\n\tUSEMEM(state, GetMemoryChunkSpace(tuple));\n\t/* read in the tuple proper */\n\ttuple->t_len = tuplen;\n\tif (BufFileRead(state->myfile, (void *) tupbody,\n\t\t\t\t\ttupbodylen) != (size_t) tupbodylen)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from tuplestore temporary file: %m\")));\n\tif (state->backward)\t\t/* need trailing length word? */\n\t\tif (BufFileRead(state->myfile, (void *) &tuplen,\n\t\t\t\t\t\tsizeof(tuplen)) != sizeof(tuplen))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from tuplestore temporary file: %m\")));\n\treturn (void *) tuple;\n}"
  },
  {
    "function_name": "writetup_heap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "1502-1533",
    "snippet": "static void\nwritetup_heap(Tuplestorestate *state, void *tup)\n{\n\tMinimalTuple tuple = (MinimalTuple) tup;\n\n\t/* the part of the MinimalTuple we'll write: */\n\tchar\t   *tupbody = (char *) tuple + MINIMAL_TUPLE_DATA_OFFSET;\n\tunsigned int tupbodylen = tuple->t_len - MINIMAL_TUPLE_DATA_OFFSET;\n\n\t/* total on-disk footprint: */\n\tunsigned int tuplen = tupbodylen + sizeof(int);\n\n\tif (BufFileWrite(state->myfile, (void *) &tuplen,\n\t\t\t\t\t sizeof(tuplen)) != sizeof(tuplen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to tuplestore temporary file: %m\")));\n\tif (BufFileWrite(state->myfile, (void *) tupbody,\n\t\t\t\t\t tupbodylen) != (size_t) tupbodylen)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to tuplestore temporary file: %m\")));\n\tif (state->backward)\t\t/* need trailing length word? */\n\t\tif (BufFileWrite(state->myfile, (void *) &tuplen,\n\t\t\t\t\t\t sizeof(tuplen)) != sizeof(tuplen))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not write to tuplestore temporary file: %m\")));\n\n\tFREEMEM(state, GetMemoryChunkSpace(tuple));\n\theap_free_minimal_tuple(tuple);\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
      "static void dumptuples(Tuplestorestate *state);",
      "static void *copytup_heap(Tuplestorestate *state, void *tup);",
      "static void writetup_heap(Tuplestorestate *state, void *tup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_free_minimal_tuple",
          "args": [
            "tuple"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FREEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(tuple)"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "tuple"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not write to tuplestore temporary file: %m\"))"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not write to tuplestore temporary file: %m\""
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileWrite",
          "args": [
            "state->myfile",
            "(void *) &tuplen",
            "sizeof(tuplen)"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to tuplestore temporary file: %m\"))"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileWrite",
          "args": [
            "state->myfile",
            "(void *) tupbody",
            "tupbodylen"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to tuplestore temporary file: %m\"))"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileWrite",
          "args": [
            "state->myfile",
            "(void *) &tuplen",
            "sizeof(tuplen)"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\nstatic void *copytup_heap(Tuplestorestate *state, void *tup);\nstatic void writetup_heap(Tuplestorestate *state, void *tup);\n\nstatic void\nwritetup_heap(Tuplestorestate *state, void *tup)\n{\n\tMinimalTuple tuple = (MinimalTuple) tup;\n\n\t/* the part of the MinimalTuple we'll write: */\n\tchar\t   *tupbody = (char *) tuple + MINIMAL_TUPLE_DATA_OFFSET;\n\tunsigned int tupbodylen = tuple->t_len - MINIMAL_TUPLE_DATA_OFFSET;\n\n\t/* total on-disk footprint: */\n\tunsigned int tuplen = tupbodylen + sizeof(int);\n\n\tif (BufFileWrite(state->myfile, (void *) &tuplen,\n\t\t\t\t\t sizeof(tuplen)) != sizeof(tuplen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to tuplestore temporary file: %m\")));\n\tif (BufFileWrite(state->myfile, (void *) tupbody,\n\t\t\t\t\t tupbodylen) != (size_t) tupbodylen)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to tuplestore temporary file: %m\")));\n\tif (state->backward)\t\t/* need trailing length word? */\n\t\tif (BufFileWrite(state->myfile, (void *) &tuplen,\n\t\t\t\t\t\t sizeof(tuplen)) != sizeof(tuplen))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not write to tuplestore temporary file: %m\")));\n\n\tFREEMEM(state, GetMemoryChunkSpace(tuple));\n\theap_free_minimal_tuple(tuple);\n}"
  },
  {
    "function_name": "copytup_heap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "1492-1500",
    "snippet": "static void *\ncopytup_heap(Tuplestorestate *state, void *tup)\n{\n\tMinimalTuple tuple;\n\n\ttuple = minimal_tuple_from_heap_tuple((HeapTuple) tup);\n\tUSEMEM(state, GetMemoryChunkSpace(tuple));\n\treturn (void *) tuple;\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
      "static void dumptuples(Tuplestorestate *state);",
      "static void *copytup_heap(Tuplestorestate *state, void *tup);",
      "static void writetup_heap(Tuplestorestate *state, void *tup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(tuple)"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "tuple"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minimal_tuple_from_heap_tuple",
          "args": [
            "(HeapTuple) tup"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\nstatic void *copytup_heap(Tuplestorestate *state, void *tup);\nstatic void writetup_heap(Tuplestorestate *state, void *tup);\n\nstatic void *\ncopytup_heap(Tuplestorestate *state, void *tup)\n{\n\tMinimalTuple tuple;\n\n\ttuple = minimal_tuple_from_heap_tuple((HeapTuple) tup);\n\tUSEMEM(state, GetMemoryChunkSpace(tuple));\n\treturn (void *) tuple;\n}"
  },
  {
    "function_name": "getlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "1465-1479",
    "snippet": "static unsigned int\ngetlen(Tuplestorestate *state, bool eofOK)\n{\n\tunsigned int len;\n\tsize_t\t\tnbytes;\n\n\tnbytes = BufFileRead(state->myfile, (void *) &len, sizeof(len));\n\tif (nbytes == sizeof(len))\n\t\treturn len;\n\tif (nbytes != 0 || !eofOK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from tuplestore temporary file: %m\")));\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void dumptuples(Tuplestorestate *state);",
      "static unsigned int getlen(Tuplestorestate *state, bool eofOK);",
      "static void *readtup_heap(Tuplestorestate *state, unsigned int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from tuplestore temporary file: %m\"))"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not read from tuplestore temporary file: %m\""
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileRead",
          "args": [
            "state->myfile",
            "(void *) &len",
            "sizeof(len)"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\nstatic unsigned int getlen(Tuplestorestate *state, bool eofOK);\nstatic void *readtup_heap(Tuplestorestate *state, unsigned int len);\n\nstatic unsigned int\ngetlen(Tuplestorestate *state, bool eofOK)\n{\n\tunsigned int len;\n\tsize_t\t\tnbytes;\n\n\tnbytes = BufFileRead(state->myfile, (void *) &len, sizeof(len));\n\tif (nbytes == sizeof(len))\n\t\treturn len;\n\tif (nbytes != 0 || !eofOK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from tuplestore temporary file: %m\")));\n\treturn 0;\n}"
  },
  {
    "function_name": "tuplestore_in_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "1454-1458",
    "snippet": "bool\ntuplestore_in_memory(Tuplestorestate *state)\n{\n\treturn (state->status == TSS_INMEM);\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nbool\ntuplestore_in_memory(Tuplestorestate *state)\n{\n\treturn (state->status == TSS_INMEM);\n}"
  },
  {
    "function_name": "tuplestore_trim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "1359-1445",
    "snippet": "void\ntuplestore_trim(Tuplestorestate *state)\n{\n\tint\t\t\toldest;\n\tint\t\t\tnremove;\n\tint\t\t\ti;\n\n\t/*\n\t * Truncation is disallowed if any read pointer requires rewind\n\t * capability.\n\t */\n\tif (state->eflags & EXEC_FLAG_REWIND)\n\t\treturn;\n\n\t/*\n\t * We don't bother trimming temp files since it usually would mean more\n\t * work than just letting them sit in kernel buffers until they age out.\n\t */\n\tif (state->status != TSS_INMEM)\n\t\treturn;\n\n\t/* Find the oldest read pointer */\n\toldest = state->memtupcount;\n\tfor (i = 0; i < state->readptrcount; i++)\n\t{\n\t\tif (!state->readptrs[i].eof_reached)\n\t\t\toldest = Min(oldest, state->readptrs[i].current);\n\t}\n\n\t/*\n\t * Note: you might think we could remove all the tuples before the oldest\n\t * \"current\", since that one is the next to be returned.  However, since\n\t * tuplestore_gettuple returns a direct pointer to our internal copy of\n\t * the tuple, it's likely that the caller has still got the tuple just\n\t * before \"current\" referenced in a slot. So we keep one extra tuple\n\t * before the oldest \"current\".  (Strictly speaking, we could require such\n\t * callers to use the \"copy\" flag to tuplestore_gettupleslot, but for\n\t * efficiency we allow this one case to not use \"copy\".)\n\t */\n\tnremove = oldest - 1;\n\tif (nremove <= 0)\n\t\treturn;\t\t\t\t\t/* nothing to do */\n\n\tAssert(nremove >= state->memtupdeleted);\n\tAssert(nremove <= state->memtupcount);\n\n\t/* Release no-longer-needed tuples */\n\tfor (i = state->memtupdeleted; i < nremove; i++)\n\t{\n\t\tFREEMEM(state, GetMemoryChunkSpace(state->memtuples[i]));\n\t\tpfree(state->memtuples[i]);\n\t\tstate->memtuples[i] = NULL;\n\t}\n\tstate->memtupdeleted = nremove;\n\n\t/* mark tuplestore as truncated (used for Assert crosschecks only) */\n\tstate->truncated = true;\n\n\t/*\n\t * If nremove is less than 1/8th memtupcount, just stop here, leaving the\n\t * \"deleted\" slots as NULL.  This prevents us from expending O(N^2) time\n\t * repeatedly memmove-ing a large pointer array.  The worst case space\n\t * wastage is pretty small, since it's just pointers and not whole tuples.\n\t */\n\tif (nremove < state->memtupcount / 8)\n\t\treturn;\n\n\t/*\n\t * Slide the array down and readjust pointers.\n\t *\n\t * In mergejoin's current usage, it's demonstrable that there will always\n\t * be exactly one non-removed tuple; so optimize that case.\n\t */\n\tif (nremove + 1 == state->memtupcount)\n\t\tstate->memtuples[0] = state->memtuples[nremove];\n\telse\n\t\tmemmove(state->memtuples, state->memtuples + nremove,\n\t\t\t\t(state->memtupcount - nremove) * sizeof(void *));\n\n\tstate->memtupdeleted = 0;\n\tstate->memtupcount -= nremove;\n\tfor (i = 0; i < state->readptrcount; i++)\n\t{\n\t\tif (!state->readptrs[i].eof_reached)\n\t\t\tstate->readptrs[i].current -= nremove;\n\t}\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "state->memtuples",
            "state->memtuples + nremove",
            "(state->memtupcount - nremove) * sizeof(void *)"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "state->memtuples[i]"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FREEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(state->memtuples[i])"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "state->memtuples[i]"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nremove <= state->memtupcount"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nremove >= state->memtupdeleted"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "oldest",
            "state->readptrs[i].current"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_trim(Tuplestorestate *state)\n{\n\tint\t\t\toldest;\n\tint\t\t\tnremove;\n\tint\t\t\ti;\n\n\t/*\n\t * Truncation is disallowed if any read pointer requires rewind\n\t * capability.\n\t */\n\tif (state->eflags & EXEC_FLAG_REWIND)\n\t\treturn;\n\n\t/*\n\t * We don't bother trimming temp files since it usually would mean more\n\t * work than just letting them sit in kernel buffers until they age out.\n\t */\n\tif (state->status != TSS_INMEM)\n\t\treturn;\n\n\t/* Find the oldest read pointer */\n\toldest = state->memtupcount;\n\tfor (i = 0; i < state->readptrcount; i++)\n\t{\n\t\tif (!state->readptrs[i].eof_reached)\n\t\t\toldest = Min(oldest, state->readptrs[i].current);\n\t}\n\n\t/*\n\t * Note: you might think we could remove all the tuples before the oldest\n\t * \"current\", since that one is the next to be returned.  However, since\n\t * tuplestore_gettuple returns a direct pointer to our internal copy of\n\t * the tuple, it's likely that the caller has still got the tuple just\n\t * before \"current\" referenced in a slot. So we keep one extra tuple\n\t * before the oldest \"current\".  (Strictly speaking, we could require such\n\t * callers to use the \"copy\" flag to tuplestore_gettupleslot, but for\n\t * efficiency we allow this one case to not use \"copy\".)\n\t */\n\tnremove = oldest - 1;\n\tif (nremove <= 0)\n\t\treturn;\t\t\t\t\t/* nothing to do */\n\n\tAssert(nremove >= state->memtupdeleted);\n\tAssert(nremove <= state->memtupcount);\n\n\t/* Release no-longer-needed tuples */\n\tfor (i = state->memtupdeleted; i < nremove; i++)\n\t{\n\t\tFREEMEM(state, GetMemoryChunkSpace(state->memtuples[i]));\n\t\tpfree(state->memtuples[i]);\n\t\tstate->memtuples[i] = NULL;\n\t}\n\tstate->memtupdeleted = nremove;\n\n\t/* mark tuplestore as truncated (used for Assert crosschecks only) */\n\tstate->truncated = true;\n\n\t/*\n\t * If nremove is less than 1/8th memtupcount, just stop here, leaving the\n\t * \"deleted\" slots as NULL.  This prevents us from expending O(N^2) time\n\t * repeatedly memmove-ing a large pointer array.  The worst case space\n\t * wastage is pretty small, since it's just pointers and not whole tuples.\n\t */\n\tif (nremove < state->memtupcount / 8)\n\t\treturn;\n\n\t/*\n\t * Slide the array down and readjust pointers.\n\t *\n\t * In mergejoin's current usage, it's demonstrable that there will always\n\t * be exactly one non-removed tuple; so optimize that case.\n\t */\n\tif (nremove + 1 == state->memtupcount)\n\t\tstate->memtuples[0] = state->memtuples[nremove];\n\telse\n\t\tmemmove(state->memtuples, state->memtuples + nremove,\n\t\t\t\t(state->memtupcount - nremove) * sizeof(void *));\n\n\tstate->memtupdeleted = 0;\n\tstate->memtupcount -= nremove;\n\tfor (i = 0; i < state->readptrcount; i++)\n\t{\n\t\tif (!state->readptrs[i].eof_reached)\n\t\t\tstate->readptrs[i].current -= nremove;\n\t}\n}"
  },
  {
    "function_name": "tuplestore_copy_read_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "1267-1345",
    "snippet": "void\ntuplestore_copy_read_pointer(Tuplestorestate *state,\n\t\t\t\t\t\t\t int srcptr, int destptr)\n{\n\tTSReadPointer *sptr = &state->readptrs[srcptr];\n\tTSReadPointer *dptr = &state->readptrs[destptr];\n\n\tAssert(srcptr >= 0 && srcptr < state->readptrcount);\n\tAssert(destptr >= 0 && destptr < state->readptrcount);\n\n\t/* Assigning to self is a no-op */\n\tif (srcptr == destptr)\n\t\treturn;\n\n\tif (dptr->eflags != sptr->eflags)\n\t{\n\t\t/* Possible change of overall eflags, so copy and then recompute */\n\t\tint\t\t\teflags;\n\t\tint\t\t\ti;\n\n\t\t*dptr = *sptr;\n\t\teflags = state->readptrs[0].eflags;\n\t\tfor (i = 1; i < state->readptrcount; i++)\n\t\t\teflags |= state->readptrs[i].eflags;\n\t\tstate->eflags = eflags;\n\t}\n\telse\n\t\t*dptr = *sptr;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* no work */\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * This case is a bit tricky since the active read pointer's\n\t\t\t * position corresponds to the seek point, not what is in its\n\t\t\t * variables.  Assigning to the active requires a seek, and\n\t\t\t * assigning from the active requires a tell, except when\n\t\t\t * eof_reached.\n\t\t\t */\n\t\t\tif (destptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (dptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tstate->writepos_file,\n\t\t\t\t\t\t\t\t\tstate->writepos_offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tdptr->file, dptr->offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (srcptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (!dptr->eof_reached)\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&dptr->file,\n\t\t\t\t\t\t\t\t&dptr->offset);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid tuplestore state\""
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileTell",
          "args": [
            "state->myfile",
            "&dptr->file",
            "&dptr->offset"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\"))"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not seek in tuplestore temporary file: %m\""
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileSeek",
          "args": [
            "state->myfile",
            "dptr->file",
            "dptr->offset",
            "SEEK_SET"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\"))"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileSeek",
          "args": [
            "state->myfile",
            "state->writepos_file",
            "state->writepos_offset",
            "SEEK_SET"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "destptr >= 0 && destptr < state->readptrcount"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "srcptr >= 0 && srcptr < state->readptrcount"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_copy_read_pointer(Tuplestorestate *state,\n\t\t\t\t\t\t\t int srcptr, int destptr)\n{\n\tTSReadPointer *sptr = &state->readptrs[srcptr];\n\tTSReadPointer *dptr = &state->readptrs[destptr];\n\n\tAssert(srcptr >= 0 && srcptr < state->readptrcount);\n\tAssert(destptr >= 0 && destptr < state->readptrcount);\n\n\t/* Assigning to self is a no-op */\n\tif (srcptr == destptr)\n\t\treturn;\n\n\tif (dptr->eflags != sptr->eflags)\n\t{\n\t\t/* Possible change of overall eflags, so copy and then recompute */\n\t\tint\t\t\teflags;\n\t\tint\t\t\ti;\n\n\t\t*dptr = *sptr;\n\t\teflags = state->readptrs[0].eflags;\n\t\tfor (i = 1; i < state->readptrcount; i++)\n\t\t\teflags |= state->readptrs[i].eflags;\n\t\tstate->eflags = eflags;\n\t}\n\telse\n\t\t*dptr = *sptr;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* no work */\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * This case is a bit tricky since the active read pointer's\n\t\t\t * position corresponds to the seek point, not what is in its\n\t\t\t * variables.  Assigning to the active requires a seek, and\n\t\t\t * assigning from the active requires a tell, except when\n\t\t\t * eof_reached.\n\t\t\t */\n\t\t\tif (destptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (dptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tstate->writepos_file,\n\t\t\t\t\t\t\t\t\tstate->writepos_offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tdptr->file, dptr->offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (srcptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (!dptr->eof_reached)\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&dptr->file,\n\t\t\t\t\t\t\t\t&dptr->offset);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "tuplestore_rescan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "1232-1262",
    "snippet": "void\ntuplestore_rescan(Tuplestorestate *state)\n{\n\tTSReadPointer *readptr = &state->readptrs[state->activeptr];\n\n\tAssert(readptr->eflags & EXEC_FLAG_REWIND);\n\tAssert(!state->truncated);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\t\treadptr->eof_reached = false;\n\t\t\treadptr->current = 0;\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\t\t\treadptr->eof_reached = false;\n\t\t\treadptr->file = 0;\n\t\t\treadptr->offset = 0L;\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\t\t\treadptr->eof_reached = false;\n\t\t\tif (BufFileSeek(state->myfile, 0, 0L, SEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid tuplestore state\""
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\"))"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not seek in tuplestore temporary file: %m\""
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileSeek",
          "args": [
            "state->myfile",
            "0",
            "0L",
            "SEEK_SET"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!state->truncated"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "readptr->eflags & EXEC_FLAG_REWIND"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_rescan(Tuplestorestate *state)\n{\n\tTSReadPointer *readptr = &state->readptrs[state->activeptr];\n\n\tAssert(readptr->eflags & EXEC_FLAG_REWIND);\n\tAssert(!state->truncated);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\t\treadptr->eof_reached = false;\n\t\t\treadptr->current = 0;\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\t\t\treadptr->eof_reached = false;\n\t\t\treadptr->file = 0;\n\t\t\treadptr->offset = 0L;\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\t\t\treadptr->eof_reached = false;\n\t\t\tif (BufFileSeek(state->myfile, 0, 0L, SEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "dumptuples",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "1205-1227",
    "snippet": "static void\ndumptuples(Tuplestorestate *state)\n{\n\tint\t\t\ti;\n\n\tfor (i = state->memtupdeleted;; i++)\n\t{\n\t\tTSReadPointer *readptr = state->readptrs;\n\t\tint\t\t\tj;\n\n\t\tfor (j = 0; j < state->readptrcount; readptr++, j++)\n\t\t{\n\t\t\tif (i == readptr->current && !readptr->eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&readptr->file, &readptr->offset);\n\t\t}\n\t\tif (i >= state->memtupcount)\n\t\t\tbreak;\n\t\tWRITETUP(state, state->memtuples[i]);\n\t}\n\tstate->memtupdeleted = 0;\n\tstate->memtupcount = 0;\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITETUP",
          "args": [
            "state",
            "state->memtuples[i]"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileTell",
          "args": [
            "state->myfile",
            "&readptr->file",
            "&readptr->offset"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nstatic void\ndumptuples(Tuplestorestate *state)\n{\n\tint\t\t\ti;\n\n\tfor (i = state->memtupdeleted;; i++)\n\t{\n\t\tTSReadPointer *readptr = state->readptrs;\n\t\tint\t\t\tj;\n\n\t\tfor (j = 0; j < state->readptrcount; readptr++, j++)\n\t\t{\n\t\t\tif (i == readptr->current && !readptr->eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&readptr->file, &readptr->offset);\n\t\t}\n\t\tif (i >= state->memtupcount)\n\t\t\tbreak;\n\t\tWRITETUP(state, state->memtuples[i]);\n\t}\n\tstate->memtupdeleted = 0;\n\tstate->memtupcount = 0;\n}"
  },
  {
    "function_name": "tuplestore_skiptuples",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "1134-1196",
    "snippet": "bool\ntuplestore_skiptuples(Tuplestorestate *state, int64 ntuples, bool forward)\n{\n\tTSReadPointer *readptr = &state->readptrs[state->activeptr];\n\n\tAssert(forward || (readptr->eflags & EXEC_FLAG_BACKWARD));\n\n\tif (ntuples <= 0)\n\t\treturn true;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t\treturn false;\n\t\t\t\tif (state->memtupcount - readptr->current >= ntuples)\n\t\t\t\t{\n\t\t\t\t\treadptr->current += ntuples;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\treadptr->eof_reached = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tntuples--;\n\t\t\t\t}\n\t\t\t\tif (readptr->current - state->memtupdeleted > ntuples)\n\t\t\t\t{\n\t\t\t\t\treadptr->current -= ntuples;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tAssert(!state->truncated);\n\t\t\t\treadptr->current = state->memtupdeleted;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* We don't currently try hard to optimize other cases */\n\t\t\twhile (ntuples-- > 0)\n\t\t\t{\n\t\t\t\tvoid\t   *tuple;\n\t\t\t\tbool\t\tshould_free;\n\n\t\t\t\ttuple = tuplestore_gettuple(state, forward, &should_free);\n\n\t\t\t\tif (tuple == NULL)\n\t\t\t\t\treturn false;\n\t\t\t\tif (should_free)\n\t\t\t\t\tpfree(tuple);\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\treturn true;\n\t}\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "tuple"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplestore_gettuple",
          "args": [
            "state",
            "forward",
            "&should_free"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_gettuple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "902-1062",
          "snippet": "static void *\ntuplestore_gettuple(Tuplestorestate *state, bool forward,\n\t\t\t\t\tbool *should_free)\n{\n\tTSReadPointer *readptr = &state->readptrs[state->activeptr];\n\tunsigned int tuplen;\n\tvoid\t   *tup;\n\n\tAssert(forward || (readptr->eflags & EXEC_FLAG_BACKWARD));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\t\t*should_free = false;\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (readptr->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t/* We have another tuple, so return it */\n\t\t\t\t\treturn state->memtuples[readptr->current++];\n\t\t\t\t}\n\t\t\t\treadptr->eof_reached = true;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (readptr->current <= state->memtupdeleted)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\treadptr->current--; /* last returned tuple */\n\t\t\t\t}\n\t\t\t\tif (readptr->current <= state->memtupdeleted)\n\t\t\t\t{\n\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\treturn state->memtuples[readptr->current - 1];\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* Skip state change if we'll just return NULL */\n\t\t\tif (readptr->eof_reached && forward)\n\t\t\t\treturn NULL;\n\n\t\t\t/*\n\t\t\t * Switch from writing to reading.\n\t\t\t */\n\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t&state->writepos_file, &state->writepos_offset);\n\t\t\tif (!readptr->eof_reached)\n\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\treadptr->file, readptr->offset,\n\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_READFILE;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase TSS_READFILE:\n\t\t\t*should_free = true;\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif ((tuplen = getlen(state, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\ttup = READTUP(state, tuplen);\n\t\t\t\t\treturn tup;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = true;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else tuple before last returned.\n\t\t\t *\n\t\t\t * Back up to fetch previously-returned tuple's ending length\n\t\t\t * word. If seek fails, assume we are at start of file.\n\t\t\t */\n\t\t\tif (BufFileSeek(state->myfile, 0, -(long) sizeof(unsigned int),\n\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t{\n\t\t\t\t/* even a failed backwards fetch gets you out of eof state */\n\t\t\t\treadptr->eof_reached = false;\n\t\t\t\tAssert(!state->truncated);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttuplen = getlen(state, false);\n\n\t\t\tif (readptr->eof_reached)\n\t\t\t{\n\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t/* We will return the tuple returned before returning NULL */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t\t-(long) (tuplen + 2 * sizeof(unsigned int)),\n\t\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If that fails, presumably the prev tuple is the first\n\t\t\t\t\t * in the file.  Back up so that it becomes next to read\n\t\t\t\t\t * in forward direction (not obviously right, but that is\n\t\t\t\t\t * what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t\t\t-(long) (tuplen + sizeof(unsigned int)),\n\t\t\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\ttuplen = getlen(state, false);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t-(long) tuplen,\n\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\ttup = READTUP(state, tuplen);\n\t\t\treturn tup;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\treturn NULL;\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
            "static void dumptuples(Tuplestorestate *state);",
            "static void *copytup_heap(Tuplestorestate *state, void *tup);",
            "static void writetup_heap(Tuplestorestate *state, void *tup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\nstatic void *copytup_heap(Tuplestorestate *state, void *tup);\nstatic void writetup_heap(Tuplestorestate *state, void *tup);\n\nstatic void *\ntuplestore_gettuple(Tuplestorestate *state, bool forward,\n\t\t\t\t\tbool *should_free)\n{\n\tTSReadPointer *readptr = &state->readptrs[state->activeptr];\n\tunsigned int tuplen;\n\tvoid\t   *tup;\n\n\tAssert(forward || (readptr->eflags & EXEC_FLAG_BACKWARD));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\t\t*should_free = false;\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (readptr->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t/* We have another tuple, so return it */\n\t\t\t\t\treturn state->memtuples[readptr->current++];\n\t\t\t\t}\n\t\t\t\treadptr->eof_reached = true;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (readptr->current <= state->memtupdeleted)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\treadptr->current--; /* last returned tuple */\n\t\t\t\t}\n\t\t\t\tif (readptr->current <= state->memtupdeleted)\n\t\t\t\t{\n\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\treturn state->memtuples[readptr->current - 1];\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* Skip state change if we'll just return NULL */\n\t\t\tif (readptr->eof_reached && forward)\n\t\t\t\treturn NULL;\n\n\t\t\t/*\n\t\t\t * Switch from writing to reading.\n\t\t\t */\n\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t&state->writepos_file, &state->writepos_offset);\n\t\t\tif (!readptr->eof_reached)\n\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\treadptr->file, readptr->offset,\n\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_READFILE;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase TSS_READFILE:\n\t\t\t*should_free = true;\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif ((tuplen = getlen(state, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\ttup = READTUP(state, tuplen);\n\t\t\t\t\treturn tup;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = true;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else tuple before last returned.\n\t\t\t *\n\t\t\t * Back up to fetch previously-returned tuple's ending length\n\t\t\t * word. If seek fails, assume we are at start of file.\n\t\t\t */\n\t\t\tif (BufFileSeek(state->myfile, 0, -(long) sizeof(unsigned int),\n\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t{\n\t\t\t\t/* even a failed backwards fetch gets you out of eof state */\n\t\t\t\treadptr->eof_reached = false;\n\t\t\t\tAssert(!state->truncated);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttuplen = getlen(state, false);\n\n\t\t\tif (readptr->eof_reached)\n\t\t\t{\n\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t/* We will return the tuple returned before returning NULL */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t\t-(long) (tuplen + 2 * sizeof(unsigned int)),\n\t\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If that fails, presumably the prev tuple is the first\n\t\t\t\t\t * in the file.  Back up so that it becomes next to read\n\t\t\t\t\t * in forward direction (not obviously right, but that is\n\t\t\t\t\t * what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t\t\t-(long) (tuplen + sizeof(unsigned int)),\n\t\t\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\ttuplen = getlen(state, false);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t-(long) tuplen,\n\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\ttup = READTUP(state, tuplen);\n\t\t\treturn tup;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\treturn NULL;\t\t/* keep compiler quiet */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!state->truncated"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "forward || (readptr->eflags & EXEC_FLAG_BACKWARD)"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nbool\ntuplestore_skiptuples(Tuplestorestate *state, int64 ntuples, bool forward)\n{\n\tTSReadPointer *readptr = &state->readptrs[state->activeptr];\n\n\tAssert(forward || (readptr->eflags & EXEC_FLAG_BACKWARD));\n\n\tif (ntuples <= 0)\n\t\treturn true;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t\treturn false;\n\t\t\t\tif (state->memtupcount - readptr->current >= ntuples)\n\t\t\t\t{\n\t\t\t\t\treadptr->current += ntuples;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\treadptr->eof_reached = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tntuples--;\n\t\t\t\t}\n\t\t\t\tif (readptr->current - state->memtupdeleted > ntuples)\n\t\t\t\t{\n\t\t\t\t\treadptr->current -= ntuples;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tAssert(!state->truncated);\n\t\t\t\treadptr->current = state->memtupdeleted;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* We don't currently try hard to optimize other cases */\n\t\t\twhile (ntuples-- > 0)\n\t\t\t{\n\t\t\t\tvoid\t   *tuple;\n\t\t\t\tbool\t\tshould_free;\n\n\t\t\t\ttuple = tuplestore_gettuple(state, forward, &should_free);\n\n\t\t\t\tif (tuple == NULL)\n\t\t\t\t\treturn false;\n\t\t\t\tif (should_free)\n\t\t\t\t\tpfree(tuple);\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\treturn true;\n\t}\n}"
  },
  {
    "function_name": "tuplestore_advance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "1109-1127",
    "snippet": "bool\ntuplestore_advance(Tuplestorestate *state, bool forward)\n{\n\tvoid\t   *tuple;\n\tbool\t\tshould_free;\n\n\ttuple = tuplestore_gettuple(state, forward, &should_free);\n\n\tif (tuple)\n\t{\n\t\tif (should_free)\n\t\t\tpfree(tuple);\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "tuple"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplestore_gettuple",
          "args": [
            "state",
            "forward",
            "&should_free"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_gettuple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "902-1062",
          "snippet": "static void *\ntuplestore_gettuple(Tuplestorestate *state, bool forward,\n\t\t\t\t\tbool *should_free)\n{\n\tTSReadPointer *readptr = &state->readptrs[state->activeptr];\n\tunsigned int tuplen;\n\tvoid\t   *tup;\n\n\tAssert(forward || (readptr->eflags & EXEC_FLAG_BACKWARD));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\t\t*should_free = false;\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (readptr->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t/* We have another tuple, so return it */\n\t\t\t\t\treturn state->memtuples[readptr->current++];\n\t\t\t\t}\n\t\t\t\treadptr->eof_reached = true;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (readptr->current <= state->memtupdeleted)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\treadptr->current--; /* last returned tuple */\n\t\t\t\t}\n\t\t\t\tif (readptr->current <= state->memtupdeleted)\n\t\t\t\t{\n\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\treturn state->memtuples[readptr->current - 1];\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* Skip state change if we'll just return NULL */\n\t\t\tif (readptr->eof_reached && forward)\n\t\t\t\treturn NULL;\n\n\t\t\t/*\n\t\t\t * Switch from writing to reading.\n\t\t\t */\n\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t&state->writepos_file, &state->writepos_offset);\n\t\t\tif (!readptr->eof_reached)\n\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\treadptr->file, readptr->offset,\n\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_READFILE;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase TSS_READFILE:\n\t\t\t*should_free = true;\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif ((tuplen = getlen(state, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\ttup = READTUP(state, tuplen);\n\t\t\t\t\treturn tup;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = true;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else tuple before last returned.\n\t\t\t *\n\t\t\t * Back up to fetch previously-returned tuple's ending length\n\t\t\t * word. If seek fails, assume we are at start of file.\n\t\t\t */\n\t\t\tif (BufFileSeek(state->myfile, 0, -(long) sizeof(unsigned int),\n\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t{\n\t\t\t\t/* even a failed backwards fetch gets you out of eof state */\n\t\t\t\treadptr->eof_reached = false;\n\t\t\t\tAssert(!state->truncated);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttuplen = getlen(state, false);\n\n\t\t\tif (readptr->eof_reached)\n\t\t\t{\n\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t/* We will return the tuple returned before returning NULL */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t\t-(long) (tuplen + 2 * sizeof(unsigned int)),\n\t\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If that fails, presumably the prev tuple is the first\n\t\t\t\t\t * in the file.  Back up so that it becomes next to read\n\t\t\t\t\t * in forward direction (not obviously right, but that is\n\t\t\t\t\t * what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t\t\t-(long) (tuplen + sizeof(unsigned int)),\n\t\t\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\ttuplen = getlen(state, false);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t-(long) tuplen,\n\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\ttup = READTUP(state, tuplen);\n\t\t\treturn tup;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\treturn NULL;\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
            "static void dumptuples(Tuplestorestate *state);",
            "static void *copytup_heap(Tuplestorestate *state, void *tup);",
            "static void writetup_heap(Tuplestorestate *state, void *tup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\nstatic void *copytup_heap(Tuplestorestate *state, void *tup);\nstatic void writetup_heap(Tuplestorestate *state, void *tup);\n\nstatic void *\ntuplestore_gettuple(Tuplestorestate *state, bool forward,\n\t\t\t\t\tbool *should_free)\n{\n\tTSReadPointer *readptr = &state->readptrs[state->activeptr];\n\tunsigned int tuplen;\n\tvoid\t   *tup;\n\n\tAssert(forward || (readptr->eflags & EXEC_FLAG_BACKWARD));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\t\t*should_free = false;\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (readptr->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t/* We have another tuple, so return it */\n\t\t\t\t\treturn state->memtuples[readptr->current++];\n\t\t\t\t}\n\t\t\t\treadptr->eof_reached = true;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (readptr->current <= state->memtupdeleted)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\treadptr->current--; /* last returned tuple */\n\t\t\t\t}\n\t\t\t\tif (readptr->current <= state->memtupdeleted)\n\t\t\t\t{\n\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\treturn state->memtuples[readptr->current - 1];\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* Skip state change if we'll just return NULL */\n\t\t\tif (readptr->eof_reached && forward)\n\t\t\t\treturn NULL;\n\n\t\t\t/*\n\t\t\t * Switch from writing to reading.\n\t\t\t */\n\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t&state->writepos_file, &state->writepos_offset);\n\t\t\tif (!readptr->eof_reached)\n\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\treadptr->file, readptr->offset,\n\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_READFILE;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase TSS_READFILE:\n\t\t\t*should_free = true;\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif ((tuplen = getlen(state, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\ttup = READTUP(state, tuplen);\n\t\t\t\t\treturn tup;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = true;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else tuple before last returned.\n\t\t\t *\n\t\t\t * Back up to fetch previously-returned tuple's ending length\n\t\t\t * word. If seek fails, assume we are at start of file.\n\t\t\t */\n\t\t\tif (BufFileSeek(state->myfile, 0, -(long) sizeof(unsigned int),\n\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t{\n\t\t\t\t/* even a failed backwards fetch gets you out of eof state */\n\t\t\t\treadptr->eof_reached = false;\n\t\t\t\tAssert(!state->truncated);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttuplen = getlen(state, false);\n\n\t\t\tif (readptr->eof_reached)\n\t\t\t{\n\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t/* We will return the tuple returned before returning NULL */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t\t-(long) (tuplen + 2 * sizeof(unsigned int)),\n\t\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If that fails, presumably the prev tuple is the first\n\t\t\t\t\t * in the file.  Back up so that it becomes next to read\n\t\t\t\t\t * in forward direction (not obviously right, but that is\n\t\t\t\t\t * what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t\t\t-(long) (tuplen + sizeof(unsigned int)),\n\t\t\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\ttuplen = getlen(state, false);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t-(long) tuplen,\n\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\ttup = READTUP(state, tuplen);\n\t\t\treturn tup;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\treturn NULL;\t\t/* keep compiler quiet */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nbool\ntuplestore_advance(Tuplestorestate *state, bool forward)\n{\n\tvoid\t   *tuple;\n\tbool\t\tshould_free;\n\n\ttuple = tuplestore_gettuple(state, forward, &should_free);\n\n\tif (tuple)\n\t{\n\t\tif (should_free)\n\t\t\tpfree(tuple);\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "tuplestore_gettupleslot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "1077-1101",
    "snippet": "bool\ntuplestore_gettupleslot(Tuplestorestate *state, bool forward,\n\t\t\t\t\t\tbool copy, TupleTableSlot *slot)\n{\n\tMinimalTuple tuple;\n\tbool\t\tshould_free;\n\n\ttuple = (MinimalTuple) tuplestore_gettuple(state, forward, &should_free);\n\n\tif (tuple)\n\t{\n\t\tif (copy && !should_free)\n\t\t{\n\t\t\ttuple = heap_copy_minimal_tuple(tuple);\n\t\t\tshould_free = true;\n\t\t}\n\t\tExecStoreMinimalTuple(tuple, slot, should_free);\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tExecClearTuple(slot);\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ExecClearTuple",
          "args": [
            "slot"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecStoreMinimalTuple",
          "args": [
            "tuple",
            "slot",
            "should_free"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_copy_minimal_tuple",
          "args": [
            "tuple"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_gettuple",
          "args": [
            "state",
            "forward",
            "&should_free"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_gettuple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "902-1062",
          "snippet": "static void *\ntuplestore_gettuple(Tuplestorestate *state, bool forward,\n\t\t\t\t\tbool *should_free)\n{\n\tTSReadPointer *readptr = &state->readptrs[state->activeptr];\n\tunsigned int tuplen;\n\tvoid\t   *tup;\n\n\tAssert(forward || (readptr->eflags & EXEC_FLAG_BACKWARD));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\t\t*should_free = false;\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (readptr->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t/* We have another tuple, so return it */\n\t\t\t\t\treturn state->memtuples[readptr->current++];\n\t\t\t\t}\n\t\t\t\treadptr->eof_reached = true;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (readptr->current <= state->memtupdeleted)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\treadptr->current--; /* last returned tuple */\n\t\t\t\t}\n\t\t\t\tif (readptr->current <= state->memtupdeleted)\n\t\t\t\t{\n\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\treturn state->memtuples[readptr->current - 1];\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* Skip state change if we'll just return NULL */\n\t\t\tif (readptr->eof_reached && forward)\n\t\t\t\treturn NULL;\n\n\t\t\t/*\n\t\t\t * Switch from writing to reading.\n\t\t\t */\n\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t&state->writepos_file, &state->writepos_offset);\n\t\t\tif (!readptr->eof_reached)\n\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\treadptr->file, readptr->offset,\n\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_READFILE;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase TSS_READFILE:\n\t\t\t*should_free = true;\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif ((tuplen = getlen(state, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\ttup = READTUP(state, tuplen);\n\t\t\t\t\treturn tup;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = true;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else tuple before last returned.\n\t\t\t *\n\t\t\t * Back up to fetch previously-returned tuple's ending length\n\t\t\t * word. If seek fails, assume we are at start of file.\n\t\t\t */\n\t\t\tif (BufFileSeek(state->myfile, 0, -(long) sizeof(unsigned int),\n\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t{\n\t\t\t\t/* even a failed backwards fetch gets you out of eof state */\n\t\t\t\treadptr->eof_reached = false;\n\t\t\t\tAssert(!state->truncated);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttuplen = getlen(state, false);\n\n\t\t\tif (readptr->eof_reached)\n\t\t\t{\n\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t/* We will return the tuple returned before returning NULL */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t\t-(long) (tuplen + 2 * sizeof(unsigned int)),\n\t\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If that fails, presumably the prev tuple is the first\n\t\t\t\t\t * in the file.  Back up so that it becomes next to read\n\t\t\t\t\t * in forward direction (not obviously right, but that is\n\t\t\t\t\t * what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t\t\t-(long) (tuplen + sizeof(unsigned int)),\n\t\t\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\ttuplen = getlen(state, false);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t-(long) tuplen,\n\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\ttup = READTUP(state, tuplen);\n\t\t\treturn tup;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\treturn NULL;\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
            "static void dumptuples(Tuplestorestate *state);",
            "static void *copytup_heap(Tuplestorestate *state, void *tup);",
            "static void writetup_heap(Tuplestorestate *state, void *tup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\nstatic void *copytup_heap(Tuplestorestate *state, void *tup);\nstatic void writetup_heap(Tuplestorestate *state, void *tup);\n\nstatic void *\ntuplestore_gettuple(Tuplestorestate *state, bool forward,\n\t\t\t\t\tbool *should_free)\n{\n\tTSReadPointer *readptr = &state->readptrs[state->activeptr];\n\tunsigned int tuplen;\n\tvoid\t   *tup;\n\n\tAssert(forward || (readptr->eflags & EXEC_FLAG_BACKWARD));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\t\t*should_free = false;\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (readptr->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t/* We have another tuple, so return it */\n\t\t\t\t\treturn state->memtuples[readptr->current++];\n\t\t\t\t}\n\t\t\t\treadptr->eof_reached = true;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (readptr->current <= state->memtupdeleted)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\treadptr->current--; /* last returned tuple */\n\t\t\t\t}\n\t\t\t\tif (readptr->current <= state->memtupdeleted)\n\t\t\t\t{\n\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\treturn state->memtuples[readptr->current - 1];\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* Skip state change if we'll just return NULL */\n\t\t\tif (readptr->eof_reached && forward)\n\t\t\t\treturn NULL;\n\n\t\t\t/*\n\t\t\t * Switch from writing to reading.\n\t\t\t */\n\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t&state->writepos_file, &state->writepos_offset);\n\t\t\tif (!readptr->eof_reached)\n\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\treadptr->file, readptr->offset,\n\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_READFILE;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase TSS_READFILE:\n\t\t\t*should_free = true;\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif ((tuplen = getlen(state, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\ttup = READTUP(state, tuplen);\n\t\t\t\t\treturn tup;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = true;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else tuple before last returned.\n\t\t\t *\n\t\t\t * Back up to fetch previously-returned tuple's ending length\n\t\t\t * word. If seek fails, assume we are at start of file.\n\t\t\t */\n\t\t\tif (BufFileSeek(state->myfile, 0, -(long) sizeof(unsigned int),\n\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t{\n\t\t\t\t/* even a failed backwards fetch gets you out of eof state */\n\t\t\t\treadptr->eof_reached = false;\n\t\t\t\tAssert(!state->truncated);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttuplen = getlen(state, false);\n\n\t\t\tif (readptr->eof_reached)\n\t\t\t{\n\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t/* We will return the tuple returned before returning NULL */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t\t-(long) (tuplen + 2 * sizeof(unsigned int)),\n\t\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If that fails, presumably the prev tuple is the first\n\t\t\t\t\t * in the file.  Back up so that it becomes next to read\n\t\t\t\t\t * in forward direction (not obviously right, but that is\n\t\t\t\t\t * what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t\t\t-(long) (tuplen + sizeof(unsigned int)),\n\t\t\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\ttuplen = getlen(state, false);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t-(long) tuplen,\n\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\ttup = READTUP(state, tuplen);\n\t\t\treturn tup;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\treturn NULL;\t\t/* keep compiler quiet */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nbool\ntuplestore_gettupleslot(Tuplestorestate *state, bool forward,\n\t\t\t\t\t\tbool copy, TupleTableSlot *slot)\n{\n\tMinimalTuple tuple;\n\tbool\t\tshould_free;\n\n\ttuple = (MinimalTuple) tuplestore_gettuple(state, forward, &should_free);\n\n\tif (tuple)\n\t{\n\t\tif (copy && !should_free)\n\t\t{\n\t\t\ttuple = heap_copy_minimal_tuple(tuple);\n\t\t\tshould_free = true;\n\t\t}\n\t\tExecStoreMinimalTuple(tuple, slot, should_free);\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tExecClearTuple(slot);\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "tuplestore_gettuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "902-1062",
    "snippet": "static void *\ntuplestore_gettuple(Tuplestorestate *state, bool forward,\n\t\t\t\t\tbool *should_free)\n{\n\tTSReadPointer *readptr = &state->readptrs[state->activeptr];\n\tunsigned int tuplen;\n\tvoid\t   *tup;\n\n\tAssert(forward || (readptr->eflags & EXEC_FLAG_BACKWARD));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\t\t*should_free = false;\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (readptr->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t/* We have another tuple, so return it */\n\t\t\t\t\treturn state->memtuples[readptr->current++];\n\t\t\t\t}\n\t\t\t\treadptr->eof_reached = true;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (readptr->current <= state->memtupdeleted)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\treadptr->current--; /* last returned tuple */\n\t\t\t\t}\n\t\t\t\tif (readptr->current <= state->memtupdeleted)\n\t\t\t\t{\n\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\treturn state->memtuples[readptr->current - 1];\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* Skip state change if we'll just return NULL */\n\t\t\tif (readptr->eof_reached && forward)\n\t\t\t\treturn NULL;\n\n\t\t\t/*\n\t\t\t * Switch from writing to reading.\n\t\t\t */\n\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t&state->writepos_file, &state->writepos_offset);\n\t\t\tif (!readptr->eof_reached)\n\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\treadptr->file, readptr->offset,\n\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_READFILE;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase TSS_READFILE:\n\t\t\t*should_free = true;\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif ((tuplen = getlen(state, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\ttup = READTUP(state, tuplen);\n\t\t\t\t\treturn tup;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = true;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else tuple before last returned.\n\t\t\t *\n\t\t\t * Back up to fetch previously-returned tuple's ending length\n\t\t\t * word. If seek fails, assume we are at start of file.\n\t\t\t */\n\t\t\tif (BufFileSeek(state->myfile, 0, -(long) sizeof(unsigned int),\n\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t{\n\t\t\t\t/* even a failed backwards fetch gets you out of eof state */\n\t\t\t\treadptr->eof_reached = false;\n\t\t\t\tAssert(!state->truncated);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttuplen = getlen(state, false);\n\n\t\t\tif (readptr->eof_reached)\n\t\t\t{\n\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t/* We will return the tuple returned before returning NULL */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t\t-(long) (tuplen + 2 * sizeof(unsigned int)),\n\t\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If that fails, presumably the prev tuple is the first\n\t\t\t\t\t * in the file.  Back up so that it becomes next to read\n\t\t\t\t\t * in forward direction (not obviously right, but that is\n\t\t\t\t\t * what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t\t\t-(long) (tuplen + sizeof(unsigned int)),\n\t\t\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\ttuplen = getlen(state, false);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t-(long) tuplen,\n\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\ttup = READTUP(state, tuplen);\n\t\t\treturn tup;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\treturn NULL;\t\t/* keep compiler quiet */\n\t}\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
      "static void dumptuples(Tuplestorestate *state);",
      "static void *copytup_heap(Tuplestorestate *state, void *tup);",
      "static void writetup_heap(Tuplestorestate *state, void *tup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid tuplestore state\""
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READTUP",
          "args": [
            "state",
            "tuplen"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\"))"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not seek in tuplestore temporary file: %m\""
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileSeek",
          "args": [
            "state->myfile",
            "0",
            "-(long) tuplen",
            "SEEK_CUR"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getlen",
          "args": [
            "state",
            "false"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "getlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "1465-1479",
          "snippet": "static unsigned int\ngetlen(Tuplestorestate *state, bool eofOK)\n{\n\tunsigned int len;\n\tsize_t\t\tnbytes;\n\n\tnbytes = BufFileRead(state->myfile, (void *) &len, sizeof(len));\n\tif (nbytes == sizeof(len))\n\t\treturn len;\n\tif (nbytes != 0 || !eofOK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from tuplestore temporary file: %m\")));\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void dumptuples(Tuplestorestate *state);",
            "static unsigned int getlen(Tuplestorestate *state, bool eofOK);",
            "static void *readtup_heap(Tuplestorestate *state, unsigned int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\nstatic unsigned int getlen(Tuplestorestate *state, bool eofOK);\nstatic void *readtup_heap(Tuplestorestate *state, unsigned int len);\n\nstatic unsigned int\ngetlen(Tuplestorestate *state, bool eofOK)\n{\n\tunsigned int len;\n\tsize_t\t\tnbytes;\n\n\tnbytes = BufFileRead(state->myfile, (void *) &len, sizeof(len));\n\tif (nbytes == sizeof(len))\n\t\treturn len;\n\tif (nbytes != 0 || !eofOK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from tuplestore temporary file: %m\")));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!state->truncated"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\"))"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileSeek",
          "args": [
            "state->myfile",
            "0",
            "-(long) (tuplen + sizeof(unsigned int))",
            "SEEK_CUR"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileSeek",
          "args": [
            "state->myfile",
            "0",
            "-(long) (tuplen + 2 * sizeof(unsigned int))",
            "SEEK_CUR"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!state->truncated"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileSeek",
          "args": [
            "state->myfile",
            "0",
            "-(long) sizeof(unsigned int)",
            "SEEK_CUR"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READTUP",
          "args": [
            "state",
            "tuplen"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\"))"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileSeek",
          "args": [
            "state->myfile",
            "readptr->file",
            "readptr->offset",
            "SEEK_SET"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileTell",
          "args": [
            "state->myfile",
            "&state->writepos_file",
            "&state->writepos_offset"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!state->truncated"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!state->truncated"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "forward || (readptr->eflags & EXEC_FLAG_BACKWARD)"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\nstatic void *copytup_heap(Tuplestorestate *state, void *tup);\nstatic void writetup_heap(Tuplestorestate *state, void *tup);\n\nstatic void *\ntuplestore_gettuple(Tuplestorestate *state, bool forward,\n\t\t\t\t\tbool *should_free)\n{\n\tTSReadPointer *readptr = &state->readptrs[state->activeptr];\n\tunsigned int tuplen;\n\tvoid\t   *tup;\n\n\tAssert(forward || (readptr->eflags & EXEC_FLAG_BACKWARD));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\t\t*should_free = false;\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (readptr->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t/* We have another tuple, so return it */\n\t\t\t\t\treturn state->memtuples[readptr->current++];\n\t\t\t\t}\n\t\t\t\treadptr->eof_reached = true;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (readptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (readptr->current <= state->memtupdeleted)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\treadptr->current--; /* last returned tuple */\n\t\t\t\t}\n\t\t\t\tif (readptr->current <= state->memtupdeleted)\n\t\t\t\t{\n\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\treturn state->memtuples[readptr->current - 1];\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* Skip state change if we'll just return NULL */\n\t\t\tif (readptr->eof_reached && forward)\n\t\t\t\treturn NULL;\n\n\t\t\t/*\n\t\t\t * Switch from writing to reading.\n\t\t\t */\n\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t&state->writepos_file, &state->writepos_offset);\n\t\t\tif (!readptr->eof_reached)\n\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\treadptr->file, readptr->offset,\n\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_READFILE;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase TSS_READFILE:\n\t\t\t*should_free = true;\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif ((tuplen = getlen(state, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\ttup = READTUP(state, tuplen);\n\t\t\t\t\treturn tup;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = true;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else tuple before last returned.\n\t\t\t *\n\t\t\t * Back up to fetch previously-returned tuple's ending length\n\t\t\t * word. If seek fails, assume we are at start of file.\n\t\t\t */\n\t\t\tif (BufFileSeek(state->myfile, 0, -(long) sizeof(unsigned int),\n\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t{\n\t\t\t\t/* even a failed backwards fetch gets you out of eof state */\n\t\t\t\treadptr->eof_reached = false;\n\t\t\t\tAssert(!state->truncated);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttuplen = getlen(state, false);\n\n\t\t\tif (readptr->eof_reached)\n\t\t\t{\n\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t/* We will return the tuple returned before returning NULL */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t\t-(long) (tuplen + 2 * sizeof(unsigned int)),\n\t\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If that fails, presumably the prev tuple is the first\n\t\t\t\t\t * in the file.  Back up so that it becomes next to read\n\t\t\t\t\t * in forward direction (not obviously right, but that is\n\t\t\t\t\t * what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t\t\t-(long) (tuplen + sizeof(unsigned int)),\n\t\t\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t\tAssert(!state->truncated);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\ttuplen = getlen(state, false);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tif (BufFileSeek(state->myfile, 0,\n\t\t\t\t\t\t\t-(long) tuplen,\n\t\t\t\t\t\t\tSEEK_CUR) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\ttup = READTUP(state, tuplen);\n\t\t\treturn tup;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\treturn NULL;\t\t/* keep compiler quiet */\n\t}\n}"
  },
  {
    "function_name": "tuplestore_puttuple_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "764-892",
    "snippet": "static void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid tuplestore state\""
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITETUP",
          "args": [
            "state",
            "tuple"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\"))"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not seek in tuplestore temporary file: %m\""
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileSeek",
          "args": [
            "state->myfile",
            "state->writepos_file",
            "state->writepos_offset",
            "SEEK_SET"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileTell",
          "args": [
            "state->myfile",
            "&state->readptrs[state->activeptr].file",
            "&state->readptrs[state->activeptr].offset"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITETUP",
          "args": [
            "state",
            "tuple"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileTell",
          "args": [
            "state->myfile",
            "&readptr->file",
            "&readptr->offset"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dumptuples",
          "args": [
            "state"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "dumptuples",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "1205-1227",
          "snippet": "static void\ndumptuples(Tuplestorestate *state)\n{\n\tint\t\t\ti;\n\n\tfor (i = state->memtupdeleted;; i++)\n\t{\n\t\tTSReadPointer *readptr = state->readptrs;\n\t\tint\t\t\tj;\n\n\t\tfor (j = 0; j < state->readptrcount; readptr++, j++)\n\t\t{\n\t\t\tif (i == readptr->current && !readptr->eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&readptr->file, &readptr->offset);\n\t\t}\n\t\tif (i >= state->memtupcount)\n\t\t\tbreak;\n\t\tWRITETUP(state, state->memtuples[i]);\n\t}\n\tstate->memtupdeleted = 0;\n\tstate->memtupcount = 0;\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nstatic void\ndumptuples(Tuplestorestate *state)\n{\n\tint\t\t\ti;\n\n\tfor (i = state->memtupdeleted;; i++)\n\t{\n\t\tTSReadPointer *readptr = state->readptrs;\n\t\tint\t\t\tj;\n\n\t\tfor (j = 0; j < state->readptrcount; readptr++, j++)\n\t\t{\n\t\t\tif (i == readptr->current && !readptr->eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&readptr->file, &readptr->offset);\n\t\t}\n\t\tif (i >= state->memtupcount)\n\t\t\tbreak;\n\t\tWRITETUP(state, state->memtuples[i]);\n\t}\n\tstate->memtupdeleted = 0;\n\tstate->memtupcount = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileCreateTemp",
          "args": [
            "state->interXact"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrepareTempTablespaces",
          "args": [],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LACKMEM",
          "args": [
            "state"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->memtupcount < state->memtupsize"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grow_memtuples",
          "args": [
            "state"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "grow_memtuples",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "577-689",
          "snippet": "static bool\ngrow_memtuples(Tuplestorestate *state)\n{\n\tint\t\t\tnewmemtupsize;\n\tint\t\t\tmemtupsize = state->memtupsize;\n\tint64\t\tmemNowUsed = state->allowedMem - state->availMem;\n\n\t/* Forget it if we've already maxed out memtuples, per comment above */\n\tif (!state->growmemtuples)\n\t\treturn false;\n\n\t/* Select new value of memtupsize */\n\tif (memNowUsed <= state->availMem)\n\t{\n\t\t/*\n\t\t * We've used no more than half of allowedMem; double our usage,\n\t\t * clamping at INT_MAX tuples.\n\t\t */\n\t\tif (memtupsize < INT_MAX / 2)\n\t\t\tnewmemtupsize = memtupsize * 2;\n\t\telse\n\t\t{\n\t\t\tnewmemtupsize = INT_MAX;\n\t\t\tstate->growmemtuples = false;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This will be the last increment of memtupsize.  Abandon doubling\n\t\t * strategy and instead increase as much as we safely can.\n\t\t *\n\t\t * To stay within allowedMem, we can't increase memtupsize by more\n\t\t * than availMem / sizeof(void *) elements. In practice, we want to\n\t\t * increase it by considerably less, because we need to leave some\n\t\t * space for the tuples to which the new array slots will refer.  We\n\t\t * assume the new tuples will be about the same size as the tuples\n\t\t * we've already seen, and thus we can extrapolate from the space\n\t\t * consumption so far to estimate an appropriate new size for the\n\t\t * memtuples array.  The optimal value might be higher or lower than\n\t\t * this estimate, but it's hard to know that in advance.  We again\n\t\t * clamp at INT_MAX tuples.\n\t\t *\n\t\t * This calculation is safe against enlarging the array so much that\n\t\t * LACKMEM becomes true, because the memory currently used includes\n\t\t * the present array; thus, there would be enough allowedMem for the\n\t\t * new array elements even if no other memory were currently used.\n\t\t *\n\t\t * We do the arithmetic in float8, because otherwise the product of\n\t\t * memtupsize and allowedMem could overflow.  Any inaccuracy in the\n\t\t * result should be insignificant; but even if we computed a\n\t\t * completely insane result, the checks below will prevent anything\n\t\t * really bad from happening.\n\t\t */\n\t\tdouble\t\tgrow_ratio;\n\n\t\tgrow_ratio = (double) state->allowedMem / (double) memNowUsed;\n\t\tif (memtupsize * grow_ratio < INT_MAX)\n\t\t\tnewmemtupsize = (int) (memtupsize * grow_ratio);\n\t\telse\n\t\t\tnewmemtupsize = INT_MAX;\n\n\t\t/* We won't make any further enlargement attempts */\n\t\tstate->growmemtuples = false;\n\t}\n\n\t/* Must enlarge array by at least one element, else report failure */\n\tif (newmemtupsize <= memtupsize)\n\t\tgoto noalloc;\n\n\t/*\n\t * On a 32-bit machine, allowedMem could exceed MaxAllocHugeSize.  Clamp\n\t * to ensure our request won't be rejected.  Note that we can easily\n\t * exhaust address space before facing this outcome.  (This is presently\n\t * impossible due to guc.c's MAX_KILOBYTES limitation on work_mem, but\n\t * don't rely on that at this distance.)\n\t */\n\tif ((Size) newmemtupsize >= MaxAllocHugeSize / sizeof(void *))\n\t{\n\t\tnewmemtupsize = (int) (MaxAllocHugeSize / sizeof(void *));\n\t\tstate->growmemtuples = false;\t/* can't grow any more */\n\t}\n\n\t/*\n\t * We need to be sure that we do not cause LACKMEM to become true, else\n\t * the space management algorithm will go nuts.  The code above should\n\t * never generate a dangerous request, but to be safe, check explicitly\n\t * that the array growth fits within availMem.  (We could still cause\n\t * LACKMEM if the memory chunk overhead associated with the memtuples\n\t * array were to increase.  That shouldn't happen because we chose the\n\t * initial array size large enough to ensure that palloc will be treating\n\t * both old and new arrays as separate chunks.  But we'll check LACKMEM\n\t * explicitly below just in case.)\n\t */\n\tif (state->availMem < (int64) ((newmemtupsize - memtupsize) * sizeof(void *)))\n\t\tgoto noalloc;\n\n\t/* OK, do it */\n\tFREEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tstate->memtupsize = newmemtupsize;\n\tstate->memtuples = (void **)\n\t\trepalloc_huge(state->memtuples,\n\t\t\t\t\t  state->memtupsize * sizeof(void *));\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"unexpected out-of-memory situation in tuplestore\");\n\treturn true;\n\nnoalloc:\n\t/* If for any reason we didn't realloc, shut off future attempts */\n\tstate->growmemtuples = false;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nstatic bool\ngrow_memtuples(Tuplestorestate *state)\n{\n\tint\t\t\tnewmemtupsize;\n\tint\t\t\tmemtupsize = state->memtupsize;\n\tint64\t\tmemNowUsed = state->allowedMem - state->availMem;\n\n\t/* Forget it if we've already maxed out memtuples, per comment above */\n\tif (!state->growmemtuples)\n\t\treturn false;\n\n\t/* Select new value of memtupsize */\n\tif (memNowUsed <= state->availMem)\n\t{\n\t\t/*\n\t\t * We've used no more than half of allowedMem; double our usage,\n\t\t * clamping at INT_MAX tuples.\n\t\t */\n\t\tif (memtupsize < INT_MAX / 2)\n\t\t\tnewmemtupsize = memtupsize * 2;\n\t\telse\n\t\t{\n\t\t\tnewmemtupsize = INT_MAX;\n\t\t\tstate->growmemtuples = false;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This will be the last increment of memtupsize.  Abandon doubling\n\t\t * strategy and instead increase as much as we safely can.\n\t\t *\n\t\t * To stay within allowedMem, we can't increase memtupsize by more\n\t\t * than availMem / sizeof(void *) elements. In practice, we want to\n\t\t * increase it by considerably less, because we need to leave some\n\t\t * space for the tuples to which the new array slots will refer.  We\n\t\t * assume the new tuples will be about the same size as the tuples\n\t\t * we've already seen, and thus we can extrapolate from the space\n\t\t * consumption so far to estimate an appropriate new size for the\n\t\t * memtuples array.  The optimal value might be higher or lower than\n\t\t * this estimate, but it's hard to know that in advance.  We again\n\t\t * clamp at INT_MAX tuples.\n\t\t *\n\t\t * This calculation is safe against enlarging the array so much that\n\t\t * LACKMEM becomes true, because the memory currently used includes\n\t\t * the present array; thus, there would be enough allowedMem for the\n\t\t * new array elements even if no other memory were currently used.\n\t\t *\n\t\t * We do the arithmetic in float8, because otherwise the product of\n\t\t * memtupsize and allowedMem could overflow.  Any inaccuracy in the\n\t\t * result should be insignificant; but even if we computed a\n\t\t * completely insane result, the checks below will prevent anything\n\t\t * really bad from happening.\n\t\t */\n\t\tdouble\t\tgrow_ratio;\n\n\t\tgrow_ratio = (double) state->allowedMem / (double) memNowUsed;\n\t\tif (memtupsize * grow_ratio < INT_MAX)\n\t\t\tnewmemtupsize = (int) (memtupsize * grow_ratio);\n\t\telse\n\t\t\tnewmemtupsize = INT_MAX;\n\n\t\t/* We won't make any further enlargement attempts */\n\t\tstate->growmemtuples = false;\n\t}\n\n\t/* Must enlarge array by at least one element, else report failure */\n\tif (newmemtupsize <= memtupsize)\n\t\tgoto noalloc;\n\n\t/*\n\t * On a 32-bit machine, allowedMem could exceed MaxAllocHugeSize.  Clamp\n\t * to ensure our request won't be rejected.  Note that we can easily\n\t * exhaust address space before facing this outcome.  (This is presently\n\t * impossible due to guc.c's MAX_KILOBYTES limitation on work_mem, but\n\t * don't rely on that at this distance.)\n\t */\n\tif ((Size) newmemtupsize >= MaxAllocHugeSize / sizeof(void *))\n\t{\n\t\tnewmemtupsize = (int) (MaxAllocHugeSize / sizeof(void *));\n\t\tstate->growmemtuples = false;\t/* can't grow any more */\n\t}\n\n\t/*\n\t * We need to be sure that we do not cause LACKMEM to become true, else\n\t * the space management algorithm will go nuts.  The code above should\n\t * never generate a dangerous request, but to be safe, check explicitly\n\t * that the array growth fits within availMem.  (We could still cause\n\t * LACKMEM if the memory chunk overhead associated with the memtuples\n\t * array were to increase.  That shouldn't happen because we chose the\n\t * initial array size large enough to ensure that palloc will be treating\n\t * both old and new arrays as separate chunks.  But we'll check LACKMEM\n\t * explicitly below just in case.)\n\t */\n\tif (state->availMem < (int64) ((newmemtupsize - memtupsize) * sizeof(void *)))\n\t\tgoto noalloc;\n\n\t/* OK, do it */\n\tFREEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tstate->memtupsize = newmemtupsize;\n\tstate->memtuples = (void **)\n\t\trepalloc_huge(state->memtuples,\n\t\t\t\t\t  state->memtupsize * sizeof(void *));\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"unexpected out-of-memory situation in tuplestore\");\n\treturn true;\n\nnoalloc:\n\t/* If for any reason we didn't realloc, shut off future attempts */\n\tstate->growmemtuples = false;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nstatic void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "tuplestore_putvalues",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "749-762",
    "snippet": "void\ntuplestore_putvalues(Tuplestorestate *state, TupleDesc tdesc,\n\t\t\t\t\t Datum *values, bool *isnull)\n{\n\tMinimalTuple tuple;\n\tMemoryContext oldcxt = MemoryContextSwitchTo(state->context);\n\n\ttuple = heap_form_minimal_tuple(tdesc, values, isnull);\n\tUSEMEM(state, GetMemoryChunkSpace(tuple));\n\n\ttuplestore_puttuple_common(state, (void *) tuple);\n\n\tMemoryContextSwitchTo(oldcxt);\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_puttuple_common",
          "args": [
            "state",
            "(void *) tuple"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_puttuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "764-892",
          "snippet": "static void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nstatic void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(tuple)"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "tuple"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_form_minimal_tuple",
          "args": [
            "tdesc",
            "values",
            "isnull"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->context"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_putvalues(Tuplestorestate *state, TupleDesc tdesc,\n\t\t\t\t\t Datum *values, bool *isnull)\n{\n\tMinimalTuple tuple;\n\tMemoryContext oldcxt = MemoryContextSwitchTo(state->context);\n\n\ttuple = heap_form_minimal_tuple(tdesc, values, isnull);\n\tUSEMEM(state, GetMemoryChunkSpace(tuple));\n\n\ttuplestore_puttuple_common(state, (void *) tuple);\n\n\tMemoryContextSwitchTo(oldcxt);\n}"
  },
  {
    "function_name": "tuplestore_puttuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "729-743",
    "snippet": "void\ntuplestore_puttuple(Tuplestorestate *state, HeapTuple tuple)\n{\n\tMemoryContext oldcxt = MemoryContextSwitchTo(state->context);\n\n\t/*\n\t * Copy the tuple.  (Must do this even in WRITEFILE case.  Note that\n\t * COPYTUP includes USEMEM, so we needn't do that here.)\n\t */\n\ttuple = COPYTUP(state, tuple);\n\n\ttuplestore_puttuple_common(state, (void *) tuple);\n\n\tMemoryContextSwitchTo(oldcxt);\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_puttuple_common",
          "args": [
            "state",
            "(void *) tuple"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_puttuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "764-892",
          "snippet": "static void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nstatic void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "COPYTUP",
          "args": [
            "state",
            "tuple"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->context"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_puttuple(Tuplestorestate *state, HeapTuple tuple)\n{\n\tMemoryContext oldcxt = MemoryContextSwitchTo(state->context);\n\n\t/*\n\t * Copy the tuple.  (Must do this even in WRITEFILE case.  Note that\n\t * COPYTUP includes USEMEM, so we needn't do that here.)\n\t */\n\ttuple = COPYTUP(state, tuple);\n\n\ttuplestore_puttuple_common(state, (void *) tuple);\n\n\tMemoryContextSwitchTo(oldcxt);\n}"
  },
  {
    "function_name": "tuplestore_puttupleslot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "707-723",
    "snippet": "void\ntuplestore_puttupleslot(Tuplestorestate *state,\n\t\t\t\t\t\tTupleTableSlot *slot)\n{\n\tMinimalTuple tuple;\n\tMemoryContext oldcxt = MemoryContextSwitchTo(state->context);\n\n\t/*\n\t * Form a MinimalTuple in working memory\n\t */\n\ttuple = ExecCopySlotMinimalTuple(slot);\n\tUSEMEM(state, GetMemoryChunkSpace(tuple));\n\n\ttuplestore_puttuple_common(state, (void *) tuple);\n\n\tMemoryContextSwitchTo(oldcxt);\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_puttuple_common",
          "args": [
            "state",
            "(void *) tuple"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_puttuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "764-892",
          "snippet": "static void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nstatic void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(tuple)"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "tuple"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExecCopySlotMinimalTuple",
          "args": [
            "slot"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->context"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_puttupleslot(Tuplestorestate *state,\n\t\t\t\t\t\tTupleTableSlot *slot)\n{\n\tMinimalTuple tuple;\n\tMemoryContext oldcxt = MemoryContextSwitchTo(state->context);\n\n\t/*\n\t * Form a MinimalTuple in working memory\n\t */\n\ttuple = ExecCopySlotMinimalTuple(slot);\n\tUSEMEM(state, GetMemoryChunkSpace(tuple));\n\n\ttuplestore_puttuple_common(state, (void *) tuple);\n\n\tMemoryContextSwitchTo(oldcxt);\n}"
  },
  {
    "function_name": "grow_memtuples",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "577-689",
    "snippet": "static bool\ngrow_memtuples(Tuplestorestate *state)\n{\n\tint\t\t\tnewmemtupsize;\n\tint\t\t\tmemtupsize = state->memtupsize;\n\tint64\t\tmemNowUsed = state->allowedMem - state->availMem;\n\n\t/* Forget it if we've already maxed out memtuples, per comment above */\n\tif (!state->growmemtuples)\n\t\treturn false;\n\n\t/* Select new value of memtupsize */\n\tif (memNowUsed <= state->availMem)\n\t{\n\t\t/*\n\t\t * We've used no more than half of allowedMem; double our usage,\n\t\t * clamping at INT_MAX tuples.\n\t\t */\n\t\tif (memtupsize < INT_MAX / 2)\n\t\t\tnewmemtupsize = memtupsize * 2;\n\t\telse\n\t\t{\n\t\t\tnewmemtupsize = INT_MAX;\n\t\t\tstate->growmemtuples = false;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This will be the last increment of memtupsize.  Abandon doubling\n\t\t * strategy and instead increase as much as we safely can.\n\t\t *\n\t\t * To stay within allowedMem, we can't increase memtupsize by more\n\t\t * than availMem / sizeof(void *) elements. In practice, we want to\n\t\t * increase it by considerably less, because we need to leave some\n\t\t * space for the tuples to which the new array slots will refer.  We\n\t\t * assume the new tuples will be about the same size as the tuples\n\t\t * we've already seen, and thus we can extrapolate from the space\n\t\t * consumption so far to estimate an appropriate new size for the\n\t\t * memtuples array.  The optimal value might be higher or lower than\n\t\t * this estimate, but it's hard to know that in advance.  We again\n\t\t * clamp at INT_MAX tuples.\n\t\t *\n\t\t * This calculation is safe against enlarging the array so much that\n\t\t * LACKMEM becomes true, because the memory currently used includes\n\t\t * the present array; thus, there would be enough allowedMem for the\n\t\t * new array elements even if no other memory were currently used.\n\t\t *\n\t\t * We do the arithmetic in float8, because otherwise the product of\n\t\t * memtupsize and allowedMem could overflow.  Any inaccuracy in the\n\t\t * result should be insignificant; but even if we computed a\n\t\t * completely insane result, the checks below will prevent anything\n\t\t * really bad from happening.\n\t\t */\n\t\tdouble\t\tgrow_ratio;\n\n\t\tgrow_ratio = (double) state->allowedMem / (double) memNowUsed;\n\t\tif (memtupsize * grow_ratio < INT_MAX)\n\t\t\tnewmemtupsize = (int) (memtupsize * grow_ratio);\n\t\telse\n\t\t\tnewmemtupsize = INT_MAX;\n\n\t\t/* We won't make any further enlargement attempts */\n\t\tstate->growmemtuples = false;\n\t}\n\n\t/* Must enlarge array by at least one element, else report failure */\n\tif (newmemtupsize <= memtupsize)\n\t\tgoto noalloc;\n\n\t/*\n\t * On a 32-bit machine, allowedMem could exceed MaxAllocHugeSize.  Clamp\n\t * to ensure our request won't be rejected.  Note that we can easily\n\t * exhaust address space before facing this outcome.  (This is presently\n\t * impossible due to guc.c's MAX_KILOBYTES limitation on work_mem, but\n\t * don't rely on that at this distance.)\n\t */\n\tif ((Size) newmemtupsize >= MaxAllocHugeSize / sizeof(void *))\n\t{\n\t\tnewmemtupsize = (int) (MaxAllocHugeSize / sizeof(void *));\n\t\tstate->growmemtuples = false;\t/* can't grow any more */\n\t}\n\n\t/*\n\t * We need to be sure that we do not cause LACKMEM to become true, else\n\t * the space management algorithm will go nuts.  The code above should\n\t * never generate a dangerous request, but to be safe, check explicitly\n\t * that the array growth fits within availMem.  (We could still cause\n\t * LACKMEM if the memory chunk overhead associated with the memtuples\n\t * array were to increase.  That shouldn't happen because we chose the\n\t * initial array size large enough to ensure that palloc will be treating\n\t * both old and new arrays as separate chunks.  But we'll check LACKMEM\n\t * explicitly below just in case.)\n\t */\n\tif (state->availMem < (int64) ((newmemtupsize - memtupsize) * sizeof(void *)))\n\t\tgoto noalloc;\n\n\t/* OK, do it */\n\tFREEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tstate->memtupsize = newmemtupsize;\n\tstate->memtuples = (void **)\n\t\trepalloc_huge(state->memtuples,\n\t\t\t\t\t  state->memtupsize * sizeof(void *));\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"unexpected out-of-memory situation in tuplestore\");\n\treturn true;\n\nnoalloc:\n\t/* If for any reason we didn't realloc, shut off future attempts */\n\tstate->growmemtuples = false;\n\treturn false;\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected out-of-memory situation in tuplestore\""
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LACKMEM",
          "args": [
            "state"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(state->memtuples)"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "state->memtuples"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "repalloc_huge",
          "args": [
            "state->memtuples",
            "state->memtupsize * sizeof(void *)"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "repalloc_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1113-1141",
          "snippet": "void *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FREEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(state->memtuples)"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(newmemtupsize - memtupsize) * sizeof(void *)"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nstatic bool\ngrow_memtuples(Tuplestorestate *state)\n{\n\tint\t\t\tnewmemtupsize;\n\tint\t\t\tmemtupsize = state->memtupsize;\n\tint64\t\tmemNowUsed = state->allowedMem - state->availMem;\n\n\t/* Forget it if we've already maxed out memtuples, per comment above */\n\tif (!state->growmemtuples)\n\t\treturn false;\n\n\t/* Select new value of memtupsize */\n\tif (memNowUsed <= state->availMem)\n\t{\n\t\t/*\n\t\t * We've used no more than half of allowedMem; double our usage,\n\t\t * clamping at INT_MAX tuples.\n\t\t */\n\t\tif (memtupsize < INT_MAX / 2)\n\t\t\tnewmemtupsize = memtupsize * 2;\n\t\telse\n\t\t{\n\t\t\tnewmemtupsize = INT_MAX;\n\t\t\tstate->growmemtuples = false;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This will be the last increment of memtupsize.  Abandon doubling\n\t\t * strategy and instead increase as much as we safely can.\n\t\t *\n\t\t * To stay within allowedMem, we can't increase memtupsize by more\n\t\t * than availMem / sizeof(void *) elements. In practice, we want to\n\t\t * increase it by considerably less, because we need to leave some\n\t\t * space for the tuples to which the new array slots will refer.  We\n\t\t * assume the new tuples will be about the same size as the tuples\n\t\t * we've already seen, and thus we can extrapolate from the space\n\t\t * consumption so far to estimate an appropriate new size for the\n\t\t * memtuples array.  The optimal value might be higher or lower than\n\t\t * this estimate, but it's hard to know that in advance.  We again\n\t\t * clamp at INT_MAX tuples.\n\t\t *\n\t\t * This calculation is safe against enlarging the array so much that\n\t\t * LACKMEM becomes true, because the memory currently used includes\n\t\t * the present array; thus, there would be enough allowedMem for the\n\t\t * new array elements even if no other memory were currently used.\n\t\t *\n\t\t * We do the arithmetic in float8, because otherwise the product of\n\t\t * memtupsize and allowedMem could overflow.  Any inaccuracy in the\n\t\t * result should be insignificant; but even if we computed a\n\t\t * completely insane result, the checks below will prevent anything\n\t\t * really bad from happening.\n\t\t */\n\t\tdouble\t\tgrow_ratio;\n\n\t\tgrow_ratio = (double) state->allowedMem / (double) memNowUsed;\n\t\tif (memtupsize * grow_ratio < INT_MAX)\n\t\t\tnewmemtupsize = (int) (memtupsize * grow_ratio);\n\t\telse\n\t\t\tnewmemtupsize = INT_MAX;\n\n\t\t/* We won't make any further enlargement attempts */\n\t\tstate->growmemtuples = false;\n\t}\n\n\t/* Must enlarge array by at least one element, else report failure */\n\tif (newmemtupsize <= memtupsize)\n\t\tgoto noalloc;\n\n\t/*\n\t * On a 32-bit machine, allowedMem could exceed MaxAllocHugeSize.  Clamp\n\t * to ensure our request won't be rejected.  Note that we can easily\n\t * exhaust address space before facing this outcome.  (This is presently\n\t * impossible due to guc.c's MAX_KILOBYTES limitation on work_mem, but\n\t * don't rely on that at this distance.)\n\t */\n\tif ((Size) newmemtupsize >= MaxAllocHugeSize / sizeof(void *))\n\t{\n\t\tnewmemtupsize = (int) (MaxAllocHugeSize / sizeof(void *));\n\t\tstate->growmemtuples = false;\t/* can't grow any more */\n\t}\n\n\t/*\n\t * We need to be sure that we do not cause LACKMEM to become true, else\n\t * the space management algorithm will go nuts.  The code above should\n\t * never generate a dangerous request, but to be safe, check explicitly\n\t * that the array growth fits within availMem.  (We could still cause\n\t * LACKMEM if the memory chunk overhead associated with the memtuples\n\t * array were to increase.  That shouldn't happen because we chose the\n\t * initial array size large enough to ensure that palloc will be treating\n\t * both old and new arrays as separate chunks.  But we'll check LACKMEM\n\t * explicitly below just in case.)\n\t */\n\tif (state->availMem < (int64) ((newmemtupsize - memtupsize) * sizeof(void *)))\n\t\tgoto noalloc;\n\n\t/* OK, do it */\n\tFREEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tstate->memtupsize = newmemtupsize;\n\tstate->memtuples = (void **)\n\t\trepalloc_huge(state->memtuples,\n\t\t\t\t\t  state->memtupsize * sizeof(void *));\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"unexpected out-of-memory situation in tuplestore\");\n\treturn true;\n\nnoalloc:\n\t/* If for any reason we didn't realloc, shut off future attempts */\n\tstate->growmemtuples = false;\n\treturn false;\n}"
  },
  {
    "function_name": "tuplestore_ateof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "556-560",
    "snippet": "bool\ntuplestore_ateof(Tuplestorestate *state)\n{\n\treturn state->readptrs[state->activeptr].eof_reached;\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nbool\ntuplestore_ateof(Tuplestorestate *state)\n{\n\treturn state->readptrs[state->activeptr].eof_reached;\n}"
  },
  {
    "function_name": "tuplestore_tuple_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "545-549",
    "snippet": "int64\ntuplestore_tuple_count(Tuplestorestate *state)\n{\n\treturn state->tuples;\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nint64\ntuplestore_tuple_count(Tuplestorestate *state)\n{\n\treturn state->tuples;\n}"
  },
  {
    "function_name": "tuplestore_select_read_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "472-537",
    "snippet": "void\ntuplestore_select_read_pointer(Tuplestorestate *state, int ptr)\n{\n\tTSReadPointer *readptr;\n\tTSReadPointer *oldptr;\n\n\tAssert(ptr >= 0 && ptr < state->readptrcount);\n\n\t/* No work if already active */\n\tif (ptr == state->activeptr)\n\t\treturn;\n\n\treadptr = &state->readptrs[ptr];\n\toldptr = &state->readptrs[state->activeptr];\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* no work */\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * First, save the current read position in the pointer about to\n\t\t\t * become inactive.\n\t\t\t */\n\t\t\tif (!oldptr->eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&oldptr->file,\n\t\t\t\t\t\t\t&oldptr->offset);\n\n\t\t\t/*\n\t\t\t * We have to make the temp file's seek position equal to the\n\t\t\t * logical position of the new read pointer.  In eof_reached\n\t\t\t * state, that's the EOF, which we have available from the saved\n\t\t\t * write position.\n\t\t\t */\n\t\t\tif (readptr->eof_reached)\n\t\t\t{\n\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\tstate->writepos_file,\n\t\t\t\t\t\t\t\tstate->writepos_offset,\n\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\treadptr->file,\n\t\t\t\t\t\t\t\treadptr->offset,\n\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n\n\tstate->activeptr = ptr;\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid tuplestore state\""
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\"))"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not seek in tuplestore temporary file: %m\""
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileSeek",
          "args": [
            "state->myfile",
            "readptr->file",
            "readptr->offset",
            "SEEK_SET"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\"))"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileSeek",
          "args": [
            "state->myfile",
            "state->writepos_file",
            "state->writepos_offset",
            "SEEK_SET"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileTell",
          "args": [
            "state->myfile",
            "&oldptr->file",
            "&oldptr->offset"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ptr >= 0 && ptr < state->readptrcount"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_select_read_pointer(Tuplestorestate *state, int ptr)\n{\n\tTSReadPointer *readptr;\n\tTSReadPointer *oldptr;\n\n\tAssert(ptr >= 0 && ptr < state->readptrcount);\n\n\t/* No work if already active */\n\tif (ptr == state->activeptr)\n\t\treturn;\n\n\treadptr = &state->readptrs[ptr];\n\toldptr = &state->readptrs[state->activeptr];\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* no work */\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * First, save the current read position in the pointer about to\n\t\t\t * become inactive.\n\t\t\t */\n\t\t\tif (!oldptr->eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&oldptr->file,\n\t\t\t\t\t\t\t&oldptr->offset);\n\n\t\t\t/*\n\t\t\t * We have to make the temp file's seek position equal to the\n\t\t\t * logical position of the new read pointer.  In eof_reached\n\t\t\t * state, that's the EOF, which we have available from the saved\n\t\t\t * write position.\n\t\t\t */\n\t\t\tif (readptr->eof_reached)\n\t\t\t{\n\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\tstate->writepos_file,\n\t\t\t\t\t\t\t\tstate->writepos_offset,\n\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\treadptr->file,\n\t\t\t\t\t\t\t\treadptr->offset,\n\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n\n\tstate->activeptr = ptr;\n}"
  },
  {
    "function_name": "tuplestore_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "452-467",
    "snippet": "void\ntuplestore_end(Tuplestorestate *state)\n{\n\tint\t\t\ti;\n\n\tif (state->myfile)\n\t\tBufFileClose(state->myfile);\n\tif (state->memtuples)\n\t{\n\t\tfor (i = state->memtupdeleted; i < state->memtupcount; i++)\n\t\t\tpfree(state->memtuples[i]);\n\t\tpfree(state->memtuples);\n\t}\n\tpfree(state->readptrs);\n\tpfree(state);\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "state"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileClose",
          "args": [
            "state->myfile"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_end(Tuplestorestate *state)\n{\n\tint\t\t\ti;\n\n\tif (state->myfile)\n\t\tBufFileClose(state->myfile);\n\tif (state->memtuples)\n\t{\n\t\tfor (i = state->memtupdeleted; i < state->memtupcount; i++)\n\t\t\tpfree(state->memtuples[i]);\n\t\tpfree(state->memtuples);\n\t}\n\tpfree(state->readptrs);\n\tpfree(state);\n}"
  },
  {
    "function_name": "tuplestore_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "417-445",
    "snippet": "void\ntuplestore_clear(Tuplestorestate *state)\n{\n\tint\t\t\ti;\n\tTSReadPointer *readptr;\n\n\tif (state->myfile)\n\t\tBufFileClose(state->myfile);\n\tstate->myfile = NULL;\n\tif (state->memtuples)\n\t{\n\t\tfor (i = state->memtupdeleted; i < state->memtupcount; i++)\n\t\t{\n\t\t\tFREEMEM(state, GetMemoryChunkSpace(state->memtuples[i]));\n\t\t\tpfree(state->memtuples[i]);\n\t\t}\n\t}\n\tstate->status = TSS_INMEM;\n\tstate->truncated = false;\n\tstate->memtupdeleted = 0;\n\tstate->memtupcount = 0;\n\tstate->tuples = 0;\n\treadptr = state->readptrs;\n\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t{\n\t\treadptr->eof_reached = false;\n\t\treadptr->current = 0;\n\t}\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "state->memtuples[i]"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FREEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(state->memtuples[i])"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "state->memtuples[i]"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileClose",
          "args": [
            "state->myfile"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_clear(Tuplestorestate *state)\n{\n\tint\t\t\ti;\n\tTSReadPointer *readptr;\n\n\tif (state->myfile)\n\t\tBufFileClose(state->myfile);\n\tstate->myfile = NULL;\n\tif (state->memtuples)\n\t{\n\t\tfor (i = state->memtupdeleted; i < state->memtupcount; i++)\n\t\t{\n\t\t\tFREEMEM(state, GetMemoryChunkSpace(state->memtuples[i]));\n\t\t\tpfree(state->memtuples[i]);\n\t\t}\n\t}\n\tstate->status = TSS_INMEM;\n\tstate->truncated = false;\n\tstate->memtupdeleted = 0;\n\tstate->memtupcount = 0;\n\tstate->tuples = 0;\n\treadptr = state->readptrs;\n\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t{\n\t\treadptr->eof_reached = false;\n\t\treadptr->current = 0;\n\t}\n}"
  },
  {
    "function_name": "tuplestore_alloc_read_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "382-409",
    "snippet": "int\ntuplestore_alloc_read_pointer(Tuplestorestate *state, int eflags)\n{\n\t/* Check for possible increase of requirements */\n\tif (state->status != TSS_INMEM || state->memtupcount != 0)\n\t{\n\t\tif ((state->eflags | eflags) != state->eflags)\n\t\t\telog(ERROR, \"too late to require new tuplestore eflags\");\n\t}\n\n\t/* Make room for another read pointer if needed */\n\tif (state->readptrcount >= state->readptrsize)\n\t{\n\t\tint\t\t\tnewcnt = state->readptrsize * 2;\n\n\t\tstate->readptrs = (TSReadPointer *)\n\t\t\trepalloc(state->readptrs, newcnt * sizeof(TSReadPointer));\n\t\tstate->readptrsize = newcnt;\n\t}\n\n\t/* And set it up */\n\tstate->readptrs[state->readptrcount] = state->readptrs[0];\n\tstate->readptrs[state->readptrcount].eflags = eflags;\n\n\tstate->eflags |= eflags;\n\n\treturn state->readptrcount++;\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "state->readptrs",
            "newcnt * sizeof(TSReadPointer)"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "repalloc_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1113-1141",
          "snippet": "void *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"too late to require new tuplestore eflags\""
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nint\ntuplestore_alloc_read_pointer(Tuplestorestate *state, int eflags)\n{\n\t/* Check for possible increase of requirements */\n\tif (state->status != TSS_INMEM || state->memtupcount != 0)\n\t{\n\t\tif ((state->eflags | eflags) != state->eflags)\n\t\t\telog(ERROR, \"too late to require new tuplestore eflags\");\n\t}\n\n\t/* Make room for another read pointer if needed */\n\tif (state->readptrcount >= state->readptrsize)\n\t{\n\t\tint\t\t\tnewcnt = state->readptrsize * 2;\n\n\t\tstate->readptrs = (TSReadPointer *)\n\t\t\trepalloc(state->readptrs, newcnt * sizeof(TSReadPointer));\n\t\tstate->readptrsize = newcnt;\n\t}\n\n\t/* And set it up */\n\tstate->readptrs[state->readptrcount] = state->readptrs[0];\n\tstate->readptrs[state->readptrcount].eflags = eflags;\n\n\tstate->eflags |= eflags;\n\n\treturn state->readptrcount++;\n}"
  },
  {
    "function_name": "tuplestore_set_eflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "358-370",
    "snippet": "void\ntuplestore_set_eflags(Tuplestorestate *state, int eflags)\n{\n\tint\t\t\ti;\n\n\tif (state->status != TSS_INMEM || state->memtupcount != 0)\n\t\telog(ERROR, \"too late to call tuplestore_set_eflags\");\n\n\tstate->readptrs[0].eflags = eflags;\n\tfor (i = 1; i < state->readptrcount; i++)\n\t\teflags |= state->readptrs[i].eflags;\n\tstate->eflags = eflags;\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"too late to call tuplestore_set_eflags\""
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_set_eflags(Tuplestorestate *state, int eflags)\n{\n\tint\t\t\ti;\n\n\tif (state->status != TSS_INMEM || state->memtupcount != 0)\n\t\telog(ERROR, \"too late to call tuplestore_set_eflags\");\n\n\tstate->readptrs[0].eflags = eflags;\n\tfor (i = 1; i < state->readptrcount; i++)\n\t\teflags |= state->readptrs[i].eflags;\n\tstate->eflags = eflags;\n}"
  },
  {
    "function_name": "tuplestore_begin_heap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "317-338",
    "snippet": "Tuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);",
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tuplestore_begin_common",
          "args": [
            "eflags",
            "interXact",
            "maxKBytes"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_begin_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "252-296",
          "snippet": "static Tuplestorestate *\ntuplestore_begin_common(int eflags, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\n\tstate = (Tuplestorestate *) palloc0(sizeof(Tuplestorestate));\n\n\tstate->status = TSS_INMEM;\n\tstate->eflags = eflags;\n\tstate->interXact = interXact;\n\tstate->truncated = false;\n\tstate->allowedMem = maxKBytes * 1024L;\n\tstate->availMem = state->allowedMem;\n\tstate->myfile = NULL;\n\tstate->context = CurrentMemoryContext;\n\tstate->resowner = CurrentResourceOwner;\n\n\tstate->memtupdeleted = 0;\n\tstate->memtupcount = 0;\n\tstate->tuples = 0;\n\n\t/*\n\t * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;\n\t * see comments in grow_memtuples().\n\t */\n\tstate->memtupsize = Max(16384 / sizeof(void *),\n\t\t\t\t\t\t\tALLOCSET_SEPARATE_THRESHOLD / sizeof(void *) + 1);\n\n\tstate->growmemtuples = true;\n\tstate->memtuples = (void **) palloc(state->memtupsize * sizeof(void *));\n\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\tstate->activeptr = 0;\n\tstate->readptrcount = 1;\n\tstate->readptrsize = 8;\t\t/* arbitrary */\n\tstate->readptrs = (TSReadPointer *)\n\t\tpalloc(state->readptrsize * sizeof(TSReadPointer));\n\n\tstate->readptrs[0].eflags = eflags;\n\tstate->readptrs[0].eof_reached = false;\n\tstate->readptrs[0].current = 0;\n\n\treturn state;\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);\nstatic void dumptuples(Tuplestorestate *state);\n\nstatic Tuplestorestate *\ntuplestore_begin_common(int eflags, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\n\tstate = (Tuplestorestate *) palloc0(sizeof(Tuplestorestate));\n\n\tstate->status = TSS_INMEM;\n\tstate->eflags = eflags;\n\tstate->interXact = interXact;\n\tstate->truncated = false;\n\tstate->allowedMem = maxKBytes * 1024L;\n\tstate->availMem = state->allowedMem;\n\tstate->myfile = NULL;\n\tstate->context = CurrentMemoryContext;\n\tstate->resowner = CurrentResourceOwner;\n\n\tstate->memtupdeleted = 0;\n\tstate->memtupcount = 0;\n\tstate->tuples = 0;\n\n\t/*\n\t * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;\n\t * see comments in grow_memtuples().\n\t */\n\tstate->memtupsize = Max(16384 / sizeof(void *),\n\t\t\t\t\t\t\tALLOCSET_SEPARATE_THRESHOLD / sizeof(void *) + 1);\n\n\tstate->growmemtuples = true;\n\tstate->memtuples = (void **) palloc(state->memtupsize * sizeof(void *));\n\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\tstate->activeptr = 0;\n\tstate->readptrcount = 1;\n\tstate->readptrsize = 8;\t\t/* arbitrary */\n\tstate->readptrs = (TSReadPointer *)\n\t\tpalloc(state->readptrsize * sizeof(TSReadPointer));\n\n\tstate->readptrs[0].eflags = eflags;\n\tstate->readptrs[0].eof_reached = false;\n\tstate->readptrs[0].current = 0;\n\n\treturn state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);\nstatic void dumptuples(Tuplestorestate *state);\n\nTuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}"
  },
  {
    "function_name": "tuplestore_begin_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
    "lines": "252-296",
    "snippet": "static Tuplestorestate *\ntuplestore_begin_common(int eflags, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\n\tstate = (Tuplestorestate *) palloc0(sizeof(Tuplestorestate));\n\n\tstate->status = TSS_INMEM;\n\tstate->eflags = eflags;\n\tstate->interXact = interXact;\n\tstate->truncated = false;\n\tstate->allowedMem = maxKBytes * 1024L;\n\tstate->availMem = state->allowedMem;\n\tstate->myfile = NULL;\n\tstate->context = CurrentMemoryContext;\n\tstate->resowner = CurrentResourceOwner;\n\n\tstate->memtupdeleted = 0;\n\tstate->memtupcount = 0;\n\tstate->tuples = 0;\n\n\t/*\n\t * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;\n\t * see comments in grow_memtuples().\n\t */\n\tstate->memtupsize = Max(16384 / sizeof(void *),\n\t\t\t\t\t\t\tALLOCSET_SEPARATE_THRESHOLD / sizeof(void *) + 1);\n\n\tstate->growmemtuples = true;\n\tstate->memtuples = (void **) palloc(state->memtupsize * sizeof(void *));\n\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\tstate->activeptr = 0;\n\tstate->readptrcount = 1;\n\tstate->readptrsize = 8;\t\t/* arbitrary */\n\tstate->readptrs = (TSReadPointer *)\n\t\tpalloc(state->readptrsize * sizeof(TSReadPointer));\n\n\tstate->readptrs[0].eflags = eflags;\n\tstate->readptrs[0].eof_reached = false;\n\tstate->readptrs[0].current = 0;\n\n\treturn state;\n}",
    "includes": [
      "#include \"utils/resowner.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);",
      "static void dumptuples(Tuplestorestate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "state->readptrsize * sizeof(TSReadPointer)"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(state->memtuples)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "state->memtuples"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "16384 / sizeof(void *)",
            "ALLOCSET_SEPARATE_THRESHOLD / sizeof(void *) + 1"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);\nstatic void dumptuples(Tuplestorestate *state);\n\nstatic Tuplestorestate *\ntuplestore_begin_common(int eflags, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\n\tstate = (Tuplestorestate *) palloc0(sizeof(Tuplestorestate));\n\n\tstate->status = TSS_INMEM;\n\tstate->eflags = eflags;\n\tstate->interXact = interXact;\n\tstate->truncated = false;\n\tstate->allowedMem = maxKBytes * 1024L;\n\tstate->availMem = state->allowedMem;\n\tstate->myfile = NULL;\n\tstate->context = CurrentMemoryContext;\n\tstate->resowner = CurrentResourceOwner;\n\n\tstate->memtupdeleted = 0;\n\tstate->memtupcount = 0;\n\tstate->tuples = 0;\n\n\t/*\n\t * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;\n\t * see comments in grow_memtuples().\n\t */\n\tstate->memtupsize = Max(16384 / sizeof(void *),\n\t\t\t\t\t\t\tALLOCSET_SEPARATE_THRESHOLD / sizeof(void *) + 1);\n\n\tstate->growmemtuples = true;\n\tstate->memtuples = (void **) palloc(state->memtupsize * sizeof(void *));\n\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\tstate->activeptr = 0;\n\tstate->readptrcount = 1;\n\tstate->readptrsize = 8;\t\t/* arbitrary */\n\tstate->readptrs = (TSReadPointer *)\n\t\tpalloc(state->readptrsize * sizeof(TSReadPointer));\n\n\tstate->readptrs[0].eflags = eflags;\n\tstate->readptrs[0].eof_reached = false;\n\tstate->readptrs[0].current = 0;\n\n\treturn state;\n}"
  }
]