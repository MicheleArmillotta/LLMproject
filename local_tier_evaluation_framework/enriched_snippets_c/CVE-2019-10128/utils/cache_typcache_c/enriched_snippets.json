[
  {
    "function_name": "shared_record_typmod_registry_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "2621-2636",
    "snippet": "static void\nshared_record_typmod_registry_detach(dsm_segment *segment, Datum datum)\n{\n\t/* Be cautious here: maybe we didn't finish initializing. */\n\tif (CurrentSession->shared_record_table != NULL)\n\t{\n\t\tdshash_detach(CurrentSession->shared_record_table);\n\t\tCurrentSession->shared_record_table = NULL;\n\t}\n\tif (CurrentSession->shared_typmod_table != NULL)\n\t{\n\t\tdshash_detach(CurrentSession->shared_typmod_table);\n\t\tCurrentSession->shared_typmod_table = NULL;\n\t}\n\tCurrentSession->shared_typmod_registry = NULL;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void shared_record_typmod_registry_detach(dsm_segment *segment,\n\t\t\t\t\t\t\t\t\t Datum datum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dshash_detach",
          "args": [
            "CurrentSession->shared_typmod_table"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dshash_detach",
          "args": [
            "CurrentSession->shared_record_table"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void shared_record_typmod_registry_detach(dsm_segment *segment,\n\t\t\t\t\t\t\t\t\t Datum datum);\n\nstatic void\nshared_record_typmod_registry_detach(dsm_segment *segment, Datum datum)\n{\n\t/* Be cautious here: maybe we didn't finish initializing. */\n\tif (CurrentSession->shared_record_table != NULL)\n\t{\n\t\tdshash_detach(CurrentSession->shared_record_table);\n\t\tCurrentSession->shared_record_table = NULL;\n\t}\n\tif (CurrentSession->shared_typmod_table != NULL)\n\t{\n\t\tdshash_detach(CurrentSession->shared_typmod_table);\n\t\tCurrentSession->shared_typmod_table = NULL;\n\t}\n\tCurrentSession->shared_typmod_registry = NULL;\n}"
  },
  {
    "function_name": "find_or_make_matching_shared_tupledesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "2509-2615",
    "snippet": "static TupleDesc\nfind_or_make_matching_shared_tupledesc(TupleDesc tupdesc)\n{\n\tTupleDesc\tresult;\n\tSharedRecordTableKey key;\n\tSharedRecordTableEntry *record_table_entry;\n\tSharedTypmodTableEntry *typmod_table_entry;\n\tdsa_pointer shared_dp;\n\tbool\t\tfound;\n\tuint32\t\ttypmod;\n\n\t/* If not even attached, nothing to do. */\n\tif (CurrentSession->shared_typmod_registry == NULL)\n\t\treturn NULL;\n\n\t/* Try to find a matching tuple descriptor in the record table. */\n\tkey.shared = false;\n\tkey.u.local_tupdesc = tupdesc;\n\trecord_table_entry = (SharedRecordTableEntry *)\n\t\tdshash_find(CurrentSession->shared_record_table, &key, false);\n\tif (record_table_entry)\n\t{\n\t\tAssert(record_table_entry->key.shared);\n\t\tdshash_release_lock(CurrentSession->shared_record_table,\n\t\t\t\t\t\t\trecord_table_entry);\n\t\tresult = (TupleDesc)\n\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\trecord_table_entry->key.u.shared_tupdesc);\n\t\tAssert(result->tdrefcount == -1);\n\n\t\treturn result;\n\t}\n\n\t/* Allocate a new typmod number.  This will be wasted if we error out. */\n\ttypmod = (int)\n\t\tpg_atomic_fetch_add_u32(&CurrentSession->shared_typmod_registry->next_typmod,\n\t\t\t\t\t\t\t\t1);\n\n\t/* Copy the TupleDesc into shared memory. */\n\tshared_dp = share_tupledesc(CurrentSession->area, tupdesc, typmod);\n\n\t/*\n\t * Create an entry in the typmod table so that others will understand this\n\t * typmod number.\n\t */\n\tPG_TRY();\n\t{\n\t\ttypmod_table_entry = (SharedTypmodTableEntry *)\n\t\t\tdshash_find_or_insert(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t  &typmod, &found);\n\t\tif (found)\n\t\t\telog(ERROR, \"cannot create duplicate shared record typmod\");\n\t}\n\tPG_CATCH();\n\t{\n\t\tdsa_free(CurrentSession->area, shared_dp);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\ttypmod_table_entry->typmod = typmod;\n\ttypmod_table_entry->shared_tupdesc = shared_dp;\n\tdshash_release_lock(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\ttypmod_table_entry);\n\n\t/*\n\t * Finally create an entry in the record table so others with matching\n\t * tuple descriptors can reuse the typmod.\n\t */\n\trecord_table_entry = (SharedRecordTableEntry *)\n\t\tdshash_find_or_insert(CurrentSession->shared_record_table, &key,\n\t\t\t\t\t\t\t  &found);\n\tif (found)\n\t{\n\t\t/*\n\t\t * Someone concurrently inserted a matching tuple descriptor since the\n\t\t * first time we checked.  Use that one instead.\n\t\t */\n\t\tdshash_release_lock(CurrentSession->shared_record_table,\n\t\t\t\t\t\t\trecord_table_entry);\n\n\t\t/* Might as well free up the space used by the one we created. */\n\t\tfound = dshash_delete_key(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t  &typmod);\n\t\tAssert(found);\n\t\tdsa_free(CurrentSession->area, shared_dp);\n\n\t\t/* Return the one we found. */\n\t\tAssert(record_table_entry->key.shared);\n\t\tresult = (TupleDesc)\n\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\trecord_table_entry->key.shared);\n\t\tAssert(result->tdrefcount == -1);\n\n\t\treturn result;\n\t}\n\n\t/* Store it and return it. */\n\trecord_table_entry->key.shared = true;\n\trecord_table_entry->key.u.shared_tupdesc = shared_dp;\n\tdshash_release_lock(CurrentSession->shared_record_table,\n\t\t\t\t\t\trecord_table_entry);\n\tresult = (TupleDesc)\n\t\tdsa_get_address(CurrentSession->area, shared_dp);\n\tAssert(result->tdrefcount == -1);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);",
      "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "result->tdrefcount == -1"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_get_address",
          "args": [
            "CurrentSession->area",
            "shared_dp"
          ],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "931-957",
          "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dshash_release_lock",
          "args": [
            "CurrentSession->shared_record_table",
            "record_table_entry"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "result->tdrefcount == -1"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "record_table_entry->key.shared"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_free",
          "args": [
            "CurrentSession->area",
            "shared_dp"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "819-923",
          "snippet": "void\ndsa_free(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_map *segment_map;\n\tint\t\t\tpageno;\n\tdsa_pointer span_pointer;\n\tdsa_area_span *span;\n\tchar\t   *superblock;\n\tchar\t   *object;\n\tsize_t\t\tsize;\n\tint\t\t\tsize_class;\n\n\t/* Make sure we don't have a stale segment in the slot 'dp' refers to. */\n\tcheck_for_freed_segments(area);\n\n\t/* Locate the object, span and pool. */\n\tsegment_map = get_segment_by_index(area, DSA_EXTRACT_SEGMENT_NUMBER(dp));\n\tpageno = DSA_EXTRACT_OFFSET(dp) / FPM_PAGE_SIZE;\n\tspan_pointer = segment_map->pagemap[pageno];\n\tspan = dsa_get_address(area, span_pointer);\n\tsuperblock = dsa_get_address(area, span->start);\n\tobject = dsa_get_address(area, dp);\n\tsize_class = span->size_class;\n\tsize = dsa_size_classes[size_class];\n\n\t/*\n\t * Special case for large objects that live in a special span: we return\n\t * those pages directly to the free page manager and free the span.\n\t */\n\tif (span->size_class == DSA_SCLASS_SPAN_LARGE)\n\t{\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\tmemset(object, 0x7f, span->npages * FPM_PAGE_SIZE);\n#endif\n\n\t\t/* Give pages back to free page manager. */\n\t\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\t\tFreePageManagerPut(segment_map->fpm,\n\t\t\t\t\t\t   DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE,\n\t\t\t\t\t\t   span->npages);\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\t/* Unlink span. */\n\t\tLWLockAcquire(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE),\n\t\t\t\t\t  LW_EXCLUSIVE);\n\t\tunlink_span(area, span);\n\t\tLWLockRelease(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE));\n\t\t/* Free the span object so it can be reused. */\n\t\tdsa_free(area, span_pointer);\n\t\treturn;\n\t}\n\n#ifdef CLOBBER_FREED_MEMORY\n\tmemset(object, 0x7f, size);\n#endif\n\n\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\n\t/* Put the object on the span's freelist. */\n\tAssert(object >= superblock);\n\tAssert(object < superblock + DSA_SUPERBLOCK_SIZE);\n\tAssert((object - superblock) % size == 0);\n\tNextFreeObjectIndex(object) = span->firstfree;\n\tspan->firstfree = (object - superblock) / size;\n\t++span->nallocatable;\n\n\t/*\n\t * See if the span needs to moved to a different fullness class, or be\n\t * freed so its pages can be given back to the segment.\n\t */\n\tif (span->nallocatable == 1 && span->fclass == DSA_FULLNESS_CLASSES - 1)\n\t{\n\t\t/*\n\t\t * The block was completely full and is located in the\n\t\t * highest-numbered fullness class, which is never scanned for free\n\t\t * chunks.  We must move it to the next-lower fullness class.\n\t\t */\n\t\tunlink_span(area, span);\n\t\tadd_span_to_fullness_class(area, span, span_pointer,\n\t\t\t\t\t\t\t\t   DSA_FULLNESS_CLASSES - 2);\n\n\t\t/*\n\t\t * If this is the only span, and there is no active span, then we\n\t\t * should probably move this span to fullness class 1.  (Otherwise if\n\t\t * you allocate exactly all the objects in the only span, it moves to\n\t\t * class 3, then you free them all, it moves to 2, and then is given\n\t\t * back, leaving no active span).\n\t\t */\n\t}\n\telse if (span->nallocatable == span->nmax &&\n\t\t\t (span->fclass != 1 || span->prevspan != InvalidDsaPointer))\n\t{\n\t\t/*\n\t\t * This entire block is free, and it's not the active block for this\n\t\t * size class.  Return the memory to the free page manager. We don't\n\t\t * do this for the active block to prevent hysteresis: if we\n\t\t * repeatedly allocate and free the only chunk in the active block, it\n\t\t * will be very inefficient if we deallocate and reallocate the block\n\t\t * every time.\n\t\t */\n\t\tdestroy_superblock(area, span_pointer);\n\t}\n\n\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)",
            "#define DSA_FULLNESS_CLASSES\t\t4",
            "#define DSA_SCLASS_SPAN_LARGE\t\t\t1"
          ],
          "globals_used": [
            "static const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};",
            "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
            "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
            "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
            "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
            "static void unlink_span(dsa_area *area, dsa_area_span *span);",
            "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)\n#define DSA_FULLNESS_CLASSES\t\t4\n#define DSA_SCLASS_SPAN_LARGE\t\t\t1\n\nstatic const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid\ndsa_free(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_map *segment_map;\n\tint\t\t\tpageno;\n\tdsa_pointer span_pointer;\n\tdsa_area_span *span;\n\tchar\t   *superblock;\n\tchar\t   *object;\n\tsize_t\t\tsize;\n\tint\t\t\tsize_class;\n\n\t/* Make sure we don't have a stale segment in the slot 'dp' refers to. */\n\tcheck_for_freed_segments(area);\n\n\t/* Locate the object, span and pool. */\n\tsegment_map = get_segment_by_index(area, DSA_EXTRACT_SEGMENT_NUMBER(dp));\n\tpageno = DSA_EXTRACT_OFFSET(dp) / FPM_PAGE_SIZE;\n\tspan_pointer = segment_map->pagemap[pageno];\n\tspan = dsa_get_address(area, span_pointer);\n\tsuperblock = dsa_get_address(area, span->start);\n\tobject = dsa_get_address(area, dp);\n\tsize_class = span->size_class;\n\tsize = dsa_size_classes[size_class];\n\n\t/*\n\t * Special case for large objects that live in a special span: we return\n\t * those pages directly to the free page manager and free the span.\n\t */\n\tif (span->size_class == DSA_SCLASS_SPAN_LARGE)\n\t{\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\tmemset(object, 0x7f, span->npages * FPM_PAGE_SIZE);\n#endif\n\n\t\t/* Give pages back to free page manager. */\n\t\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\t\tFreePageManagerPut(segment_map->fpm,\n\t\t\t\t\t\t   DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE,\n\t\t\t\t\t\t   span->npages);\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\t/* Unlink span. */\n\t\tLWLockAcquire(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE),\n\t\t\t\t\t  LW_EXCLUSIVE);\n\t\tunlink_span(area, span);\n\t\tLWLockRelease(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE));\n\t\t/* Free the span object so it can be reused. */\n\t\tdsa_free(area, span_pointer);\n\t\treturn;\n\t}\n\n#ifdef CLOBBER_FREED_MEMORY\n\tmemset(object, 0x7f, size);\n#endif\n\n\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\n\t/* Put the object on the span's freelist. */\n\tAssert(object >= superblock);\n\tAssert(object < superblock + DSA_SUPERBLOCK_SIZE);\n\tAssert((object - superblock) % size == 0);\n\tNextFreeObjectIndex(object) = span->firstfree;\n\tspan->firstfree = (object - superblock) / size;\n\t++span->nallocatable;\n\n\t/*\n\t * See if the span needs to moved to a different fullness class, or be\n\t * freed so its pages can be given back to the segment.\n\t */\n\tif (span->nallocatable == 1 && span->fclass == DSA_FULLNESS_CLASSES - 1)\n\t{\n\t\t/*\n\t\t * The block was completely full and is located in the\n\t\t * highest-numbered fullness class, which is never scanned for free\n\t\t * chunks.  We must move it to the next-lower fullness class.\n\t\t */\n\t\tunlink_span(area, span);\n\t\tadd_span_to_fullness_class(area, span, span_pointer,\n\t\t\t\t\t\t\t\t   DSA_FULLNESS_CLASSES - 2);\n\n\t\t/*\n\t\t * If this is the only span, and there is no active span, then we\n\t\t * should probably move this span to fullness class 1.  (Otherwise if\n\t\t * you allocate exactly all the objects in the only span, it moves to\n\t\t * class 3, then you free them all, it moves to 2, and then is given\n\t\t * back, leaving no active span).\n\t\t */\n\t}\n\telse if (span->nallocatable == span->nmax &&\n\t\t\t (span->fclass != 1 || span->prevspan != InvalidDsaPointer))\n\t{\n\t\t/*\n\t\t * This entire block is free, and it's not the active block for this\n\t\t * size class.  Return the memory to the free page manager. We don't\n\t\t * do this for the active block to prevent hysteresis: if we\n\t\t * repeatedly allocate and free the only chunk in the active block, it\n\t\t * will be very inefficient if we deallocate and reallocate the block\n\t\t * every time.\n\t\t */\n\t\tdestroy_superblock(area, span_pointer);\n\t}\n\n\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "found"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dshash_delete_key",
          "args": [
            "CurrentSession->shared_typmod_table",
            "&typmod"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dshash_release_lock",
          "args": [
            "CurrentSession->shared_record_table",
            "record_table_entry"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dshash_find_or_insert",
          "args": [
            "CurrentSession->shared_record_table",
            "&key",
            "&found"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dshash_release_lock",
          "args": [
            "CurrentSession->shared_typmod_table",
            "typmod_table_entry"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_END_TRY",
          "args": [],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_CATCH",
          "args": [],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cannot create duplicate shared record typmod\""
          ],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dshash_find_or_insert",
          "args": [
            "CurrentSession->shared_typmod_table",
            "&typmod",
            "&found"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_TRY",
          "args": [],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "share_tupledesc",
          "args": [
            "CurrentSession->area",
            "tupdesc",
            "typmod"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "share_tupledesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "2488-2500",
          "snippet": "static dsa_pointer\nshare_tupledesc(dsa_area *area, TupleDesc tupdesc, uint32 typmod)\n{\n\tdsa_pointer shared_dp;\n\tTupleDesc\tshared;\n\n\tshared_dp = dsa_allocate(area, TupleDescSize(tupdesc));\n\tshared = (TupleDesc) dsa_get_address(area, shared_dp);\n\tTupleDescCopy(shared, tupdesc);\n\tshared->tdtypmod = typmod;\n\n\treturn shared_dp;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);",
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nstatic dsa_pointer\nshare_tupledesc(dsa_area *area, TupleDesc tupdesc, uint32 typmod)\n{\n\tdsa_pointer shared_dp;\n\tTupleDesc\tshared;\n\n\tshared_dp = dsa_allocate(area, TupleDescSize(tupdesc));\n\tshared = (TupleDesc) dsa_get_address(area, shared_dp);\n\tTupleDescCopy(shared, tupdesc);\n\tshared->tdtypmod = typmod;\n\n\treturn shared_dp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_atomic_fetch_add_u32",
          "args": [
            "&CurrentSession->shared_typmod_registry->next_typmod",
            "1"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "result->tdrefcount == -1"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dshash_release_lock",
          "args": [
            "CurrentSession->shared_record_table",
            "record_table_entry"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "record_table_entry->key.shared"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dshash_find",
          "args": [
            "CurrentSession->shared_record_table",
            "&key",
            "false"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nstatic TupleDesc\nfind_or_make_matching_shared_tupledesc(TupleDesc tupdesc)\n{\n\tTupleDesc\tresult;\n\tSharedRecordTableKey key;\n\tSharedRecordTableEntry *record_table_entry;\n\tSharedTypmodTableEntry *typmod_table_entry;\n\tdsa_pointer shared_dp;\n\tbool\t\tfound;\n\tuint32\t\ttypmod;\n\n\t/* If not even attached, nothing to do. */\n\tif (CurrentSession->shared_typmod_registry == NULL)\n\t\treturn NULL;\n\n\t/* Try to find a matching tuple descriptor in the record table. */\n\tkey.shared = false;\n\tkey.u.local_tupdesc = tupdesc;\n\trecord_table_entry = (SharedRecordTableEntry *)\n\t\tdshash_find(CurrentSession->shared_record_table, &key, false);\n\tif (record_table_entry)\n\t{\n\t\tAssert(record_table_entry->key.shared);\n\t\tdshash_release_lock(CurrentSession->shared_record_table,\n\t\t\t\t\t\t\trecord_table_entry);\n\t\tresult = (TupleDesc)\n\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\trecord_table_entry->key.u.shared_tupdesc);\n\t\tAssert(result->tdrefcount == -1);\n\n\t\treturn result;\n\t}\n\n\t/* Allocate a new typmod number.  This will be wasted if we error out. */\n\ttypmod = (int)\n\t\tpg_atomic_fetch_add_u32(&CurrentSession->shared_typmod_registry->next_typmod,\n\t\t\t\t\t\t\t\t1);\n\n\t/* Copy the TupleDesc into shared memory. */\n\tshared_dp = share_tupledesc(CurrentSession->area, tupdesc, typmod);\n\n\t/*\n\t * Create an entry in the typmod table so that others will understand this\n\t * typmod number.\n\t */\n\tPG_TRY();\n\t{\n\t\ttypmod_table_entry = (SharedTypmodTableEntry *)\n\t\t\tdshash_find_or_insert(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t  &typmod, &found);\n\t\tif (found)\n\t\t\telog(ERROR, \"cannot create duplicate shared record typmod\");\n\t}\n\tPG_CATCH();\n\t{\n\t\tdsa_free(CurrentSession->area, shared_dp);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\ttypmod_table_entry->typmod = typmod;\n\ttypmod_table_entry->shared_tupdesc = shared_dp;\n\tdshash_release_lock(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\ttypmod_table_entry);\n\n\t/*\n\t * Finally create an entry in the record table so others with matching\n\t * tuple descriptors can reuse the typmod.\n\t */\n\trecord_table_entry = (SharedRecordTableEntry *)\n\t\tdshash_find_or_insert(CurrentSession->shared_record_table, &key,\n\t\t\t\t\t\t\t  &found);\n\tif (found)\n\t{\n\t\t/*\n\t\t * Someone concurrently inserted a matching tuple descriptor since the\n\t\t * first time we checked.  Use that one instead.\n\t\t */\n\t\tdshash_release_lock(CurrentSession->shared_record_table,\n\t\t\t\t\t\t\trecord_table_entry);\n\n\t\t/* Might as well free up the space used by the one we created. */\n\t\tfound = dshash_delete_key(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t  &typmod);\n\t\tAssert(found);\n\t\tdsa_free(CurrentSession->area, shared_dp);\n\n\t\t/* Return the one we found. */\n\t\tAssert(record_table_entry->key.shared);\n\t\tresult = (TupleDesc)\n\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\trecord_table_entry->key.shared);\n\t\tAssert(result->tdrefcount == -1);\n\n\t\treturn result;\n\t}\n\n\t/* Store it and return it. */\n\trecord_table_entry->key.shared = true;\n\trecord_table_entry->key.u.shared_tupdesc = shared_dp;\n\tdshash_release_lock(CurrentSession->shared_record_table,\n\t\t\t\t\t\trecord_table_entry);\n\tresult = (TupleDesc)\n\t\tdsa_get_address(CurrentSession->area, shared_dp);\n\tAssert(result->tdrefcount == -1);\n\n\treturn result;\n}"
  },
  {
    "function_name": "share_tupledesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "2488-2500",
    "snippet": "static dsa_pointer\nshare_tupledesc(dsa_area *area, TupleDesc tupdesc, uint32 typmod)\n{\n\tdsa_pointer shared_dp;\n\tTupleDesc\tshared;\n\n\tshared_dp = dsa_allocate(area, TupleDescSize(tupdesc));\n\tshared = (TupleDesc) dsa_get_address(area, shared_dp);\n\tTupleDescCopy(shared, tupdesc);\n\tshared->tdtypmod = typmod;\n\n\treturn shared_dp;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);",
      "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TupleDescCopy",
          "args": [
            "shared",
            "tupdesc"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_get_address",
          "args": [
            "area",
            "shared_dp"
          ],
          "line": 2495
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "931-957",
          "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dsa_allocate",
          "args": [
            "area",
            "TupleDescSize(tupdesc)"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescSize",
          "args": [
            "tupdesc"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nstatic dsa_pointer\nshare_tupledesc(dsa_area *area, TupleDesc tupdesc, uint32 typmod)\n{\n\tdsa_pointer shared_dp;\n\tTupleDesc\tshared;\n\n\tshared_dp = dsa_allocate(area, TupleDescSize(tupdesc));\n\tshared = (TupleDesc) dsa_get_address(area, shared_dp);\n\tTupleDescCopy(shared, tupdesc);\n\tshared->tdtypmod = typmod;\n\n\treturn shared_dp;\n}"
  },
  {
    "function_name": "enum_oid_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "2470-2482",
    "snippet": "static int\nenum_oid_cmp(const void *left, const void *right)\n{\n\tconst EnumItem *l = (const EnumItem *) left;\n\tconst EnumItem *r = (const EnumItem *) right;\n\n\tif (l->enum_oid < r->enum_oid)\n\t\treturn -1;\n\telse if (l->enum_oid > r->enum_oid)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tenum_oid_cmp(const void *left, const void *right);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\tenum_oid_cmp(const void *left, const void *right);\n\nstatic int\nenum_oid_cmp(const void *left, const void *right)\n{\n\tconst EnumItem *l = (const EnumItem *) left;\n\tconst EnumItem *r = (const EnumItem *) right;\n\n\tif (l->enum_oid < r->enum_oid)\n\t\treturn -1;\n\telse if (l->enum_oid > r->enum_oid)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "find_enumitem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "2453-2465",
    "snippet": "static EnumItem *\nfind_enumitem(TypeCacheEnumData *enumdata, Oid arg)\n{\n\tEnumItem\tsrch;\n\n\t/* On some versions of Solaris, bsearch of zero items dumps core */\n\tif (enumdata->num_values <= 0)\n\t\treturn NULL;\n\n\tsrch.enum_oid = arg;\n\treturn bsearch(&srch, enumdata->enum_values, enumdata->num_values,\n\t\t\t\t   sizeof(EnumItem), enum_oid_cmp);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void dccref_deletion_callback(void *arg);",
      "static EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bsearch",
          "args": [
            "&srch",
            "enumdata->enum_values",
            "enumdata->num_values",
            "sizeof(EnumItem)",
            "enum_oid_cmp"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "rbound_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "617-637",
          "snippet": "static int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dccref_deletion_callback(void *arg);\nstatic EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);\n\nstatic EnumItem *\nfind_enumitem(TypeCacheEnumData *enumdata, Oid arg)\n{\n\tEnumItem\tsrch;\n\n\t/* On some versions of Solaris, bsearch of zero items dumps core */\n\tif (enumdata->num_values <= 0)\n\t\treturn NULL;\n\n\tsrch.enum_oid = arg;\n\treturn bsearch(&srch, enumdata->enum_values, enumdata->num_values,\n\t\t\t\t   sizeof(EnumItem), enum_oid_cmp);\n}"
  },
  {
    "function_name": "load_enum_cache_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "2298-2448",
    "snippet": "static void\nload_enum_cache_data(TypeCacheEntry *tcache)\n{\n\tTypeCacheEnumData *enumdata;\n\tRelation\tenum_rel;\n\tSysScanDesc enum_scan;\n\tHeapTuple\tenum_tuple;\n\tScanKeyData skey;\n\tEnumItem   *items;\n\tint\t\t\tnumitems;\n\tint\t\t\tmaxitems;\n\tOid\t\t\tbitmap_base;\n\tBitmapset  *bitmap;\n\tMemoryContext oldcxt;\n\tint\t\t\tbm_size,\n\t\t\t\tstart_pos;\n\n\t/* Check that this is actually an enum */\n\tif (tcache->typtype != TYPTYPE_ENUM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t errmsg(\"%s is not an enum\",\n\t\t\t\t\t\tformat_type_be(tcache->type_id))));\n\n\t/*\n\t * Read all the information for members of the enum type.  We collect the\n\t * info in working memory in the caller's context, and then transfer it to\n\t * permanent memory in CacheMemoryContext.  This minimizes the risk of\n\t * leaking memory from CacheMemoryContext in the event of an error partway\n\t * through.\n\t */\n\tmaxitems = 64;\n\titems = (EnumItem *) palloc(sizeof(EnumItem) * maxitems);\n\tnumitems = 0;\n\n\t/* Scan pg_enum for the members of the target enum type. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_enum_enumtypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(tcache->type_id));\n\n\tenum_rel = heap_open(EnumRelationId, AccessShareLock);\n\tenum_scan = systable_beginscan(enum_rel,\n\t\t\t\t\t\t\t\t   EnumTypIdLabelIndexId,\n\t\t\t\t\t\t\t\t   true, NULL,\n\t\t\t\t\t\t\t\t   1, &skey);\n\n\twhile (HeapTupleIsValid(enum_tuple = systable_getnext(enum_scan)))\n\t{\n\t\tForm_pg_enum en = (Form_pg_enum) GETSTRUCT(enum_tuple);\n\n\t\tif (numitems >= maxitems)\n\t\t{\n\t\t\tmaxitems *= 2;\n\t\t\titems = (EnumItem *) repalloc(items, sizeof(EnumItem) * maxitems);\n\t\t}\n\t\titems[numitems].enum_oid = HeapTupleGetOid(enum_tuple);\n\t\titems[numitems].sort_order = en->enumsortorder;\n\t\tnumitems++;\n\t}\n\n\tsystable_endscan(enum_scan);\n\theap_close(enum_rel, AccessShareLock);\n\n\t/* Sort the items into OID order */\n\tqsort(items, numitems, sizeof(EnumItem), enum_oid_cmp);\n\n\t/*\n\t * Here, we create a bitmap listing a subset of the enum's OIDs that are\n\t * known to be in order and can thus be compared with just OID comparison.\n\t *\n\t * The point of this is that the enum's initial OIDs were certainly in\n\t * order, so there is some subset that can be compared via OID comparison;\n\t * and we'd rather not do binary searches unnecessarily.\n\t *\n\t * This is somewhat heuristic, and might identify a subset of OIDs that\n\t * isn't exactly what the type started with.  That's okay as long as the\n\t * subset is correctly sorted.\n\t */\n\tbitmap_base = InvalidOid;\n\tbitmap = NULL;\n\tbm_size = 1;\t\t\t\t/* only save sets of at least 2 OIDs */\n\n\tfor (start_pos = 0; start_pos < numitems - 1; start_pos++)\n\t{\n\t\t/*\n\t\t * Identify longest sorted subsequence starting at start_pos\n\t\t */\n\t\tBitmapset  *this_bitmap = bms_make_singleton(0);\n\t\tint\t\t\tthis_bm_size = 1;\n\t\tOid\t\t\tstart_oid = items[start_pos].enum_oid;\n\t\tfloat4\t\tprev_order = items[start_pos].sort_order;\n\t\tint\t\t\ti;\n\n\t\tfor (i = start_pos + 1; i < numitems; i++)\n\t\t{\n\t\t\tOid\t\t\toffset;\n\n\t\t\toffset = items[i].enum_oid - start_oid;\n\t\t\t/* quit if bitmap would be too large; cutoff is arbitrary */\n\t\t\tif (offset >= 8192)\n\t\t\t\tbreak;\n\t\t\t/* include the item if it's in-order */\n\t\t\tif (items[i].sort_order > prev_order)\n\t\t\t{\n\t\t\t\tprev_order = items[i].sort_order;\n\t\t\t\tthis_bitmap = bms_add_member(this_bitmap, (int) offset);\n\t\t\t\tthis_bm_size++;\n\t\t\t}\n\t\t}\n\n\t\t/* Remember it if larger than previous best */\n\t\tif (this_bm_size > bm_size)\n\t\t{\n\t\t\tbms_free(bitmap);\n\t\t\tbitmap_base = start_oid;\n\t\t\tbitmap = this_bitmap;\n\t\t\tbm_size = this_bm_size;\n\t\t}\n\t\telse\n\t\t\tbms_free(this_bitmap);\n\n\t\t/*\n\t\t * Done if it's not possible to find a longer sequence in the rest of\n\t\t * the list.  In typical cases this will happen on the first\n\t\t * iteration, which is why we create the bitmaps on the fly instead of\n\t\t * doing a second pass over the list.\n\t\t */\n\t\tif (bm_size >= (numitems - start_pos - 1))\n\t\t\tbreak;\n\t}\n\n\t/* OK, copy the data into CacheMemoryContext */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\tenumdata = (TypeCacheEnumData *)\n\t\tpalloc(offsetof(TypeCacheEnumData, enum_values) +\n\t\t\t   numitems * sizeof(EnumItem));\n\tenumdata->bitmap_base = bitmap_base;\n\tenumdata->sorted_values = bms_copy(bitmap);\n\tenumdata->num_values = numitems;\n\tmemcpy(enumdata->enum_values, items, numitems * sizeof(EnumItem));\n\tMemoryContextSwitchTo(oldcxt);\n\n\tpfree(items);\n\tbms_free(bitmap);\n\n\t/* And link the finished cache struct into the typcache */\n\tif (tcache->enumData != NULL)\n\t\tpfree(tcache->enumData);\n\ttcache->enumData = enumdata;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void load_enum_cache_data(TypeCacheEntry *tcache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "tcache->enumData"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "bitmap"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "enumdata->enum_values",
            "items",
            "numitems * sizeof(EnumItem)"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_copy",
          "args": [
            "bitmap"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "offsetof(TypeCacheEnumData, enum_values) +\n\t\t\t   numitems * sizeof(EnumItem)"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "this_bitmap"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "bitmap"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_add_member",
          "args": [
            "this_bitmap",
            "(int) offset"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_make_singleton",
          "args": [
            "0"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "items",
            "numitems",
            "sizeof(EnumItem)",
            "enum_oid_cmp"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "enum_rel",
            "AccessShareLock"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "enum_scan"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "enum_tuple"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "items",
            "sizeof(EnumItem) * maxitems"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "repalloc_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1113-1141",
          "snippet": "void *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "enum_tuple"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "enum_tuple = systable_getnext(enum_scan)"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "enum_scan"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "enum_rel",
            "EnumTypIdLabelIndexId",
            "true",
            "NULL",
            "1",
            "&skey"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "EnumRelationId",
            "AccessShareLock"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&skey",
            "Anum_pg_enum_enumtypid",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(tcache->type_id)"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "tcache->type_id"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t errmsg(\"%s is not an enum\",\n\t\t\t\t\t\tformat_type_be(tcache->type_id)))"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"%s is not an enum\"",
            "format_type_be(tcache->type_id)"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "tcache->type_id"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_WRONG_OBJECT_TYPE"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void load_enum_cache_data(TypeCacheEntry *tcache);\n\nstatic void\nload_enum_cache_data(TypeCacheEntry *tcache)\n{\n\tTypeCacheEnumData *enumdata;\n\tRelation\tenum_rel;\n\tSysScanDesc enum_scan;\n\tHeapTuple\tenum_tuple;\n\tScanKeyData skey;\n\tEnumItem   *items;\n\tint\t\t\tnumitems;\n\tint\t\t\tmaxitems;\n\tOid\t\t\tbitmap_base;\n\tBitmapset  *bitmap;\n\tMemoryContext oldcxt;\n\tint\t\t\tbm_size,\n\t\t\t\tstart_pos;\n\n\t/* Check that this is actually an enum */\n\tif (tcache->typtype != TYPTYPE_ENUM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t errmsg(\"%s is not an enum\",\n\t\t\t\t\t\tformat_type_be(tcache->type_id))));\n\n\t/*\n\t * Read all the information for members of the enum type.  We collect the\n\t * info in working memory in the caller's context, and then transfer it to\n\t * permanent memory in CacheMemoryContext.  This minimizes the risk of\n\t * leaking memory from CacheMemoryContext in the event of an error partway\n\t * through.\n\t */\n\tmaxitems = 64;\n\titems = (EnumItem *) palloc(sizeof(EnumItem) * maxitems);\n\tnumitems = 0;\n\n\t/* Scan pg_enum for the members of the target enum type. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_enum_enumtypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(tcache->type_id));\n\n\tenum_rel = heap_open(EnumRelationId, AccessShareLock);\n\tenum_scan = systable_beginscan(enum_rel,\n\t\t\t\t\t\t\t\t   EnumTypIdLabelIndexId,\n\t\t\t\t\t\t\t\t   true, NULL,\n\t\t\t\t\t\t\t\t   1, &skey);\n\n\twhile (HeapTupleIsValid(enum_tuple = systable_getnext(enum_scan)))\n\t{\n\t\tForm_pg_enum en = (Form_pg_enum) GETSTRUCT(enum_tuple);\n\n\t\tif (numitems >= maxitems)\n\t\t{\n\t\t\tmaxitems *= 2;\n\t\t\titems = (EnumItem *) repalloc(items, sizeof(EnumItem) * maxitems);\n\t\t}\n\t\titems[numitems].enum_oid = HeapTupleGetOid(enum_tuple);\n\t\titems[numitems].sort_order = en->enumsortorder;\n\t\tnumitems++;\n\t}\n\n\tsystable_endscan(enum_scan);\n\theap_close(enum_rel, AccessShareLock);\n\n\t/* Sort the items into OID order */\n\tqsort(items, numitems, sizeof(EnumItem), enum_oid_cmp);\n\n\t/*\n\t * Here, we create a bitmap listing a subset of the enum's OIDs that are\n\t * known to be in order and can thus be compared with just OID comparison.\n\t *\n\t * The point of this is that the enum's initial OIDs were certainly in\n\t * order, so there is some subset that can be compared via OID comparison;\n\t * and we'd rather not do binary searches unnecessarily.\n\t *\n\t * This is somewhat heuristic, and might identify a subset of OIDs that\n\t * isn't exactly what the type started with.  That's okay as long as the\n\t * subset is correctly sorted.\n\t */\n\tbitmap_base = InvalidOid;\n\tbitmap = NULL;\n\tbm_size = 1;\t\t\t\t/* only save sets of at least 2 OIDs */\n\n\tfor (start_pos = 0; start_pos < numitems - 1; start_pos++)\n\t{\n\t\t/*\n\t\t * Identify longest sorted subsequence starting at start_pos\n\t\t */\n\t\tBitmapset  *this_bitmap = bms_make_singleton(0);\n\t\tint\t\t\tthis_bm_size = 1;\n\t\tOid\t\t\tstart_oid = items[start_pos].enum_oid;\n\t\tfloat4\t\tprev_order = items[start_pos].sort_order;\n\t\tint\t\t\ti;\n\n\t\tfor (i = start_pos + 1; i < numitems; i++)\n\t\t{\n\t\t\tOid\t\t\toffset;\n\n\t\t\toffset = items[i].enum_oid - start_oid;\n\t\t\t/* quit if bitmap would be too large; cutoff is arbitrary */\n\t\t\tif (offset >= 8192)\n\t\t\t\tbreak;\n\t\t\t/* include the item if it's in-order */\n\t\t\tif (items[i].sort_order > prev_order)\n\t\t\t{\n\t\t\t\tprev_order = items[i].sort_order;\n\t\t\t\tthis_bitmap = bms_add_member(this_bitmap, (int) offset);\n\t\t\t\tthis_bm_size++;\n\t\t\t}\n\t\t}\n\n\t\t/* Remember it if larger than previous best */\n\t\tif (this_bm_size > bm_size)\n\t\t{\n\t\t\tbms_free(bitmap);\n\t\t\tbitmap_base = start_oid;\n\t\t\tbitmap = this_bitmap;\n\t\t\tbm_size = this_bm_size;\n\t\t}\n\t\telse\n\t\t\tbms_free(this_bitmap);\n\n\t\t/*\n\t\t * Done if it's not possible to find a longer sequence in the rest of\n\t\t * the list.  In typical cases this will happen on the first\n\t\t * iteration, which is why we create the bitmaps on the fly instead of\n\t\t * doing a second pass over the list.\n\t\t */\n\t\tif (bm_size >= (numitems - start_pos - 1))\n\t\t\tbreak;\n\t}\n\n\t/* OK, copy the data into CacheMemoryContext */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\tenumdata = (TypeCacheEnumData *)\n\t\tpalloc(offsetof(TypeCacheEnumData, enum_values) +\n\t\t\t   numitems * sizeof(EnumItem));\n\tenumdata->bitmap_base = bitmap_base;\n\tenumdata->sorted_values = bms_copy(bitmap);\n\tenumdata->num_values = numitems;\n\tmemcpy(enumdata->enum_values, items, numitems * sizeof(EnumItem));\n\tMemoryContextSwitchTo(oldcxt);\n\n\tpfree(items);\n\tbms_free(bitmap);\n\n\t/* And link the finished cache struct into the typcache */\n\tif (tcache->enumData != NULL)\n\t\tpfree(tcache->enumData);\n\ttcache->enumData = enumdata;\n}"
  },
  {
    "function_name": "compare_values_of_enum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "2225-2293",
    "snippet": "int\ncompare_values_of_enum(TypeCacheEntry *tcache, Oid arg1, Oid arg2)\n{\n\tTypeCacheEnumData *enumdata;\n\tEnumItem   *item1;\n\tEnumItem   *item2;\n\n\t/*\n\t * Equal OIDs are certainly equal --- this case was probably handled by\n\t * our caller, but we may as well check.\n\t */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Load up the cache if first time through */\n\tif (tcache->enumData == NULL)\n\t\tload_enum_cache_data(tcache);\n\tenumdata = tcache->enumData;\n\n\t/*\n\t * If both OIDs are known-sorted, we can just compare them directly.\n\t */\n\tif (enum_known_sorted(enumdata, arg1) &&\n\t\tenum_known_sorted(enumdata, arg2))\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/*\n\t * Slow path: we have to identify their actual sort-order positions.\n\t */\n\titem1 = find_enumitem(enumdata, arg1);\n\titem2 = find_enumitem(enumdata, arg2);\n\n\tif (item1 == NULL || item2 == NULL)\n\t{\n\t\t/*\n\t\t * We couldn't find one or both values.  That means the enum has\n\t\t * changed under us, so re-initialize the cache and try again. We\n\t\t * don't bother retrying the known-sorted case in this path.\n\t\t */\n\t\tload_enum_cache_data(tcache);\n\t\tenumdata = tcache->enumData;\n\n\t\titem1 = find_enumitem(enumdata, arg1);\n\t\titem2 = find_enumitem(enumdata, arg2);\n\n\t\t/*\n\t\t * If we still can't find the values, complain: we must have corrupt\n\t\t * data.\n\t\t */\n\t\tif (item1 == NULL)\n\t\t\telog(ERROR, \"enum value %u not found in cache for enum %s\",\n\t\t\t\t arg1, format_type_be(tcache->type_id));\n\t\tif (item2 == NULL)\n\t\t\telog(ERROR, \"enum value %u not found in cache for enum %s\",\n\t\t\t\t arg2, format_type_be(tcache->type_id));\n\t}\n\n\tif (item1->sort_order < item2->sort_order)\n\t\treturn -1;\n\telse if (item1->sort_order > item2->sort_order)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void load_enum_cache_data(TypeCacheEntry *tcache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"enum value %u not found in cache for enum %s\"",
            "arg2",
            "format_type_be(tcache->type_id)"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "tcache->type_id"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_enumitem",
          "args": [
            "enumdata",
            "arg2"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "find_enumitem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "2453-2465",
          "snippet": "static EnumItem *\nfind_enumitem(TypeCacheEnumData *enumdata, Oid arg)\n{\n\tEnumItem\tsrch;\n\n\t/* On some versions of Solaris, bsearch of zero items dumps core */\n\tif (enumdata->num_values <= 0)\n\t\treturn NULL;\n\n\tsrch.enum_oid = arg;\n\treturn bsearch(&srch, enumdata->enum_values, enumdata->num_values,\n\t\t\t\t   sizeof(EnumItem), enum_oid_cmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void dccref_deletion_callback(void *arg);",
            "static EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dccref_deletion_callback(void *arg);\nstatic EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);\n\nstatic EnumItem *\nfind_enumitem(TypeCacheEnumData *enumdata, Oid arg)\n{\n\tEnumItem\tsrch;\n\n\t/* On some versions of Solaris, bsearch of zero items dumps core */\n\tif (enumdata->num_values <= 0)\n\t\treturn NULL;\n\n\tsrch.enum_oid = arg;\n\treturn bsearch(&srch, enumdata->enum_values, enumdata->num_values,\n\t\t\t\t   sizeof(EnumItem), enum_oid_cmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_enum_cache_data",
          "args": [
            "tcache"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "load_enum_cache_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "2298-2448",
          "snippet": "static void\nload_enum_cache_data(TypeCacheEntry *tcache)\n{\n\tTypeCacheEnumData *enumdata;\n\tRelation\tenum_rel;\n\tSysScanDesc enum_scan;\n\tHeapTuple\tenum_tuple;\n\tScanKeyData skey;\n\tEnumItem   *items;\n\tint\t\t\tnumitems;\n\tint\t\t\tmaxitems;\n\tOid\t\t\tbitmap_base;\n\tBitmapset  *bitmap;\n\tMemoryContext oldcxt;\n\tint\t\t\tbm_size,\n\t\t\t\tstart_pos;\n\n\t/* Check that this is actually an enum */\n\tif (tcache->typtype != TYPTYPE_ENUM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t errmsg(\"%s is not an enum\",\n\t\t\t\t\t\tformat_type_be(tcache->type_id))));\n\n\t/*\n\t * Read all the information for members of the enum type.  We collect the\n\t * info in working memory in the caller's context, and then transfer it to\n\t * permanent memory in CacheMemoryContext.  This minimizes the risk of\n\t * leaking memory from CacheMemoryContext in the event of an error partway\n\t * through.\n\t */\n\tmaxitems = 64;\n\titems = (EnumItem *) palloc(sizeof(EnumItem) * maxitems);\n\tnumitems = 0;\n\n\t/* Scan pg_enum for the members of the target enum type. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_enum_enumtypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(tcache->type_id));\n\n\tenum_rel = heap_open(EnumRelationId, AccessShareLock);\n\tenum_scan = systable_beginscan(enum_rel,\n\t\t\t\t\t\t\t\t   EnumTypIdLabelIndexId,\n\t\t\t\t\t\t\t\t   true, NULL,\n\t\t\t\t\t\t\t\t   1, &skey);\n\n\twhile (HeapTupleIsValid(enum_tuple = systable_getnext(enum_scan)))\n\t{\n\t\tForm_pg_enum en = (Form_pg_enum) GETSTRUCT(enum_tuple);\n\n\t\tif (numitems >= maxitems)\n\t\t{\n\t\t\tmaxitems *= 2;\n\t\t\titems = (EnumItem *) repalloc(items, sizeof(EnumItem) * maxitems);\n\t\t}\n\t\titems[numitems].enum_oid = HeapTupleGetOid(enum_tuple);\n\t\titems[numitems].sort_order = en->enumsortorder;\n\t\tnumitems++;\n\t}\n\n\tsystable_endscan(enum_scan);\n\theap_close(enum_rel, AccessShareLock);\n\n\t/* Sort the items into OID order */\n\tqsort(items, numitems, sizeof(EnumItem), enum_oid_cmp);\n\n\t/*\n\t * Here, we create a bitmap listing a subset of the enum's OIDs that are\n\t * known to be in order and can thus be compared with just OID comparison.\n\t *\n\t * The point of this is that the enum's initial OIDs were certainly in\n\t * order, so there is some subset that can be compared via OID comparison;\n\t * and we'd rather not do binary searches unnecessarily.\n\t *\n\t * This is somewhat heuristic, and might identify a subset of OIDs that\n\t * isn't exactly what the type started with.  That's okay as long as the\n\t * subset is correctly sorted.\n\t */\n\tbitmap_base = InvalidOid;\n\tbitmap = NULL;\n\tbm_size = 1;\t\t\t\t/* only save sets of at least 2 OIDs */\n\n\tfor (start_pos = 0; start_pos < numitems - 1; start_pos++)\n\t{\n\t\t/*\n\t\t * Identify longest sorted subsequence starting at start_pos\n\t\t */\n\t\tBitmapset  *this_bitmap = bms_make_singleton(0);\n\t\tint\t\t\tthis_bm_size = 1;\n\t\tOid\t\t\tstart_oid = items[start_pos].enum_oid;\n\t\tfloat4\t\tprev_order = items[start_pos].sort_order;\n\t\tint\t\t\ti;\n\n\t\tfor (i = start_pos + 1; i < numitems; i++)\n\t\t{\n\t\t\tOid\t\t\toffset;\n\n\t\t\toffset = items[i].enum_oid - start_oid;\n\t\t\t/* quit if bitmap would be too large; cutoff is arbitrary */\n\t\t\tif (offset >= 8192)\n\t\t\t\tbreak;\n\t\t\t/* include the item if it's in-order */\n\t\t\tif (items[i].sort_order > prev_order)\n\t\t\t{\n\t\t\t\tprev_order = items[i].sort_order;\n\t\t\t\tthis_bitmap = bms_add_member(this_bitmap, (int) offset);\n\t\t\t\tthis_bm_size++;\n\t\t\t}\n\t\t}\n\n\t\t/* Remember it if larger than previous best */\n\t\tif (this_bm_size > bm_size)\n\t\t{\n\t\t\tbms_free(bitmap);\n\t\t\tbitmap_base = start_oid;\n\t\t\tbitmap = this_bitmap;\n\t\t\tbm_size = this_bm_size;\n\t\t}\n\t\telse\n\t\t\tbms_free(this_bitmap);\n\n\t\t/*\n\t\t * Done if it's not possible to find a longer sequence in the rest of\n\t\t * the list.  In typical cases this will happen on the first\n\t\t * iteration, which is why we create the bitmaps on the fly instead of\n\t\t * doing a second pass over the list.\n\t\t */\n\t\tif (bm_size >= (numitems - start_pos - 1))\n\t\t\tbreak;\n\t}\n\n\t/* OK, copy the data into CacheMemoryContext */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\tenumdata = (TypeCacheEnumData *)\n\t\tpalloc(offsetof(TypeCacheEnumData, enum_values) +\n\t\t\t   numitems * sizeof(EnumItem));\n\tenumdata->bitmap_base = bitmap_base;\n\tenumdata->sorted_values = bms_copy(bitmap);\n\tenumdata->num_values = numitems;\n\tmemcpy(enumdata->enum_values, items, numitems * sizeof(EnumItem));\n\tMemoryContextSwitchTo(oldcxt);\n\n\tpfree(items);\n\tbms_free(bitmap);\n\n\t/* And link the finished cache struct into the typcache */\n\tif (tcache->enumData != NULL)\n\t\tpfree(tcache->enumData);\n\ttcache->enumData = enumdata;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void load_enum_cache_data(TypeCacheEntry *tcache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void load_enum_cache_data(TypeCacheEntry *tcache);\n\nstatic void\nload_enum_cache_data(TypeCacheEntry *tcache)\n{\n\tTypeCacheEnumData *enumdata;\n\tRelation\tenum_rel;\n\tSysScanDesc enum_scan;\n\tHeapTuple\tenum_tuple;\n\tScanKeyData skey;\n\tEnumItem   *items;\n\tint\t\t\tnumitems;\n\tint\t\t\tmaxitems;\n\tOid\t\t\tbitmap_base;\n\tBitmapset  *bitmap;\n\tMemoryContext oldcxt;\n\tint\t\t\tbm_size,\n\t\t\t\tstart_pos;\n\n\t/* Check that this is actually an enum */\n\tif (tcache->typtype != TYPTYPE_ENUM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t errmsg(\"%s is not an enum\",\n\t\t\t\t\t\tformat_type_be(tcache->type_id))));\n\n\t/*\n\t * Read all the information for members of the enum type.  We collect the\n\t * info in working memory in the caller's context, and then transfer it to\n\t * permanent memory in CacheMemoryContext.  This minimizes the risk of\n\t * leaking memory from CacheMemoryContext in the event of an error partway\n\t * through.\n\t */\n\tmaxitems = 64;\n\titems = (EnumItem *) palloc(sizeof(EnumItem) * maxitems);\n\tnumitems = 0;\n\n\t/* Scan pg_enum for the members of the target enum type. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_enum_enumtypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(tcache->type_id));\n\n\tenum_rel = heap_open(EnumRelationId, AccessShareLock);\n\tenum_scan = systable_beginscan(enum_rel,\n\t\t\t\t\t\t\t\t   EnumTypIdLabelIndexId,\n\t\t\t\t\t\t\t\t   true, NULL,\n\t\t\t\t\t\t\t\t   1, &skey);\n\n\twhile (HeapTupleIsValid(enum_tuple = systable_getnext(enum_scan)))\n\t{\n\t\tForm_pg_enum en = (Form_pg_enum) GETSTRUCT(enum_tuple);\n\n\t\tif (numitems >= maxitems)\n\t\t{\n\t\t\tmaxitems *= 2;\n\t\t\titems = (EnumItem *) repalloc(items, sizeof(EnumItem) * maxitems);\n\t\t}\n\t\titems[numitems].enum_oid = HeapTupleGetOid(enum_tuple);\n\t\titems[numitems].sort_order = en->enumsortorder;\n\t\tnumitems++;\n\t}\n\n\tsystable_endscan(enum_scan);\n\theap_close(enum_rel, AccessShareLock);\n\n\t/* Sort the items into OID order */\n\tqsort(items, numitems, sizeof(EnumItem), enum_oid_cmp);\n\n\t/*\n\t * Here, we create a bitmap listing a subset of the enum's OIDs that are\n\t * known to be in order and can thus be compared with just OID comparison.\n\t *\n\t * The point of this is that the enum's initial OIDs were certainly in\n\t * order, so there is some subset that can be compared via OID comparison;\n\t * and we'd rather not do binary searches unnecessarily.\n\t *\n\t * This is somewhat heuristic, and might identify a subset of OIDs that\n\t * isn't exactly what the type started with.  That's okay as long as the\n\t * subset is correctly sorted.\n\t */\n\tbitmap_base = InvalidOid;\n\tbitmap = NULL;\n\tbm_size = 1;\t\t\t\t/* only save sets of at least 2 OIDs */\n\n\tfor (start_pos = 0; start_pos < numitems - 1; start_pos++)\n\t{\n\t\t/*\n\t\t * Identify longest sorted subsequence starting at start_pos\n\t\t */\n\t\tBitmapset  *this_bitmap = bms_make_singleton(0);\n\t\tint\t\t\tthis_bm_size = 1;\n\t\tOid\t\t\tstart_oid = items[start_pos].enum_oid;\n\t\tfloat4\t\tprev_order = items[start_pos].sort_order;\n\t\tint\t\t\ti;\n\n\t\tfor (i = start_pos + 1; i < numitems; i++)\n\t\t{\n\t\t\tOid\t\t\toffset;\n\n\t\t\toffset = items[i].enum_oid - start_oid;\n\t\t\t/* quit if bitmap would be too large; cutoff is arbitrary */\n\t\t\tif (offset >= 8192)\n\t\t\t\tbreak;\n\t\t\t/* include the item if it's in-order */\n\t\t\tif (items[i].sort_order > prev_order)\n\t\t\t{\n\t\t\t\tprev_order = items[i].sort_order;\n\t\t\t\tthis_bitmap = bms_add_member(this_bitmap, (int) offset);\n\t\t\t\tthis_bm_size++;\n\t\t\t}\n\t\t}\n\n\t\t/* Remember it if larger than previous best */\n\t\tif (this_bm_size > bm_size)\n\t\t{\n\t\t\tbms_free(bitmap);\n\t\t\tbitmap_base = start_oid;\n\t\t\tbitmap = this_bitmap;\n\t\t\tbm_size = this_bm_size;\n\t\t}\n\t\telse\n\t\t\tbms_free(this_bitmap);\n\n\t\t/*\n\t\t * Done if it's not possible to find a longer sequence in the rest of\n\t\t * the list.  In typical cases this will happen on the first\n\t\t * iteration, which is why we create the bitmaps on the fly instead of\n\t\t * doing a second pass over the list.\n\t\t */\n\t\tif (bm_size >= (numitems - start_pos - 1))\n\t\t\tbreak;\n\t}\n\n\t/* OK, copy the data into CacheMemoryContext */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\tenumdata = (TypeCacheEnumData *)\n\t\tpalloc(offsetof(TypeCacheEnumData, enum_values) +\n\t\t\t   numitems * sizeof(EnumItem));\n\tenumdata->bitmap_base = bitmap_base;\n\tenumdata->sorted_values = bms_copy(bitmap);\n\tenumdata->num_values = numitems;\n\tmemcpy(enumdata->enum_values, items, numitems * sizeof(EnumItem));\n\tMemoryContextSwitchTo(oldcxt);\n\n\tpfree(items);\n\tbms_free(bitmap);\n\n\t/* And link the finished cache struct into the typcache */\n\tif (tcache->enumData != NULL)\n\t\tpfree(tcache->enumData);\n\ttcache->enumData = enumdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enum_known_sorted",
          "args": [
            "enumdata",
            "arg2"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "enum_known_sorted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "2196-2207",
          "snippet": "static inline bool\nenum_known_sorted(TypeCacheEnumData *enumdata, Oid arg)\n{\n\tOid\t\t\toffset;\n\n\tif (arg < enumdata->bitmap_base)\n\t\treturn false;\n\toffset = arg - enumdata->bitmap_base;\n\tif (offset > (Oid) INT_MAX)\n\t\treturn false;\n\treturn bms_is_member((int) offset, enumdata->sorted_values);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void dccref_deletion_callback(void *arg);",
            "static EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dccref_deletion_callback(void *arg);\nstatic EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);\n\nstatic inline bool\nenum_known_sorted(TypeCacheEnumData *enumdata, Oid arg)\n{\n\tOid\t\t\toffset;\n\n\tif (arg < enumdata->bitmap_base)\n\t\treturn false;\n\toffset = arg - enumdata->bitmap_base;\n\tif (offset > (Oid) INT_MAX)\n\t\treturn false;\n\treturn bms_is_member((int) offset, enumdata->sorted_values);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void load_enum_cache_data(TypeCacheEntry *tcache);\n\nint\ncompare_values_of_enum(TypeCacheEntry *tcache, Oid arg1, Oid arg2)\n{\n\tTypeCacheEnumData *enumdata;\n\tEnumItem   *item1;\n\tEnumItem   *item2;\n\n\t/*\n\t * Equal OIDs are certainly equal --- this case was probably handled by\n\t * our caller, but we may as well check.\n\t */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Load up the cache if first time through */\n\tif (tcache->enumData == NULL)\n\t\tload_enum_cache_data(tcache);\n\tenumdata = tcache->enumData;\n\n\t/*\n\t * If both OIDs are known-sorted, we can just compare them directly.\n\t */\n\tif (enum_known_sorted(enumdata, arg1) &&\n\t\tenum_known_sorted(enumdata, arg2))\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/*\n\t * Slow path: we have to identify their actual sort-order positions.\n\t */\n\titem1 = find_enumitem(enumdata, arg1);\n\titem2 = find_enumitem(enumdata, arg2);\n\n\tif (item1 == NULL || item2 == NULL)\n\t{\n\t\t/*\n\t\t * We couldn't find one or both values.  That means the enum has\n\t\t * changed under us, so re-initialize the cache and try again. We\n\t\t * don't bother retrying the known-sorted case in this path.\n\t\t */\n\t\tload_enum_cache_data(tcache);\n\t\tenumdata = tcache->enumData;\n\n\t\titem1 = find_enumitem(enumdata, arg1);\n\t\titem2 = find_enumitem(enumdata, arg2);\n\n\t\t/*\n\t\t * If we still can't find the values, complain: we must have corrupt\n\t\t * data.\n\t\t */\n\t\tif (item1 == NULL)\n\t\t\telog(ERROR, \"enum value %u not found in cache for enum %s\",\n\t\t\t\t arg1, format_type_be(tcache->type_id));\n\t\tif (item2 == NULL)\n\t\t\telog(ERROR, \"enum value %u not found in cache for enum %s\",\n\t\t\t\t arg2, format_type_be(tcache->type_id));\n\t}\n\n\tif (item1->sort_order < item2->sort_order)\n\t\treturn -1;\n\telse if (item1->sort_order > item2->sort_order)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "enum_known_sorted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "2196-2207",
    "snippet": "static inline bool\nenum_known_sorted(TypeCacheEnumData *enumdata, Oid arg)\n{\n\tOid\t\t\toffset;\n\n\tif (arg < enumdata->bitmap_base)\n\t\treturn false;\n\toffset = arg - enumdata->bitmap_base;\n\tif (offset > (Oid) INT_MAX)\n\t\treturn false;\n\treturn bms_is_member((int) offset, enumdata->sorted_values);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void dccref_deletion_callback(void *arg);",
      "static EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bms_is_member",
          "args": [
            "(int) offset",
            "enumdata->sorted_values"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dccref_deletion_callback(void *arg);\nstatic EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);\n\nstatic inline bool\nenum_known_sorted(TypeCacheEnumData *enumdata, Oid arg)\n{\n\tOid\t\t\toffset;\n\n\tif (arg < enumdata->bitmap_base)\n\t\treturn false;\n\toffset = arg - enumdata->bitmap_base;\n\tif (offset > (Oid) INT_MAX)\n\t\treturn false;\n\treturn bms_is_member((int) offset, enumdata->sorted_values);\n}"
  },
  {
    "function_name": "TypeCacheConstrCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "2172-2190",
    "snippet": "static void\nTypeCacheConstrCallback(Datum arg, int cacheid, uint32 hashvalue)\n{\n\tTypeCacheEntry *typentry;\n\n\t/*\n\t * Because this is called very frequently, and typically very few of the\n\t * typcache entries are for domains, we don't use hash_seq_search here.\n\t * Instead we thread all the domain-type entries together so that we can\n\t * visit them cheaply.\n\t */\n\tfor (typentry = firstDomainTypeEntry;\n\t\t typentry != NULL;\n\t\t typentry = typentry->nextDomain)\n\t{\n\t\t/* Reset domain constraint validity information */\n\t\ttypentry->flags &= ~TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000"
    ],
    "globals_used": [
      "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static void dccref_deletion_callback(void *arg);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);",
      "static void TypeCacheOpcCallback(Datum arg, int cacheid, uint32 hashvalue);",
      "static void TypeCacheConstrCallback(Datum arg, int cacheid, uint32 hashvalue);",
      "static EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic void dccref_deletion_callback(void *arg);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic void TypeCacheOpcCallback(Datum arg, int cacheid, uint32 hashvalue);\nstatic void TypeCacheConstrCallback(Datum arg, int cacheid, uint32 hashvalue);\nstatic EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);\n\nstatic void\nTypeCacheConstrCallback(Datum arg, int cacheid, uint32 hashvalue)\n{\n\tTypeCacheEntry *typentry;\n\n\t/*\n\t * Because this is called very frequently, and typically very few of the\n\t * typcache entries are for domains, we don't use hash_seq_search here.\n\t * Instead we thread all the domain-type entries together so that we can\n\t * visit them cheaply.\n\t */\n\tfor (typentry = firstDomainTypeEntry;\n\t\t typentry != NULL;\n\t\t typentry = typentry->nextDomain)\n\t{\n\t\t/* Reset domain constraint validity information */\n\t\ttypentry->flags &= ~TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS;\n\t}\n}"
  },
  {
    "function_name": "TypeCacheOpcCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "2143-2156",
    "snippet": "static void\nTypeCacheOpcCallback(Datum arg, int cacheid, uint32 hashvalue)\n{\n\tHASH_SEQ_STATUS status;\n\tTypeCacheEntry *typentry;\n\n\t/* TypeCacheHash must exist, else this callback wouldn't be registered */\n\thash_seq_init(&status, TypeCacheHash);\n\twhile ((typentry = (TypeCacheEntry *) hash_seq_search(&status)) != NULL)\n\t{\n\t\t/* Reset equality/comparison/hashing validity information */\n\t\ttypentry->flags = 0;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *TypeCacheHash = NULL;",
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static void dccref_deletion_callback(void *arg);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);",
      "static void TypeCacheOpcCallback(Datum arg, int cacheid, uint32 hashvalue);",
      "static void TypeCacheConstrCallback(Datum arg, int cacheid, uint32 hashvalue);",
      "static EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "TypeCacheHash"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic void dccref_deletion_callback(void *arg);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic void TypeCacheOpcCallback(Datum arg, int cacheid, uint32 hashvalue);\nstatic void TypeCacheConstrCallback(Datum arg, int cacheid, uint32 hashvalue);\nstatic EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);\n\nstatic void\nTypeCacheOpcCallback(Datum arg, int cacheid, uint32 hashvalue)\n{\n\tHASH_SEQ_STATUS status;\n\tTypeCacheEntry *typentry;\n\n\t/* TypeCacheHash must exist, else this callback wouldn't be registered */\n\thash_seq_init(&status, TypeCacheHash);\n\twhile ((typentry = (TypeCacheEntry *) hash_seq_search(&status)) != NULL)\n\t{\n\t\t/* Reset equality/comparison/hashing validity information */\n\t\ttypentry->flags = 0;\n\t}\n}"
  },
  {
    "function_name": "TypeCacheRelCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "2080-2125",
    "snippet": "static void\nTypeCacheRelCallback(Datum arg, Oid relid)\n{\n\tHASH_SEQ_STATUS status;\n\tTypeCacheEntry *typentry;\n\n\t/* TypeCacheHash must exist, else this callback wouldn't be registered */\n\thash_seq_init(&status, TypeCacheHash);\n\twhile ((typentry = (TypeCacheEntry *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tif (typentry->typtype == TYPTYPE_COMPOSITE)\n\t\t{\n\t\t\t/* Skip if no match, unless we're zapping all composite types */\n\t\t\tif (relid != typentry->typrelid && relid != InvalidOid)\n\t\t\t\tcontinue;\n\n\t\t\t/* Delete tupdesc if we have it */\n\t\t\tif (typentry->tupDesc != NULL)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Release our refcount, and free the tupdesc if none remain.\n\t\t\t\t * (Can't use DecrTupleDescRefCount because this reference is\n\t\t\t\t * not logged in current resource owner.)\n\t\t\t\t */\n\t\t\t\tAssert(typentry->tupDesc->tdrefcount > 0);\n\t\t\t\tif (--typentry->tupDesc->tdrefcount == 0)\n\t\t\t\t\tFreeTupleDesc(typentry->tupDesc);\n\t\t\t\ttypentry->tupDesc = NULL;\n\t\t\t}\n\n\t\t\t/* Reset equality/comparison/hashing validity information */\n\t\t\ttypentry->flags = 0;\n\t\t}\n\t\telse if (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/*\n\t\t\t * If it's domain over composite, reset flags.  (We don't bother\n\t\t\t * trying to determine whether the specific base type needs a\n\t\t\t * reset.)  Note that if we haven't determined whether the base\n\t\t\t * type is composite, we don't need to reset anything.\n\t\t\t */\n\t\t\tif (typentry->flags & TCFLAGS_DOMAIN_BASE_IS_COMPOSITE)\n\t\t\t\ttypentry->flags = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TCFLAGS_DOMAIN_BASE_IS_COMPOSITE\t0x020000"
    ],
    "globals_used": [
      "static HTAB *TypeCacheHash = NULL;",
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static void dccref_deletion_callback(void *arg);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);",
      "static void TypeCacheRelCallback(Datum arg, Oid relid);",
      "static EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);",
      "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreeTupleDesc",
          "args": [
            "typentry->tupDesc"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "RememberToFreeTupleDescAtEOX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2789-2815",
          "snippet": "static void\nRememberToFreeTupleDescAtEOX(TupleDesc td)\n{\n\tif (EOXactTupleDescArray == NULL)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) palloc(16 * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = 16;\n\t\tNextEOXactTupleDescNum = 0;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse if (NextEOXactTupleDescNum >= EOXactTupleDescArrayLen)\n\t{\n\t\tint32\t\tnewlen = EOXactTupleDescArrayLen * 2;\n\n\t\tAssert(EOXactTupleDescArrayLen > 0);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) repalloc(EOXactTupleDescArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = newlen;\n\t}\n\n\tEOXactTupleDescArray[NextEOXactTupleDescNum++] = td;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc *EOXactTupleDescArray;",
            "static int\tNextEOXactTupleDescNum = 0;",
            "static int\tEOXactTupleDescArrayLen = 0;",
            "static void RememberToFreeTupleDescAtEOX(TupleDesc td);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *EOXactTupleDescArray;\nstatic int\tNextEOXactTupleDescNum = 0;\nstatic int\tEOXactTupleDescArrayLen = 0;\nstatic void RememberToFreeTupleDescAtEOX(TupleDesc td);\n\nstatic void\nRememberToFreeTupleDescAtEOX(TupleDesc td)\n{\n\tif (EOXactTupleDescArray == NULL)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) palloc(16 * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = 16;\n\t\tNextEOXactTupleDescNum = 0;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse if (NextEOXactTupleDescNum >= EOXactTupleDescArrayLen)\n\t{\n\t\tint32\t\tnewlen = EOXactTupleDescArrayLen * 2;\n\n\t\tAssert(EOXactTupleDescArrayLen > 0);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) repalloc(EOXactTupleDescArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = newlen;\n\t}\n\n\tEOXactTupleDescArray[NextEOXactTupleDescNum++] = td;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "typentry->tupDesc->tdrefcount > 0"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "TypeCacheHash"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_DOMAIN_BASE_IS_COMPOSITE\t0x020000\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic void dccref_deletion_callback(void *arg);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic void TypeCacheRelCallback(Datum arg, Oid relid);\nstatic EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nstatic void\nTypeCacheRelCallback(Datum arg, Oid relid)\n{\n\tHASH_SEQ_STATUS status;\n\tTypeCacheEntry *typentry;\n\n\t/* TypeCacheHash must exist, else this callback wouldn't be registered */\n\thash_seq_init(&status, TypeCacheHash);\n\twhile ((typentry = (TypeCacheEntry *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tif (typentry->typtype == TYPTYPE_COMPOSITE)\n\t\t{\n\t\t\t/* Skip if no match, unless we're zapping all composite types */\n\t\t\tif (relid != typentry->typrelid && relid != InvalidOid)\n\t\t\t\tcontinue;\n\n\t\t\t/* Delete tupdesc if we have it */\n\t\t\tif (typentry->tupDesc != NULL)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Release our refcount, and free the tupdesc if none remain.\n\t\t\t\t * (Can't use DecrTupleDescRefCount because this reference is\n\t\t\t\t * not logged in current resource owner.)\n\t\t\t\t */\n\t\t\t\tAssert(typentry->tupDesc->tdrefcount > 0);\n\t\t\t\tif (--typentry->tupDesc->tdrefcount == 0)\n\t\t\t\t\tFreeTupleDesc(typentry->tupDesc);\n\t\t\t\ttypentry->tupDesc = NULL;\n\t\t\t}\n\n\t\t\t/* Reset equality/comparison/hashing validity information */\n\t\t\ttypentry->flags = 0;\n\t\t}\n\t\telse if (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/*\n\t\t\t * If it's domain over composite, reset flags.  (We don't bother\n\t\t\t * trying to determine whether the specific base type needs a\n\t\t\t * reset.)  Note that if we haven't determined whether the base\n\t\t\t * type is composite, we don't need to reset anything.\n\t\t\t */\n\t\t\tif (typentry->flags & TCFLAGS_DOMAIN_BASE_IS_COMPOSITE)\n\t\t\t\ttypentry->flags = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "SharedRecordTypmodRegistryAttach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1997-2056",
    "snippet": "void\nSharedRecordTypmodRegistryAttach(SharedRecordTypmodRegistry *registry)\n{\n\tMemoryContext old_context;\n\tdshash_table *record_table;\n\tdshash_table *typmod_table;\n\n\tAssert(IsParallelWorker());\n\n\t/* We can't already be attached to a shared registry. */\n\tAssert(CurrentSession != NULL);\n\tAssert(CurrentSession->segment != NULL);\n\tAssert(CurrentSession->area != NULL);\n\tAssert(CurrentSession->shared_typmod_registry == NULL);\n\tAssert(CurrentSession->shared_record_table == NULL);\n\tAssert(CurrentSession->shared_typmod_table == NULL);\n\n\t/*\n\t * We can't already have typmods in our local cache, because they'd clash\n\t * with those imported by SharedRecordTypmodRegistryInit.  This should be\n\t * a freshly started parallel worker.  If we ever support worker\n\t * recycling, a worker would need to zap its local cache in between\n\t * servicing different queries, in order to be able to call this and\n\t * synchronize typmods with a new leader; but that's problematic because\n\t * we can't be very sure that record-typmod-related state hasn't escaped\n\t * to anywhere else in the process.\n\t */\n\tAssert(NextRecordTypmod == 0);\n\n\told_context = MemoryContextSwitchTo(TopMemoryContext);\n\n\t/* Attach to the two hash tables. */\n\trecord_table = dshash_attach(CurrentSession->area,\n\t\t\t\t\t\t\t\t &srtr_record_table_params,\n\t\t\t\t\t\t\t\t registry->record_table_handle,\n\t\t\t\t\t\t\t\t CurrentSession->area);\n\ttypmod_table = dshash_attach(CurrentSession->area,\n\t\t\t\t\t\t\t\t &srtr_typmod_table_params,\n\t\t\t\t\t\t\t\t registry->typmod_table_handle,\n\t\t\t\t\t\t\t\t NULL);\n\n\tMemoryContextSwitchTo(old_context);\n\n\t/*\n\t * Set up detach hook to run at worker exit.  Currently this is the same\n\t * as the leader's detach hook, but in future they might need to be\n\t * different.\n\t */\n\ton_dsm_detach(CurrentSession->segment,\n\t\t\t\t  shared_record_typmod_registry_detach,\n\t\t\t\t  PointerGetDatum(registry));\n\n\t/*\n\t * Set up the session state that will tell assign_record_type_typmod and\n\t * lookup_rowtype_tupdesc_internal about the shared registry.\n\t */\n\tCurrentSession->shared_typmod_registry = registry;\n\tCurrentSession->shared_record_table = record_table;\n\tCurrentSession->shared_typmod_table = typmod_table;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const dshash_parameters srtr_record_table_params = {\n\tsizeof(SharedRecordTableKey),\t/* unused */\n\tsizeof(SharedRecordTableEntry),\n\tshared_record_table_compare,\n\tshared_record_table_hash,\n\tLWTRANCHE_SESSION_RECORD_TABLE\n};",
      "static const dshash_parameters srtr_typmod_table_params = {\n\tsizeof(uint32),\n\tsizeof(SharedTypmodTableEntry),\n\tdshash_memcmp,\n\tdshash_memhash,\n\tLWTRANCHE_SESSION_TYPMOD_TABLE\n};",
      "static int32 NextRecordTypmod = 0;",
      "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "on_dsm_detach",
          "args": [
            "CurrentSession->segment",
            "shared_record_typmod_registry_detach",
            "PointerGetDatum(registry)"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "registry"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "old_context"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dshash_attach",
          "args": [
            "CurrentSession->area",
            "&srtr_typmod_table_params",
            "registry->typmod_table_handle",
            "NULL"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dshash_attach",
          "args": [
            "CurrentSession->area",
            "&srtr_record_table_params",
            "registry->record_table_handle",
            "CurrentSession->area"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "TopMemoryContext"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "NextRecordTypmod == 0"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "CurrentSession->shared_typmod_table == NULL"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "CurrentSession->shared_record_table == NULL"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "CurrentSession->shared_typmod_registry == NULL"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "CurrentSession->area != NULL"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "CurrentSession->segment != NULL"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "CurrentSession != NULL"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "IsParallelWorker()"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsParallelWorker",
          "args": [],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic const dshash_parameters srtr_record_table_params = {\n\tsizeof(SharedRecordTableKey),\t/* unused */\n\tsizeof(SharedRecordTableEntry),\n\tshared_record_table_compare,\n\tshared_record_table_hash,\n\tLWTRANCHE_SESSION_RECORD_TABLE\n};\nstatic const dshash_parameters srtr_typmod_table_params = {\n\tsizeof(uint32),\n\tsizeof(SharedTypmodTableEntry),\n\tdshash_memcmp,\n\tdshash_memhash,\n\tLWTRANCHE_SESSION_TYPMOD_TABLE\n};\nstatic int32 NextRecordTypmod = 0;\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nvoid\nSharedRecordTypmodRegistryAttach(SharedRecordTypmodRegistry *registry)\n{\n\tMemoryContext old_context;\n\tdshash_table *record_table;\n\tdshash_table *typmod_table;\n\n\tAssert(IsParallelWorker());\n\n\t/* We can't already be attached to a shared registry. */\n\tAssert(CurrentSession != NULL);\n\tAssert(CurrentSession->segment != NULL);\n\tAssert(CurrentSession->area != NULL);\n\tAssert(CurrentSession->shared_typmod_registry == NULL);\n\tAssert(CurrentSession->shared_record_table == NULL);\n\tAssert(CurrentSession->shared_typmod_table == NULL);\n\n\t/*\n\t * We can't already have typmods in our local cache, because they'd clash\n\t * with those imported by SharedRecordTypmodRegistryInit.  This should be\n\t * a freshly started parallel worker.  If we ever support worker\n\t * recycling, a worker would need to zap its local cache in between\n\t * servicing different queries, in order to be able to call this and\n\t * synchronize typmods with a new leader; but that's problematic because\n\t * we can't be very sure that record-typmod-related state hasn't escaped\n\t * to anywhere else in the process.\n\t */\n\tAssert(NextRecordTypmod == 0);\n\n\told_context = MemoryContextSwitchTo(TopMemoryContext);\n\n\t/* Attach to the two hash tables. */\n\trecord_table = dshash_attach(CurrentSession->area,\n\t\t\t\t\t\t\t\t &srtr_record_table_params,\n\t\t\t\t\t\t\t\t registry->record_table_handle,\n\t\t\t\t\t\t\t\t CurrentSession->area);\n\ttypmod_table = dshash_attach(CurrentSession->area,\n\t\t\t\t\t\t\t\t &srtr_typmod_table_params,\n\t\t\t\t\t\t\t\t registry->typmod_table_handle,\n\t\t\t\t\t\t\t\t NULL);\n\n\tMemoryContextSwitchTo(old_context);\n\n\t/*\n\t * Set up detach hook to run at worker exit.  Currently this is the same\n\t * as the leader's detach hook, but in future they might need to be\n\t * different.\n\t */\n\ton_dsm_detach(CurrentSession->segment,\n\t\t\t\t  shared_record_typmod_registry_detach,\n\t\t\t\t  PointerGetDatum(registry));\n\n\t/*\n\t * Set up the session state that will tell assign_record_type_typmod and\n\t * lookup_rowtype_tupdesc_internal about the shared registry.\n\t */\n\tCurrentSession->shared_typmod_registry = registry;\n\tCurrentSession->shared_record_table = record_table;\n\tCurrentSession->shared_typmod_table = typmod_table;\n}"
  },
  {
    "function_name": "SharedRecordTypmodRegistryInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1898-1989",
    "snippet": "void\nSharedRecordTypmodRegistryInit(SharedRecordTypmodRegistry *registry,\n\t\t\t\t\t\t\t   dsm_segment *segment,\n\t\t\t\t\t\t\t   dsa_area *area)\n{\n\tMemoryContext old_context;\n\tdshash_table *record_table;\n\tdshash_table *typmod_table;\n\tint32\t\ttypmod;\n\n\tAssert(!IsParallelWorker());\n\n\t/* We can't already be attached to a shared registry. */\n\tAssert(CurrentSession->shared_typmod_registry == NULL);\n\tAssert(CurrentSession->shared_record_table == NULL);\n\tAssert(CurrentSession->shared_typmod_table == NULL);\n\n\told_context = MemoryContextSwitchTo(TopMemoryContext);\n\n\t/* Create the hash table of tuple descriptors indexed by themselves. */\n\trecord_table = dshash_create(area, &srtr_record_table_params, area);\n\n\t/* Create the hash table of tuple descriptors indexed by typmod. */\n\ttypmod_table = dshash_create(area, &srtr_typmod_table_params, NULL);\n\n\tMemoryContextSwitchTo(old_context);\n\n\t/* Initialize the SharedRecordTypmodRegistry. */\n\tregistry->record_table_handle = dshash_get_hash_table_handle(record_table);\n\tregistry->typmod_table_handle = dshash_get_hash_table_handle(typmod_table);\n\tpg_atomic_init_u32(&registry->next_typmod, NextRecordTypmod);\n\n\t/*\n\t * Copy all entries from this backend's private registry into the shared\n\t * registry.\n\t */\n\tfor (typmod = 0; typmod < NextRecordTypmod; ++typmod)\n\t{\n\t\tSharedTypmodTableEntry *typmod_table_entry;\n\t\tSharedRecordTableEntry *record_table_entry;\n\t\tSharedRecordTableKey record_table_key;\n\t\tdsa_pointer shared_dp;\n\t\tTupleDesc\ttupdesc;\n\t\tbool\t\tfound;\n\n\t\ttupdesc = RecordCacheArray[typmod];\n\t\tif (tupdesc == NULL)\n\t\t\tcontinue;\n\n\t\t/* Copy the TupleDesc into shared memory. */\n\t\tshared_dp = share_tupledesc(area, tupdesc, typmod);\n\n\t\t/* Insert into the typmod table. */\n\t\ttypmod_table_entry = dshash_find_or_insert(typmod_table,\n\t\t\t\t\t\t\t\t\t\t\t\t   &tupdesc->tdtypmod,\n\t\t\t\t\t\t\t\t\t\t\t\t   &found);\n\t\tif (found)\n\t\t\telog(ERROR, \"cannot create duplicate shared record typmod\");\n\t\ttypmod_table_entry->typmod = tupdesc->tdtypmod;\n\t\ttypmod_table_entry->shared_tupdesc = shared_dp;\n\t\tdshash_release_lock(typmod_table, typmod_table_entry);\n\n\t\t/* Insert into the record table. */\n\t\trecord_table_key.shared = false;\n\t\trecord_table_key.u.local_tupdesc = tupdesc;\n\t\trecord_table_entry = dshash_find_or_insert(record_table,\n\t\t\t\t\t\t\t\t\t\t\t\t   &record_table_key,\n\t\t\t\t\t\t\t\t\t\t\t\t   &found);\n\t\tif (!found)\n\t\t{\n\t\t\trecord_table_entry->key.shared = true;\n\t\t\trecord_table_entry->key.u.shared_tupdesc = shared_dp;\n\t\t}\n\t\tdshash_release_lock(record_table, record_table_entry);\n\t}\n\n\t/*\n\t * Set up the global state that will tell assign_record_type_typmod and\n\t * lookup_rowtype_tupdesc_internal about the shared registry.\n\t */\n\tCurrentSession->shared_record_table = record_table;\n\tCurrentSession->shared_typmod_table = typmod_table;\n\tCurrentSession->shared_typmod_registry = registry;\n\n\t/*\n\t * We install a detach hook in the leader, but only to handle cleanup on\n\t * failure during GetSessionDsmHandle().  Once GetSessionDsmHandle() pins\n\t * the memory, the leader process will use a shared registry until it\n\t * exits.\n\t */\n\ton_dsm_detach(segment, shared_record_typmod_registry_detach, (Datum) 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const dshash_parameters srtr_record_table_params = {\n\tsizeof(SharedRecordTableKey),\t/* unused */\n\tsizeof(SharedRecordTableEntry),\n\tshared_record_table_compare,\n\tshared_record_table_hash,\n\tLWTRANCHE_SESSION_RECORD_TABLE\n};",
      "static const dshash_parameters srtr_typmod_table_params = {\n\tsizeof(uint32),\n\tsizeof(SharedTypmodTableEntry),\n\tdshash_memcmp,\n\tdshash_memhash,\n\tLWTRANCHE_SESSION_TYPMOD_TABLE\n};",
      "static TupleDesc *RecordCacheArray = NULL;",
      "static int32 NextRecordTypmod = 0;",
      "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);",
      "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "on_dsm_detach",
          "args": [
            "segment",
            "shared_record_typmod_registry_detach",
            "(Datum) 0"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dshash_release_lock",
          "args": [
            "record_table",
            "record_table_entry"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dshash_find_or_insert",
          "args": [
            "record_table",
            "&record_table_key",
            "&found"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dshash_release_lock",
          "args": [
            "typmod_table",
            "typmod_table_entry"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cannot create duplicate shared record typmod\""
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dshash_find_or_insert",
          "args": [
            "typmod_table",
            "&tupdesc->tdtypmod",
            "&found"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "share_tupledesc",
          "args": [
            "area",
            "tupdesc",
            "typmod"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "share_tupledesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "2488-2500",
          "snippet": "static dsa_pointer\nshare_tupledesc(dsa_area *area, TupleDesc tupdesc, uint32 typmod)\n{\n\tdsa_pointer shared_dp;\n\tTupleDesc\tshared;\n\n\tshared_dp = dsa_allocate(area, TupleDescSize(tupdesc));\n\tshared = (TupleDesc) dsa_get_address(area, shared_dp);\n\tTupleDescCopy(shared, tupdesc);\n\tshared->tdtypmod = typmod;\n\n\treturn shared_dp;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);",
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nstatic dsa_pointer\nshare_tupledesc(dsa_area *area, TupleDesc tupdesc, uint32 typmod)\n{\n\tdsa_pointer shared_dp;\n\tTupleDesc\tshared;\n\n\tshared_dp = dsa_allocate(area, TupleDescSize(tupdesc));\n\tshared = (TupleDesc) dsa_get_address(area, shared_dp);\n\tTupleDescCopy(shared, tupdesc);\n\tshared->tdtypmod = typmod;\n\n\treturn shared_dp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_atomic_init_u32",
          "args": [
            "&registry->next_typmod",
            "NextRecordTypmod"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dshash_get_hash_table_handle",
          "args": [
            "typmod_table"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dshash_get_hash_table_handle",
          "args": [
            "record_table"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "old_context"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dshash_create",
          "args": [
            "area",
            "&srtr_typmod_table_params",
            "NULL"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dshash_create",
          "args": [
            "area",
            "&srtr_record_table_params",
            "area"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "TopMemoryContext"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "CurrentSession->shared_typmod_table == NULL"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "CurrentSession->shared_record_table == NULL"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "CurrentSession->shared_typmod_registry == NULL"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!IsParallelWorker()"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsParallelWorker",
          "args": [],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic const dshash_parameters srtr_record_table_params = {\n\tsizeof(SharedRecordTableKey),\t/* unused */\n\tsizeof(SharedRecordTableEntry),\n\tshared_record_table_compare,\n\tshared_record_table_hash,\n\tLWTRANCHE_SESSION_RECORD_TABLE\n};\nstatic const dshash_parameters srtr_typmod_table_params = {\n\tsizeof(uint32),\n\tsizeof(SharedTypmodTableEntry),\n\tdshash_memcmp,\n\tdshash_memhash,\n\tLWTRANCHE_SESSION_TYPMOD_TABLE\n};\nstatic TupleDesc *RecordCacheArray = NULL;\nstatic int32 NextRecordTypmod = 0;\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nvoid\nSharedRecordTypmodRegistryInit(SharedRecordTypmodRegistry *registry,\n\t\t\t\t\t\t\t   dsm_segment *segment,\n\t\t\t\t\t\t\t   dsa_area *area)\n{\n\tMemoryContext old_context;\n\tdshash_table *record_table;\n\tdshash_table *typmod_table;\n\tint32\t\ttypmod;\n\n\tAssert(!IsParallelWorker());\n\n\t/* We can't already be attached to a shared registry. */\n\tAssert(CurrentSession->shared_typmod_registry == NULL);\n\tAssert(CurrentSession->shared_record_table == NULL);\n\tAssert(CurrentSession->shared_typmod_table == NULL);\n\n\told_context = MemoryContextSwitchTo(TopMemoryContext);\n\n\t/* Create the hash table of tuple descriptors indexed by themselves. */\n\trecord_table = dshash_create(area, &srtr_record_table_params, area);\n\n\t/* Create the hash table of tuple descriptors indexed by typmod. */\n\ttypmod_table = dshash_create(area, &srtr_typmod_table_params, NULL);\n\n\tMemoryContextSwitchTo(old_context);\n\n\t/* Initialize the SharedRecordTypmodRegistry. */\n\tregistry->record_table_handle = dshash_get_hash_table_handle(record_table);\n\tregistry->typmod_table_handle = dshash_get_hash_table_handle(typmod_table);\n\tpg_atomic_init_u32(&registry->next_typmod, NextRecordTypmod);\n\n\t/*\n\t * Copy all entries from this backend's private registry into the shared\n\t * registry.\n\t */\n\tfor (typmod = 0; typmod < NextRecordTypmod; ++typmod)\n\t{\n\t\tSharedTypmodTableEntry *typmod_table_entry;\n\t\tSharedRecordTableEntry *record_table_entry;\n\t\tSharedRecordTableKey record_table_key;\n\t\tdsa_pointer shared_dp;\n\t\tTupleDesc\ttupdesc;\n\t\tbool\t\tfound;\n\n\t\ttupdesc = RecordCacheArray[typmod];\n\t\tif (tupdesc == NULL)\n\t\t\tcontinue;\n\n\t\t/* Copy the TupleDesc into shared memory. */\n\t\tshared_dp = share_tupledesc(area, tupdesc, typmod);\n\n\t\t/* Insert into the typmod table. */\n\t\ttypmod_table_entry = dshash_find_or_insert(typmod_table,\n\t\t\t\t\t\t\t\t\t\t\t\t   &tupdesc->tdtypmod,\n\t\t\t\t\t\t\t\t\t\t\t\t   &found);\n\t\tif (found)\n\t\t\telog(ERROR, \"cannot create duplicate shared record typmod\");\n\t\ttypmod_table_entry->typmod = tupdesc->tdtypmod;\n\t\ttypmod_table_entry->shared_tupdesc = shared_dp;\n\t\tdshash_release_lock(typmod_table, typmod_table_entry);\n\n\t\t/* Insert into the record table. */\n\t\trecord_table_key.shared = false;\n\t\trecord_table_key.u.local_tupdesc = tupdesc;\n\t\trecord_table_entry = dshash_find_or_insert(record_table,\n\t\t\t\t\t\t\t\t\t\t\t\t   &record_table_key,\n\t\t\t\t\t\t\t\t\t\t\t\t   &found);\n\t\tif (!found)\n\t\t{\n\t\t\trecord_table_entry->key.shared = true;\n\t\t\trecord_table_entry->key.u.shared_tupdesc = shared_dp;\n\t\t}\n\t\tdshash_release_lock(record_table, record_table_entry);\n\t}\n\n\t/*\n\t * Set up the global state that will tell assign_record_type_typmod and\n\t * lookup_rowtype_tupdesc_internal about the shared registry.\n\t */\n\tCurrentSession->shared_record_table = record_table;\n\tCurrentSession->shared_typmod_table = typmod_table;\n\tCurrentSession->shared_typmod_registry = registry;\n\n\t/*\n\t * We install a detach hook in the leader, but only to handle cleanup on\n\t * failure during GetSessionDsmHandle().  Once GetSessionDsmHandle() pins\n\t * the memory, the leader process will use a shared registry until it\n\t * exits.\n\t */\n\ton_dsm_detach(segment, shared_record_typmod_registry_detach, (Datum) 0);\n}"
  },
  {
    "function_name": "SharedRecordTypmodRegistryEstimate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1876-1880",
    "snippet": "size_t\nSharedRecordTypmodRegistryEstimate(void)\n{\n\treturn sizeof(SharedRecordTypmodRegistry);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nsize_t\nSharedRecordTypmodRegistryEstimate(void)\n{\n\treturn sizeof(SharedRecordTypmodRegistry);\n}"
  },
  {
    "function_name": "assign_record_type_identifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1835-1869",
    "snippet": "uint64\nassign_record_type_identifier(Oid type_id, int32 typmod)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\tAssert(typentry->tupDesc_identifier != 0);\n\t\treturn typentry->tupDesc_identifier;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0 && typmod < RecordCacheArrayLen &&\n\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t{\n\t\t\tAssert(RecordIdentifierArray[typmod] != 0);\n\t\t\treturn RecordIdentifierArray[typmod];\n\t\t}\n\n\t\t/* For anonymous or unrecognized record type, generate a new ID */\n\t\treturn ++tupledesc_id_counter;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TupleDesc *RecordCacheArray = NULL;",
      "static uint64 *RecordIdentifierArray = NULL;",
      "static int32 RecordCacheArrayLen = 0;",
      "static uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;",
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);",
      "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "RecordIdentifierArray[typmod] != 0"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "typentry->tupDesc_identifier != 0"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id)))"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"type %s is not composite\"",
            "format_type_be(type_id)"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "type_id"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_WRONG_OBJECT_TYPE"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "type_id",
            "TYPECACHE_TUPDESC"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *RecordCacheArray = NULL;\nstatic uint64 *RecordIdentifierArray = NULL;\nstatic int32 RecordCacheArrayLen = 0;\nstatic uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nuint64\nassign_record_type_identifier(Oid type_id, int32 typmod)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\tAssert(typentry->tupDesc_identifier != 0);\n\t\treturn typentry->tupDesc_identifier;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0 && typmod < RecordCacheArrayLen &&\n\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t{\n\t\t\tAssert(RecordIdentifierArray[typmod] != 0);\n\t\t\treturn RecordIdentifierArray[typmod];\n\t\t}\n\n\t\t/* For anonymous or unrecognized record type, generate a new ID */\n\t\treturn ++tupledesc_id_counter;\n\t}\n}"
  },
  {
    "function_name": "assign_record_type_typmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1760-1823",
    "snippet": "void\nassign_record_type_typmod(TupleDesc tupDesc)\n{\n\tRecordCacheEntry *recentry;\n\tTupleDesc\tentDesc;\n\tbool\t\tfound;\n\tMemoryContext oldcxt;\n\n\tAssert(tupDesc->tdtypeid == RECORDOID);\n\n\tif (RecordCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(TupleDesc);\t/* just the pointer */\n\t\tctl.entrysize = sizeof(RecordCacheEntry);\n\t\tctl.hash = record_type_typmod_hash;\n\t\tctl.match = record_type_typmod_compare;\n\t\tRecordCacheHash = hash_create(\"Record information cache\", 64,\n\t\t\t\t\t\t\t\t\t  &ctl,\n\t\t\t\t\t\t\t\t\t  HASH_ELEM | HASH_FUNCTION | HASH_COMPARE);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Find or create a hashtable entry for this tuple descriptor */\n\trecentry = (RecordCacheEntry *) hash_search(RecordCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t(void *) &tupDesc,\n\t\t\t\t\t\t\t\t\t\t\t\tHASH_ENTER, &found);\n\tif (found && recentry->tupdesc != NULL)\n\t{\n\t\ttupDesc->tdtypmod = recentry->tupdesc->tdtypmod;\n\t\treturn;\n\t}\n\n\t/* Not present, so need to manufacture an entry */\n\trecentry->tupdesc = NULL;\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/* Look in the SharedRecordTypmodRegistry, if attached */\n\tentDesc = find_or_make_matching_shared_tupledesc(tupDesc);\n\tif (entDesc == NULL)\n\t{\n\t\t/* Reference-counted local cache only. */\n\t\tentDesc = CreateTupleDescCopy(tupDesc);\n\t\tentDesc->tdrefcount = 1;\n\t\tentDesc->tdtypmod = NextRecordTypmod++;\n\t}\n\tensure_record_cache_typmod_slot_exists(entDesc->tdtypmod);\n\tRecordCacheArray[entDesc->tdtypmod] = entDesc;\n\trecentry->tupdesc = entDesc;\n\n\t/* Assign a unique tupdesc identifier, too. */\n\tRecordIdentifierArray[entDesc->tdtypmod] = ++tupledesc_id_counter;\n\n\t/* Update the caller's tuple descriptor. */\n\ttupDesc->tdtypmod = entDesc->tdtypmod;\n\n\tMemoryContextSwitchTo(oldcxt);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *RecordCacheHash = NULL;",
      "static TupleDesc *RecordCacheArray = NULL;",
      "static uint64 *RecordIdentifierArray = NULL;",
      "static int32 NextRecordTypmod = 0;",
      "static uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;",
      "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ensure_record_cache_typmod_slot_exists",
          "args": [
            "entDesc->tdtypmod"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_record_cache_typmod_slot_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1512-1541",
          "snippet": "static void\nensure_record_cache_typmod_slot_exists(int32 typmod)\n{\n\tif (RecordCacheArray == NULL)\n\t{\n\t\tRecordCacheArray = (TupleDesc *)\n\t\t\tMemoryContextAllocZero(CacheMemoryContext, 64 * sizeof(TupleDesc));\n\t\tRecordIdentifierArray = (uint64 *)\n\t\t\tMemoryContextAllocZero(CacheMemoryContext, 64 * sizeof(uint64));\n\t\tRecordCacheArrayLen = 64;\n\t}\n\n\tif (typmod >= RecordCacheArrayLen)\n\t{\n\t\tint32\t\tnewlen = RecordCacheArrayLen * 2;\n\n\t\twhile (typmod >= newlen)\n\t\t\tnewlen *= 2;\n\n\t\tRecordCacheArray = (TupleDesc *) repalloc(RecordCacheArray,\n\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tmemset(RecordCacheArray + RecordCacheArrayLen, 0,\n\t\t\t   (newlen - RecordCacheArrayLen) * sizeof(TupleDesc));\n\t\tRecordIdentifierArray = (uint64 *) repalloc(RecordIdentifierArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnewlen * sizeof(uint64));\n\t\tmemset(RecordIdentifierArray + RecordCacheArrayLen, 0,\n\t\t\t   (newlen - RecordCacheArrayLen) * sizeof(uint64));\n\t\tRecordCacheArrayLen = newlen;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc *RecordCacheArray = NULL;",
            "static uint64 *RecordIdentifierArray = NULL;",
            "static int32 RecordCacheArrayLen = 0;",
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *RecordCacheArray = NULL;\nstatic uint64 *RecordIdentifierArray = NULL;\nstatic int32 RecordCacheArrayLen = 0;\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nstatic void\nensure_record_cache_typmod_slot_exists(int32 typmod)\n{\n\tif (RecordCacheArray == NULL)\n\t{\n\t\tRecordCacheArray = (TupleDesc *)\n\t\t\tMemoryContextAllocZero(CacheMemoryContext, 64 * sizeof(TupleDesc));\n\t\tRecordIdentifierArray = (uint64 *)\n\t\t\tMemoryContextAllocZero(CacheMemoryContext, 64 * sizeof(uint64));\n\t\tRecordCacheArrayLen = 64;\n\t}\n\n\tif (typmod >= RecordCacheArrayLen)\n\t{\n\t\tint32\t\tnewlen = RecordCacheArrayLen * 2;\n\n\t\twhile (typmod >= newlen)\n\t\t\tnewlen *= 2;\n\n\t\tRecordCacheArray = (TupleDesc *) repalloc(RecordCacheArray,\n\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tmemset(RecordCacheArray + RecordCacheArrayLen, 0,\n\t\t\t   (newlen - RecordCacheArrayLen) * sizeof(TupleDesc));\n\t\tRecordIdentifierArray = (uint64 *) repalloc(RecordIdentifierArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnewlen * sizeof(uint64));\n\t\tmemset(RecordIdentifierArray + RecordCacheArrayLen, 0,\n\t\t\t   (newlen - RecordCacheArrayLen) * sizeof(uint64));\n\t\tRecordCacheArrayLen = newlen;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "tupDesc"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_make_matching_shared_tupledesc",
          "args": [
            "tupDesc"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "find_or_make_matching_shared_tupledesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "2509-2615",
          "snippet": "static TupleDesc\nfind_or_make_matching_shared_tupledesc(TupleDesc tupdesc)\n{\n\tTupleDesc\tresult;\n\tSharedRecordTableKey key;\n\tSharedRecordTableEntry *record_table_entry;\n\tSharedTypmodTableEntry *typmod_table_entry;\n\tdsa_pointer shared_dp;\n\tbool\t\tfound;\n\tuint32\t\ttypmod;\n\n\t/* If not even attached, nothing to do. */\n\tif (CurrentSession->shared_typmod_registry == NULL)\n\t\treturn NULL;\n\n\t/* Try to find a matching tuple descriptor in the record table. */\n\tkey.shared = false;\n\tkey.u.local_tupdesc = tupdesc;\n\trecord_table_entry = (SharedRecordTableEntry *)\n\t\tdshash_find(CurrentSession->shared_record_table, &key, false);\n\tif (record_table_entry)\n\t{\n\t\tAssert(record_table_entry->key.shared);\n\t\tdshash_release_lock(CurrentSession->shared_record_table,\n\t\t\t\t\t\t\trecord_table_entry);\n\t\tresult = (TupleDesc)\n\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\trecord_table_entry->key.u.shared_tupdesc);\n\t\tAssert(result->tdrefcount == -1);\n\n\t\treturn result;\n\t}\n\n\t/* Allocate a new typmod number.  This will be wasted if we error out. */\n\ttypmod = (int)\n\t\tpg_atomic_fetch_add_u32(&CurrentSession->shared_typmod_registry->next_typmod,\n\t\t\t\t\t\t\t\t1);\n\n\t/* Copy the TupleDesc into shared memory. */\n\tshared_dp = share_tupledesc(CurrentSession->area, tupdesc, typmod);\n\n\t/*\n\t * Create an entry in the typmod table so that others will understand this\n\t * typmod number.\n\t */\n\tPG_TRY();\n\t{\n\t\ttypmod_table_entry = (SharedTypmodTableEntry *)\n\t\t\tdshash_find_or_insert(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t  &typmod, &found);\n\t\tif (found)\n\t\t\telog(ERROR, \"cannot create duplicate shared record typmod\");\n\t}\n\tPG_CATCH();\n\t{\n\t\tdsa_free(CurrentSession->area, shared_dp);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\ttypmod_table_entry->typmod = typmod;\n\ttypmod_table_entry->shared_tupdesc = shared_dp;\n\tdshash_release_lock(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\ttypmod_table_entry);\n\n\t/*\n\t * Finally create an entry in the record table so others with matching\n\t * tuple descriptors can reuse the typmod.\n\t */\n\trecord_table_entry = (SharedRecordTableEntry *)\n\t\tdshash_find_or_insert(CurrentSession->shared_record_table, &key,\n\t\t\t\t\t\t\t  &found);\n\tif (found)\n\t{\n\t\t/*\n\t\t * Someone concurrently inserted a matching tuple descriptor since the\n\t\t * first time we checked.  Use that one instead.\n\t\t */\n\t\tdshash_release_lock(CurrentSession->shared_record_table,\n\t\t\t\t\t\t\trecord_table_entry);\n\n\t\t/* Might as well free up the space used by the one we created. */\n\t\tfound = dshash_delete_key(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t  &typmod);\n\t\tAssert(found);\n\t\tdsa_free(CurrentSession->area, shared_dp);\n\n\t\t/* Return the one we found. */\n\t\tAssert(record_table_entry->key.shared);\n\t\tresult = (TupleDesc)\n\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\trecord_table_entry->key.shared);\n\t\tAssert(result->tdrefcount == -1);\n\n\t\treturn result;\n\t}\n\n\t/* Store it and return it. */\n\trecord_table_entry->key.shared = true;\n\trecord_table_entry->key.u.shared_tupdesc = shared_dp;\n\tdshash_release_lock(CurrentSession->shared_record_table,\n\t\t\t\t\t\trecord_table_entry);\n\tresult = (TupleDesc)\n\t\tdsa_get_address(CurrentSession->area, shared_dp);\n\tAssert(result->tdrefcount == -1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);",
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nstatic TupleDesc\nfind_or_make_matching_shared_tupledesc(TupleDesc tupdesc)\n{\n\tTupleDesc\tresult;\n\tSharedRecordTableKey key;\n\tSharedRecordTableEntry *record_table_entry;\n\tSharedTypmodTableEntry *typmod_table_entry;\n\tdsa_pointer shared_dp;\n\tbool\t\tfound;\n\tuint32\t\ttypmod;\n\n\t/* If not even attached, nothing to do. */\n\tif (CurrentSession->shared_typmod_registry == NULL)\n\t\treturn NULL;\n\n\t/* Try to find a matching tuple descriptor in the record table. */\n\tkey.shared = false;\n\tkey.u.local_tupdesc = tupdesc;\n\trecord_table_entry = (SharedRecordTableEntry *)\n\t\tdshash_find(CurrentSession->shared_record_table, &key, false);\n\tif (record_table_entry)\n\t{\n\t\tAssert(record_table_entry->key.shared);\n\t\tdshash_release_lock(CurrentSession->shared_record_table,\n\t\t\t\t\t\t\trecord_table_entry);\n\t\tresult = (TupleDesc)\n\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\trecord_table_entry->key.u.shared_tupdesc);\n\t\tAssert(result->tdrefcount == -1);\n\n\t\treturn result;\n\t}\n\n\t/* Allocate a new typmod number.  This will be wasted if we error out. */\n\ttypmod = (int)\n\t\tpg_atomic_fetch_add_u32(&CurrentSession->shared_typmod_registry->next_typmod,\n\t\t\t\t\t\t\t\t1);\n\n\t/* Copy the TupleDesc into shared memory. */\n\tshared_dp = share_tupledesc(CurrentSession->area, tupdesc, typmod);\n\n\t/*\n\t * Create an entry in the typmod table so that others will understand this\n\t * typmod number.\n\t */\n\tPG_TRY();\n\t{\n\t\ttypmod_table_entry = (SharedTypmodTableEntry *)\n\t\t\tdshash_find_or_insert(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t  &typmod, &found);\n\t\tif (found)\n\t\t\telog(ERROR, \"cannot create duplicate shared record typmod\");\n\t}\n\tPG_CATCH();\n\t{\n\t\tdsa_free(CurrentSession->area, shared_dp);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\ttypmod_table_entry->typmod = typmod;\n\ttypmod_table_entry->shared_tupdesc = shared_dp;\n\tdshash_release_lock(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\ttypmod_table_entry);\n\n\t/*\n\t * Finally create an entry in the record table so others with matching\n\t * tuple descriptors can reuse the typmod.\n\t */\n\trecord_table_entry = (SharedRecordTableEntry *)\n\t\tdshash_find_or_insert(CurrentSession->shared_record_table, &key,\n\t\t\t\t\t\t\t  &found);\n\tif (found)\n\t{\n\t\t/*\n\t\t * Someone concurrently inserted a matching tuple descriptor since the\n\t\t * first time we checked.  Use that one instead.\n\t\t */\n\t\tdshash_release_lock(CurrentSession->shared_record_table,\n\t\t\t\t\t\t\trecord_table_entry);\n\n\t\t/* Might as well free up the space used by the one we created. */\n\t\tfound = dshash_delete_key(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t  &typmod);\n\t\tAssert(found);\n\t\tdsa_free(CurrentSession->area, shared_dp);\n\n\t\t/* Return the one we found. */\n\t\tAssert(record_table_entry->key.shared);\n\t\tresult = (TupleDesc)\n\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\trecord_table_entry->key.shared);\n\t\tAssert(result->tdrefcount == -1);\n\n\t\treturn result;\n\t}\n\n\t/* Store it and return it. */\n\trecord_table_entry->key.shared = true;\n\trecord_table_entry->key.u.shared_tupdesc = shared_dp;\n\tdshash_release_lock(CurrentSession->shared_record_table,\n\t\t\t\t\t\trecord_table_entry);\n\tresult = (TupleDesc)\n\t\tdsa_get_address(CurrentSession->area, shared_dp);\n\tAssert(result->tdrefcount == -1);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "RecordCacheHash",
            "(void *) &tupDesc",
            "HASH_ENTER",
            "&found"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CreateCacheMemoryContext",
          "args": [],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "CreateCacheMemoryContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "635-646",
          "snippet": "void\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nvoid\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_create",
          "args": [
            "\"Record information cache\"",
            "64",
            "&ctl",
            "HASH_ELEM | HASH_FUNCTION | HASH_COMPARE"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "hash_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "315-564",
          "snippet": "HTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_FREELISTS\t\t\t32"
          ],
          "globals_used": [
            "static void *DynaHashAlloc(Size size);",
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static int\tchoose_nelem_alloc(Size entrysize);",
            "static bool init_htab(HTAB *hashp, long nelem);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);",
            "static MemoryContext CurrentDynaHashCxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define NUM_FREELISTS\t\t\t32\n\nstatic void *DynaHashAlloc(Size size);\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic int\tchoose_nelem_alloc(Size entrysize);\nstatic bool init_htab(HTAB *hashp, long nelem);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\nstatic MemoryContext CurrentDynaHashCxt = NULL;\n\nHTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&ctl",
            "0",
            "sizeof(ctl)"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tupDesc->tdtypeid == RECORDOID"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HTAB *RecordCacheHash = NULL;\nstatic TupleDesc *RecordCacheArray = NULL;\nstatic uint64 *RecordIdentifierArray = NULL;\nstatic int32 NextRecordTypmod = 0;\nstatic uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nvoid\nassign_record_type_typmod(TupleDesc tupDesc)\n{\n\tRecordCacheEntry *recentry;\n\tTupleDesc\tentDesc;\n\tbool\t\tfound;\n\tMemoryContext oldcxt;\n\n\tAssert(tupDesc->tdtypeid == RECORDOID);\n\n\tif (RecordCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(TupleDesc);\t/* just the pointer */\n\t\tctl.entrysize = sizeof(RecordCacheEntry);\n\t\tctl.hash = record_type_typmod_hash;\n\t\tctl.match = record_type_typmod_compare;\n\t\tRecordCacheHash = hash_create(\"Record information cache\", 64,\n\t\t\t\t\t\t\t\t\t  &ctl,\n\t\t\t\t\t\t\t\t\t  HASH_ELEM | HASH_FUNCTION | HASH_COMPARE);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Find or create a hashtable entry for this tuple descriptor */\n\trecentry = (RecordCacheEntry *) hash_search(RecordCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t(void *) &tupDesc,\n\t\t\t\t\t\t\t\t\t\t\t\tHASH_ENTER, &found);\n\tif (found && recentry->tupdesc != NULL)\n\t{\n\t\ttupDesc->tdtypmod = recentry->tupdesc->tdtypmod;\n\t\treturn;\n\t}\n\n\t/* Not present, so need to manufacture an entry */\n\trecentry->tupdesc = NULL;\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/* Look in the SharedRecordTypmodRegistry, if attached */\n\tentDesc = find_or_make_matching_shared_tupledesc(tupDesc);\n\tif (entDesc == NULL)\n\t{\n\t\t/* Reference-counted local cache only. */\n\t\tentDesc = CreateTupleDescCopy(tupDesc);\n\t\tentDesc->tdrefcount = 1;\n\t\tentDesc->tdtypmod = NextRecordTypmod++;\n\t}\n\tensure_record_cache_typmod_slot_exists(entDesc->tdtypmod);\n\tRecordCacheArray[entDesc->tdtypmod] = entDesc;\n\trecentry->tupdesc = entDesc;\n\n\t/* Assign a unique tupdesc identifier, too. */\n\tRecordIdentifierArray[entDesc->tdtypmod] = ++tupledesc_id_counter;\n\n\t/* Update the caller's tuple descriptor. */\n\ttupDesc->tdtypmod = entDesc->tdtypmod;\n\n\tMemoryContextSwitchTo(oldcxt);\n}"
  },
  {
    "function_name": "record_type_typmod_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1744-1751",
    "snippet": "static int\nrecord_type_typmod_compare(const void *a, const void *b, size_t size)\n{\n\tRecordCacheEntry *left = (RecordCacheEntry *) a;\n\tRecordCacheEntry *right = (RecordCacheEntry *) b;\n\n\treturn equalTupleDescs(left->tupdesc, right->tupdesc) ? 0 : 1;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tdcs_cmp(const void *a, const void *b);",
      "static int\tenum_oid_cmp(const void *left, const void *right);",
      "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "equalTupleDescs",
          "args": [
            "left->tupdesc",
            "right->tupdesc"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\tdcs_cmp(const void *a, const void *b);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nstatic int\nrecord_type_typmod_compare(const void *a, const void *b, size_t size)\n{\n\tRecordCacheEntry *left = (RecordCacheEntry *) a;\n\tRecordCacheEntry *right = (RecordCacheEntry *) b;\n\n\treturn equalTupleDescs(left->tupdesc, right->tupdesc) ? 0 : 1;\n}"
  },
  {
    "function_name": "record_type_typmod_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1733-1739",
    "snippet": "static uint32\nrecord_type_typmod_hash(const void *data, size_t size)\n{\n\tRecordCacheEntry *entry = (RecordCacheEntry *) data;\n\n\treturn hashTupleDesc(entry->tupdesc);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashTupleDesc",
          "args": [
            "entry->tupdesc"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nstatic uint32\nrecord_type_typmod_hash(const void *data, size_t size)\n{\n\tRecordCacheEntry *entry = (RecordCacheEntry *) data;\n\n\treturn hashTupleDesc(entry->tupdesc);\n}"
  },
  {
    "function_name": "lookup_rowtype_tupdesc_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1696-1728",
    "snippet": "TupleDesc\nlookup_rowtype_tupdesc_domain(Oid type_id, int32 typmod, bool noError)\n{\n\tTupleDesc\ttupDesc;\n\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * Check for domain or named composite type.  We might as well load\n\t\t * whichever data is needed.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id,\n\t\t\t\t\t\t\t\t\t TYPECACHE_TUPDESC |\n\t\t\t\t\t\t\t\t\t TYPECACHE_DOMAIN_BASE_INFO);\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t\treturn lookup_rowtype_tupdesc_noerror(typentry->domainBaseType,\n\t\t\t\t\t\t\t\t\t\t\t\t  typentry->domainBaseTypmod,\n\t\t\t\t\t\t\t\t\t\t\t\t  noError);\n\t\tif (typentry->tupDesc == NULL && !noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\ttupDesc = typentry->tupDesc;\n\t}\n\telse\n\t\ttupDesc = lookup_rowtype_tupdesc_internal(type_id, typmod, noError);\n\tif (tupDesc != NULL)\n\t\tPinTupleDesc(tupDesc);\n\treturn tupDesc;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);",
      "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PinTupleDesc",
          "args": [
            "tupDesc"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc_internal",
          "args": [
            "type_id",
            "typmod",
            "noError"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1549-1626",
          "snippet": "static TupleDesc\nlookup_rowtype_tupdesc_internal(Oid type_id, int32 typmod, bool noError)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL && !noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\treturn typentry->tupDesc;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0)\n\t\t{\n\t\t\t/* It is already in our local cache? */\n\t\t\tif (typmod < RecordCacheArrayLen &&\n\t\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t\t\treturn RecordCacheArray[typmod];\n\n\t\t\t/* Are we attached to a shared record typmod registry? */\n\t\t\tif (CurrentSession->shared_typmod_registry != NULL)\n\t\t\t{\n\t\t\t\tSharedTypmodTableEntry *entry;\n\n\t\t\t\t/* Try to find it in the shared typmod index. */\n\t\t\t\tentry = dshash_find(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t&typmod, false);\n\t\t\t\tif (entry != NULL)\n\t\t\t\t{\n\t\t\t\t\tTupleDesc\ttupdesc;\n\n\t\t\t\t\ttupdesc = (TupleDesc)\n\t\t\t\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\t\t\t\tentry->shared_tupdesc);\n\t\t\t\t\tAssert(typmod == tupdesc->tdtypmod);\n\n\t\t\t\t\t/* We may need to extend the local RecordCacheArray. */\n\t\t\t\t\tensure_record_cache_typmod_slot_exists(typmod);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Our local array can now point directly to the TupleDesc\n\t\t\t\t\t * in shared memory, which is non-reference-counted.\n\t\t\t\t\t */\n\t\t\t\t\tRecordCacheArray[typmod] = tupdesc;\n\t\t\t\t\tAssert(tupdesc->tdrefcount == -1);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We don't share tupdesc identifiers across processes, so\n\t\t\t\t\t * assign one locally.\n\t\t\t\t\t */\n\t\t\t\t\tRecordIdentifierArray[typmod] = ++tupledesc_id_counter;\n\n\t\t\t\t\tdshash_release_lock(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t\tentry);\n\n\t\t\t\t\treturn RecordCacheArray[typmod];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"record type has not been registered\")));\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc *RecordCacheArray = NULL;",
            "static uint64 *RecordIdentifierArray = NULL;",
            "static int32 RecordCacheArrayLen = 0;",
            "static uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);",
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *RecordCacheArray = NULL;\nstatic uint64 *RecordIdentifierArray = NULL;\nstatic int32 RecordCacheArrayLen = 0;\nstatic uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nstatic TupleDesc\nlookup_rowtype_tupdesc_internal(Oid type_id, int32 typmod, bool noError)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL && !noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\treturn typentry->tupDesc;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0)\n\t\t{\n\t\t\t/* It is already in our local cache? */\n\t\t\tif (typmod < RecordCacheArrayLen &&\n\t\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t\t\treturn RecordCacheArray[typmod];\n\n\t\t\t/* Are we attached to a shared record typmod registry? */\n\t\t\tif (CurrentSession->shared_typmod_registry != NULL)\n\t\t\t{\n\t\t\t\tSharedTypmodTableEntry *entry;\n\n\t\t\t\t/* Try to find it in the shared typmod index. */\n\t\t\t\tentry = dshash_find(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t&typmod, false);\n\t\t\t\tif (entry != NULL)\n\t\t\t\t{\n\t\t\t\t\tTupleDesc\ttupdesc;\n\n\t\t\t\t\ttupdesc = (TupleDesc)\n\t\t\t\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\t\t\t\tentry->shared_tupdesc);\n\t\t\t\t\tAssert(typmod == tupdesc->tdtypmod);\n\n\t\t\t\t\t/* We may need to extend the local RecordCacheArray. */\n\t\t\t\t\tensure_record_cache_typmod_slot_exists(typmod);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Our local array can now point directly to the TupleDesc\n\t\t\t\t\t * in shared memory, which is non-reference-counted.\n\t\t\t\t\t */\n\t\t\t\t\tRecordCacheArray[typmod] = tupdesc;\n\t\t\t\t\tAssert(tupdesc->tdrefcount == -1);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We don't share tupdesc identifiers across processes, so\n\t\t\t\t\t * assign one locally.\n\t\t\t\t\t */\n\t\t\t\t\tRecordIdentifierArray[typmod] = ++tupledesc_id_counter;\n\n\t\t\t\t\tdshash_release_lock(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t\tentry);\n\n\t\t\t\t\treturn RecordCacheArray[typmod];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"record type has not been registered\")));\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id)))"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"type %s is not composite\"",
            "format_type_be(type_id)"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "type_id"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_WRONG_OBJECT_TYPE"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc_noerror",
          "args": [
            "typentry->domainBaseType",
            "typentry->domainBaseTypmod",
            "noError"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_noerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1657-1666",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_noerror(Oid type_id, int32 typmod, bool noError)\n{\n\tTupleDesc\ttupDesc;\n\n\ttupDesc = lookup_rowtype_tupdesc_internal(type_id, typmod, noError);\n\tif (tupDesc != NULL)\n\t\tPinTupleDesc(tupDesc);\n\treturn tupDesc;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_noerror(Oid type_id, int32 typmod, bool noError)\n{\n\tTupleDesc\ttupDesc;\n\n\ttupDesc = lookup_rowtype_tupdesc_internal(type_id, typmod, noError);\n\tif (tupDesc != NULL)\n\t\tPinTupleDesc(tupDesc);\n\treturn tupDesc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "type_id",
            "TYPECACHE_TUPDESC |\n\t\t\t\t\t\t\t\t\t TYPECACHE_DOMAIN_BASE_INFO"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_domain(Oid type_id, int32 typmod, bool noError)\n{\n\tTupleDesc\ttupDesc;\n\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * Check for domain or named composite type.  We might as well load\n\t\t * whichever data is needed.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id,\n\t\t\t\t\t\t\t\t\t TYPECACHE_TUPDESC |\n\t\t\t\t\t\t\t\t\t TYPECACHE_DOMAIN_BASE_INFO);\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t\treturn lookup_rowtype_tupdesc_noerror(typentry->domainBaseType,\n\t\t\t\t\t\t\t\t\t\t\t\t  typentry->domainBaseTypmod,\n\t\t\t\t\t\t\t\t\t\t\t\t  noError);\n\t\tif (typentry->tupDesc == NULL && !noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\ttupDesc = typentry->tupDesc;\n\t}\n\telse\n\t\ttupDesc = lookup_rowtype_tupdesc_internal(type_id, typmod, noError);\n\tif (tupDesc != NULL)\n\t\tPinTupleDesc(tupDesc);\n\treturn tupDesc;\n}"
  },
  {
    "function_name": "lookup_rowtype_tupdesc_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1674-1681",
    "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CreateTupleDescCopyConstr",
          "args": [
            "tmp"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc_internal",
          "args": [
            "type_id",
            "typmod",
            "false"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1549-1626",
          "snippet": "static TupleDesc\nlookup_rowtype_tupdesc_internal(Oid type_id, int32 typmod, bool noError)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL && !noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\treturn typentry->tupDesc;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0)\n\t\t{\n\t\t\t/* It is already in our local cache? */\n\t\t\tif (typmod < RecordCacheArrayLen &&\n\t\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t\t\treturn RecordCacheArray[typmod];\n\n\t\t\t/* Are we attached to a shared record typmod registry? */\n\t\t\tif (CurrentSession->shared_typmod_registry != NULL)\n\t\t\t{\n\t\t\t\tSharedTypmodTableEntry *entry;\n\n\t\t\t\t/* Try to find it in the shared typmod index. */\n\t\t\t\tentry = dshash_find(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t&typmod, false);\n\t\t\t\tif (entry != NULL)\n\t\t\t\t{\n\t\t\t\t\tTupleDesc\ttupdesc;\n\n\t\t\t\t\ttupdesc = (TupleDesc)\n\t\t\t\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\t\t\t\tentry->shared_tupdesc);\n\t\t\t\t\tAssert(typmod == tupdesc->tdtypmod);\n\n\t\t\t\t\t/* We may need to extend the local RecordCacheArray. */\n\t\t\t\t\tensure_record_cache_typmod_slot_exists(typmod);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Our local array can now point directly to the TupleDesc\n\t\t\t\t\t * in shared memory, which is non-reference-counted.\n\t\t\t\t\t */\n\t\t\t\t\tRecordCacheArray[typmod] = tupdesc;\n\t\t\t\t\tAssert(tupdesc->tdrefcount == -1);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We don't share tupdesc identifiers across processes, so\n\t\t\t\t\t * assign one locally.\n\t\t\t\t\t */\n\t\t\t\t\tRecordIdentifierArray[typmod] = ++tupledesc_id_counter;\n\n\t\t\t\t\tdshash_release_lock(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t\tentry);\n\n\t\t\t\t\treturn RecordCacheArray[typmod];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"record type has not been registered\")));\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc *RecordCacheArray = NULL;",
            "static uint64 *RecordIdentifierArray = NULL;",
            "static int32 RecordCacheArrayLen = 0;",
            "static uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);",
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *RecordCacheArray = NULL;\nstatic uint64 *RecordIdentifierArray = NULL;\nstatic int32 RecordCacheArrayLen = 0;\nstatic uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nstatic TupleDesc\nlookup_rowtype_tupdesc_internal(Oid type_id, int32 typmod, bool noError)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL && !noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\treturn typentry->tupDesc;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0)\n\t\t{\n\t\t\t/* It is already in our local cache? */\n\t\t\tif (typmod < RecordCacheArrayLen &&\n\t\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t\t\treturn RecordCacheArray[typmod];\n\n\t\t\t/* Are we attached to a shared record typmod registry? */\n\t\t\tif (CurrentSession->shared_typmod_registry != NULL)\n\t\t\t{\n\t\t\t\tSharedTypmodTableEntry *entry;\n\n\t\t\t\t/* Try to find it in the shared typmod index. */\n\t\t\t\tentry = dshash_find(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t&typmod, false);\n\t\t\t\tif (entry != NULL)\n\t\t\t\t{\n\t\t\t\t\tTupleDesc\ttupdesc;\n\n\t\t\t\t\ttupdesc = (TupleDesc)\n\t\t\t\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\t\t\t\tentry->shared_tupdesc);\n\t\t\t\t\tAssert(typmod == tupdesc->tdtypmod);\n\n\t\t\t\t\t/* We may need to extend the local RecordCacheArray. */\n\t\t\t\t\tensure_record_cache_typmod_slot_exists(typmod);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Our local array can now point directly to the TupleDesc\n\t\t\t\t\t * in shared memory, which is non-reference-counted.\n\t\t\t\t\t */\n\t\t\t\t\tRecordCacheArray[typmod] = tupdesc;\n\t\t\t\t\tAssert(tupdesc->tdrefcount == -1);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We don't share tupdesc identifiers across processes, so\n\t\t\t\t\t * assign one locally.\n\t\t\t\t\t */\n\t\t\t\t\tRecordIdentifierArray[typmod] = ++tupledesc_id_counter;\n\n\t\t\t\t\tdshash_release_lock(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t\tentry);\n\n\t\t\t\t\treturn RecordCacheArray[typmod];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"record type has not been registered\")));\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
  },
  {
    "function_name": "lookup_rowtype_tupdesc_noerror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1657-1666",
    "snippet": "TupleDesc\nlookup_rowtype_tupdesc_noerror(Oid type_id, int32 typmod, bool noError)\n{\n\tTupleDesc\ttupDesc;\n\n\ttupDesc = lookup_rowtype_tupdesc_internal(type_id, typmod, noError);\n\tif (tupDesc != NULL)\n\t\tPinTupleDesc(tupDesc);\n\treturn tupDesc;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PinTupleDesc",
          "args": [
            "tupDesc"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc_internal",
          "args": [
            "type_id",
            "typmod",
            "noError"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1549-1626",
          "snippet": "static TupleDesc\nlookup_rowtype_tupdesc_internal(Oid type_id, int32 typmod, bool noError)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL && !noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\treturn typentry->tupDesc;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0)\n\t\t{\n\t\t\t/* It is already in our local cache? */\n\t\t\tif (typmod < RecordCacheArrayLen &&\n\t\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t\t\treturn RecordCacheArray[typmod];\n\n\t\t\t/* Are we attached to a shared record typmod registry? */\n\t\t\tif (CurrentSession->shared_typmod_registry != NULL)\n\t\t\t{\n\t\t\t\tSharedTypmodTableEntry *entry;\n\n\t\t\t\t/* Try to find it in the shared typmod index. */\n\t\t\t\tentry = dshash_find(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t&typmod, false);\n\t\t\t\tif (entry != NULL)\n\t\t\t\t{\n\t\t\t\t\tTupleDesc\ttupdesc;\n\n\t\t\t\t\ttupdesc = (TupleDesc)\n\t\t\t\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\t\t\t\tentry->shared_tupdesc);\n\t\t\t\t\tAssert(typmod == tupdesc->tdtypmod);\n\n\t\t\t\t\t/* We may need to extend the local RecordCacheArray. */\n\t\t\t\t\tensure_record_cache_typmod_slot_exists(typmod);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Our local array can now point directly to the TupleDesc\n\t\t\t\t\t * in shared memory, which is non-reference-counted.\n\t\t\t\t\t */\n\t\t\t\t\tRecordCacheArray[typmod] = tupdesc;\n\t\t\t\t\tAssert(tupdesc->tdrefcount == -1);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We don't share tupdesc identifiers across processes, so\n\t\t\t\t\t * assign one locally.\n\t\t\t\t\t */\n\t\t\t\t\tRecordIdentifierArray[typmod] = ++tupledesc_id_counter;\n\n\t\t\t\t\tdshash_release_lock(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t\tentry);\n\n\t\t\t\t\treturn RecordCacheArray[typmod];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"record type has not been registered\")));\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc *RecordCacheArray = NULL;",
            "static uint64 *RecordIdentifierArray = NULL;",
            "static int32 RecordCacheArrayLen = 0;",
            "static uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);",
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *RecordCacheArray = NULL;\nstatic uint64 *RecordIdentifierArray = NULL;\nstatic int32 RecordCacheArrayLen = 0;\nstatic uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nstatic TupleDesc\nlookup_rowtype_tupdesc_internal(Oid type_id, int32 typmod, bool noError)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL && !noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\treturn typentry->tupDesc;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0)\n\t\t{\n\t\t\t/* It is already in our local cache? */\n\t\t\tif (typmod < RecordCacheArrayLen &&\n\t\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t\t\treturn RecordCacheArray[typmod];\n\n\t\t\t/* Are we attached to a shared record typmod registry? */\n\t\t\tif (CurrentSession->shared_typmod_registry != NULL)\n\t\t\t{\n\t\t\t\tSharedTypmodTableEntry *entry;\n\n\t\t\t\t/* Try to find it in the shared typmod index. */\n\t\t\t\tentry = dshash_find(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t&typmod, false);\n\t\t\t\tif (entry != NULL)\n\t\t\t\t{\n\t\t\t\t\tTupleDesc\ttupdesc;\n\n\t\t\t\t\ttupdesc = (TupleDesc)\n\t\t\t\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\t\t\t\tentry->shared_tupdesc);\n\t\t\t\t\tAssert(typmod == tupdesc->tdtypmod);\n\n\t\t\t\t\t/* We may need to extend the local RecordCacheArray. */\n\t\t\t\t\tensure_record_cache_typmod_slot_exists(typmod);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Our local array can now point directly to the TupleDesc\n\t\t\t\t\t * in shared memory, which is non-reference-counted.\n\t\t\t\t\t */\n\t\t\t\t\tRecordCacheArray[typmod] = tupdesc;\n\t\t\t\t\tAssert(tupdesc->tdrefcount == -1);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We don't share tupdesc identifiers across processes, so\n\t\t\t\t\t * assign one locally.\n\t\t\t\t\t */\n\t\t\t\t\tRecordIdentifierArray[typmod] = ++tupledesc_id_counter;\n\n\t\t\t\t\tdshash_release_lock(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t\tentry);\n\n\t\t\t\t\treturn RecordCacheArray[typmod];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"record type has not been registered\")));\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_noerror(Oid type_id, int32 typmod, bool noError)\n{\n\tTupleDesc\ttupDesc;\n\n\ttupDesc = lookup_rowtype_tupdesc_internal(type_id, typmod, noError);\n\tif (tupDesc != NULL)\n\t\tPinTupleDesc(tupDesc);\n\treturn tupDesc;\n}"
  },
  {
    "function_name": "lookup_rowtype_tupdesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1640-1648",
    "snippet": "TupleDesc\nlookup_rowtype_tupdesc(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttupDesc;\n\n\ttupDesc = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\tPinTupleDesc(tupDesc);\n\treturn tupDesc;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PinTupleDesc",
          "args": [
            "tupDesc"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc_internal",
          "args": [
            "type_id",
            "typmod",
            "false"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1549-1626",
          "snippet": "static TupleDesc\nlookup_rowtype_tupdesc_internal(Oid type_id, int32 typmod, bool noError)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL && !noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\treturn typentry->tupDesc;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0)\n\t\t{\n\t\t\t/* It is already in our local cache? */\n\t\t\tif (typmod < RecordCacheArrayLen &&\n\t\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t\t\treturn RecordCacheArray[typmod];\n\n\t\t\t/* Are we attached to a shared record typmod registry? */\n\t\t\tif (CurrentSession->shared_typmod_registry != NULL)\n\t\t\t{\n\t\t\t\tSharedTypmodTableEntry *entry;\n\n\t\t\t\t/* Try to find it in the shared typmod index. */\n\t\t\t\tentry = dshash_find(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t&typmod, false);\n\t\t\t\tif (entry != NULL)\n\t\t\t\t{\n\t\t\t\t\tTupleDesc\ttupdesc;\n\n\t\t\t\t\ttupdesc = (TupleDesc)\n\t\t\t\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\t\t\t\tentry->shared_tupdesc);\n\t\t\t\t\tAssert(typmod == tupdesc->tdtypmod);\n\n\t\t\t\t\t/* We may need to extend the local RecordCacheArray. */\n\t\t\t\t\tensure_record_cache_typmod_slot_exists(typmod);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Our local array can now point directly to the TupleDesc\n\t\t\t\t\t * in shared memory, which is non-reference-counted.\n\t\t\t\t\t */\n\t\t\t\t\tRecordCacheArray[typmod] = tupdesc;\n\t\t\t\t\tAssert(tupdesc->tdrefcount == -1);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We don't share tupdesc identifiers across processes, so\n\t\t\t\t\t * assign one locally.\n\t\t\t\t\t */\n\t\t\t\t\tRecordIdentifierArray[typmod] = ++tupledesc_id_counter;\n\n\t\t\t\t\tdshash_release_lock(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t\tentry);\n\n\t\t\t\t\treturn RecordCacheArray[typmod];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"record type has not been registered\")));\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc *RecordCacheArray = NULL;",
            "static uint64 *RecordIdentifierArray = NULL;",
            "static int32 RecordCacheArrayLen = 0;",
            "static uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);",
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *RecordCacheArray = NULL;\nstatic uint64 *RecordIdentifierArray = NULL;\nstatic int32 RecordCacheArrayLen = 0;\nstatic uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nstatic TupleDesc\nlookup_rowtype_tupdesc_internal(Oid type_id, int32 typmod, bool noError)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL && !noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\treturn typentry->tupDesc;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0)\n\t\t{\n\t\t\t/* It is already in our local cache? */\n\t\t\tif (typmod < RecordCacheArrayLen &&\n\t\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t\t\treturn RecordCacheArray[typmod];\n\n\t\t\t/* Are we attached to a shared record typmod registry? */\n\t\t\tif (CurrentSession->shared_typmod_registry != NULL)\n\t\t\t{\n\t\t\t\tSharedTypmodTableEntry *entry;\n\n\t\t\t\t/* Try to find it in the shared typmod index. */\n\t\t\t\tentry = dshash_find(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t&typmod, false);\n\t\t\t\tif (entry != NULL)\n\t\t\t\t{\n\t\t\t\t\tTupleDesc\ttupdesc;\n\n\t\t\t\t\ttupdesc = (TupleDesc)\n\t\t\t\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\t\t\t\tentry->shared_tupdesc);\n\t\t\t\t\tAssert(typmod == tupdesc->tdtypmod);\n\n\t\t\t\t\t/* We may need to extend the local RecordCacheArray. */\n\t\t\t\t\tensure_record_cache_typmod_slot_exists(typmod);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Our local array can now point directly to the TupleDesc\n\t\t\t\t\t * in shared memory, which is non-reference-counted.\n\t\t\t\t\t */\n\t\t\t\t\tRecordCacheArray[typmod] = tupdesc;\n\t\t\t\t\tAssert(tupdesc->tdrefcount == -1);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We don't share tupdesc identifiers across processes, so\n\t\t\t\t\t * assign one locally.\n\t\t\t\t\t */\n\t\t\t\t\tRecordIdentifierArray[typmod] = ++tupledesc_id_counter;\n\n\t\t\t\t\tdshash_release_lock(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t\tentry);\n\n\t\t\t\t\treturn RecordCacheArray[typmod];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"record type has not been registered\")));\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttupDesc;\n\n\ttupDesc = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\tPinTupleDesc(tupDesc);\n\treturn tupDesc;\n}"
  },
  {
    "function_name": "lookup_rowtype_tupdesc_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1549-1626",
    "snippet": "static TupleDesc\nlookup_rowtype_tupdesc_internal(Oid type_id, int32 typmod, bool noError)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL && !noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\treturn typentry->tupDesc;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0)\n\t\t{\n\t\t\t/* It is already in our local cache? */\n\t\t\tif (typmod < RecordCacheArrayLen &&\n\t\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t\t\treturn RecordCacheArray[typmod];\n\n\t\t\t/* Are we attached to a shared record typmod registry? */\n\t\t\tif (CurrentSession->shared_typmod_registry != NULL)\n\t\t\t{\n\t\t\t\tSharedTypmodTableEntry *entry;\n\n\t\t\t\t/* Try to find it in the shared typmod index. */\n\t\t\t\tentry = dshash_find(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t&typmod, false);\n\t\t\t\tif (entry != NULL)\n\t\t\t\t{\n\t\t\t\t\tTupleDesc\ttupdesc;\n\n\t\t\t\t\ttupdesc = (TupleDesc)\n\t\t\t\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\t\t\t\tentry->shared_tupdesc);\n\t\t\t\t\tAssert(typmod == tupdesc->tdtypmod);\n\n\t\t\t\t\t/* We may need to extend the local RecordCacheArray. */\n\t\t\t\t\tensure_record_cache_typmod_slot_exists(typmod);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Our local array can now point directly to the TupleDesc\n\t\t\t\t\t * in shared memory, which is non-reference-counted.\n\t\t\t\t\t */\n\t\t\t\t\tRecordCacheArray[typmod] = tupdesc;\n\t\t\t\t\tAssert(tupdesc->tdrefcount == -1);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We don't share tupdesc identifiers across processes, so\n\t\t\t\t\t * assign one locally.\n\t\t\t\t\t */\n\t\t\t\t\tRecordIdentifierArray[typmod] = ++tupledesc_id_counter;\n\n\t\t\t\t\tdshash_release_lock(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t\tentry);\n\n\t\t\t\t\treturn RecordCacheArray[typmod];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"record type has not been registered\")));\n\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TupleDesc *RecordCacheArray = NULL;",
      "static uint64 *RecordIdentifierArray = NULL;",
      "static int32 RecordCacheArrayLen = 0;",
      "static uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;",
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);",
      "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);",
      "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"record type has not been registered\"))"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"record type has not been registered\""
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_WRONG_OBJECT_TYPE"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dshash_release_lock",
          "args": [
            "CurrentSession->shared_typmod_table",
            "entry"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tupdesc->tdrefcount == -1"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ensure_record_cache_typmod_slot_exists",
          "args": [
            "typmod"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_record_cache_typmod_slot_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1512-1541",
          "snippet": "static void\nensure_record_cache_typmod_slot_exists(int32 typmod)\n{\n\tif (RecordCacheArray == NULL)\n\t{\n\t\tRecordCacheArray = (TupleDesc *)\n\t\t\tMemoryContextAllocZero(CacheMemoryContext, 64 * sizeof(TupleDesc));\n\t\tRecordIdentifierArray = (uint64 *)\n\t\t\tMemoryContextAllocZero(CacheMemoryContext, 64 * sizeof(uint64));\n\t\tRecordCacheArrayLen = 64;\n\t}\n\n\tif (typmod >= RecordCacheArrayLen)\n\t{\n\t\tint32\t\tnewlen = RecordCacheArrayLen * 2;\n\n\t\twhile (typmod >= newlen)\n\t\t\tnewlen *= 2;\n\n\t\tRecordCacheArray = (TupleDesc *) repalloc(RecordCacheArray,\n\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tmemset(RecordCacheArray + RecordCacheArrayLen, 0,\n\t\t\t   (newlen - RecordCacheArrayLen) * sizeof(TupleDesc));\n\t\tRecordIdentifierArray = (uint64 *) repalloc(RecordIdentifierArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnewlen * sizeof(uint64));\n\t\tmemset(RecordIdentifierArray + RecordCacheArrayLen, 0,\n\t\t\t   (newlen - RecordCacheArrayLen) * sizeof(uint64));\n\t\tRecordCacheArrayLen = newlen;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc *RecordCacheArray = NULL;",
            "static uint64 *RecordIdentifierArray = NULL;",
            "static int32 RecordCacheArrayLen = 0;",
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *RecordCacheArray = NULL;\nstatic uint64 *RecordIdentifierArray = NULL;\nstatic int32 RecordCacheArrayLen = 0;\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nstatic void\nensure_record_cache_typmod_slot_exists(int32 typmod)\n{\n\tif (RecordCacheArray == NULL)\n\t{\n\t\tRecordCacheArray = (TupleDesc *)\n\t\t\tMemoryContextAllocZero(CacheMemoryContext, 64 * sizeof(TupleDesc));\n\t\tRecordIdentifierArray = (uint64 *)\n\t\t\tMemoryContextAllocZero(CacheMemoryContext, 64 * sizeof(uint64));\n\t\tRecordCacheArrayLen = 64;\n\t}\n\n\tif (typmod >= RecordCacheArrayLen)\n\t{\n\t\tint32\t\tnewlen = RecordCacheArrayLen * 2;\n\n\t\twhile (typmod >= newlen)\n\t\t\tnewlen *= 2;\n\n\t\tRecordCacheArray = (TupleDesc *) repalloc(RecordCacheArray,\n\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tmemset(RecordCacheArray + RecordCacheArrayLen, 0,\n\t\t\t   (newlen - RecordCacheArrayLen) * sizeof(TupleDesc));\n\t\tRecordIdentifierArray = (uint64 *) repalloc(RecordIdentifierArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnewlen * sizeof(uint64));\n\t\tmemset(RecordIdentifierArray + RecordCacheArrayLen, 0,\n\t\t\t   (newlen - RecordCacheArrayLen) * sizeof(uint64));\n\t\tRecordCacheArrayLen = newlen;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "typmod == tupdesc->tdtypmod"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_get_address",
          "args": [
            "CurrentSession->area",
            "entry->shared_tupdesc"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "931-957",
          "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dshash_find",
          "args": [
            "CurrentSession->shared_typmod_table",
            "&typmod",
            "false"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id)))"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "type_id"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "type_id",
            "TYPECACHE_TUPDESC"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *RecordCacheArray = NULL;\nstatic uint64 *RecordIdentifierArray = NULL;\nstatic int32 RecordCacheArrayLen = 0;\nstatic uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nstatic TupleDesc\nlookup_rowtype_tupdesc_internal(Oid type_id, int32 typmod, bool noError)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL && !noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\treturn typentry->tupDesc;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0)\n\t\t{\n\t\t\t/* It is already in our local cache? */\n\t\t\tif (typmod < RecordCacheArrayLen &&\n\t\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t\t\treturn RecordCacheArray[typmod];\n\n\t\t\t/* Are we attached to a shared record typmod registry? */\n\t\t\tif (CurrentSession->shared_typmod_registry != NULL)\n\t\t\t{\n\t\t\t\tSharedTypmodTableEntry *entry;\n\n\t\t\t\t/* Try to find it in the shared typmod index. */\n\t\t\t\tentry = dshash_find(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t&typmod, false);\n\t\t\t\tif (entry != NULL)\n\t\t\t\t{\n\t\t\t\t\tTupleDesc\ttupdesc;\n\n\t\t\t\t\ttupdesc = (TupleDesc)\n\t\t\t\t\t\tdsa_get_address(CurrentSession->area,\n\t\t\t\t\t\t\t\t\t\tentry->shared_tupdesc);\n\t\t\t\t\tAssert(typmod == tupdesc->tdtypmod);\n\n\t\t\t\t\t/* We may need to extend the local RecordCacheArray. */\n\t\t\t\t\tensure_record_cache_typmod_slot_exists(typmod);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Our local array can now point directly to the TupleDesc\n\t\t\t\t\t * in shared memory, which is non-reference-counted.\n\t\t\t\t\t */\n\t\t\t\t\tRecordCacheArray[typmod] = tupdesc;\n\t\t\t\t\tAssert(tupdesc->tdrefcount == -1);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We don't share tupdesc identifiers across processes, so\n\t\t\t\t\t * assign one locally.\n\t\t\t\t\t */\n\t\t\t\t\tRecordIdentifierArray[typmod] = ++tupledesc_id_counter;\n\n\t\t\t\t\tdshash_release_lock(CurrentSession->shared_typmod_table,\n\t\t\t\t\t\t\t\t\t\tentry);\n\n\t\t\t\t\treturn RecordCacheArray[typmod];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!noError)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"record type has not been registered\")));\n\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "ensure_record_cache_typmod_slot_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1512-1541",
    "snippet": "static void\nensure_record_cache_typmod_slot_exists(int32 typmod)\n{\n\tif (RecordCacheArray == NULL)\n\t{\n\t\tRecordCacheArray = (TupleDesc *)\n\t\t\tMemoryContextAllocZero(CacheMemoryContext, 64 * sizeof(TupleDesc));\n\t\tRecordIdentifierArray = (uint64 *)\n\t\t\tMemoryContextAllocZero(CacheMemoryContext, 64 * sizeof(uint64));\n\t\tRecordCacheArrayLen = 64;\n\t}\n\n\tif (typmod >= RecordCacheArrayLen)\n\t{\n\t\tint32\t\tnewlen = RecordCacheArrayLen * 2;\n\n\t\twhile (typmod >= newlen)\n\t\t\tnewlen *= 2;\n\n\t\tRecordCacheArray = (TupleDesc *) repalloc(RecordCacheArray,\n\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tmemset(RecordCacheArray + RecordCacheArrayLen, 0,\n\t\t\t   (newlen - RecordCacheArrayLen) * sizeof(TupleDesc));\n\t\tRecordIdentifierArray = (uint64 *) repalloc(RecordIdentifierArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnewlen * sizeof(uint64));\n\t\tmemset(RecordIdentifierArray + RecordCacheArrayLen, 0,\n\t\t\t   (newlen - RecordCacheArrayLen) * sizeof(uint64));\n\t\tRecordCacheArrayLen = newlen;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TupleDesc *RecordCacheArray = NULL;",
      "static uint64 *RecordIdentifierArray = NULL;",
      "static int32 RecordCacheArrayLen = 0;",
      "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "RecordIdentifierArray + RecordCacheArrayLen",
            "0",
            "(newlen - RecordCacheArrayLen) * sizeof(uint64)"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "RecordIdentifierArray",
            "newlen * sizeof(uint64)"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "repalloc_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1113-1141",
          "snippet": "void *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "RecordCacheArray + RecordCacheArrayLen",
            "0",
            "(newlen - RecordCacheArrayLen) * sizeof(TupleDesc)"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "CacheMemoryContext",
            "64 * sizeof(uint64)"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *RecordCacheArray = NULL;\nstatic uint64 *RecordIdentifierArray = NULL;\nstatic int32 RecordCacheArrayLen = 0;\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nstatic void\nensure_record_cache_typmod_slot_exists(int32 typmod)\n{\n\tif (RecordCacheArray == NULL)\n\t{\n\t\tRecordCacheArray = (TupleDesc *)\n\t\t\tMemoryContextAllocZero(CacheMemoryContext, 64 * sizeof(TupleDesc));\n\t\tRecordIdentifierArray = (uint64 *)\n\t\t\tMemoryContextAllocZero(CacheMemoryContext, 64 * sizeof(uint64));\n\t\tRecordCacheArrayLen = 64;\n\t}\n\n\tif (typmod >= RecordCacheArrayLen)\n\t{\n\t\tint32\t\tnewlen = RecordCacheArrayLen * 2;\n\n\t\twhile (typmod >= newlen)\n\t\t\tnewlen *= 2;\n\n\t\tRecordCacheArray = (TupleDesc *) repalloc(RecordCacheArray,\n\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tmemset(RecordCacheArray + RecordCacheArrayLen, 0,\n\t\t\t   (newlen - RecordCacheArrayLen) * sizeof(TupleDesc));\n\t\tRecordIdentifierArray = (uint64 *) repalloc(RecordIdentifierArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnewlen * sizeof(uint64));\n\t\tmemset(RecordIdentifierArray + RecordCacheArrayLen, 0,\n\t\t\t   (newlen - RecordCacheArrayLen) * sizeof(uint64));\n\t\tRecordCacheArrayLen = newlen;\n\t}\n}"
  },
  {
    "function_name": "cache_range_element_properties",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1484-1506",
    "snippet": "static void\ncache_range_element_properties(TypeCacheEntry *typentry)\n{\n\t/* load up subtype link if we didn't already */\n\tif (typentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t\tload_rangetype_info(typentry);\n\n\tif (typentry->rngelemtype != NULL)\n\t{\n\t\tTypeCacheEntry *elementry;\n\n\t\t/* might need to calculate subtype's hash function properties */\n\t\telementry = lookup_type_cache(typentry->rngelemtype->type_id,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC);\n\t\tif (OidIsValid(elementry->hash_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_HASHING;\n\t\tif (OidIsValid(elementry->hash_extended_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EXTENDED_HASHING;\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_ELEM_PROPERTIES;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000",
      "#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800",
      "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
    ],
    "globals_used": [
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "elementry->hash_extended_proc"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "elementry->hash_proc"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "typentry->rngelemtype->type_id",
            "TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_rangetype_info",
          "args": [
            "typentry"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "load_rangetype_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "817-868",
          "snippet": "static void\nload_rangetype_info(TypeCacheEntry *typentry)\n{\n\tForm_pg_range pg_range;\n\tHeapTuple\ttup;\n\tOid\t\t\tsubtypeOid;\n\tOid\t\t\topclassOid;\n\tOid\t\t\tcanonicalOid;\n\tOid\t\t\tsubdiffOid;\n\tOid\t\t\topfamilyOid;\n\tOid\t\t\topcintype;\n\tOid\t\t\tcmpFnOid;\n\n\t/* get information from pg_range */\n\ttup = SearchSysCache1(RANGETYPE, ObjectIdGetDatum(typentry->type_id));\n\t/* should not fail, since we already checked typtype ... */\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for range type %u\",\n\t\t\t typentry->type_id);\n\tpg_range = (Form_pg_range) GETSTRUCT(tup);\n\n\tsubtypeOid = pg_range->rngsubtype;\n\ttypentry->rng_collation = pg_range->rngcollation;\n\topclassOid = pg_range->rngsubopc;\n\tcanonicalOid = pg_range->rngcanonical;\n\tsubdiffOid = pg_range->rngsubdiff;\n\n\tReleaseSysCache(tup);\n\n\t/* get opclass properties and look up the comparison function */\n\topfamilyOid = get_opclass_family(opclassOid);\n\topcintype = get_opclass_input_type(opclassOid);\n\n\tcmpFnOid = get_opfamily_proc(opfamilyOid, opcintype, opcintype,\n\t\t\t\t\t\t\t\t BTORDER_PROC);\n\tif (!RegProcedureIsValid(cmpFnOid))\n\t\telog(ERROR, \"missing support function %d(%u,%u) in opfamily %u\",\n\t\t\t BTORDER_PROC, opcintype, opcintype, opfamilyOid);\n\n\t/* set up cached fmgrinfo structs */\n\tfmgr_info_cxt(cmpFnOid, &typentry->rng_cmp_proc_finfo,\n\t\t\t\t  CacheMemoryContext);\n\tif (OidIsValid(canonicalOid))\n\t\tfmgr_info_cxt(canonicalOid, &typentry->rng_canonical_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\tif (OidIsValid(subdiffOid))\n\t\tfmgr_info_cxt(subdiffOid, &typentry->rng_subdiff_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t/* Lastly, set up link to the element type --- this marks data valid */\n\ttypentry->rngelemtype = lookup_type_cache(subtypeOid, 0);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic void\nload_rangetype_info(TypeCacheEntry *typentry)\n{\n\tForm_pg_range pg_range;\n\tHeapTuple\ttup;\n\tOid\t\t\tsubtypeOid;\n\tOid\t\t\topclassOid;\n\tOid\t\t\tcanonicalOid;\n\tOid\t\t\tsubdiffOid;\n\tOid\t\t\topfamilyOid;\n\tOid\t\t\topcintype;\n\tOid\t\t\tcmpFnOid;\n\n\t/* get information from pg_range */\n\ttup = SearchSysCache1(RANGETYPE, ObjectIdGetDatum(typentry->type_id));\n\t/* should not fail, since we already checked typtype ... */\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for range type %u\",\n\t\t\t typentry->type_id);\n\tpg_range = (Form_pg_range) GETSTRUCT(tup);\n\n\tsubtypeOid = pg_range->rngsubtype;\n\ttypentry->rng_collation = pg_range->rngcollation;\n\topclassOid = pg_range->rngsubopc;\n\tcanonicalOid = pg_range->rngcanonical;\n\tsubdiffOid = pg_range->rngsubdiff;\n\n\tReleaseSysCache(tup);\n\n\t/* get opclass properties and look up the comparison function */\n\topfamilyOid = get_opclass_family(opclassOid);\n\topcintype = get_opclass_input_type(opclassOid);\n\n\tcmpFnOid = get_opfamily_proc(opfamilyOid, opcintype, opcintype,\n\t\t\t\t\t\t\t\t BTORDER_PROC);\n\tif (!RegProcedureIsValid(cmpFnOid))\n\t\telog(ERROR, \"missing support function %d(%u,%u) in opfamily %u\",\n\t\t\t BTORDER_PROC, opcintype, opcintype, opfamilyOid);\n\n\t/* set up cached fmgrinfo structs */\n\tfmgr_info_cxt(cmpFnOid, &typentry->rng_cmp_proc_finfo,\n\t\t\t\t  CacheMemoryContext);\n\tif (OidIsValid(canonicalOid))\n\t\tfmgr_info_cxt(canonicalOid, &typentry->rng_canonical_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\tif (OidIsValid(subdiffOid))\n\t\tfmgr_info_cxt(subdiffOid, &typentry->rng_subdiff_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t/* Lastly, set up link to the element type --- this marks data valid */\n\ttypentry->rngelemtype = lookup_type_cache(subtypeOid, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000\n#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic void\ncache_range_element_properties(TypeCacheEntry *typentry)\n{\n\t/* load up subtype link if we didn't already */\n\tif (typentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t\tload_rangetype_info(typentry);\n\n\tif (typentry->rngelemtype != NULL)\n\t{\n\t\tTypeCacheEntry *elementry;\n\n\t\t/* might need to calculate subtype's hash function properties */\n\t\telementry = lookup_type_cache(typentry->rngelemtype->type_id,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC);\n\t\tif (OidIsValid(elementry->hash_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_HASHING;\n\t\tif (OidIsValid(elementry->hash_extended_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EXTENDED_HASHING;\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_ELEM_PROPERTIES;\n}"
  },
  {
    "function_name": "range_element_has_extended_hashing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1476-1482",
    "snippet": "static bool\nrange_element_has_extended_hashing(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_range_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_EXTENDED_HASHING) != 0;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000",
      "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
    ],
    "globals_used": [
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_range_element_properties",
          "args": [
            "typentry"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "cache_range_element_properties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1484-1506",
          "snippet": "static void\ncache_range_element_properties(TypeCacheEntry *typentry)\n{\n\t/* load up subtype link if we didn't already */\n\tif (typentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t\tload_rangetype_info(typentry);\n\n\tif (typentry->rngelemtype != NULL)\n\t{\n\t\tTypeCacheEntry *elementry;\n\n\t\t/* might need to calculate subtype's hash function properties */\n\t\telementry = lookup_type_cache(typentry->rngelemtype->type_id,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC);\n\t\tif (OidIsValid(elementry->hash_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_HASHING;\n\t\tif (OidIsValid(elementry->hash_extended_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EXTENDED_HASHING;\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_ELEM_PROPERTIES;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000",
            "#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800",
            "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000\n#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic void\ncache_range_element_properties(TypeCacheEntry *typentry)\n{\n\t/* load up subtype link if we didn't already */\n\tif (typentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t\tload_rangetype_info(typentry);\n\n\tif (typentry->rngelemtype != NULL)\n\t{\n\t\tTypeCacheEntry *elementry;\n\n\t\t/* might need to calculate subtype's hash function properties */\n\t\telementry = lookup_type_cache(typentry->rngelemtype->type_id,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC);\n\t\tif (OidIsValid(elementry->hash_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_HASHING;\n\t\tif (OidIsValid(elementry->hash_extended_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EXTENDED_HASHING;\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_ELEM_PROPERTIES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic bool\nrange_element_has_extended_hashing(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_range_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_EXTENDED_HASHING) != 0;\n}"
  },
  {
    "function_name": "range_element_has_hashing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1468-1474",
    "snippet": "static bool\nrange_element_has_hashing(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_range_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_HASHING) != 0;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800",
      "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
    ],
    "globals_used": [
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_range_element_properties",
          "args": [
            "typentry"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "cache_range_element_properties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1484-1506",
          "snippet": "static void\ncache_range_element_properties(TypeCacheEntry *typentry)\n{\n\t/* load up subtype link if we didn't already */\n\tif (typentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t\tload_rangetype_info(typentry);\n\n\tif (typentry->rngelemtype != NULL)\n\t{\n\t\tTypeCacheEntry *elementry;\n\n\t\t/* might need to calculate subtype's hash function properties */\n\t\telementry = lookup_type_cache(typentry->rngelemtype->type_id,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC);\n\t\tif (OidIsValid(elementry->hash_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_HASHING;\n\t\tif (OidIsValid(elementry->hash_extended_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EXTENDED_HASHING;\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_ELEM_PROPERTIES;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000",
            "#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800",
            "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000\n#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic void\ncache_range_element_properties(TypeCacheEntry *typentry)\n{\n\t/* load up subtype link if we didn't already */\n\tif (typentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t\tload_rangetype_info(typentry);\n\n\tif (typentry->rngelemtype != NULL)\n\t{\n\t\tTypeCacheEntry *elementry;\n\n\t\t/* might need to calculate subtype's hash function properties */\n\t\telementry = lookup_type_cache(typentry->rngelemtype->type_id,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC);\n\t\tif (OidIsValid(elementry->hash_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_HASHING;\n\t\tif (OidIsValid(elementry->hash_extended_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EXTENDED_HASHING;\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_ELEM_PROPERTIES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic bool\nrange_element_has_hashing(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_range_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_HASHING) != 0;\n}"
  },
  {
    "function_name": "cache_record_field_properties",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1382-1458",
    "snippet": "static void\ncache_record_field_properties(TypeCacheEntry *typentry)\n{\n\t/*\n\t * For type RECORD, we can't really tell what will work, since we don't\n\t * have access here to the specific anonymous type.  Just assume that\n\t * everything will (we may get a failure at runtime ...)\n\t */\n\tif (typentry->type_id == RECORDOID)\n\t\ttypentry->flags |= (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\t\t\tTCFLAGS_HAVE_FIELD_COMPARE);\n\telse if (typentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tTupleDesc\ttupdesc;\n\t\tint\t\t\tnewflags;\n\t\tint\t\t\ti;\n\n\t\t/* Fetch composite type's tupdesc if we don't have it already */\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tload_typcache_tupdesc(typentry);\n\t\ttupdesc = typentry->tupDesc;\n\n\t\t/* Must bump the refcount while we do additional catalog lookups */\n\t\tIncrTupleDescRefCount(tupdesc);\n\n\t\t/* Have each property if all non-dropped fields have the property */\n\t\tnewflags = (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\tTCFLAGS_HAVE_FIELD_COMPARE);\n\t\tfor (i = 0; i < tupdesc->natts; i++)\n\t\t{\n\t\t\tTypeCacheEntry *fieldentry;\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, i);\n\n\t\t\tif (attr->attisdropped)\n\t\t\t\tcontinue;\n\n\t\t\tfieldentry = lookup_type_cache(attr->atttypid,\n\t\t\t\t\t\t\t\t\t\t   TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t\t   TYPECACHE_CMP_PROC);\n\t\t\tif (!OidIsValid(fieldentry->eq_opr))\n\t\t\t\tnewflags &= ~TCFLAGS_HAVE_FIELD_EQUALITY;\n\t\t\tif (!OidIsValid(fieldentry->cmp_proc))\n\t\t\t\tnewflags &= ~TCFLAGS_HAVE_FIELD_COMPARE;\n\n\t\t\t/* We can drop out of the loop once we disprove all bits */\n\t\t\tif (newflags == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\ttypentry->flags |= newflags;\n\n\t\tDecrTupleDescRefCount(tupdesc);\n\t}\n\telse if (typentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\t/* If it's domain over composite, copy base type's properties */\n\t\tTypeCacheEntry *baseentry;\n\n\t\t/* load up basetype info if we didn't already */\n\t\tif (typentry->domainBaseType == InvalidOid)\n\t\t{\n\t\t\ttypentry->domainBaseTypmod = -1;\n\t\t\ttypentry->domainBaseType =\n\t\t\t\tgetBaseTypeAndTypmod(typentry->type_id,\n\t\t\t\t\t\t\t\t\t &typentry->domainBaseTypmod);\n\t\t}\n\t\tbaseentry = lookup_type_cache(typentry->domainBaseType,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC);\n\t\tif (baseentry->typtype == TYPTYPE_COMPOSITE)\n\t\t{\n\t\t\ttypentry->flags |= TCFLAGS_DOMAIN_BASE_IS_COMPOSITE;\n\t\t\ttypentry->flags |= baseentry->flags & (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\t\t\t\t\t\t\t\t   TCFLAGS_HAVE_FIELD_COMPARE);\n\t\t}\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_FIELD_PROPERTIES;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TCFLAGS_DOMAIN_BASE_IS_COMPOSITE\t0x020000",
      "#define TCFLAGS_HAVE_FIELD_COMPARE\t\t\t0x008000",
      "#define TCFLAGS_HAVE_FIELD_EQUALITY\t\t\t0x004000",
      "#define TCFLAGS_CHECKED_FIELD_PROPERTIES\t0x002000"
    ],
    "globals_used": [
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);",
      "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "typentry->domainBaseType",
            "TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getBaseTypeAndTypmod",
          "args": [
            "typentry->type_id",
            "&typentry->domainBaseTypmod"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "getBaseTypeAndTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2315-2345",
          "snippet": "Oid\ngetBaseTypeAndTypmod(Oid typid, int32 *typmod)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so done */\n\t\t\tReleaseSysCache(tup);\n\t\t\tbreak;\n\t\t}\n\n\t\tAssert(*typmod == -1);\n\t\ttypid = typTup->typbasetype;\n\t\t*typmod = typTup->typtypmod;\n\n\t\tReleaseSysCache(tup);\n\t}\n\n\treturn typid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\ngetBaseTypeAndTypmod(Oid typid, int32 *typmod)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so done */\n\t\t\tReleaseSysCache(tup);\n\t\t\tbreak;\n\t\t}\n\n\t\tAssert(*typmod == -1);\n\t\ttypid = typTup->typbasetype;\n\t\t*typmod = typTup->typtypmod;\n\n\t\tReleaseSysCache(tup);\n\t}\n\n\treturn typid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecrTupleDescRefCount",
          "args": [
            "tupdesc"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "fieldentry->cmp_proc"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "fieldentry->eq_opr"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IncrTupleDescRefCount",
          "args": [
            "tupdesc"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_typcache_tupdesc",
          "args": [
            "typentry"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "load_typcache_tupdesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "783-812",
          "snippet": "static void\nload_typcache_tupdesc(TypeCacheEntry *typentry)\n{\n\tRelation\trel;\n\n\tif (!OidIsValid(typentry->typrelid))\t/* should not happen */\n\t\telog(ERROR, \"invalid typrelid for composite type %u\",\n\t\t\t typentry->type_id);\n\trel = relation_open(typentry->typrelid, AccessShareLock);\n\tAssert(rel->rd_rel->reltype == typentry->type_id);\n\n\t/*\n\t * Link to the tupdesc and increment its refcount (we assert it's a\n\t * refcounted descriptor).  We don't use IncrTupleDescRefCount() for this,\n\t * because the reference mustn't be entered in the current resource owner;\n\t * it can outlive the current query.\n\t */\n\ttypentry->tupDesc = RelationGetDescr(rel);\n\n\tAssert(typentry->tupDesc->tdrefcount > 0);\n\ttypentry->tupDesc->tdrefcount++;\n\n\t/*\n\t * In future, we could take some pains to not change tupDesc_identifier if\n\t * the tupdesc didn't really change; but for now it's not worth it.\n\t */\n\ttypentry->tupDesc_identifier = ++tupledesc_id_counter;\n\n\trelation_close(rel, AccessShareLock);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nstatic void\nload_typcache_tupdesc(TypeCacheEntry *typentry)\n{\n\tRelation\trel;\n\n\tif (!OidIsValid(typentry->typrelid))\t/* should not happen */\n\t\telog(ERROR, \"invalid typrelid for composite type %u\",\n\t\t\t typentry->type_id);\n\trel = relation_open(typentry->typrelid, AccessShareLock);\n\tAssert(rel->rd_rel->reltype == typentry->type_id);\n\n\t/*\n\t * Link to the tupdesc and increment its refcount (we assert it's a\n\t * refcounted descriptor).  We don't use IncrTupleDescRefCount() for this,\n\t * because the reference mustn't be entered in the current resource owner;\n\t * it can outlive the current query.\n\t */\n\ttypentry->tupDesc = RelationGetDescr(rel);\n\n\tAssert(typentry->tupDesc->tdrefcount > 0);\n\ttypentry->tupDesc->tdrefcount++;\n\n\t/*\n\t * In future, we could take some pains to not change tupDesc_identifier if\n\t * the tupdesc didn't really change; but for now it's not worth it.\n\t */\n\ttypentry->tupDesc_identifier = ++tupledesc_id_counter;\n\n\trelation_close(rel, AccessShareLock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_DOMAIN_BASE_IS_COMPOSITE\t0x020000\n#define TCFLAGS_HAVE_FIELD_COMPARE\t\t\t0x008000\n#define TCFLAGS_HAVE_FIELD_EQUALITY\t\t\t0x004000\n#define TCFLAGS_CHECKED_FIELD_PROPERTIES\t0x002000\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nstatic void\ncache_record_field_properties(TypeCacheEntry *typentry)\n{\n\t/*\n\t * For type RECORD, we can't really tell what will work, since we don't\n\t * have access here to the specific anonymous type.  Just assume that\n\t * everything will (we may get a failure at runtime ...)\n\t */\n\tif (typentry->type_id == RECORDOID)\n\t\ttypentry->flags |= (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\t\t\tTCFLAGS_HAVE_FIELD_COMPARE);\n\telse if (typentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tTupleDesc\ttupdesc;\n\t\tint\t\t\tnewflags;\n\t\tint\t\t\ti;\n\n\t\t/* Fetch composite type's tupdesc if we don't have it already */\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tload_typcache_tupdesc(typentry);\n\t\ttupdesc = typentry->tupDesc;\n\n\t\t/* Must bump the refcount while we do additional catalog lookups */\n\t\tIncrTupleDescRefCount(tupdesc);\n\n\t\t/* Have each property if all non-dropped fields have the property */\n\t\tnewflags = (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\tTCFLAGS_HAVE_FIELD_COMPARE);\n\t\tfor (i = 0; i < tupdesc->natts; i++)\n\t\t{\n\t\t\tTypeCacheEntry *fieldentry;\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, i);\n\n\t\t\tif (attr->attisdropped)\n\t\t\t\tcontinue;\n\n\t\t\tfieldentry = lookup_type_cache(attr->atttypid,\n\t\t\t\t\t\t\t\t\t\t   TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t\t   TYPECACHE_CMP_PROC);\n\t\t\tif (!OidIsValid(fieldentry->eq_opr))\n\t\t\t\tnewflags &= ~TCFLAGS_HAVE_FIELD_EQUALITY;\n\t\t\tif (!OidIsValid(fieldentry->cmp_proc))\n\t\t\t\tnewflags &= ~TCFLAGS_HAVE_FIELD_COMPARE;\n\n\t\t\t/* We can drop out of the loop once we disprove all bits */\n\t\t\tif (newflags == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\ttypentry->flags |= newflags;\n\n\t\tDecrTupleDescRefCount(tupdesc);\n\t}\n\telse if (typentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\t/* If it's domain over composite, copy base type's properties */\n\t\tTypeCacheEntry *baseentry;\n\n\t\t/* load up basetype info if we didn't already */\n\t\tif (typentry->domainBaseType == InvalidOid)\n\t\t{\n\t\t\ttypentry->domainBaseTypmod = -1;\n\t\t\ttypentry->domainBaseType =\n\t\t\t\tgetBaseTypeAndTypmod(typentry->type_id,\n\t\t\t\t\t\t\t\t\t &typentry->domainBaseTypmod);\n\t\t}\n\t\tbaseentry = lookup_type_cache(typentry->domainBaseType,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC);\n\t\tif (baseentry->typtype == TYPTYPE_COMPOSITE)\n\t\t{\n\t\t\ttypentry->flags |= TCFLAGS_DOMAIN_BASE_IS_COMPOSITE;\n\t\t\ttypentry->flags |= baseentry->flags & (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\t\t\t\t\t\t\t\t   TCFLAGS_HAVE_FIELD_COMPARE);\n\t\t}\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_FIELD_PROPERTIES;\n}"
  },
  {
    "function_name": "record_fields_have_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1374-1380",
    "snippet": "static bool\nrecord_fields_have_compare(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_FIELD_PROPERTIES))\n\t\tcache_record_field_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_FIELD_COMPARE) != 0;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TCFLAGS_HAVE_FIELD_COMPARE\t\t\t0x008000",
      "#define TCFLAGS_CHECKED_FIELD_PROPERTIES\t0x002000"
    ],
    "globals_used": [
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_record_field_properties",
          "args": [
            "typentry"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "cache_record_field_properties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1382-1458",
          "snippet": "static void\ncache_record_field_properties(TypeCacheEntry *typentry)\n{\n\t/*\n\t * For type RECORD, we can't really tell what will work, since we don't\n\t * have access here to the specific anonymous type.  Just assume that\n\t * everything will (we may get a failure at runtime ...)\n\t */\n\tif (typentry->type_id == RECORDOID)\n\t\ttypentry->flags |= (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\t\t\tTCFLAGS_HAVE_FIELD_COMPARE);\n\telse if (typentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tTupleDesc\ttupdesc;\n\t\tint\t\t\tnewflags;\n\t\tint\t\t\ti;\n\n\t\t/* Fetch composite type's tupdesc if we don't have it already */\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tload_typcache_tupdesc(typentry);\n\t\ttupdesc = typentry->tupDesc;\n\n\t\t/* Must bump the refcount while we do additional catalog lookups */\n\t\tIncrTupleDescRefCount(tupdesc);\n\n\t\t/* Have each property if all non-dropped fields have the property */\n\t\tnewflags = (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\tTCFLAGS_HAVE_FIELD_COMPARE);\n\t\tfor (i = 0; i < tupdesc->natts; i++)\n\t\t{\n\t\t\tTypeCacheEntry *fieldentry;\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, i);\n\n\t\t\tif (attr->attisdropped)\n\t\t\t\tcontinue;\n\n\t\t\tfieldentry = lookup_type_cache(attr->atttypid,\n\t\t\t\t\t\t\t\t\t\t   TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t\t   TYPECACHE_CMP_PROC);\n\t\t\tif (!OidIsValid(fieldentry->eq_opr))\n\t\t\t\tnewflags &= ~TCFLAGS_HAVE_FIELD_EQUALITY;\n\t\t\tif (!OidIsValid(fieldentry->cmp_proc))\n\t\t\t\tnewflags &= ~TCFLAGS_HAVE_FIELD_COMPARE;\n\n\t\t\t/* We can drop out of the loop once we disprove all bits */\n\t\t\tif (newflags == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\ttypentry->flags |= newflags;\n\n\t\tDecrTupleDescRefCount(tupdesc);\n\t}\n\telse if (typentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\t/* If it's domain over composite, copy base type's properties */\n\t\tTypeCacheEntry *baseentry;\n\n\t\t/* load up basetype info if we didn't already */\n\t\tif (typentry->domainBaseType == InvalidOid)\n\t\t{\n\t\t\ttypentry->domainBaseTypmod = -1;\n\t\t\ttypentry->domainBaseType =\n\t\t\t\tgetBaseTypeAndTypmod(typentry->type_id,\n\t\t\t\t\t\t\t\t\t &typentry->domainBaseTypmod);\n\t\t}\n\t\tbaseentry = lookup_type_cache(typentry->domainBaseType,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC);\n\t\tif (baseentry->typtype == TYPTYPE_COMPOSITE)\n\t\t{\n\t\t\ttypentry->flags |= TCFLAGS_DOMAIN_BASE_IS_COMPOSITE;\n\t\t\ttypentry->flags |= baseentry->flags & (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\t\t\t\t\t\t\t\t   TCFLAGS_HAVE_FIELD_COMPARE);\n\t\t}\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_FIELD_PROPERTIES;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_DOMAIN_BASE_IS_COMPOSITE\t0x020000",
            "#define TCFLAGS_HAVE_FIELD_COMPARE\t\t\t0x008000",
            "#define TCFLAGS_HAVE_FIELD_EQUALITY\t\t\t0x004000",
            "#define TCFLAGS_CHECKED_FIELD_PROPERTIES\t0x002000"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_DOMAIN_BASE_IS_COMPOSITE\t0x020000\n#define TCFLAGS_HAVE_FIELD_COMPARE\t\t\t0x008000\n#define TCFLAGS_HAVE_FIELD_EQUALITY\t\t\t0x004000\n#define TCFLAGS_CHECKED_FIELD_PROPERTIES\t0x002000\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nstatic void\ncache_record_field_properties(TypeCacheEntry *typentry)\n{\n\t/*\n\t * For type RECORD, we can't really tell what will work, since we don't\n\t * have access here to the specific anonymous type.  Just assume that\n\t * everything will (we may get a failure at runtime ...)\n\t */\n\tif (typentry->type_id == RECORDOID)\n\t\ttypentry->flags |= (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\t\t\tTCFLAGS_HAVE_FIELD_COMPARE);\n\telse if (typentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tTupleDesc\ttupdesc;\n\t\tint\t\t\tnewflags;\n\t\tint\t\t\ti;\n\n\t\t/* Fetch composite type's tupdesc if we don't have it already */\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tload_typcache_tupdesc(typentry);\n\t\ttupdesc = typentry->tupDesc;\n\n\t\t/* Must bump the refcount while we do additional catalog lookups */\n\t\tIncrTupleDescRefCount(tupdesc);\n\n\t\t/* Have each property if all non-dropped fields have the property */\n\t\tnewflags = (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\tTCFLAGS_HAVE_FIELD_COMPARE);\n\t\tfor (i = 0; i < tupdesc->natts; i++)\n\t\t{\n\t\t\tTypeCacheEntry *fieldentry;\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, i);\n\n\t\t\tif (attr->attisdropped)\n\t\t\t\tcontinue;\n\n\t\t\tfieldentry = lookup_type_cache(attr->atttypid,\n\t\t\t\t\t\t\t\t\t\t   TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t\t   TYPECACHE_CMP_PROC);\n\t\t\tif (!OidIsValid(fieldentry->eq_opr))\n\t\t\t\tnewflags &= ~TCFLAGS_HAVE_FIELD_EQUALITY;\n\t\t\tif (!OidIsValid(fieldentry->cmp_proc))\n\t\t\t\tnewflags &= ~TCFLAGS_HAVE_FIELD_COMPARE;\n\n\t\t\t/* We can drop out of the loop once we disprove all bits */\n\t\t\tif (newflags == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\ttypentry->flags |= newflags;\n\n\t\tDecrTupleDescRefCount(tupdesc);\n\t}\n\telse if (typentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\t/* If it's domain over composite, copy base type's properties */\n\t\tTypeCacheEntry *baseentry;\n\n\t\t/* load up basetype info if we didn't already */\n\t\tif (typentry->domainBaseType == InvalidOid)\n\t\t{\n\t\t\ttypentry->domainBaseTypmod = -1;\n\t\t\ttypentry->domainBaseType =\n\t\t\t\tgetBaseTypeAndTypmod(typentry->type_id,\n\t\t\t\t\t\t\t\t\t &typentry->domainBaseTypmod);\n\t\t}\n\t\tbaseentry = lookup_type_cache(typentry->domainBaseType,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC);\n\t\tif (baseentry->typtype == TYPTYPE_COMPOSITE)\n\t\t{\n\t\t\ttypentry->flags |= TCFLAGS_DOMAIN_BASE_IS_COMPOSITE;\n\t\t\ttypentry->flags |= baseentry->flags & (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\t\t\t\t\t\t\t\t   TCFLAGS_HAVE_FIELD_COMPARE);\n\t\t}\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_FIELD_PROPERTIES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_FIELD_COMPARE\t\t\t0x008000\n#define TCFLAGS_CHECKED_FIELD_PROPERTIES\t0x002000\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic bool\nrecord_fields_have_compare(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_FIELD_PROPERTIES))\n\t\tcache_record_field_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_FIELD_COMPARE) != 0;\n}"
  },
  {
    "function_name": "record_fields_have_equality",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1366-1372",
    "snippet": "static bool\nrecord_fields_have_equality(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_FIELD_PROPERTIES))\n\t\tcache_record_field_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_FIELD_EQUALITY) != 0;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TCFLAGS_HAVE_FIELD_EQUALITY\t\t\t0x004000",
      "#define TCFLAGS_CHECKED_FIELD_PROPERTIES\t0x002000"
    ],
    "globals_used": [
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_record_field_properties",
          "args": [
            "typentry"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "cache_record_field_properties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1382-1458",
          "snippet": "static void\ncache_record_field_properties(TypeCacheEntry *typentry)\n{\n\t/*\n\t * For type RECORD, we can't really tell what will work, since we don't\n\t * have access here to the specific anonymous type.  Just assume that\n\t * everything will (we may get a failure at runtime ...)\n\t */\n\tif (typentry->type_id == RECORDOID)\n\t\ttypentry->flags |= (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\t\t\tTCFLAGS_HAVE_FIELD_COMPARE);\n\telse if (typentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tTupleDesc\ttupdesc;\n\t\tint\t\t\tnewflags;\n\t\tint\t\t\ti;\n\n\t\t/* Fetch composite type's tupdesc if we don't have it already */\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tload_typcache_tupdesc(typentry);\n\t\ttupdesc = typentry->tupDesc;\n\n\t\t/* Must bump the refcount while we do additional catalog lookups */\n\t\tIncrTupleDescRefCount(tupdesc);\n\n\t\t/* Have each property if all non-dropped fields have the property */\n\t\tnewflags = (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\tTCFLAGS_HAVE_FIELD_COMPARE);\n\t\tfor (i = 0; i < tupdesc->natts; i++)\n\t\t{\n\t\t\tTypeCacheEntry *fieldentry;\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, i);\n\n\t\t\tif (attr->attisdropped)\n\t\t\t\tcontinue;\n\n\t\t\tfieldentry = lookup_type_cache(attr->atttypid,\n\t\t\t\t\t\t\t\t\t\t   TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t\t   TYPECACHE_CMP_PROC);\n\t\t\tif (!OidIsValid(fieldentry->eq_opr))\n\t\t\t\tnewflags &= ~TCFLAGS_HAVE_FIELD_EQUALITY;\n\t\t\tif (!OidIsValid(fieldentry->cmp_proc))\n\t\t\t\tnewflags &= ~TCFLAGS_HAVE_FIELD_COMPARE;\n\n\t\t\t/* We can drop out of the loop once we disprove all bits */\n\t\t\tif (newflags == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\ttypentry->flags |= newflags;\n\n\t\tDecrTupleDescRefCount(tupdesc);\n\t}\n\telse if (typentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\t/* If it's domain over composite, copy base type's properties */\n\t\tTypeCacheEntry *baseentry;\n\n\t\t/* load up basetype info if we didn't already */\n\t\tif (typentry->domainBaseType == InvalidOid)\n\t\t{\n\t\t\ttypentry->domainBaseTypmod = -1;\n\t\t\ttypentry->domainBaseType =\n\t\t\t\tgetBaseTypeAndTypmod(typentry->type_id,\n\t\t\t\t\t\t\t\t\t &typentry->domainBaseTypmod);\n\t\t}\n\t\tbaseentry = lookup_type_cache(typentry->domainBaseType,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC);\n\t\tif (baseentry->typtype == TYPTYPE_COMPOSITE)\n\t\t{\n\t\t\ttypentry->flags |= TCFLAGS_DOMAIN_BASE_IS_COMPOSITE;\n\t\t\ttypentry->flags |= baseentry->flags & (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\t\t\t\t\t\t\t\t   TCFLAGS_HAVE_FIELD_COMPARE);\n\t\t}\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_FIELD_PROPERTIES;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_DOMAIN_BASE_IS_COMPOSITE\t0x020000",
            "#define TCFLAGS_HAVE_FIELD_COMPARE\t\t\t0x008000",
            "#define TCFLAGS_HAVE_FIELD_EQUALITY\t\t\t0x004000",
            "#define TCFLAGS_CHECKED_FIELD_PROPERTIES\t0x002000"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_DOMAIN_BASE_IS_COMPOSITE\t0x020000\n#define TCFLAGS_HAVE_FIELD_COMPARE\t\t\t0x008000\n#define TCFLAGS_HAVE_FIELD_EQUALITY\t\t\t0x004000\n#define TCFLAGS_CHECKED_FIELD_PROPERTIES\t0x002000\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nstatic void\ncache_record_field_properties(TypeCacheEntry *typentry)\n{\n\t/*\n\t * For type RECORD, we can't really tell what will work, since we don't\n\t * have access here to the specific anonymous type.  Just assume that\n\t * everything will (we may get a failure at runtime ...)\n\t */\n\tif (typentry->type_id == RECORDOID)\n\t\ttypentry->flags |= (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\t\t\tTCFLAGS_HAVE_FIELD_COMPARE);\n\telse if (typentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tTupleDesc\ttupdesc;\n\t\tint\t\t\tnewflags;\n\t\tint\t\t\ti;\n\n\t\t/* Fetch composite type's tupdesc if we don't have it already */\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tload_typcache_tupdesc(typentry);\n\t\ttupdesc = typentry->tupDesc;\n\n\t\t/* Must bump the refcount while we do additional catalog lookups */\n\t\tIncrTupleDescRefCount(tupdesc);\n\n\t\t/* Have each property if all non-dropped fields have the property */\n\t\tnewflags = (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\tTCFLAGS_HAVE_FIELD_COMPARE);\n\t\tfor (i = 0; i < tupdesc->natts; i++)\n\t\t{\n\t\t\tTypeCacheEntry *fieldentry;\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, i);\n\n\t\t\tif (attr->attisdropped)\n\t\t\t\tcontinue;\n\n\t\t\tfieldentry = lookup_type_cache(attr->atttypid,\n\t\t\t\t\t\t\t\t\t\t   TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t\t   TYPECACHE_CMP_PROC);\n\t\t\tif (!OidIsValid(fieldentry->eq_opr))\n\t\t\t\tnewflags &= ~TCFLAGS_HAVE_FIELD_EQUALITY;\n\t\t\tif (!OidIsValid(fieldentry->cmp_proc))\n\t\t\t\tnewflags &= ~TCFLAGS_HAVE_FIELD_COMPARE;\n\n\t\t\t/* We can drop out of the loop once we disprove all bits */\n\t\t\tif (newflags == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\ttypentry->flags |= newflags;\n\n\t\tDecrTupleDescRefCount(tupdesc);\n\t}\n\telse if (typentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\t/* If it's domain over composite, copy base type's properties */\n\t\tTypeCacheEntry *baseentry;\n\n\t\t/* load up basetype info if we didn't already */\n\t\tif (typentry->domainBaseType == InvalidOid)\n\t\t{\n\t\t\ttypentry->domainBaseTypmod = -1;\n\t\t\ttypentry->domainBaseType =\n\t\t\t\tgetBaseTypeAndTypmod(typentry->type_id,\n\t\t\t\t\t\t\t\t\t &typentry->domainBaseTypmod);\n\t\t}\n\t\tbaseentry = lookup_type_cache(typentry->domainBaseType,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC);\n\t\tif (baseentry->typtype == TYPTYPE_COMPOSITE)\n\t\t{\n\t\t\ttypentry->flags |= TCFLAGS_DOMAIN_BASE_IS_COMPOSITE;\n\t\t\ttypentry->flags |= baseentry->flags & (TCFLAGS_HAVE_FIELD_EQUALITY |\n\t\t\t\t\t\t\t\t\t\t\t\t   TCFLAGS_HAVE_FIELD_COMPARE);\n\t\t}\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_FIELD_PROPERTIES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_FIELD_EQUALITY\t\t\t0x004000\n#define TCFLAGS_CHECKED_FIELD_PROPERTIES\t0x002000\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic bool\nrecord_fields_have_equality(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_FIELD_PROPERTIES))\n\t\tcache_record_field_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_FIELD_EQUALITY) != 0;\n}"
  },
  {
    "function_name": "cache_array_element_properties",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1336-1360",
    "snippet": "static void\ncache_array_element_properties(TypeCacheEntry *typentry)\n{\n\tOid\t\t\telem_type = get_base_element_type(typentry->type_id);\n\n\tif (OidIsValid(elem_type))\n\t{\n\t\tTypeCacheEntry *elementry;\n\n\t\telementry = lookup_type_cache(elem_type,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC);\n\t\tif (OidIsValid(elementry->eq_opr))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EQUALITY;\n\t\tif (OidIsValid(elementry->cmp_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_COMPARE;\n\t\tif (OidIsValid(elementry->hash_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_HASHING;\n\t\tif (OidIsValid(elementry->hash_extended_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EXTENDED_HASHING;\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_ELEM_PROPERTIES;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000",
      "#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800",
      "#define TCFLAGS_HAVE_ELEM_COMPARE\t\t\t0x000400",
      "#define TCFLAGS_HAVE_ELEM_EQUALITY\t\t\t0x000200",
      "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
    ],
    "globals_used": [
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "elementry->hash_extended_proc"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "elementry->hash_proc"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "elementry->cmp_proc"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "elementry->eq_opr"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "elem_type",
            "TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "elem_type"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_base_element_type",
          "args": [
            "typentry->type_id"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "get_base_element_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2598-2633",
          "snippet": "Oid\nget_base_element_type(Oid typid)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so stop descending */\n\t\t\tOid\t\t\tresult;\n\n\t\t\t/* This test must match get_element_type */\n\t\t\tif (typTup->typlen == -1)\n\t\t\t\tresult = typTup->typelem;\n\t\t\telse\n\t\t\t\tresult = InvalidOid;\n\t\t\tReleaseSysCache(tup);\n\t\t\treturn result;\n\t\t}\n\n\t\ttypid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\t/* Like get_element_type, silently return InvalidOid for bogus input */\n\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_base_element_type(Oid typid)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so stop descending */\n\t\t\tOid\t\t\tresult;\n\n\t\t\t/* This test must match get_element_type */\n\t\t\tif (typTup->typlen == -1)\n\t\t\t\tresult = typTup->typelem;\n\t\t\telse\n\t\t\t\tresult = InvalidOid;\n\t\t\tReleaseSysCache(tup);\n\t\t\treturn result;\n\t\t}\n\n\t\ttypid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\t/* Like get_element_type, silently return InvalidOid for bogus input */\n\treturn InvalidOid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000\n#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800\n#define TCFLAGS_HAVE_ELEM_COMPARE\t\t\t0x000400\n#define TCFLAGS_HAVE_ELEM_EQUALITY\t\t\t0x000200\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic void\ncache_array_element_properties(TypeCacheEntry *typentry)\n{\n\tOid\t\t\telem_type = get_base_element_type(typentry->type_id);\n\n\tif (OidIsValid(elem_type))\n\t{\n\t\tTypeCacheEntry *elementry;\n\n\t\telementry = lookup_type_cache(elem_type,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC);\n\t\tif (OidIsValid(elementry->eq_opr))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EQUALITY;\n\t\tif (OidIsValid(elementry->cmp_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_COMPARE;\n\t\tif (OidIsValid(elementry->hash_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_HASHING;\n\t\tif (OidIsValid(elementry->hash_extended_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EXTENDED_HASHING;\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_ELEM_PROPERTIES;\n}"
  },
  {
    "function_name": "array_element_has_extended_hashing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1328-1334",
    "snippet": "static bool\narray_element_has_extended_hashing(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_array_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_EXTENDED_HASHING) != 0;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000",
      "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
    ],
    "globals_used": [
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_array_element_properties",
          "args": [
            "typentry"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "cache_array_element_properties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1336-1360",
          "snippet": "static void\ncache_array_element_properties(TypeCacheEntry *typentry)\n{\n\tOid\t\t\telem_type = get_base_element_type(typentry->type_id);\n\n\tif (OidIsValid(elem_type))\n\t{\n\t\tTypeCacheEntry *elementry;\n\n\t\telementry = lookup_type_cache(elem_type,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC);\n\t\tif (OidIsValid(elementry->eq_opr))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EQUALITY;\n\t\tif (OidIsValid(elementry->cmp_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_COMPARE;\n\t\tif (OidIsValid(elementry->hash_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_HASHING;\n\t\tif (OidIsValid(elementry->hash_extended_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EXTENDED_HASHING;\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_ELEM_PROPERTIES;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000",
            "#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800",
            "#define TCFLAGS_HAVE_ELEM_COMPARE\t\t\t0x000400",
            "#define TCFLAGS_HAVE_ELEM_EQUALITY\t\t\t0x000200",
            "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000\n#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800\n#define TCFLAGS_HAVE_ELEM_COMPARE\t\t\t0x000400\n#define TCFLAGS_HAVE_ELEM_EQUALITY\t\t\t0x000200\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic void\ncache_array_element_properties(TypeCacheEntry *typentry)\n{\n\tOid\t\t\telem_type = get_base_element_type(typentry->type_id);\n\n\tif (OidIsValid(elem_type))\n\t{\n\t\tTypeCacheEntry *elementry;\n\n\t\telementry = lookup_type_cache(elem_type,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC);\n\t\tif (OidIsValid(elementry->eq_opr))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EQUALITY;\n\t\tif (OidIsValid(elementry->cmp_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_COMPARE;\n\t\tif (OidIsValid(elementry->hash_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_HASHING;\n\t\tif (OidIsValid(elementry->hash_extended_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EXTENDED_HASHING;\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_ELEM_PROPERTIES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic bool\narray_element_has_extended_hashing(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_array_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_EXTENDED_HASHING) != 0;\n}"
  },
  {
    "function_name": "array_element_has_hashing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1320-1326",
    "snippet": "static bool\narray_element_has_hashing(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_array_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_HASHING) != 0;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800",
      "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
    ],
    "globals_used": [
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_array_element_properties",
          "args": [
            "typentry"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "cache_array_element_properties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1336-1360",
          "snippet": "static void\ncache_array_element_properties(TypeCacheEntry *typentry)\n{\n\tOid\t\t\telem_type = get_base_element_type(typentry->type_id);\n\n\tif (OidIsValid(elem_type))\n\t{\n\t\tTypeCacheEntry *elementry;\n\n\t\telementry = lookup_type_cache(elem_type,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC);\n\t\tif (OidIsValid(elementry->eq_opr))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EQUALITY;\n\t\tif (OidIsValid(elementry->cmp_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_COMPARE;\n\t\tif (OidIsValid(elementry->hash_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_HASHING;\n\t\tif (OidIsValid(elementry->hash_extended_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EXTENDED_HASHING;\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_ELEM_PROPERTIES;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000",
            "#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800",
            "#define TCFLAGS_HAVE_ELEM_COMPARE\t\t\t0x000400",
            "#define TCFLAGS_HAVE_ELEM_EQUALITY\t\t\t0x000200",
            "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000\n#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800\n#define TCFLAGS_HAVE_ELEM_COMPARE\t\t\t0x000400\n#define TCFLAGS_HAVE_ELEM_EQUALITY\t\t\t0x000200\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic void\ncache_array_element_properties(TypeCacheEntry *typentry)\n{\n\tOid\t\t\telem_type = get_base_element_type(typentry->type_id);\n\n\tif (OidIsValid(elem_type))\n\t{\n\t\tTypeCacheEntry *elementry;\n\n\t\telementry = lookup_type_cache(elem_type,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC);\n\t\tif (OidIsValid(elementry->eq_opr))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EQUALITY;\n\t\tif (OidIsValid(elementry->cmp_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_COMPARE;\n\t\tif (OidIsValid(elementry->hash_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_HASHING;\n\t\tif (OidIsValid(elementry->hash_extended_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EXTENDED_HASHING;\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_ELEM_PROPERTIES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic bool\narray_element_has_hashing(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_array_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_HASHING) != 0;\n}"
  },
  {
    "function_name": "array_element_has_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1312-1318",
    "snippet": "static bool\narray_element_has_compare(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_array_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_COMPARE) != 0;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TCFLAGS_HAVE_ELEM_COMPARE\t\t\t0x000400",
      "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
    ],
    "globals_used": [
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_array_element_properties",
          "args": [
            "typentry"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "cache_array_element_properties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1336-1360",
          "snippet": "static void\ncache_array_element_properties(TypeCacheEntry *typentry)\n{\n\tOid\t\t\telem_type = get_base_element_type(typentry->type_id);\n\n\tif (OidIsValid(elem_type))\n\t{\n\t\tTypeCacheEntry *elementry;\n\n\t\telementry = lookup_type_cache(elem_type,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC);\n\t\tif (OidIsValid(elementry->eq_opr))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EQUALITY;\n\t\tif (OidIsValid(elementry->cmp_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_COMPARE;\n\t\tif (OidIsValid(elementry->hash_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_HASHING;\n\t\tif (OidIsValid(elementry->hash_extended_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EXTENDED_HASHING;\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_ELEM_PROPERTIES;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000",
            "#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800",
            "#define TCFLAGS_HAVE_ELEM_COMPARE\t\t\t0x000400",
            "#define TCFLAGS_HAVE_ELEM_EQUALITY\t\t\t0x000200",
            "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000\n#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800\n#define TCFLAGS_HAVE_ELEM_COMPARE\t\t\t0x000400\n#define TCFLAGS_HAVE_ELEM_EQUALITY\t\t\t0x000200\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic void\ncache_array_element_properties(TypeCacheEntry *typentry)\n{\n\tOid\t\t\telem_type = get_base_element_type(typentry->type_id);\n\n\tif (OidIsValid(elem_type))\n\t{\n\t\tTypeCacheEntry *elementry;\n\n\t\telementry = lookup_type_cache(elem_type,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC);\n\t\tif (OidIsValid(elementry->eq_opr))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EQUALITY;\n\t\tif (OidIsValid(elementry->cmp_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_COMPARE;\n\t\tif (OidIsValid(elementry->hash_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_HASHING;\n\t\tif (OidIsValid(elementry->hash_extended_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EXTENDED_HASHING;\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_ELEM_PROPERTIES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_COMPARE\t\t\t0x000400\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic bool\narray_element_has_compare(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_array_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_COMPARE) != 0;\n}"
  },
  {
    "function_name": "array_element_has_equality",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1304-1310",
    "snippet": "static bool\narray_element_has_equality(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_array_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_EQUALITY) != 0;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TCFLAGS_HAVE_ELEM_EQUALITY\t\t\t0x000200",
      "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
    ],
    "globals_used": [
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_array_element_properties",
          "args": [
            "typentry"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "cache_array_element_properties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1336-1360",
          "snippet": "static void\ncache_array_element_properties(TypeCacheEntry *typentry)\n{\n\tOid\t\t\telem_type = get_base_element_type(typentry->type_id);\n\n\tif (OidIsValid(elem_type))\n\t{\n\t\tTypeCacheEntry *elementry;\n\n\t\telementry = lookup_type_cache(elem_type,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC);\n\t\tif (OidIsValid(elementry->eq_opr))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EQUALITY;\n\t\tif (OidIsValid(elementry->cmp_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_COMPARE;\n\t\tif (OidIsValid(elementry->hash_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_HASHING;\n\t\tif (OidIsValid(elementry->hash_extended_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EXTENDED_HASHING;\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_ELEM_PROPERTIES;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000",
            "#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800",
            "#define TCFLAGS_HAVE_ELEM_COMPARE\t\t\t0x000400",
            "#define TCFLAGS_HAVE_ELEM_EQUALITY\t\t\t0x000200",
            "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000\n#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800\n#define TCFLAGS_HAVE_ELEM_COMPARE\t\t\t0x000400\n#define TCFLAGS_HAVE_ELEM_EQUALITY\t\t\t0x000200\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic void\ncache_array_element_properties(TypeCacheEntry *typentry)\n{\n\tOid\t\t\telem_type = get_base_element_type(typentry->type_id);\n\n\tif (OidIsValid(elem_type))\n\t{\n\t\tTypeCacheEntry *elementry;\n\n\t\telementry = lookup_type_cache(elem_type,\n\t\t\t\t\t\t\t\t\t  TYPECACHE_EQ_OPR |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_PROC |\n\t\t\t\t\t\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC);\n\t\tif (OidIsValid(elementry->eq_opr))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EQUALITY;\n\t\tif (OidIsValid(elementry->cmp_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_COMPARE;\n\t\tif (OidIsValid(elementry->hash_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_HASHING;\n\t\tif (OidIsValid(elementry->hash_extended_proc))\n\t\t\ttypentry->flags |= TCFLAGS_HAVE_ELEM_EXTENDED_HASHING;\n\t}\n\ttypentry->flags |= TCFLAGS_CHECKED_ELEM_PROPERTIES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_EQUALITY\t\t\t0x000200\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic bool\narray_element_has_equality(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_array_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_EQUALITY) != 0;\n}"
  },
  {
    "function_name": "DomainHasConstraints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1277-1289",
    "snippet": "bool\nDomainHasConstraints(Oid type_id)\n{\n\tTypeCacheEntry *typentry;\n\n\t/*\n\t * Note: a side effect is to cause the typcache's domain data to become\n\t * valid.  This is fine since we'll likely need it soon if there is any.\n\t */\n\ttypentry = lookup_type_cache(type_id, TYPECACHE_DOMAIN_CONSTR_INFO);\n\n\treturn (typentry->domainData != NULL);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "type_id",
            "TYPECACHE_DOMAIN_CONSTR_INFO"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nbool\nDomainHasConstraints(Oid type_id)\n{\n\tTypeCacheEntry *typentry;\n\n\t/*\n\t * Note: a side effect is to cause the typcache's domain data to become\n\t * valid.  This is fine since we'll likely need it soon if there is any.\n\t */\n\ttypentry = lookup_type_cache(type_id, TYPECACHE_DOMAIN_CONSTR_INFO);\n\n\treturn (typentry->domainData != NULL);\n}"
  },
  {
    "function_name": "UpdateDomainConstraintRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1228-1270",
    "snippet": "void\nUpdateDomainConstraintRef(DomainConstraintRef *ref)\n{\n\tTypeCacheEntry *typentry = ref->tcache;\n\n\t/* Make sure typcache entry's data is up to date */\n\tif ((typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t\tload_domaintype_info(typentry);\n\n\t/* Transfer to ref object if there's new info, adjusting refcounts */\n\tif (ref->dcc != typentry->domainData)\n\t{\n\t\t/* Paranoia --- be sure link is nulled before trying to release */\n\t\tDomainConstraintCache *dcc = ref->dcc;\n\n\t\tif (dcc)\n\t\t{\n\t\t\t/*\n\t\t\t * Note: we just leak the previous list of executable domain\n\t\t\t * constraints.  Alternatively, we could keep those in a child\n\t\t\t * context of ref->refctx and free that context at this point.\n\t\t\t * However, in practice this code path will be taken so seldom\n\t\t\t * that the extra bookkeeping for a child context doesn't seem\n\t\t\t * worthwhile; we'll just allow a leak for the lifespan of refctx.\n\t\t\t */\n\t\t\tref->constraints = NIL;\n\t\t\tref->dcc = NULL;\n\t\t\tdecr_dcc_refcount(dcc);\n\t\t}\n\t\tdcc = typentry->domainData;\n\t\tif (dcc)\n\t\t{\n\t\t\tref->dcc = dcc;\n\t\t\tdcc->dccRefCount++;\n\t\t\tif (ref->need_exprstate)\n\t\t\t\tref->constraints = prep_domain_constraints(dcc->constraints,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   ref->refctx);\n\t\t\telse\n\t\t\t\tref->constraints = dcc->constraints;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000"
    ],
    "globals_used": [
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static void decr_dcc_refcount(DomainConstraintCache *dcc);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);",
      "static void load_enum_cache_data(TypeCacheEntry *tcache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prep_domain_constraints",
          "args": [
            "dcc->constraints",
            "ref->refctx"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "prep_domain_constraints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1152-1178",
          "snippet": "static List *\nprep_domain_constraints(List *constraints, MemoryContext execctx)\n{\n\tList\t   *result = NIL;\n\tMemoryContext oldcxt;\n\tListCell   *lc;\n\n\toldcxt = MemoryContextSwitchTo(execctx);\n\n\tforeach(lc, constraints)\n\t{\n\t\tDomainConstraintState *r = (DomainConstraintState *) lfirst(lc);\n\t\tDomainConstraintState *newr;\n\n\t\tnewr = makeNode(DomainConstraintState);\n\t\tnewr->constrainttype = r->constrainttype;\n\t\tnewr->name = r->name;\n\t\tnewr->check_expr = r->check_expr;\n\t\tnewr->check_exprstate = ExecInitExpr(r->check_expr, NULL);\n\n\t\tresult = lappend(result, newr);\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *prep_domain_constraints(List *constraints, MemoryContext execctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic List *prep_domain_constraints(List *constraints, MemoryContext execctx);\n\nstatic List *\nprep_domain_constraints(List *constraints, MemoryContext execctx)\n{\n\tList\t   *result = NIL;\n\tMemoryContext oldcxt;\n\tListCell   *lc;\n\n\toldcxt = MemoryContextSwitchTo(execctx);\n\n\tforeach(lc, constraints)\n\t{\n\t\tDomainConstraintState *r = (DomainConstraintState *) lfirst(lc);\n\t\tDomainConstraintState *newr;\n\n\t\tnewr = makeNode(DomainConstraintState);\n\t\tnewr->constrainttype = r->constrainttype;\n\t\tnewr->name = r->name;\n\t\tnewr->check_expr = r->check_expr;\n\t\tnewr->check_exprstate = ExecInitExpr(r->check_expr, NULL);\n\n\t\tresult = lappend(result, newr);\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decr_dcc_refcount",
          "args": [
            "dcc"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "decr_dcc_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1120-1126",
          "snippet": "static void\ndecr_dcc_refcount(DomainConstraintCache *dcc)\n{\n\tAssert(dcc->dccRefCount > 0);\n\tif (--(dcc->dccRefCount) <= 0)\n\t\tMemoryContextDelete(dcc->dccContext);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void decr_dcc_refcount(DomainConstraintCache *dcc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void decr_dcc_refcount(DomainConstraintCache *dcc);\n\nstatic void\ndecr_dcc_refcount(DomainConstraintCache *dcc)\n{\n\tAssert(dcc->dccRefCount > 0);\n\tif (--(dcc->dccRefCount) <= 0)\n\t\tMemoryContextDelete(dcc->dccContext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_domaintype_info",
          "args": [
            "typentry"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "load_domaintype_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "880-1102",
          "snippet": "static void\nload_domaintype_info(TypeCacheEntry *typentry)\n{\n\tOid\t\t\ttypeOid = typentry->type_id;\n\tDomainConstraintCache *dcc;\n\tbool\t\tnotNull = false;\n\tDomainConstraintState **ccons;\n\tint\t\t\tcconslen;\n\tRelation\tconRel;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * If we're here, any existing constraint info is stale, so release it.\n\t * For safety, be sure to null the link before trying to delete the data.\n\t */\n\tif (typentry->domainData)\n\t{\n\t\tdcc = typentry->domainData;\n\t\ttypentry->domainData = NULL;\n\t\tdecr_dcc_refcount(dcc);\n\t}\n\n\t/*\n\t * We try to optimize the common case of no domain constraints, so don't\n\t * create the dcc object and context until we find a constraint.  Likewise\n\t * for the temp sorting array.\n\t */\n\tdcc = NULL;\n\tccons = NULL;\n\tcconslen = 0;\n\n\t/*\n\t * Scan pg_constraint for relevant constraints.  We want to find\n\t * constraints for not just this domain, but any ancestor domains, so the\n\t * outer loop crawls up the domain stack.\n\t */\n\tconRel = heap_open(ConstraintRelationId, AccessShareLock);\n\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tHeapTuple\tconTup;\n\t\tForm_pg_type typTup;\n\t\tint\t\t\tnccons = 0;\n\t\tScanKeyData key[1];\n\t\tSysScanDesc scan;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typeOid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", typeOid);\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so done */\n\t\t\tReleaseSysCache(tup);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Test for NOT NULL Constraint */\n\t\tif (typTup->typnotnull)\n\t\t\tnotNull = true;\n\n\t\t/* Look for CHECK Constraints on this domain */\n\t\tScanKeyInit(&key[0],\n\t\t\t\t\tAnum_pg_constraint_contypid,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(typeOid));\n\n\t\tscan = systable_beginscan(conRel, ConstraintTypidIndexId, true,\n\t\t\t\t\t\t\t\t  NULL, 1, key);\n\n\t\twhile (HeapTupleIsValid(conTup = systable_getnext(scan)))\n\t\t{\n\t\t\tForm_pg_constraint c = (Form_pg_constraint) GETSTRUCT(conTup);\n\t\t\tDatum\t\tval;\n\t\t\tbool\t\tisNull;\n\t\t\tchar\t   *constring;\n\t\t\tExpr\t   *check_expr;\n\t\t\tDomainConstraintState *r;\n\n\t\t\t/* Ignore non-CHECK constraints (presently, shouldn't be any) */\n\t\t\tif (c->contype != CONSTRAINT_CHECK)\n\t\t\t\tcontinue;\n\n\t\t\t/* Not expecting conbin to be NULL, but we'll test for it anyway */\n\t\t\tval = fastgetattr(conTup, Anum_pg_constraint_conbin,\n\t\t\t\t\t\t\t  conRel->rd_att, &isNull);\n\t\t\tif (isNull)\n\t\t\t\telog(ERROR, \"domain \\\"%s\\\" constraint \\\"%s\\\" has NULL conbin\",\n\t\t\t\t\t NameStr(typTup->typname), NameStr(c->conname));\n\n\t\t\t/* Convert conbin to C string in caller context */\n\t\t\tconstring = TextDatumGetCString(val);\n\n\t\t\t/* Create the DomainConstraintCache object and context if needed */\n\t\t\tif (dcc == NULL)\n\t\t\t{\n\t\t\t\tMemoryContext cxt;\n\n\t\t\t\tcxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\"Domain constraints\",\n\t\t\t\t\t\t\t\t\t\t\tALLOCSET_SMALL_SIZES);\n\t\t\t\tdcc = (DomainConstraintCache *)\n\t\t\t\t\tMemoryContextAlloc(cxt, sizeof(DomainConstraintCache));\n\t\t\t\tdcc->constraints = NIL;\n\t\t\t\tdcc->dccContext = cxt;\n\t\t\t\tdcc->dccRefCount = 0;\n\t\t\t}\n\n\t\t\t/* Create node trees in DomainConstraintCache's context */\n\t\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\n\t\t\tcheck_expr = (Expr *) stringToNode(constring);\n\n\t\t\t/* ExecInitExpr will assume we've planned the expression */\n\t\t\tcheck_expr = expression_planner(check_expr);\n\n\t\t\tr = makeNode(DomainConstraintState);\n\t\t\tr->constrainttype = DOM_CONSTRAINT_CHECK;\n\t\t\tr->name = pstrdup(NameStr(c->conname));\n\t\t\tr->check_expr = check_expr;\n\t\t\tr->check_exprstate = NULL;\n\n\t\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t\t/* Accumulate constraints in an array, for sorting below */\n\t\t\tif (ccons == NULL)\n\t\t\t{\n\t\t\t\tcconslen = 8;\n\t\t\t\tccons = (DomainConstraintState **)\n\t\t\t\t\tpalloc(cconslen * sizeof(DomainConstraintState *));\n\t\t\t}\n\t\t\telse if (nccons >= cconslen)\n\t\t\t{\n\t\t\t\tcconslen *= 2;\n\t\t\t\tccons = (DomainConstraintState **)\n\t\t\t\t\trepalloc(ccons, cconslen * sizeof(DomainConstraintState *));\n\t\t\t}\n\t\t\tccons[nccons++] = r;\n\t\t}\n\n\t\tsystable_endscan(scan);\n\n\t\tif (nccons > 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Sort the items for this domain, so that CHECKs are applied in a\n\t\t\t * deterministic order.\n\t\t\t */\n\t\t\tif (nccons > 1)\n\t\t\t\tqsort(ccons, nccons, sizeof(DomainConstraintState *), dcs_cmp);\n\n\t\t\t/*\n\t\t\t * Now attach them to the overall list.  Use lcons() here because\n\t\t\t * constraints of parent domains should be applied earlier.\n\t\t\t */\n\t\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\t\t\twhile (nccons > 0)\n\t\t\t\tdcc->constraints = lcons(ccons[--nccons], dcc->constraints);\n\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t}\n\n\t\t/* loop to next domain in stack */\n\t\ttypeOid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\theap_close(conRel, AccessShareLock);\n\n\t/*\n\t * Only need to add one NOT NULL check regardless of how many domains in\n\t * the stack request it.\n\t */\n\tif (notNull)\n\t{\n\t\tDomainConstraintState *r;\n\n\t\t/* Create the DomainConstraintCache object and context if needed */\n\t\tif (dcc == NULL)\n\t\t{\n\t\t\tMemoryContext cxt;\n\n\t\t\tcxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"Domain constraints\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_SMALL_SIZES);\n\t\t\tdcc = (DomainConstraintCache *)\n\t\t\t\tMemoryContextAlloc(cxt, sizeof(DomainConstraintCache));\n\t\t\tdcc->constraints = NIL;\n\t\t\tdcc->dccContext = cxt;\n\t\t\tdcc->dccRefCount = 0;\n\t\t}\n\n\t\t/* Create node trees in DomainConstraintCache's context */\n\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\n\t\tr = makeNode(DomainConstraintState);\n\n\t\tr->constrainttype = DOM_CONSTRAINT_NOTNULL;\n\t\tr->name = pstrdup(\"NOT NULL\");\n\t\tr->check_expr = NULL;\n\t\tr->check_exprstate = NULL;\n\n\t\t/* lcons to apply the nullness check FIRST */\n\t\tdcc->constraints = lcons(r, dcc->constraints);\n\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * If we made a constraint object, move it into CacheMemoryContext and\n\t * attach it to the typcache entry.\n\t */\n\tif (dcc)\n\t{\n\t\tMemoryContextSetParent(dcc->dccContext, CacheMemoryContext);\n\t\ttypentry->domainData = dcc;\n\t\tdcc->dccRefCount++;\t\t/* count the typcache's reference */\n\t}\n\n\t/* Either way, the typcache entry's domain data is now valid. */\n\ttypentry->flags |= TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static void decr_dcc_refcount(DomainConstraintCache *dcc);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic void decr_dcc_refcount(DomainConstraintCache *dcc);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic void\nload_domaintype_info(TypeCacheEntry *typentry)\n{\n\tOid\t\t\ttypeOid = typentry->type_id;\n\tDomainConstraintCache *dcc;\n\tbool\t\tnotNull = false;\n\tDomainConstraintState **ccons;\n\tint\t\t\tcconslen;\n\tRelation\tconRel;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * If we're here, any existing constraint info is stale, so release it.\n\t * For safety, be sure to null the link before trying to delete the data.\n\t */\n\tif (typentry->domainData)\n\t{\n\t\tdcc = typentry->domainData;\n\t\ttypentry->domainData = NULL;\n\t\tdecr_dcc_refcount(dcc);\n\t}\n\n\t/*\n\t * We try to optimize the common case of no domain constraints, so don't\n\t * create the dcc object and context until we find a constraint.  Likewise\n\t * for the temp sorting array.\n\t */\n\tdcc = NULL;\n\tccons = NULL;\n\tcconslen = 0;\n\n\t/*\n\t * Scan pg_constraint for relevant constraints.  We want to find\n\t * constraints for not just this domain, but any ancestor domains, so the\n\t * outer loop crawls up the domain stack.\n\t */\n\tconRel = heap_open(ConstraintRelationId, AccessShareLock);\n\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tHeapTuple\tconTup;\n\t\tForm_pg_type typTup;\n\t\tint\t\t\tnccons = 0;\n\t\tScanKeyData key[1];\n\t\tSysScanDesc scan;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typeOid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", typeOid);\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so done */\n\t\t\tReleaseSysCache(tup);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Test for NOT NULL Constraint */\n\t\tif (typTup->typnotnull)\n\t\t\tnotNull = true;\n\n\t\t/* Look for CHECK Constraints on this domain */\n\t\tScanKeyInit(&key[0],\n\t\t\t\t\tAnum_pg_constraint_contypid,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(typeOid));\n\n\t\tscan = systable_beginscan(conRel, ConstraintTypidIndexId, true,\n\t\t\t\t\t\t\t\t  NULL, 1, key);\n\n\t\twhile (HeapTupleIsValid(conTup = systable_getnext(scan)))\n\t\t{\n\t\t\tForm_pg_constraint c = (Form_pg_constraint) GETSTRUCT(conTup);\n\t\t\tDatum\t\tval;\n\t\t\tbool\t\tisNull;\n\t\t\tchar\t   *constring;\n\t\t\tExpr\t   *check_expr;\n\t\t\tDomainConstraintState *r;\n\n\t\t\t/* Ignore non-CHECK constraints (presently, shouldn't be any) */\n\t\t\tif (c->contype != CONSTRAINT_CHECK)\n\t\t\t\tcontinue;\n\n\t\t\t/* Not expecting conbin to be NULL, but we'll test for it anyway */\n\t\t\tval = fastgetattr(conTup, Anum_pg_constraint_conbin,\n\t\t\t\t\t\t\t  conRel->rd_att, &isNull);\n\t\t\tif (isNull)\n\t\t\t\telog(ERROR, \"domain \\\"%s\\\" constraint \\\"%s\\\" has NULL conbin\",\n\t\t\t\t\t NameStr(typTup->typname), NameStr(c->conname));\n\n\t\t\t/* Convert conbin to C string in caller context */\n\t\t\tconstring = TextDatumGetCString(val);\n\n\t\t\t/* Create the DomainConstraintCache object and context if needed */\n\t\t\tif (dcc == NULL)\n\t\t\t{\n\t\t\t\tMemoryContext cxt;\n\n\t\t\t\tcxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\"Domain constraints\",\n\t\t\t\t\t\t\t\t\t\t\tALLOCSET_SMALL_SIZES);\n\t\t\t\tdcc = (DomainConstraintCache *)\n\t\t\t\t\tMemoryContextAlloc(cxt, sizeof(DomainConstraintCache));\n\t\t\t\tdcc->constraints = NIL;\n\t\t\t\tdcc->dccContext = cxt;\n\t\t\t\tdcc->dccRefCount = 0;\n\t\t\t}\n\n\t\t\t/* Create node trees in DomainConstraintCache's context */\n\t\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\n\t\t\tcheck_expr = (Expr *) stringToNode(constring);\n\n\t\t\t/* ExecInitExpr will assume we've planned the expression */\n\t\t\tcheck_expr = expression_planner(check_expr);\n\n\t\t\tr = makeNode(DomainConstraintState);\n\t\t\tr->constrainttype = DOM_CONSTRAINT_CHECK;\n\t\t\tr->name = pstrdup(NameStr(c->conname));\n\t\t\tr->check_expr = check_expr;\n\t\t\tr->check_exprstate = NULL;\n\n\t\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t\t/* Accumulate constraints in an array, for sorting below */\n\t\t\tif (ccons == NULL)\n\t\t\t{\n\t\t\t\tcconslen = 8;\n\t\t\t\tccons = (DomainConstraintState **)\n\t\t\t\t\tpalloc(cconslen * sizeof(DomainConstraintState *));\n\t\t\t}\n\t\t\telse if (nccons >= cconslen)\n\t\t\t{\n\t\t\t\tcconslen *= 2;\n\t\t\t\tccons = (DomainConstraintState **)\n\t\t\t\t\trepalloc(ccons, cconslen * sizeof(DomainConstraintState *));\n\t\t\t}\n\t\t\tccons[nccons++] = r;\n\t\t}\n\n\t\tsystable_endscan(scan);\n\n\t\tif (nccons > 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Sort the items for this domain, so that CHECKs are applied in a\n\t\t\t * deterministic order.\n\t\t\t */\n\t\t\tif (nccons > 1)\n\t\t\t\tqsort(ccons, nccons, sizeof(DomainConstraintState *), dcs_cmp);\n\n\t\t\t/*\n\t\t\t * Now attach them to the overall list.  Use lcons() here because\n\t\t\t * constraints of parent domains should be applied earlier.\n\t\t\t */\n\t\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\t\t\twhile (nccons > 0)\n\t\t\t\tdcc->constraints = lcons(ccons[--nccons], dcc->constraints);\n\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t}\n\n\t\t/* loop to next domain in stack */\n\t\ttypeOid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\theap_close(conRel, AccessShareLock);\n\n\t/*\n\t * Only need to add one NOT NULL check regardless of how many domains in\n\t * the stack request it.\n\t */\n\tif (notNull)\n\t{\n\t\tDomainConstraintState *r;\n\n\t\t/* Create the DomainConstraintCache object and context if needed */\n\t\tif (dcc == NULL)\n\t\t{\n\t\t\tMemoryContext cxt;\n\n\t\t\tcxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"Domain constraints\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_SMALL_SIZES);\n\t\t\tdcc = (DomainConstraintCache *)\n\t\t\t\tMemoryContextAlloc(cxt, sizeof(DomainConstraintCache));\n\t\t\tdcc->constraints = NIL;\n\t\t\tdcc->dccContext = cxt;\n\t\t\tdcc->dccRefCount = 0;\n\t\t}\n\n\t\t/* Create node trees in DomainConstraintCache's context */\n\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\n\t\tr = makeNode(DomainConstraintState);\n\n\t\tr->constrainttype = DOM_CONSTRAINT_NOTNULL;\n\t\tr->name = pstrdup(\"NOT NULL\");\n\t\tr->check_expr = NULL;\n\t\tr->check_exprstate = NULL;\n\n\t\t/* lcons to apply the nullness check FIRST */\n\t\tdcc->constraints = lcons(r, dcc->constraints);\n\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * If we made a constraint object, move it into CacheMemoryContext and\n\t * attach it to the typcache entry.\n\t */\n\tif (dcc)\n\t{\n\t\tMemoryContextSetParent(dcc->dccContext, CacheMemoryContext);\n\t\ttypentry->domainData = dcc;\n\t\tdcc->dccRefCount++;\t\t/* count the typcache's reference */\n\t}\n\n\t/* Either way, the typcache entry's domain data is now valid. */\n\ttypentry->flags |= TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic void decr_dcc_refcount(DomainConstraintCache *dcc);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic void load_enum_cache_data(TypeCacheEntry *tcache);\n\nvoid\nUpdateDomainConstraintRef(DomainConstraintRef *ref)\n{\n\tTypeCacheEntry *typentry = ref->tcache;\n\n\t/* Make sure typcache entry's data is up to date */\n\tif ((typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t\tload_domaintype_info(typentry);\n\n\t/* Transfer to ref object if there's new info, adjusting refcounts */\n\tif (ref->dcc != typentry->domainData)\n\t{\n\t\t/* Paranoia --- be sure link is nulled before trying to release */\n\t\tDomainConstraintCache *dcc = ref->dcc;\n\n\t\tif (dcc)\n\t\t{\n\t\t\t/*\n\t\t\t * Note: we just leak the previous list of executable domain\n\t\t\t * constraints.  Alternatively, we could keep those in a child\n\t\t\t * context of ref->refctx and free that context at this point.\n\t\t\t * However, in practice this code path will be taken so seldom\n\t\t\t * that the extra bookkeeping for a child context doesn't seem\n\t\t\t * worthwhile; we'll just allow a leak for the lifespan of refctx.\n\t\t\t */\n\t\t\tref->constraints = NIL;\n\t\t\tref->dcc = NULL;\n\t\t\tdecr_dcc_refcount(dcc);\n\t\t}\n\t\tdcc = typentry->domainData;\n\t\tif (dcc)\n\t\t{\n\t\t\tref->dcc = dcc;\n\t\t\tdcc->dccRefCount++;\n\t\t\tif (ref->need_exprstate)\n\t\t\t\tref->constraints = prep_domain_constraints(dcc->constraints,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   ref->refctx);\n\t\t\telse\n\t\t\t\tref->constraints = dcc->constraints;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "InitDomainConstraintRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1190-1216",
    "snippet": "void\nInitDomainConstraintRef(Oid type_id, DomainConstraintRef *ref,\n\t\t\t\t\t\tMemoryContext refctx, bool need_exprstate)\n{\n\t/* Look up the typcache entry --- we assume it survives indefinitely */\n\tref->tcache = lookup_type_cache(type_id, TYPECACHE_DOMAIN_CONSTR_INFO);\n\tref->need_exprstate = need_exprstate;\n\t/* For safety, establish the callback before acquiring a refcount */\n\tref->refctx = refctx;\n\tref->dcc = NULL;\n\tref->callback.func = dccref_deletion_callback;\n\tref->callback.arg = (void *) ref;\n\tMemoryContextRegisterResetCallback(refctx, &ref->callback);\n\t/* Acquire refcount if there are constraints, and set up exported list */\n\tif (ref->tcache->domainData)\n\t{\n\t\tref->dcc = ref->tcache->domainData;\n\t\tref->dcc->dccRefCount++;\n\t\tif (ref->need_exprstate)\n\t\t\tref->constraints = prep_domain_constraints(ref->dcc->constraints,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ref->refctx);\n\t\telse\n\t\t\tref->constraints = ref->dcc->constraints;\n\t}\n\telse\n\t\tref->constraints = NIL;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void decr_dcc_refcount(DomainConstraintCache *dcc);",
      "static void dccref_deletion_callback(void *arg);",
      "static void load_enum_cache_data(TypeCacheEntry *tcache);",
      "static EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prep_domain_constraints",
          "args": [
            "ref->dcc->constraints",
            "ref->refctx"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "prep_domain_constraints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1152-1178",
          "snippet": "static List *\nprep_domain_constraints(List *constraints, MemoryContext execctx)\n{\n\tList\t   *result = NIL;\n\tMemoryContext oldcxt;\n\tListCell   *lc;\n\n\toldcxt = MemoryContextSwitchTo(execctx);\n\n\tforeach(lc, constraints)\n\t{\n\t\tDomainConstraintState *r = (DomainConstraintState *) lfirst(lc);\n\t\tDomainConstraintState *newr;\n\n\t\tnewr = makeNode(DomainConstraintState);\n\t\tnewr->constrainttype = r->constrainttype;\n\t\tnewr->name = r->name;\n\t\tnewr->check_expr = r->check_expr;\n\t\tnewr->check_exprstate = ExecInitExpr(r->check_expr, NULL);\n\n\t\tresult = lappend(result, newr);\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *prep_domain_constraints(List *constraints, MemoryContext execctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic List *prep_domain_constraints(List *constraints, MemoryContext execctx);\n\nstatic List *\nprep_domain_constraints(List *constraints, MemoryContext execctx)\n{\n\tList\t   *result = NIL;\n\tMemoryContext oldcxt;\n\tListCell   *lc;\n\n\toldcxt = MemoryContextSwitchTo(execctx);\n\n\tforeach(lc, constraints)\n\t{\n\t\tDomainConstraintState *r = (DomainConstraintState *) lfirst(lc);\n\t\tDomainConstraintState *newr;\n\n\t\tnewr = makeNode(DomainConstraintState);\n\t\tnewr->constrainttype = r->constrainttype;\n\t\tnewr->name = r->name;\n\t\tnewr->check_expr = r->check_expr;\n\t\tnewr->check_exprstate = ExecInitExpr(r->check_expr, NULL);\n\n\t\tresult = lappend(result, newr);\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextRegisterResetCallback",
          "args": [
            "refctx",
            "&ref->callback"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextRegisterResetCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "284-295",
          "snippet": "void\nMemoryContextRegisterResetCallback(MemoryContext context,\n\t\t\t\t\t\t\t\t   MemoryContextCallback *cb)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/* Push onto head so this will be called before older registrants. */\n\tcb->next = context->reset_cbs;\n\tcontext->reset_cbs = cb;\n\t/* Mark the context as non-reset (it probably is already). */\n\tcontext->isReset = false;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextRegisterResetCallback(MemoryContext context,\n\t\t\t\t\t\t\t\t   MemoryContextCallback *cb)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/* Push onto head so this will be called before older registrants. */\n\tcb->next = context->reset_cbs;\n\tcontext->reset_cbs = cb;\n\t/* Mark the context as non-reset (it probably is already). */\n\tcontext->isReset = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "type_id",
            "TYPECACHE_DOMAIN_CONSTR_INFO"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void decr_dcc_refcount(DomainConstraintCache *dcc);\nstatic void dccref_deletion_callback(void *arg);\nstatic void load_enum_cache_data(TypeCacheEntry *tcache);\nstatic EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);\n\nvoid\nInitDomainConstraintRef(Oid type_id, DomainConstraintRef *ref,\n\t\t\t\t\t\tMemoryContext refctx, bool need_exprstate)\n{\n\t/* Look up the typcache entry --- we assume it survives indefinitely */\n\tref->tcache = lookup_type_cache(type_id, TYPECACHE_DOMAIN_CONSTR_INFO);\n\tref->need_exprstate = need_exprstate;\n\t/* For safety, establish the callback before acquiring a refcount */\n\tref->refctx = refctx;\n\tref->dcc = NULL;\n\tref->callback.func = dccref_deletion_callback;\n\tref->callback.arg = (void *) ref;\n\tMemoryContextRegisterResetCallback(refctx, &ref->callback);\n\t/* Acquire refcount if there are constraints, and set up exported list */\n\tif (ref->tcache->domainData)\n\t{\n\t\tref->dcc = ref->tcache->domainData;\n\t\tref->dcc->dccRefCount++;\n\t\tif (ref->need_exprstate)\n\t\t\tref->constraints = prep_domain_constraints(ref->dcc->constraints,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ref->refctx);\n\t\telse\n\t\t\tref->constraints = ref->dcc->constraints;\n\t}\n\telse\n\t\tref->constraints = NIL;\n}"
  },
  {
    "function_name": "prep_domain_constraints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1152-1178",
    "snippet": "static List *\nprep_domain_constraints(List *constraints, MemoryContext execctx)\n{\n\tList\t   *result = NIL;\n\tMemoryContext oldcxt;\n\tListCell   *lc;\n\n\toldcxt = MemoryContextSwitchTo(execctx);\n\n\tforeach(lc, constraints)\n\t{\n\t\tDomainConstraintState *r = (DomainConstraintState *) lfirst(lc);\n\t\tDomainConstraintState *newr;\n\n\t\tnewr = makeNode(DomainConstraintState);\n\t\tnewr->constrainttype = r->constrainttype;\n\t\tnewr->name = r->name;\n\t\tnewr->check_expr = r->check_expr;\n\t\tnewr->check_exprstate = ExecInitExpr(r->check_expr, NULL);\n\n\t\tresult = lappend(result, newr);\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static List *prep_domain_constraints(List *constraints, MemoryContext execctx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "result",
            "newr"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecInitExpr",
          "args": [
            "r->check_expr",
            "NULL"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeNode",
          "args": [
            "DomainConstraintState"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "constraints"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "execctx"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic List *prep_domain_constraints(List *constraints, MemoryContext execctx);\n\nstatic List *\nprep_domain_constraints(List *constraints, MemoryContext execctx)\n{\n\tList\t   *result = NIL;\n\tMemoryContext oldcxt;\n\tListCell   *lc;\n\n\toldcxt = MemoryContextSwitchTo(execctx);\n\n\tforeach(lc, constraints)\n\t{\n\t\tDomainConstraintState *r = (DomainConstraintState *) lfirst(lc);\n\t\tDomainConstraintState *newr;\n\n\t\tnewr = makeNode(DomainConstraintState);\n\t\tnewr->constrainttype = r->constrainttype;\n\t\tnewr->name = r->name;\n\t\tnewr->check_expr = r->check_expr;\n\t\tnewr->check_exprstate = ExecInitExpr(r->check_expr, NULL);\n\n\t\tresult = lappend(result, newr);\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}"
  },
  {
    "function_name": "dccref_deletion_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1131-1144",
    "snippet": "static void\ndccref_deletion_callback(void *arg)\n{\n\tDomainConstraintRef *ref = (DomainConstraintRef *) arg;\n\tDomainConstraintCache *dcc = ref->dcc;\n\n\t/* Paranoia --- be sure link is nulled before trying to release */\n\tif (dcc)\n\t{\n\t\tref->constraints = NIL;\n\t\tref->dcc = NULL;\n\t\tdecr_dcc_refcount(dcc);\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void decr_dcc_refcount(DomainConstraintCache *dcc);",
      "static void dccref_deletion_callback(void *arg);",
      "static EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "decr_dcc_refcount",
          "args": [
            "dcc"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "decr_dcc_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1120-1126",
          "snippet": "static void\ndecr_dcc_refcount(DomainConstraintCache *dcc)\n{\n\tAssert(dcc->dccRefCount > 0);\n\tif (--(dcc->dccRefCount) <= 0)\n\t\tMemoryContextDelete(dcc->dccContext);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void decr_dcc_refcount(DomainConstraintCache *dcc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void decr_dcc_refcount(DomainConstraintCache *dcc);\n\nstatic void\ndecr_dcc_refcount(DomainConstraintCache *dcc)\n{\n\tAssert(dcc->dccRefCount > 0);\n\tif (--(dcc->dccRefCount) <= 0)\n\t\tMemoryContextDelete(dcc->dccContext);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void decr_dcc_refcount(DomainConstraintCache *dcc);\nstatic void dccref_deletion_callback(void *arg);\nstatic EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);\n\nstatic void\ndccref_deletion_callback(void *arg)\n{\n\tDomainConstraintRef *ref = (DomainConstraintRef *) arg;\n\tDomainConstraintCache *dcc = ref->dcc;\n\n\t/* Paranoia --- be sure link is nulled before trying to release */\n\tif (dcc)\n\t{\n\t\tref->constraints = NIL;\n\t\tref->dcc = NULL;\n\t\tdecr_dcc_refcount(dcc);\n\t}\n}"
  },
  {
    "function_name": "decr_dcc_refcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1120-1126",
    "snippet": "static void\ndecr_dcc_refcount(DomainConstraintCache *dcc)\n{\n\tAssert(dcc->dccRefCount > 0);\n\tif (--(dcc->dccRefCount) <= 0)\n\t\tMemoryContextDelete(dcc->dccContext);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void decr_dcc_refcount(DomainConstraintCache *dcc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "dcc->dccContext"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "dcc->dccRefCount > 0"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void decr_dcc_refcount(DomainConstraintCache *dcc);\n\nstatic void\ndecr_dcc_refcount(DomainConstraintCache *dcc)\n{\n\tAssert(dcc->dccRefCount > 0);\n\tif (--(dcc->dccRefCount) <= 0)\n\t\tMemoryContextDelete(dcc->dccContext);\n}"
  },
  {
    "function_name": "dcs_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "1107-1114",
    "snippet": "static int\ndcs_cmp(const void *a, const void *b)\n{\n\tconst DomainConstraintState *const *ca = (const DomainConstraintState *const *) a;\n\tconst DomainConstraintState *const *cb = (const DomainConstraintState *const *) b;\n\n\treturn strcmp((*ca)->name, (*cb)->name);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tdcs_cmp(const void *a, const void *b);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "(*ca)->name",
            "(*cb)->name"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\tdcs_cmp(const void *a, const void *b);\n\nstatic int\ndcs_cmp(const void *a, const void *b)\n{\n\tconst DomainConstraintState *const *ca = (const DomainConstraintState *const *) a;\n\tconst DomainConstraintState *const *cb = (const DomainConstraintState *const *) b;\n\n\treturn strcmp((*ca)->name, (*cb)->name);\n}"
  },
  {
    "function_name": "load_domaintype_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "880-1102",
    "snippet": "static void\nload_domaintype_info(TypeCacheEntry *typentry)\n{\n\tOid\t\t\ttypeOid = typentry->type_id;\n\tDomainConstraintCache *dcc;\n\tbool\t\tnotNull = false;\n\tDomainConstraintState **ccons;\n\tint\t\t\tcconslen;\n\tRelation\tconRel;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * If we're here, any existing constraint info is stale, so release it.\n\t * For safety, be sure to null the link before trying to delete the data.\n\t */\n\tif (typentry->domainData)\n\t{\n\t\tdcc = typentry->domainData;\n\t\ttypentry->domainData = NULL;\n\t\tdecr_dcc_refcount(dcc);\n\t}\n\n\t/*\n\t * We try to optimize the common case of no domain constraints, so don't\n\t * create the dcc object and context until we find a constraint.  Likewise\n\t * for the temp sorting array.\n\t */\n\tdcc = NULL;\n\tccons = NULL;\n\tcconslen = 0;\n\n\t/*\n\t * Scan pg_constraint for relevant constraints.  We want to find\n\t * constraints for not just this domain, but any ancestor domains, so the\n\t * outer loop crawls up the domain stack.\n\t */\n\tconRel = heap_open(ConstraintRelationId, AccessShareLock);\n\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tHeapTuple\tconTup;\n\t\tForm_pg_type typTup;\n\t\tint\t\t\tnccons = 0;\n\t\tScanKeyData key[1];\n\t\tSysScanDesc scan;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typeOid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", typeOid);\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so done */\n\t\t\tReleaseSysCache(tup);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Test for NOT NULL Constraint */\n\t\tif (typTup->typnotnull)\n\t\t\tnotNull = true;\n\n\t\t/* Look for CHECK Constraints on this domain */\n\t\tScanKeyInit(&key[0],\n\t\t\t\t\tAnum_pg_constraint_contypid,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(typeOid));\n\n\t\tscan = systable_beginscan(conRel, ConstraintTypidIndexId, true,\n\t\t\t\t\t\t\t\t  NULL, 1, key);\n\n\t\twhile (HeapTupleIsValid(conTup = systable_getnext(scan)))\n\t\t{\n\t\t\tForm_pg_constraint c = (Form_pg_constraint) GETSTRUCT(conTup);\n\t\t\tDatum\t\tval;\n\t\t\tbool\t\tisNull;\n\t\t\tchar\t   *constring;\n\t\t\tExpr\t   *check_expr;\n\t\t\tDomainConstraintState *r;\n\n\t\t\t/* Ignore non-CHECK constraints (presently, shouldn't be any) */\n\t\t\tif (c->contype != CONSTRAINT_CHECK)\n\t\t\t\tcontinue;\n\n\t\t\t/* Not expecting conbin to be NULL, but we'll test for it anyway */\n\t\t\tval = fastgetattr(conTup, Anum_pg_constraint_conbin,\n\t\t\t\t\t\t\t  conRel->rd_att, &isNull);\n\t\t\tif (isNull)\n\t\t\t\telog(ERROR, \"domain \\\"%s\\\" constraint \\\"%s\\\" has NULL conbin\",\n\t\t\t\t\t NameStr(typTup->typname), NameStr(c->conname));\n\n\t\t\t/* Convert conbin to C string in caller context */\n\t\t\tconstring = TextDatumGetCString(val);\n\n\t\t\t/* Create the DomainConstraintCache object and context if needed */\n\t\t\tif (dcc == NULL)\n\t\t\t{\n\t\t\t\tMemoryContext cxt;\n\n\t\t\t\tcxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\"Domain constraints\",\n\t\t\t\t\t\t\t\t\t\t\tALLOCSET_SMALL_SIZES);\n\t\t\t\tdcc = (DomainConstraintCache *)\n\t\t\t\t\tMemoryContextAlloc(cxt, sizeof(DomainConstraintCache));\n\t\t\t\tdcc->constraints = NIL;\n\t\t\t\tdcc->dccContext = cxt;\n\t\t\t\tdcc->dccRefCount = 0;\n\t\t\t}\n\n\t\t\t/* Create node trees in DomainConstraintCache's context */\n\t\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\n\t\t\tcheck_expr = (Expr *) stringToNode(constring);\n\n\t\t\t/* ExecInitExpr will assume we've planned the expression */\n\t\t\tcheck_expr = expression_planner(check_expr);\n\n\t\t\tr = makeNode(DomainConstraintState);\n\t\t\tr->constrainttype = DOM_CONSTRAINT_CHECK;\n\t\t\tr->name = pstrdup(NameStr(c->conname));\n\t\t\tr->check_expr = check_expr;\n\t\t\tr->check_exprstate = NULL;\n\n\t\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t\t/* Accumulate constraints in an array, for sorting below */\n\t\t\tif (ccons == NULL)\n\t\t\t{\n\t\t\t\tcconslen = 8;\n\t\t\t\tccons = (DomainConstraintState **)\n\t\t\t\t\tpalloc(cconslen * sizeof(DomainConstraintState *));\n\t\t\t}\n\t\t\telse if (nccons >= cconslen)\n\t\t\t{\n\t\t\t\tcconslen *= 2;\n\t\t\t\tccons = (DomainConstraintState **)\n\t\t\t\t\trepalloc(ccons, cconslen * sizeof(DomainConstraintState *));\n\t\t\t}\n\t\t\tccons[nccons++] = r;\n\t\t}\n\n\t\tsystable_endscan(scan);\n\n\t\tif (nccons > 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Sort the items for this domain, so that CHECKs are applied in a\n\t\t\t * deterministic order.\n\t\t\t */\n\t\t\tif (nccons > 1)\n\t\t\t\tqsort(ccons, nccons, sizeof(DomainConstraintState *), dcs_cmp);\n\n\t\t\t/*\n\t\t\t * Now attach them to the overall list.  Use lcons() here because\n\t\t\t * constraints of parent domains should be applied earlier.\n\t\t\t */\n\t\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\t\t\twhile (nccons > 0)\n\t\t\t\tdcc->constraints = lcons(ccons[--nccons], dcc->constraints);\n\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t}\n\n\t\t/* loop to next domain in stack */\n\t\ttypeOid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\theap_close(conRel, AccessShareLock);\n\n\t/*\n\t * Only need to add one NOT NULL check regardless of how many domains in\n\t * the stack request it.\n\t */\n\tif (notNull)\n\t{\n\t\tDomainConstraintState *r;\n\n\t\t/* Create the DomainConstraintCache object and context if needed */\n\t\tif (dcc == NULL)\n\t\t{\n\t\t\tMemoryContext cxt;\n\n\t\t\tcxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"Domain constraints\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_SMALL_SIZES);\n\t\t\tdcc = (DomainConstraintCache *)\n\t\t\t\tMemoryContextAlloc(cxt, sizeof(DomainConstraintCache));\n\t\t\tdcc->constraints = NIL;\n\t\t\tdcc->dccContext = cxt;\n\t\t\tdcc->dccRefCount = 0;\n\t\t}\n\n\t\t/* Create node trees in DomainConstraintCache's context */\n\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\n\t\tr = makeNode(DomainConstraintState);\n\n\t\tr->constrainttype = DOM_CONSTRAINT_NOTNULL;\n\t\tr->name = pstrdup(\"NOT NULL\");\n\t\tr->check_expr = NULL;\n\t\tr->check_exprstate = NULL;\n\n\t\t/* lcons to apply the nullness check FIRST */\n\t\tdcc->constraints = lcons(r, dcc->constraints);\n\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * If we made a constraint object, move it into CacheMemoryContext and\n\t * attach it to the typcache entry.\n\t */\n\tif (dcc)\n\t{\n\t\tMemoryContextSetParent(dcc->dccContext, CacheMemoryContext);\n\t\ttypentry->domainData = dcc;\n\t\tdcc->dccRefCount++;\t\t/* count the typcache's reference */\n\t}\n\n\t/* Either way, the typcache entry's domain data is now valid. */\n\ttypentry->flags |= TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000"
    ],
    "globals_used": [
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static void decr_dcc_refcount(DomainConstraintCache *dcc);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSetParent",
          "args": [
            "dcc->dccContext",
            "CacheMemoryContext"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextSetParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "353-397",
          "snippet": "void\nMemoryContextSetParent(MemoryContext context, MemoryContext new_parent)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertArg(context != new_parent);\n\n\t/* Fast path if it's got correct parent already */\n\tif (new_parent == context->parent)\n\t\treturn;\n\n\t/* Delink from existing parent, if any */\n\tif (context->parent)\n\t{\n\t\tMemoryContext parent = context->parent;\n\n\t\tif (context->prevchild != NULL)\n\t\t\tcontext->prevchild->nextchild = context->nextchild;\n\t\telse\n\t\t{\n\t\t\tAssert(parent->firstchild == context);\n\t\t\tparent->firstchild = context->nextchild;\n\t\t}\n\n\t\tif (context->nextchild != NULL)\n\t\t\tcontext->nextchild->prevchild = context->prevchild;\n\t}\n\n\t/* And relink */\n\tif (new_parent)\n\t{\n\t\tAssertArg(MemoryContextIsValid(new_parent));\n\t\tcontext->parent = new_parent;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = new_parent->firstchild;\n\t\tif (new_parent->firstchild != NULL)\n\t\t\tnew_parent->firstchild->prevchild = context;\n\t\tnew_parent->firstchild = context;\n\t}\n\telse\n\t{\n\t\tcontext->parent = NULL;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextSetParent(MemoryContext context, MemoryContext new_parent)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertArg(context != new_parent);\n\n\t/* Fast path if it's got correct parent already */\n\tif (new_parent == context->parent)\n\t\treturn;\n\n\t/* Delink from existing parent, if any */\n\tif (context->parent)\n\t{\n\t\tMemoryContext parent = context->parent;\n\n\t\tif (context->prevchild != NULL)\n\t\t\tcontext->prevchild->nextchild = context->nextchild;\n\t\telse\n\t\t{\n\t\t\tAssert(parent->firstchild == context);\n\t\t\tparent->firstchild = context->nextchild;\n\t\t}\n\n\t\tif (context->nextchild != NULL)\n\t\t\tcontext->nextchild->prevchild = context->prevchild;\n\t}\n\n\t/* And relink */\n\tif (new_parent)\n\t{\n\t\tAssertArg(MemoryContextIsValid(new_parent));\n\t\tcontext->parent = new_parent;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = new_parent->firstchild;\n\t\tif (new_parent->firstchild != NULL)\n\t\t\tnew_parent->firstchild->prevchild = context;\n\t\tnew_parent->firstchild = context;\n\t}\n\telse\n\t{\n\t\tcontext->parent = NULL;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lcons",
          "args": [
            "r",
            "dcc->constraints"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "\"NOT NULL\""
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeNode",
          "args": [
            "DomainConstraintState"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "dcc->dccContext"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "cxt",
            "sizeof(DomainConstraintCache)"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CurrentMemoryContext",
            "\"Domain constraints\"",
            "ALLOCSET_SMALL_SIZES"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "conRel",
            "AccessShareLock"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tup"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lcons",
          "args": [
            "ccons[--nccons]",
            "dcc->constraints"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "dcc->dccContext"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "ccons",
            "nccons",
            "sizeof(DomainConstraintState *)",
            "dcs_cmp"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "scan"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "ccons",
            "cconslen * sizeof(DomainConstraintState *)"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "repalloc_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1113-1141",
          "snippet": "void *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "cconslen * sizeof(DomainConstraintState *)"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "c->conname"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeNode",
          "args": [
            "DomainConstraintState"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expression_planner",
          "args": [
            "check_expr"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToNode",
          "args": [
            "constring"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "dcc->dccContext"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CurrentMemoryContext",
            "\"Domain constraints\"",
            "ALLOCSET_SMALL_SIZES"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "val"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"domain \\\"%s\\\" constraint \\\"%s\\\" has NULL conbin\"",
            "NameStr(typTup->typname)",
            "NameStr(c->conname)"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "c->conname"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "typTup->typname"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastgetattr",
          "args": [
            "conTup",
            "Anum_pg_constraint_conbin",
            "conRel->rd_att",
            "&isNull"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "conTup"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "conTup = systable_getnext(scan)"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "scan"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "conRel",
            "ConstraintTypidIndexId",
            "true",
            "NULL",
            "1",
            "key"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&key[0]",
            "Anum_pg_constraint_contypid",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(typeOid)"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "typeOid"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tup"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tup"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "TYPEOID",
            "ObjectIdGetDatum(typeOid)"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "typeOid"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "ConstraintRelationId",
            "AccessShareLock"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decr_dcc_refcount",
          "args": [
            "dcc"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "decr_dcc_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1120-1126",
          "snippet": "static void\ndecr_dcc_refcount(DomainConstraintCache *dcc)\n{\n\tAssert(dcc->dccRefCount > 0);\n\tif (--(dcc->dccRefCount) <= 0)\n\t\tMemoryContextDelete(dcc->dccContext);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void decr_dcc_refcount(DomainConstraintCache *dcc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void decr_dcc_refcount(DomainConstraintCache *dcc);\n\nstatic void\ndecr_dcc_refcount(DomainConstraintCache *dcc)\n{\n\tAssert(dcc->dccRefCount > 0);\n\tif (--(dcc->dccRefCount) <= 0)\n\t\tMemoryContextDelete(dcc->dccContext);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic void decr_dcc_refcount(DomainConstraintCache *dcc);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic void\nload_domaintype_info(TypeCacheEntry *typentry)\n{\n\tOid\t\t\ttypeOid = typentry->type_id;\n\tDomainConstraintCache *dcc;\n\tbool\t\tnotNull = false;\n\tDomainConstraintState **ccons;\n\tint\t\t\tcconslen;\n\tRelation\tconRel;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * If we're here, any existing constraint info is stale, so release it.\n\t * For safety, be sure to null the link before trying to delete the data.\n\t */\n\tif (typentry->domainData)\n\t{\n\t\tdcc = typentry->domainData;\n\t\ttypentry->domainData = NULL;\n\t\tdecr_dcc_refcount(dcc);\n\t}\n\n\t/*\n\t * We try to optimize the common case of no domain constraints, so don't\n\t * create the dcc object and context until we find a constraint.  Likewise\n\t * for the temp sorting array.\n\t */\n\tdcc = NULL;\n\tccons = NULL;\n\tcconslen = 0;\n\n\t/*\n\t * Scan pg_constraint for relevant constraints.  We want to find\n\t * constraints for not just this domain, but any ancestor domains, so the\n\t * outer loop crawls up the domain stack.\n\t */\n\tconRel = heap_open(ConstraintRelationId, AccessShareLock);\n\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tHeapTuple\tconTup;\n\t\tForm_pg_type typTup;\n\t\tint\t\t\tnccons = 0;\n\t\tScanKeyData key[1];\n\t\tSysScanDesc scan;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typeOid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", typeOid);\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so done */\n\t\t\tReleaseSysCache(tup);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Test for NOT NULL Constraint */\n\t\tif (typTup->typnotnull)\n\t\t\tnotNull = true;\n\n\t\t/* Look for CHECK Constraints on this domain */\n\t\tScanKeyInit(&key[0],\n\t\t\t\t\tAnum_pg_constraint_contypid,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(typeOid));\n\n\t\tscan = systable_beginscan(conRel, ConstraintTypidIndexId, true,\n\t\t\t\t\t\t\t\t  NULL, 1, key);\n\n\t\twhile (HeapTupleIsValid(conTup = systable_getnext(scan)))\n\t\t{\n\t\t\tForm_pg_constraint c = (Form_pg_constraint) GETSTRUCT(conTup);\n\t\t\tDatum\t\tval;\n\t\t\tbool\t\tisNull;\n\t\t\tchar\t   *constring;\n\t\t\tExpr\t   *check_expr;\n\t\t\tDomainConstraintState *r;\n\n\t\t\t/* Ignore non-CHECK constraints (presently, shouldn't be any) */\n\t\t\tif (c->contype != CONSTRAINT_CHECK)\n\t\t\t\tcontinue;\n\n\t\t\t/* Not expecting conbin to be NULL, but we'll test for it anyway */\n\t\t\tval = fastgetattr(conTup, Anum_pg_constraint_conbin,\n\t\t\t\t\t\t\t  conRel->rd_att, &isNull);\n\t\t\tif (isNull)\n\t\t\t\telog(ERROR, \"domain \\\"%s\\\" constraint \\\"%s\\\" has NULL conbin\",\n\t\t\t\t\t NameStr(typTup->typname), NameStr(c->conname));\n\n\t\t\t/* Convert conbin to C string in caller context */\n\t\t\tconstring = TextDatumGetCString(val);\n\n\t\t\t/* Create the DomainConstraintCache object and context if needed */\n\t\t\tif (dcc == NULL)\n\t\t\t{\n\t\t\t\tMemoryContext cxt;\n\n\t\t\t\tcxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\"Domain constraints\",\n\t\t\t\t\t\t\t\t\t\t\tALLOCSET_SMALL_SIZES);\n\t\t\t\tdcc = (DomainConstraintCache *)\n\t\t\t\t\tMemoryContextAlloc(cxt, sizeof(DomainConstraintCache));\n\t\t\t\tdcc->constraints = NIL;\n\t\t\t\tdcc->dccContext = cxt;\n\t\t\t\tdcc->dccRefCount = 0;\n\t\t\t}\n\n\t\t\t/* Create node trees in DomainConstraintCache's context */\n\t\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\n\t\t\tcheck_expr = (Expr *) stringToNode(constring);\n\n\t\t\t/* ExecInitExpr will assume we've planned the expression */\n\t\t\tcheck_expr = expression_planner(check_expr);\n\n\t\t\tr = makeNode(DomainConstraintState);\n\t\t\tr->constrainttype = DOM_CONSTRAINT_CHECK;\n\t\t\tr->name = pstrdup(NameStr(c->conname));\n\t\t\tr->check_expr = check_expr;\n\t\t\tr->check_exprstate = NULL;\n\n\t\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t\t/* Accumulate constraints in an array, for sorting below */\n\t\t\tif (ccons == NULL)\n\t\t\t{\n\t\t\t\tcconslen = 8;\n\t\t\t\tccons = (DomainConstraintState **)\n\t\t\t\t\tpalloc(cconslen * sizeof(DomainConstraintState *));\n\t\t\t}\n\t\t\telse if (nccons >= cconslen)\n\t\t\t{\n\t\t\t\tcconslen *= 2;\n\t\t\t\tccons = (DomainConstraintState **)\n\t\t\t\t\trepalloc(ccons, cconslen * sizeof(DomainConstraintState *));\n\t\t\t}\n\t\t\tccons[nccons++] = r;\n\t\t}\n\n\t\tsystable_endscan(scan);\n\n\t\tif (nccons > 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Sort the items for this domain, so that CHECKs are applied in a\n\t\t\t * deterministic order.\n\t\t\t */\n\t\t\tif (nccons > 1)\n\t\t\t\tqsort(ccons, nccons, sizeof(DomainConstraintState *), dcs_cmp);\n\n\t\t\t/*\n\t\t\t * Now attach them to the overall list.  Use lcons() here because\n\t\t\t * constraints of parent domains should be applied earlier.\n\t\t\t */\n\t\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\t\t\twhile (nccons > 0)\n\t\t\t\tdcc->constraints = lcons(ccons[--nccons], dcc->constraints);\n\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t}\n\n\t\t/* loop to next domain in stack */\n\t\ttypeOid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\theap_close(conRel, AccessShareLock);\n\n\t/*\n\t * Only need to add one NOT NULL check regardless of how many domains in\n\t * the stack request it.\n\t */\n\tif (notNull)\n\t{\n\t\tDomainConstraintState *r;\n\n\t\t/* Create the DomainConstraintCache object and context if needed */\n\t\tif (dcc == NULL)\n\t\t{\n\t\t\tMemoryContext cxt;\n\n\t\t\tcxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"Domain constraints\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_SMALL_SIZES);\n\t\t\tdcc = (DomainConstraintCache *)\n\t\t\t\tMemoryContextAlloc(cxt, sizeof(DomainConstraintCache));\n\t\t\tdcc->constraints = NIL;\n\t\t\tdcc->dccContext = cxt;\n\t\t\tdcc->dccRefCount = 0;\n\t\t}\n\n\t\t/* Create node trees in DomainConstraintCache's context */\n\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\n\t\tr = makeNode(DomainConstraintState);\n\n\t\tr->constrainttype = DOM_CONSTRAINT_NOTNULL;\n\t\tr->name = pstrdup(\"NOT NULL\");\n\t\tr->check_expr = NULL;\n\t\tr->check_exprstate = NULL;\n\n\t\t/* lcons to apply the nullness check FIRST */\n\t\tdcc->constraints = lcons(r, dcc->constraints);\n\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * If we made a constraint object, move it into CacheMemoryContext and\n\t * attach it to the typcache entry.\n\t */\n\tif (dcc)\n\t{\n\t\tMemoryContextSetParent(dcc->dccContext, CacheMemoryContext);\n\t\ttypentry->domainData = dcc;\n\t\tdcc->dccRefCount++;\t\t/* count the typcache's reference */\n\t}\n\n\t/* Either way, the typcache entry's domain data is now valid. */\n\ttypentry->flags |= TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS;\n}"
  },
  {
    "function_name": "load_rangetype_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "817-868",
    "snippet": "static void\nload_rangetype_info(TypeCacheEntry *typentry)\n{\n\tForm_pg_range pg_range;\n\tHeapTuple\ttup;\n\tOid\t\t\tsubtypeOid;\n\tOid\t\t\topclassOid;\n\tOid\t\t\tcanonicalOid;\n\tOid\t\t\tsubdiffOid;\n\tOid\t\t\topfamilyOid;\n\tOid\t\t\topcintype;\n\tOid\t\t\tcmpFnOid;\n\n\t/* get information from pg_range */\n\ttup = SearchSysCache1(RANGETYPE, ObjectIdGetDatum(typentry->type_id));\n\t/* should not fail, since we already checked typtype ... */\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for range type %u\",\n\t\t\t typentry->type_id);\n\tpg_range = (Form_pg_range) GETSTRUCT(tup);\n\n\tsubtypeOid = pg_range->rngsubtype;\n\ttypentry->rng_collation = pg_range->rngcollation;\n\topclassOid = pg_range->rngsubopc;\n\tcanonicalOid = pg_range->rngcanonical;\n\tsubdiffOid = pg_range->rngsubdiff;\n\n\tReleaseSysCache(tup);\n\n\t/* get opclass properties and look up the comparison function */\n\topfamilyOid = get_opclass_family(opclassOid);\n\topcintype = get_opclass_input_type(opclassOid);\n\n\tcmpFnOid = get_opfamily_proc(opfamilyOid, opcintype, opcintype,\n\t\t\t\t\t\t\t\t BTORDER_PROC);\n\tif (!RegProcedureIsValid(cmpFnOid))\n\t\telog(ERROR, \"missing support function %d(%u,%u) in opfamily %u\",\n\t\t\t BTORDER_PROC, opcintype, opcintype, opfamilyOid);\n\n\t/* set up cached fmgrinfo structs */\n\tfmgr_info_cxt(cmpFnOid, &typentry->rng_cmp_proc_finfo,\n\t\t\t\t  CacheMemoryContext);\n\tif (OidIsValid(canonicalOid))\n\t\tfmgr_info_cxt(canonicalOid, &typentry->rng_canonical_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\tif (OidIsValid(subdiffOid))\n\t\tfmgr_info_cxt(subdiffOid, &typentry->rng_subdiff_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t/* Lastly, set up link to the element type --- this marks data valid */\n\ttypentry->rngelemtype = lookup_type_cache(subtypeOid, 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "subtypeOid",
            "0"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "subdiffOid",
            "&typentry->rng_subdiff_finfo",
            "CacheMemoryContext"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "subdiffOid"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "canonicalOid"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"missing support function %d(%u,%u) in opfamily %u\"",
            "BTORDER_PROC",
            "opcintype",
            "opcintype",
            "opfamilyOid"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RegProcedureIsValid",
          "args": [
            "cmpFnOid"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_opfamily_proc",
          "args": [
            "opfamilyOid",
            "opcintype",
            "opcintype",
            "BTORDER_PROC"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "get_opfamily_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "743-761",
          "snippet": "Oid\nget_opfamily_proc(Oid opfamily, Oid lefttype, Oid righttype, int16 procnum)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amproc amproc_tup;\n\tRegProcedure result;\n\n\ttp = SearchSysCache4(AMPROCNUM,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(procnum));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamproc_tup = (Form_pg_amproc) GETSTRUCT(tp);\n\tresult = amproc_tup->amproc;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_opfamily_proc(Oid opfamily, Oid lefttype, Oid righttype, int16 procnum)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amproc amproc_tup;\n\tRegProcedure result;\n\n\ttp = SearchSysCache4(AMPROCNUM,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(procnum));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamproc_tup = (Form_pg_amproc) GETSTRUCT(tp);\n\tresult = amproc_tup->amproc;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opclass_input_type",
          "args": [
            "opclassOid"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "get_opclass_input_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1053-1068",
          "snippet": "Oid\nget_opclass_input_type(Oid opclass)\n{\n\tHeapTuple\ttp;\n\tForm_pg_opclass cla_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache1(CLAOID, ObjectIdGetDatum(opclass));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for opclass %u\", opclass);\n\tcla_tup = (Form_pg_opclass) GETSTRUCT(tp);\n\n\tresult = cla_tup->opcintype;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_opclass_input_type(Oid opclass)\n{\n\tHeapTuple\ttp;\n\tForm_pg_opclass cla_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache1(CLAOID, ObjectIdGetDatum(opclass));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for opclass %u\", opclass);\n\tcla_tup = (Form_pg_opclass) GETSTRUCT(tp);\n\n\tresult = cla_tup->opcintype;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opclass_family",
          "args": [
            "opclassOid"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "get_opclass_family",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1031-1046",
          "snippet": "Oid\nget_opclass_family(Oid opclass)\n{\n\tHeapTuple\ttp;\n\tForm_pg_opclass cla_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache1(CLAOID, ObjectIdGetDatum(opclass));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for opclass %u\", opclass);\n\tcla_tup = (Form_pg_opclass) GETSTRUCT(tp);\n\n\tresult = cla_tup->opcfamily;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_opclass_family(Oid opclass)\n{\n\tHeapTuple\ttp;\n\tForm_pg_opclass cla_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache1(CLAOID, ObjectIdGetDatum(opclass));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for opclass %u\", opclass);\n\tcla_tup = (Form_pg_opclass) GETSTRUCT(tp);\n\n\tresult = cla_tup->opcfamily;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tup"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tup"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tup"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "RANGETYPE",
            "ObjectIdGetDatum(typentry->type_id)"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "typentry->type_id"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic void\nload_rangetype_info(TypeCacheEntry *typentry)\n{\n\tForm_pg_range pg_range;\n\tHeapTuple\ttup;\n\tOid\t\t\tsubtypeOid;\n\tOid\t\t\topclassOid;\n\tOid\t\t\tcanonicalOid;\n\tOid\t\t\tsubdiffOid;\n\tOid\t\t\topfamilyOid;\n\tOid\t\t\topcintype;\n\tOid\t\t\tcmpFnOid;\n\n\t/* get information from pg_range */\n\ttup = SearchSysCache1(RANGETYPE, ObjectIdGetDatum(typentry->type_id));\n\t/* should not fail, since we already checked typtype ... */\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for range type %u\",\n\t\t\t typentry->type_id);\n\tpg_range = (Form_pg_range) GETSTRUCT(tup);\n\n\tsubtypeOid = pg_range->rngsubtype;\n\ttypentry->rng_collation = pg_range->rngcollation;\n\topclassOid = pg_range->rngsubopc;\n\tcanonicalOid = pg_range->rngcanonical;\n\tsubdiffOid = pg_range->rngsubdiff;\n\n\tReleaseSysCache(tup);\n\n\t/* get opclass properties and look up the comparison function */\n\topfamilyOid = get_opclass_family(opclassOid);\n\topcintype = get_opclass_input_type(opclassOid);\n\n\tcmpFnOid = get_opfamily_proc(opfamilyOid, opcintype, opcintype,\n\t\t\t\t\t\t\t\t BTORDER_PROC);\n\tif (!RegProcedureIsValid(cmpFnOid))\n\t\telog(ERROR, \"missing support function %d(%u,%u) in opfamily %u\",\n\t\t\t BTORDER_PROC, opcintype, opcintype, opfamilyOid);\n\n\t/* set up cached fmgrinfo structs */\n\tfmgr_info_cxt(cmpFnOid, &typentry->rng_cmp_proc_finfo,\n\t\t\t\t  CacheMemoryContext);\n\tif (OidIsValid(canonicalOid))\n\t\tfmgr_info_cxt(canonicalOid, &typentry->rng_canonical_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\tif (OidIsValid(subdiffOid))\n\t\tfmgr_info_cxt(subdiffOid, &typentry->rng_subdiff_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t/* Lastly, set up link to the element type --- this marks data valid */\n\ttypentry->rngelemtype = lookup_type_cache(subtypeOid, 0);\n}"
  },
  {
    "function_name": "load_typcache_tupdesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "783-812",
    "snippet": "static void\nload_typcache_tupdesc(TypeCacheEntry *typentry)\n{\n\tRelation\trel;\n\n\tif (!OidIsValid(typentry->typrelid))\t/* should not happen */\n\t\telog(ERROR, \"invalid typrelid for composite type %u\",\n\t\t\t typentry->type_id);\n\trel = relation_open(typentry->typrelid, AccessShareLock);\n\tAssert(rel->rd_rel->reltype == typentry->type_id);\n\n\t/*\n\t * Link to the tupdesc and increment its refcount (we assert it's a\n\t * refcounted descriptor).  We don't use IncrTupleDescRefCount() for this,\n\t * because the reference mustn't be entered in the current resource owner;\n\t * it can outlive the current query.\n\t */\n\ttypentry->tupDesc = RelationGetDescr(rel);\n\n\tAssert(typentry->tupDesc->tdrefcount > 0);\n\ttypentry->tupDesc->tdrefcount++;\n\n\t/*\n\t * In future, we could take some pains to not change tupDesc_identifier if\n\t * the tupdesc didn't really change; but for now it's not worth it.\n\t */\n\ttypentry->tupDesc_identifier = ++tupledesc_id_counter;\n\n\trelation_close(rel, AccessShareLock);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;",
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);",
      "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "relation_close",
          "args": [
            "rel",
            "AccessShareLock"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "typentry->tupDesc->tdrefcount > 0"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "rel"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rel->rd_rel->reltype == typentry->type_id"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relation_open",
          "args": [
            "typentry->typrelid",
            "AccessShareLock"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid typrelid for composite type %u\"",
            "typentry->type_id"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->typrelid"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nstatic void\nload_typcache_tupdesc(TypeCacheEntry *typentry)\n{\n\tRelation\trel;\n\n\tif (!OidIsValid(typentry->typrelid))\t/* should not happen */\n\t\telog(ERROR, \"invalid typrelid for composite type %u\",\n\t\t\t typentry->type_id);\n\trel = relation_open(typentry->typrelid, AccessShareLock);\n\tAssert(rel->rd_rel->reltype == typentry->type_id);\n\n\t/*\n\t * Link to the tupdesc and increment its refcount (we assert it's a\n\t * refcounted descriptor).  We don't use IncrTupleDescRefCount() for this,\n\t * because the reference mustn't be entered in the current resource owner;\n\t * it can outlive the current query.\n\t */\n\ttypentry->tupDesc = RelationGetDescr(rel);\n\n\tAssert(typentry->tupDesc->tdrefcount > 0);\n\ttypentry->tupDesc->tdrefcount++;\n\n\t/*\n\t * In future, we could take some pains to not change tupDesc_identifier if\n\t * the tupdesc didn't really change; but for now it's not worth it.\n\t */\n\ttypentry->tupDesc_identifier = ++tupledesc_id_counter;\n\n\trelation_close(rel, AccessShareLock);\n}"
  },
  {
    "function_name": "lookup_type_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "320-778",
    "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
      "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
      "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
      "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
      "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
      "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
      "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
      "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
      "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
    ],
    "globals_used": [
      "static HTAB *TypeCacheHash = NULL;",
      "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
      "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
      "static void load_rangetype_info(TypeCacheEntry *typentry);",
      "static void load_domaintype_info(TypeCacheEntry *typentry);",
      "static bool array_element_has_equality(TypeCacheEntry *typentry);",
      "static bool array_element_has_compare(TypeCacheEntry *typentry);",
      "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_array_element_properties(TypeCacheEntry *typentry);",
      "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
      "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
      "static void cache_record_field_properties(TypeCacheEntry *typentry);",
      "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
      "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
      "static void cache_range_element_properties(TypeCacheEntry *typentry);",
      "static int\tenum_oid_cmp(const void *left, const void *right);",
      "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_domaintype_info",
          "args": [
            "typentry"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "load_domaintype_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "880-1102",
          "snippet": "static void\nload_domaintype_info(TypeCacheEntry *typentry)\n{\n\tOid\t\t\ttypeOid = typentry->type_id;\n\tDomainConstraintCache *dcc;\n\tbool\t\tnotNull = false;\n\tDomainConstraintState **ccons;\n\tint\t\t\tcconslen;\n\tRelation\tconRel;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * If we're here, any existing constraint info is stale, so release it.\n\t * For safety, be sure to null the link before trying to delete the data.\n\t */\n\tif (typentry->domainData)\n\t{\n\t\tdcc = typentry->domainData;\n\t\ttypentry->domainData = NULL;\n\t\tdecr_dcc_refcount(dcc);\n\t}\n\n\t/*\n\t * We try to optimize the common case of no domain constraints, so don't\n\t * create the dcc object and context until we find a constraint.  Likewise\n\t * for the temp sorting array.\n\t */\n\tdcc = NULL;\n\tccons = NULL;\n\tcconslen = 0;\n\n\t/*\n\t * Scan pg_constraint for relevant constraints.  We want to find\n\t * constraints for not just this domain, but any ancestor domains, so the\n\t * outer loop crawls up the domain stack.\n\t */\n\tconRel = heap_open(ConstraintRelationId, AccessShareLock);\n\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tHeapTuple\tconTup;\n\t\tForm_pg_type typTup;\n\t\tint\t\t\tnccons = 0;\n\t\tScanKeyData key[1];\n\t\tSysScanDesc scan;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typeOid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", typeOid);\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so done */\n\t\t\tReleaseSysCache(tup);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Test for NOT NULL Constraint */\n\t\tif (typTup->typnotnull)\n\t\t\tnotNull = true;\n\n\t\t/* Look for CHECK Constraints on this domain */\n\t\tScanKeyInit(&key[0],\n\t\t\t\t\tAnum_pg_constraint_contypid,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(typeOid));\n\n\t\tscan = systable_beginscan(conRel, ConstraintTypidIndexId, true,\n\t\t\t\t\t\t\t\t  NULL, 1, key);\n\n\t\twhile (HeapTupleIsValid(conTup = systable_getnext(scan)))\n\t\t{\n\t\t\tForm_pg_constraint c = (Form_pg_constraint) GETSTRUCT(conTup);\n\t\t\tDatum\t\tval;\n\t\t\tbool\t\tisNull;\n\t\t\tchar\t   *constring;\n\t\t\tExpr\t   *check_expr;\n\t\t\tDomainConstraintState *r;\n\n\t\t\t/* Ignore non-CHECK constraints (presently, shouldn't be any) */\n\t\t\tif (c->contype != CONSTRAINT_CHECK)\n\t\t\t\tcontinue;\n\n\t\t\t/* Not expecting conbin to be NULL, but we'll test for it anyway */\n\t\t\tval = fastgetattr(conTup, Anum_pg_constraint_conbin,\n\t\t\t\t\t\t\t  conRel->rd_att, &isNull);\n\t\t\tif (isNull)\n\t\t\t\telog(ERROR, \"domain \\\"%s\\\" constraint \\\"%s\\\" has NULL conbin\",\n\t\t\t\t\t NameStr(typTup->typname), NameStr(c->conname));\n\n\t\t\t/* Convert conbin to C string in caller context */\n\t\t\tconstring = TextDatumGetCString(val);\n\n\t\t\t/* Create the DomainConstraintCache object and context if needed */\n\t\t\tif (dcc == NULL)\n\t\t\t{\n\t\t\t\tMemoryContext cxt;\n\n\t\t\t\tcxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\"Domain constraints\",\n\t\t\t\t\t\t\t\t\t\t\tALLOCSET_SMALL_SIZES);\n\t\t\t\tdcc = (DomainConstraintCache *)\n\t\t\t\t\tMemoryContextAlloc(cxt, sizeof(DomainConstraintCache));\n\t\t\t\tdcc->constraints = NIL;\n\t\t\t\tdcc->dccContext = cxt;\n\t\t\t\tdcc->dccRefCount = 0;\n\t\t\t}\n\n\t\t\t/* Create node trees in DomainConstraintCache's context */\n\t\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\n\t\t\tcheck_expr = (Expr *) stringToNode(constring);\n\n\t\t\t/* ExecInitExpr will assume we've planned the expression */\n\t\t\tcheck_expr = expression_planner(check_expr);\n\n\t\t\tr = makeNode(DomainConstraintState);\n\t\t\tr->constrainttype = DOM_CONSTRAINT_CHECK;\n\t\t\tr->name = pstrdup(NameStr(c->conname));\n\t\t\tr->check_expr = check_expr;\n\t\t\tr->check_exprstate = NULL;\n\n\t\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t\t/* Accumulate constraints in an array, for sorting below */\n\t\t\tif (ccons == NULL)\n\t\t\t{\n\t\t\t\tcconslen = 8;\n\t\t\t\tccons = (DomainConstraintState **)\n\t\t\t\t\tpalloc(cconslen * sizeof(DomainConstraintState *));\n\t\t\t}\n\t\t\telse if (nccons >= cconslen)\n\t\t\t{\n\t\t\t\tcconslen *= 2;\n\t\t\t\tccons = (DomainConstraintState **)\n\t\t\t\t\trepalloc(ccons, cconslen * sizeof(DomainConstraintState *));\n\t\t\t}\n\t\t\tccons[nccons++] = r;\n\t\t}\n\n\t\tsystable_endscan(scan);\n\n\t\tif (nccons > 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Sort the items for this domain, so that CHECKs are applied in a\n\t\t\t * deterministic order.\n\t\t\t */\n\t\t\tif (nccons > 1)\n\t\t\t\tqsort(ccons, nccons, sizeof(DomainConstraintState *), dcs_cmp);\n\n\t\t\t/*\n\t\t\t * Now attach them to the overall list.  Use lcons() here because\n\t\t\t * constraints of parent domains should be applied earlier.\n\t\t\t */\n\t\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\t\t\twhile (nccons > 0)\n\t\t\t\tdcc->constraints = lcons(ccons[--nccons], dcc->constraints);\n\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t}\n\n\t\t/* loop to next domain in stack */\n\t\ttypeOid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\theap_close(conRel, AccessShareLock);\n\n\t/*\n\t * Only need to add one NOT NULL check regardless of how many domains in\n\t * the stack request it.\n\t */\n\tif (notNull)\n\t{\n\t\tDomainConstraintState *r;\n\n\t\t/* Create the DomainConstraintCache object and context if needed */\n\t\tif (dcc == NULL)\n\t\t{\n\t\t\tMemoryContext cxt;\n\n\t\t\tcxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"Domain constraints\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_SMALL_SIZES);\n\t\t\tdcc = (DomainConstraintCache *)\n\t\t\t\tMemoryContextAlloc(cxt, sizeof(DomainConstraintCache));\n\t\t\tdcc->constraints = NIL;\n\t\t\tdcc->dccContext = cxt;\n\t\t\tdcc->dccRefCount = 0;\n\t\t}\n\n\t\t/* Create node trees in DomainConstraintCache's context */\n\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\n\t\tr = makeNode(DomainConstraintState);\n\n\t\tr->constrainttype = DOM_CONSTRAINT_NOTNULL;\n\t\tr->name = pstrdup(\"NOT NULL\");\n\t\tr->check_expr = NULL;\n\t\tr->check_exprstate = NULL;\n\n\t\t/* lcons to apply the nullness check FIRST */\n\t\tdcc->constraints = lcons(r, dcc->constraints);\n\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * If we made a constraint object, move it into CacheMemoryContext and\n\t * attach it to the typcache entry.\n\t */\n\tif (dcc)\n\t{\n\t\tMemoryContextSetParent(dcc->dccContext, CacheMemoryContext);\n\t\ttypentry->domainData = dcc;\n\t\tdcc->dccRefCount++;\t\t/* count the typcache's reference */\n\t}\n\n\t/* Either way, the typcache entry's domain data is now valid. */\n\ttypentry->flags |= TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static void decr_dcc_refcount(DomainConstraintCache *dcc);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic void decr_dcc_refcount(DomainConstraintCache *dcc);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic void\nload_domaintype_info(TypeCacheEntry *typentry)\n{\n\tOid\t\t\ttypeOid = typentry->type_id;\n\tDomainConstraintCache *dcc;\n\tbool\t\tnotNull = false;\n\tDomainConstraintState **ccons;\n\tint\t\t\tcconslen;\n\tRelation\tconRel;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * If we're here, any existing constraint info is stale, so release it.\n\t * For safety, be sure to null the link before trying to delete the data.\n\t */\n\tif (typentry->domainData)\n\t{\n\t\tdcc = typentry->domainData;\n\t\ttypentry->domainData = NULL;\n\t\tdecr_dcc_refcount(dcc);\n\t}\n\n\t/*\n\t * We try to optimize the common case of no domain constraints, so don't\n\t * create the dcc object and context until we find a constraint.  Likewise\n\t * for the temp sorting array.\n\t */\n\tdcc = NULL;\n\tccons = NULL;\n\tcconslen = 0;\n\n\t/*\n\t * Scan pg_constraint for relevant constraints.  We want to find\n\t * constraints for not just this domain, but any ancestor domains, so the\n\t * outer loop crawls up the domain stack.\n\t */\n\tconRel = heap_open(ConstraintRelationId, AccessShareLock);\n\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tHeapTuple\tconTup;\n\t\tForm_pg_type typTup;\n\t\tint\t\t\tnccons = 0;\n\t\tScanKeyData key[1];\n\t\tSysScanDesc scan;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typeOid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", typeOid);\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so done */\n\t\t\tReleaseSysCache(tup);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Test for NOT NULL Constraint */\n\t\tif (typTup->typnotnull)\n\t\t\tnotNull = true;\n\n\t\t/* Look for CHECK Constraints on this domain */\n\t\tScanKeyInit(&key[0],\n\t\t\t\t\tAnum_pg_constraint_contypid,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(typeOid));\n\n\t\tscan = systable_beginscan(conRel, ConstraintTypidIndexId, true,\n\t\t\t\t\t\t\t\t  NULL, 1, key);\n\n\t\twhile (HeapTupleIsValid(conTup = systable_getnext(scan)))\n\t\t{\n\t\t\tForm_pg_constraint c = (Form_pg_constraint) GETSTRUCT(conTup);\n\t\t\tDatum\t\tval;\n\t\t\tbool\t\tisNull;\n\t\t\tchar\t   *constring;\n\t\t\tExpr\t   *check_expr;\n\t\t\tDomainConstraintState *r;\n\n\t\t\t/* Ignore non-CHECK constraints (presently, shouldn't be any) */\n\t\t\tif (c->contype != CONSTRAINT_CHECK)\n\t\t\t\tcontinue;\n\n\t\t\t/* Not expecting conbin to be NULL, but we'll test for it anyway */\n\t\t\tval = fastgetattr(conTup, Anum_pg_constraint_conbin,\n\t\t\t\t\t\t\t  conRel->rd_att, &isNull);\n\t\t\tif (isNull)\n\t\t\t\telog(ERROR, \"domain \\\"%s\\\" constraint \\\"%s\\\" has NULL conbin\",\n\t\t\t\t\t NameStr(typTup->typname), NameStr(c->conname));\n\n\t\t\t/* Convert conbin to C string in caller context */\n\t\t\tconstring = TextDatumGetCString(val);\n\n\t\t\t/* Create the DomainConstraintCache object and context if needed */\n\t\t\tif (dcc == NULL)\n\t\t\t{\n\t\t\t\tMemoryContext cxt;\n\n\t\t\t\tcxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\"Domain constraints\",\n\t\t\t\t\t\t\t\t\t\t\tALLOCSET_SMALL_SIZES);\n\t\t\t\tdcc = (DomainConstraintCache *)\n\t\t\t\t\tMemoryContextAlloc(cxt, sizeof(DomainConstraintCache));\n\t\t\t\tdcc->constraints = NIL;\n\t\t\t\tdcc->dccContext = cxt;\n\t\t\t\tdcc->dccRefCount = 0;\n\t\t\t}\n\n\t\t\t/* Create node trees in DomainConstraintCache's context */\n\t\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\n\t\t\tcheck_expr = (Expr *) stringToNode(constring);\n\n\t\t\t/* ExecInitExpr will assume we've planned the expression */\n\t\t\tcheck_expr = expression_planner(check_expr);\n\n\t\t\tr = makeNode(DomainConstraintState);\n\t\t\tr->constrainttype = DOM_CONSTRAINT_CHECK;\n\t\t\tr->name = pstrdup(NameStr(c->conname));\n\t\t\tr->check_expr = check_expr;\n\t\t\tr->check_exprstate = NULL;\n\n\t\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t\t/* Accumulate constraints in an array, for sorting below */\n\t\t\tif (ccons == NULL)\n\t\t\t{\n\t\t\t\tcconslen = 8;\n\t\t\t\tccons = (DomainConstraintState **)\n\t\t\t\t\tpalloc(cconslen * sizeof(DomainConstraintState *));\n\t\t\t}\n\t\t\telse if (nccons >= cconslen)\n\t\t\t{\n\t\t\t\tcconslen *= 2;\n\t\t\t\tccons = (DomainConstraintState **)\n\t\t\t\t\trepalloc(ccons, cconslen * sizeof(DomainConstraintState *));\n\t\t\t}\n\t\t\tccons[nccons++] = r;\n\t\t}\n\n\t\tsystable_endscan(scan);\n\n\t\tif (nccons > 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Sort the items for this domain, so that CHECKs are applied in a\n\t\t\t * deterministic order.\n\t\t\t */\n\t\t\tif (nccons > 1)\n\t\t\t\tqsort(ccons, nccons, sizeof(DomainConstraintState *), dcs_cmp);\n\n\t\t\t/*\n\t\t\t * Now attach them to the overall list.  Use lcons() here because\n\t\t\t * constraints of parent domains should be applied earlier.\n\t\t\t */\n\t\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\t\t\twhile (nccons > 0)\n\t\t\t\tdcc->constraints = lcons(ccons[--nccons], dcc->constraints);\n\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t}\n\n\t\t/* loop to next domain in stack */\n\t\ttypeOid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\theap_close(conRel, AccessShareLock);\n\n\t/*\n\t * Only need to add one NOT NULL check regardless of how many domains in\n\t * the stack request it.\n\t */\n\tif (notNull)\n\t{\n\t\tDomainConstraintState *r;\n\n\t\t/* Create the DomainConstraintCache object and context if needed */\n\t\tif (dcc == NULL)\n\t\t{\n\t\t\tMemoryContext cxt;\n\n\t\t\tcxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"Domain constraints\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_SMALL_SIZES);\n\t\t\tdcc = (DomainConstraintCache *)\n\t\t\t\tMemoryContextAlloc(cxt, sizeof(DomainConstraintCache));\n\t\t\tdcc->constraints = NIL;\n\t\t\tdcc->dccContext = cxt;\n\t\t\tdcc->dccRefCount = 0;\n\t\t}\n\n\t\t/* Create node trees in DomainConstraintCache's context */\n\t\toldcxt = MemoryContextSwitchTo(dcc->dccContext);\n\n\t\tr = makeNode(DomainConstraintState);\n\n\t\tr->constrainttype = DOM_CONSTRAINT_NOTNULL;\n\t\tr->name = pstrdup(\"NOT NULL\");\n\t\tr->check_expr = NULL;\n\t\tr->check_exprstate = NULL;\n\n\t\t/* lcons to apply the nullness check FIRST */\n\t\tdcc->constraints = lcons(r, dcc->constraints);\n\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * If we made a constraint object, move it into CacheMemoryContext and\n\t * attach it to the typcache entry.\n\t */\n\tif (dcc)\n\t{\n\t\tMemoryContextSetParent(dcc->dccContext, CacheMemoryContext);\n\t\ttypentry->domainData = dcc;\n\t\tdcc->dccRefCount++;\t\t/* count the typcache's reference */\n\t}\n\n\t/* Either way, the typcache entry's domain data is now valid. */\n\ttypentry->flags |= TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getBaseTypeAndTypmod",
          "args": [
            "type_id",
            "&typentry->domainBaseTypmod"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "getBaseTypeAndTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2315-2345",
          "snippet": "Oid\ngetBaseTypeAndTypmod(Oid typid, int32 *typmod)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so done */\n\t\t\tReleaseSysCache(tup);\n\t\t\tbreak;\n\t\t}\n\n\t\tAssert(*typmod == -1);\n\t\ttypid = typTup->typbasetype;\n\t\t*typmod = typTup->typtypmod;\n\n\t\tReleaseSysCache(tup);\n\t}\n\n\treturn typid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\ngetBaseTypeAndTypmod(Oid typid, int32 *typmod)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so done */\n\t\t\tReleaseSysCache(tup);\n\t\t\tbreak;\n\t\t}\n\n\t\tAssert(*typmod == -1);\n\t\ttypid = typTup->typbasetype;\n\t\t*typmod = typTup->typtypmod;\n\n\t\tReleaseSysCache(tup);\n\t}\n\n\treturn typid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_rangetype_info",
          "args": [
            "typentry"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "load_rangetype_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "817-868",
          "snippet": "static void\nload_rangetype_info(TypeCacheEntry *typentry)\n{\n\tForm_pg_range pg_range;\n\tHeapTuple\ttup;\n\tOid\t\t\tsubtypeOid;\n\tOid\t\t\topclassOid;\n\tOid\t\t\tcanonicalOid;\n\tOid\t\t\tsubdiffOid;\n\tOid\t\t\topfamilyOid;\n\tOid\t\t\topcintype;\n\tOid\t\t\tcmpFnOid;\n\n\t/* get information from pg_range */\n\ttup = SearchSysCache1(RANGETYPE, ObjectIdGetDatum(typentry->type_id));\n\t/* should not fail, since we already checked typtype ... */\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for range type %u\",\n\t\t\t typentry->type_id);\n\tpg_range = (Form_pg_range) GETSTRUCT(tup);\n\n\tsubtypeOid = pg_range->rngsubtype;\n\ttypentry->rng_collation = pg_range->rngcollation;\n\topclassOid = pg_range->rngsubopc;\n\tcanonicalOid = pg_range->rngcanonical;\n\tsubdiffOid = pg_range->rngsubdiff;\n\n\tReleaseSysCache(tup);\n\n\t/* get opclass properties and look up the comparison function */\n\topfamilyOid = get_opclass_family(opclassOid);\n\topcintype = get_opclass_input_type(opclassOid);\n\n\tcmpFnOid = get_opfamily_proc(opfamilyOid, opcintype, opcintype,\n\t\t\t\t\t\t\t\t BTORDER_PROC);\n\tif (!RegProcedureIsValid(cmpFnOid))\n\t\telog(ERROR, \"missing support function %d(%u,%u) in opfamily %u\",\n\t\t\t BTORDER_PROC, opcintype, opcintype, opfamilyOid);\n\n\t/* set up cached fmgrinfo structs */\n\tfmgr_info_cxt(cmpFnOid, &typentry->rng_cmp_proc_finfo,\n\t\t\t\t  CacheMemoryContext);\n\tif (OidIsValid(canonicalOid))\n\t\tfmgr_info_cxt(canonicalOid, &typentry->rng_canonical_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\tif (OidIsValid(subdiffOid))\n\t\tfmgr_info_cxt(subdiffOid, &typentry->rng_subdiff_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t/* Lastly, set up link to the element type --- this marks data valid */\n\ttypentry->rngelemtype = lookup_type_cache(subtypeOid, 0);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic void\nload_rangetype_info(TypeCacheEntry *typentry)\n{\n\tForm_pg_range pg_range;\n\tHeapTuple\ttup;\n\tOid\t\t\tsubtypeOid;\n\tOid\t\t\topclassOid;\n\tOid\t\t\tcanonicalOid;\n\tOid\t\t\tsubdiffOid;\n\tOid\t\t\topfamilyOid;\n\tOid\t\t\topcintype;\n\tOid\t\t\tcmpFnOid;\n\n\t/* get information from pg_range */\n\ttup = SearchSysCache1(RANGETYPE, ObjectIdGetDatum(typentry->type_id));\n\t/* should not fail, since we already checked typtype ... */\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for range type %u\",\n\t\t\t typentry->type_id);\n\tpg_range = (Form_pg_range) GETSTRUCT(tup);\n\n\tsubtypeOid = pg_range->rngsubtype;\n\ttypentry->rng_collation = pg_range->rngcollation;\n\topclassOid = pg_range->rngsubopc;\n\tcanonicalOid = pg_range->rngcanonical;\n\tsubdiffOid = pg_range->rngsubdiff;\n\n\tReleaseSysCache(tup);\n\n\t/* get opclass properties and look up the comparison function */\n\topfamilyOid = get_opclass_family(opclassOid);\n\topcintype = get_opclass_input_type(opclassOid);\n\n\tcmpFnOid = get_opfamily_proc(opfamilyOid, opcintype, opcintype,\n\t\t\t\t\t\t\t\t BTORDER_PROC);\n\tif (!RegProcedureIsValid(cmpFnOid))\n\t\telog(ERROR, \"missing support function %d(%u,%u) in opfamily %u\",\n\t\t\t BTORDER_PROC, opcintype, opcintype, opfamilyOid);\n\n\t/* set up cached fmgrinfo structs */\n\tfmgr_info_cxt(cmpFnOid, &typentry->rng_cmp_proc_finfo,\n\t\t\t\t  CacheMemoryContext);\n\tif (OidIsValid(canonicalOid))\n\t\tfmgr_info_cxt(canonicalOid, &typentry->rng_canonical_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\tif (OidIsValid(subdiffOid))\n\t\tfmgr_info_cxt(subdiffOid, &typentry->rng_subdiff_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t/* Lastly, set up link to the element type --- this marks data valid */\n\ttypentry->rngelemtype = lookup_type_cache(subtypeOid, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_typcache_tupdesc",
          "args": [
            "typentry"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "load_typcache_tupdesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "783-812",
          "snippet": "static void\nload_typcache_tupdesc(TypeCacheEntry *typentry)\n{\n\tRelation\trel;\n\n\tif (!OidIsValid(typentry->typrelid))\t/* should not happen */\n\t\telog(ERROR, \"invalid typrelid for composite type %u\",\n\t\t\t typentry->type_id);\n\trel = relation_open(typentry->typrelid, AccessShareLock);\n\tAssert(rel->rd_rel->reltype == typentry->type_id);\n\n\t/*\n\t * Link to the tupdesc and increment its refcount (we assert it's a\n\t * refcounted descriptor).  We don't use IncrTupleDescRefCount() for this,\n\t * because the reference mustn't be entered in the current resource owner;\n\t * it can outlive the current query.\n\t */\n\ttypentry->tupDesc = RelationGetDescr(rel);\n\n\tAssert(typentry->tupDesc->tdrefcount > 0);\n\ttypentry->tupDesc->tdrefcount++;\n\n\t/*\n\t * In future, we could take some pains to not change tupDesc_identifier if\n\t * the tupdesc didn't really change; but for now it's not worth it.\n\t */\n\ttypentry->tupDesc_identifier = ++tupledesc_id_counter;\n\n\trelation_close(rel, AccessShareLock);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nstatic void\nload_typcache_tupdesc(TypeCacheEntry *typentry)\n{\n\tRelation\trel;\n\n\tif (!OidIsValid(typentry->typrelid))\t/* should not happen */\n\t\telog(ERROR, \"invalid typrelid for composite type %u\",\n\t\t\t typentry->type_id);\n\trel = relation_open(typentry->typrelid, AccessShareLock);\n\tAssert(rel->rd_rel->reltype == typentry->type_id);\n\n\t/*\n\t * Link to the tupdesc and increment its refcount (we assert it's a\n\t * refcounted descriptor).  We don't use IncrTupleDescRefCount() for this,\n\t * because the reference mustn't be entered in the current resource owner;\n\t * it can outlive the current query.\n\t */\n\ttypentry->tupDesc = RelationGetDescr(rel);\n\n\tAssert(typentry->tupDesc->tdrefcount > 0);\n\ttypentry->tupDesc->tdrefcount++;\n\n\t/*\n\t * In future, we could take some pains to not change tupDesc_identifier if\n\t * the tupdesc didn't really change; but for now it's not worth it.\n\t */\n\ttypentry->tupDesc_identifier = ++tupledesc_id_counter;\n\n\trelation_close(rel, AccessShareLock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "typentry->hash_extended_proc",
            "&typentry->hash_extended_proc_finfo",
            "CacheMemoryContext"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opcode",
          "args": [
            "typentry->eq_opr"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "get_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1078-1095",
          "snippet": "RegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_element_has_extended_hashing",
          "args": [
            "typentry"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "range_element_has_extended_hashing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1476-1482",
          "snippet": "static bool\nrange_element_has_extended_hashing(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_range_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_EXTENDED_HASHING) != 0;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000",
            "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic bool\nrange_element_has_extended_hashing(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_range_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_EXTENDED_HASHING) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_element_has_extended_hashing",
          "args": [
            "typentry"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "array_element_has_extended_hashing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1328-1334",
          "snippet": "static bool\narray_element_has_extended_hashing(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_array_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_EXTENDED_HASHING) != 0;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000",
            "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_EXTENDED_HASHING\t0x001000\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic bool\narray_element_has_extended_hashing(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_array_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_EXTENDED_HASHING) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opfamily_proc",
          "args": [
            "typentry->hash_opf",
            "typentry->hash_opintype",
            "typentry->hash_opintype",
            "HASHEXTENDED_PROC"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "get_opfamily_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "743-761",
          "snippet": "Oid\nget_opfamily_proc(Oid opfamily, Oid lefttype, Oid righttype, int16 procnum)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amproc amproc_tup;\n\tRegProcedure result;\n\n\ttp = SearchSysCache4(AMPROCNUM,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(procnum));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamproc_tup = (Form_pg_amproc) GETSTRUCT(tp);\n\tresult = amproc_tup->amproc;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_opfamily_proc(Oid opfamily, Oid lefttype, Oid righttype, int16 procnum)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amproc amproc_tup;\n\tRegProcedure result;\n\n\ttp = SearchSysCache4(AMPROCNUM,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(procnum));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamproc_tup = (Form_pg_amproc) GETSTRUCT(tp);\n\tresult = amproc_tup->amproc;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opfamily_member",
          "args": [
            "typentry->hash_opf",
            "typentry->hash_opintype",
            "typentry->hash_opintype",
            "HTEqualStrategyNumber"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "get_opfamily_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "162-181",
          "snippet": "Oid\nget_opfamily_member(Oid opfamily, Oid lefttype, Oid righttype,\n\t\t\t\t\tint16 strategy)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache4(AMOPSTRATEGY,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(strategy));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopopr;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_opfamily_member(Oid opfamily, Oid lefttype, Oid righttype,\n\t\t\t\t\tint16 strategy)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache4(AMOPSTRATEGY,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(strategy));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopopr;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->eq_opr"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_element_has_hashing",
          "args": [
            "typentry"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "range_element_has_hashing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1468-1474",
          "snippet": "static bool\nrange_element_has_hashing(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_range_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_HASHING) != 0;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800",
            "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic bool\nrange_element_has_hashing(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_range_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_HASHING) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_element_has_hashing",
          "args": [
            "typentry"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "array_element_has_hashing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1320-1326",
          "snippet": "static bool\narray_element_has_hashing(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_array_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_HASHING) != 0;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800",
            "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_HASHING\t\t\t0x000800\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic bool\narray_element_has_hashing(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_array_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_HASHING) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->eq_opr"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_fields_have_compare",
          "args": [
            "typentry"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "record_fields_have_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1374-1380",
          "snippet": "static bool\nrecord_fields_have_compare(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_FIELD_PROPERTIES))\n\t\tcache_record_field_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_FIELD_COMPARE) != 0;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_HAVE_FIELD_COMPARE\t\t\t0x008000",
            "#define TCFLAGS_CHECKED_FIELD_PROPERTIES\t0x002000"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_FIELD_COMPARE\t\t\t0x008000\n#define TCFLAGS_CHECKED_FIELD_PROPERTIES\t0x002000\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic bool\nrecord_fields_have_compare(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_FIELD_PROPERTIES))\n\t\tcache_record_field_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_FIELD_COMPARE) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_element_has_compare",
          "args": [
            "typentry"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "array_element_has_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1312-1318",
          "snippet": "static bool\narray_element_has_compare(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_array_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_COMPARE) != 0;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_HAVE_ELEM_COMPARE\t\t\t0x000400",
            "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_COMPARE\t\t\t0x000400\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic bool\narray_element_has_compare(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_array_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_COMPARE) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "record_fields_have_equality",
          "args": [
            "typentry"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "record_fields_have_equality",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1366-1372",
          "snippet": "static bool\nrecord_fields_have_equality(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_FIELD_PROPERTIES))\n\t\tcache_record_field_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_FIELD_EQUALITY) != 0;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_HAVE_FIELD_EQUALITY\t\t\t0x004000",
            "#define TCFLAGS_CHECKED_FIELD_PROPERTIES\t0x002000"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_FIELD_EQUALITY\t\t\t0x004000\n#define TCFLAGS_CHECKED_FIELD_PROPERTIES\t0x002000\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic bool\nrecord_fields_have_equality(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_FIELD_PROPERTIES))\n\t\tcache_record_field_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_FIELD_EQUALITY) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_element_has_equality",
          "args": [
            "typentry"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "array_element_has_equality",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1304-1310",
          "snippet": "static bool\narray_element_has_equality(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_array_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_EQUALITY) != 0;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_HAVE_ELEM_EQUALITY\t\t\t0x000200",
            "#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_HAVE_ELEM_EQUALITY\t\t\t0x000200\n#define TCFLAGS_CHECKED_ELEM_PROPERTIES\t\t0x000100\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\n\nstatic bool\narray_element_has_equality(TypeCacheEntry *typentry)\n{\n\tif (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES))\n\t\tcache_array_element_properties(typentry);\n\treturn (typentry->flags & TCFLAGS_HAVE_ELEM_EQUALITY) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opclass_input_type",
          "args": [
            "opclass"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "get_opclass_input_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1053-1068",
          "snippet": "Oid\nget_opclass_input_type(Oid opclass)\n{\n\tHeapTuple\ttp;\n\tForm_pg_opclass cla_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache1(CLAOID, ObjectIdGetDatum(opclass));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for opclass %u\", opclass);\n\tcla_tup = (Form_pg_opclass) GETSTRUCT(tp);\n\n\tresult = cla_tup->opcintype;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_opclass_input_type(Oid opclass)\n{\n\tHeapTuple\ttp;\n\tForm_pg_opclass cla_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache1(CLAOID, ObjectIdGetDatum(opclass));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for opclass %u\", opclass);\n\tcla_tup = (Form_pg_opclass) GETSTRUCT(tp);\n\n\tresult = cla_tup->opcintype;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opclass_family",
          "args": [
            "opclass"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "get_opclass_family",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1031-1046",
          "snippet": "Oid\nget_opclass_family(Oid opclass)\n{\n\tHeapTuple\ttp;\n\tForm_pg_opclass cla_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache1(CLAOID, ObjectIdGetDatum(opclass));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for opclass %u\", opclass);\n\tcla_tup = (Form_pg_opclass) GETSTRUCT(tp);\n\n\tresult = cla_tup->opcfamily;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_opclass_family(Oid opclass)\n{\n\tHeapTuple\ttp;\n\tForm_pg_opclass cla_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache1(CLAOID, ObjectIdGetDatum(opclass));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for opclass %u\", opclass);\n\tcla_tup = (Form_pg_opclass) GETSTRUCT(tp);\n\n\tresult = cla_tup->opcfamily;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "opclass"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultOpClass",
          "args": [
            "type_id",
            "HASH_AM_OID"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "opclass"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultOpClass",
          "args": [
            "type_id",
            "BTREE_AM_OID"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tp"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "typentry",
            "0",
            "sizeof(TypeCacheEntry)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!found"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "TypeCacheHash",
            "(void *) &type_id",
            "HASH_ENTER",
            "&found"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname)))"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"type \\\"%s\\\" is only a shell\"",
            "NameStr(typtup->typname)"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "typtup->typname"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_OBJECT"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tp"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id))"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tp"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "TYPEOID",
            "ObjectIdGetDatum(type_id)"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "type_id"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateCacheMemoryContext",
          "args": [],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "CreateCacheMemoryContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "635-646",
          "snippet": "void\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nvoid\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CacheRegisterSyscacheCallback",
          "args": [
            "TYPEOID",
            "TypeCacheConstrCallback",
            "(Datum) 0"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "CacheRegisterSyscacheCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1425-1456",
          "snippet": "void\nCacheRegisterSyscacheCallback(int cacheid,\n\t\t\t\t\t\t\t  SyscacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(FATAL, \"invalid cache ID: %d\", cacheid);\n\tif (syscache_callback_count >= MAX_SYSCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of syscache_callback_list slots\");\n\n\tif (syscache_callback_links[cacheid] == 0)\n\t{\n\t\t/* first callback for this cache */\n\t\tsyscache_callback_links[cacheid] = syscache_callback_count + 1;\n\t}\n\telse\n\t{\n\t\t/* add to end of chain, so that older callbacks are called first */\n\t\tint\t\t\ti = syscache_callback_links[cacheid] - 1;\n\n\t\twhile (syscache_callback_list[i].link > 0)\n\t\t\ti = syscache_callback_list[i].link - 1;\n\t\tsyscache_callback_list[i].link = syscache_callback_count + 1;\n\t}\n\n\tsyscache_callback_list[syscache_callback_count].id = cacheid;\n\tsyscache_callback_list[syscache_callback_count].link = 0;\n\tsyscache_callback_list[syscache_callback_count].function = func;\n\tsyscache_callback_list[syscache_callback_count].arg = arg;\n\n\t++syscache_callback_count;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_SYSCACHE_CALLBACKS 64"
          ],
          "globals_used": [
            "static struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];",
            "static int16 syscache_callback_links[SysCacheSize];",
            "static int\tsyscache_callback_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MAX_SYSCACHE_CALLBACKS 64\n\nstatic struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];\nstatic int16 syscache_callback_links[SysCacheSize];\nstatic int\tsyscache_callback_count = 0;\n\nvoid\nCacheRegisterSyscacheCallback(int cacheid,\n\t\t\t\t\t\t\t  SyscacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(FATAL, \"invalid cache ID: %d\", cacheid);\n\tif (syscache_callback_count >= MAX_SYSCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of syscache_callback_list slots\");\n\n\tif (syscache_callback_links[cacheid] == 0)\n\t{\n\t\t/* first callback for this cache */\n\t\tsyscache_callback_links[cacheid] = syscache_callback_count + 1;\n\t}\n\telse\n\t{\n\t\t/* add to end of chain, so that older callbacks are called first */\n\t\tint\t\t\ti = syscache_callback_links[cacheid] - 1;\n\n\t\twhile (syscache_callback_list[i].link > 0)\n\t\t\ti = syscache_callback_list[i].link - 1;\n\t\tsyscache_callback_list[i].link = syscache_callback_count + 1;\n\t}\n\n\tsyscache_callback_list[syscache_callback_count].id = cacheid;\n\tsyscache_callback_list[syscache_callback_count].link = 0;\n\tsyscache_callback_list[syscache_callback_count].function = func;\n\tsyscache_callback_list[syscache_callback_count].arg = arg;\n\n\t++syscache_callback_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CacheRegisterRelcacheCallback",
          "args": [
            "TypeCacheRelCallback",
            "(Datum) 0"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "CacheRegisterRelcacheCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1467-1478",
          "snippet": "void\nCacheRegisterRelcacheCallback(RelcacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (relcache_callback_count >= MAX_RELCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of relcache_callback_list slots\");\n\n\trelcache_callback_list[relcache_callback_count].function = func;\n\trelcache_callback_list[relcache_callback_count].arg = arg;\n\n\t++relcache_callback_count;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_RELCACHE_CALLBACKS 10"
          ],
          "globals_used": [
            "static struct RELCACHECALLBACK\n{\n\tRelcacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\trelcache_callback_list[MAX_RELCACHE_CALLBACKS];",
            "static int\trelcache_callback_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MAX_RELCACHE_CALLBACKS 10\n\nstatic struct RELCACHECALLBACK\n{\n\tRelcacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\trelcache_callback_list[MAX_RELCACHE_CALLBACKS];\nstatic int\trelcache_callback_count = 0;\n\nvoid\nCacheRegisterRelcacheCallback(RelcacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (relcache_callback_count >= MAX_RELCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of relcache_callback_list slots\");\n\n\trelcache_callback_list[relcache_callback_count].function = func;\n\trelcache_callback_list[relcache_callback_count].arg = arg;\n\n\t++relcache_callback_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_create",
          "args": [
            "\"Type information cache\"",
            "64",
            "&ctl",
            "HASH_ELEM | HASH_BLOBS"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "hash_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "315-564",
          "snippet": "HTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_FREELISTS\t\t\t32"
          ],
          "globals_used": [
            "static void *DynaHashAlloc(Size size);",
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static int\tchoose_nelem_alloc(Size entrysize);",
            "static bool init_htab(HTAB *hashp, long nelem);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);",
            "static MemoryContext CurrentDynaHashCxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define NUM_FREELISTS\t\t\t32\n\nstatic void *DynaHashAlloc(Size size);\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic int\tchoose_nelem_alloc(Size entrysize);\nstatic bool init_htab(HTAB *hashp, long nelem);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\nstatic MemoryContext CurrentDynaHashCxt = NULL;\n\nHTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&ctl",
            "0",
            "sizeof(ctl)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
  },
  {
    "function_name": "shared_record_table_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "229-242",
    "snippet": "static uint32\nshared_record_table_hash(const void *a, size_t size, void *arg)\n{\n\tdsa_area   *area = (dsa_area *) arg;\n\tSharedRecordTableKey *k = (SharedRecordTableKey *) a;\n\tTupleDesc\tt;\n\n\tif (k->shared)\n\t\tt = (TupleDesc) dsa_get_address(area, k->u.shared_tupdesc);\n\telse\n\t\tt = k->u.local_tupdesc;\n\n\treturn hashTupleDesc(t);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void dccref_deletion_callback(void *arg);",
      "static EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashTupleDesc",
          "args": [
            "t"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_get_address",
          "args": [
            "area",
            "k->u.shared_tupdesc"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "931-957",
          "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dccref_deletion_callback(void *arg);\nstatic EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);\n\nstatic uint32\nshared_record_table_hash(const void *a, size_t size, void *arg)\n{\n\tdsa_area   *area = (dsa_area *) arg;\n\tSharedRecordTableKey *k = (SharedRecordTableKey *) a;\n\tTupleDesc\tt;\n\n\tif (k->shared)\n\t\tt = (TupleDesc) dsa_get_address(area, k->u.shared_tupdesc);\n\telse\n\t\tt = k->u.local_tupdesc;\n\n\treturn hashTupleDesc(t);\n}"
  },
  {
    "function_name": "shared_record_table_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
    "lines": "203-224",
    "snippet": "static int\nshared_record_table_compare(const void *a, const void *b, size_t size,\n\t\t\t\t\t\t\tvoid *arg)\n{\n\tdsa_area   *area = (dsa_area *) arg;\n\tSharedRecordTableKey *k1 = (SharedRecordTableKey *) a;\n\tSharedRecordTableKey *k2 = (SharedRecordTableKey *) b;\n\tTupleDesc\tt1;\n\tTupleDesc\tt2;\n\n\tif (k1->shared)\n\t\tt1 = (TupleDesc) dsa_get_address(area, k1->u.shared_tupdesc);\n\telse\n\t\tt1 = k1->u.local_tupdesc;\n\n\tif (k2->shared)\n\t\tt2 = (TupleDesc) dsa_get_address(area, k2->u.shared_tupdesc);\n\telse\n\t\tt2 = k2->u.local_tupdesc;\n\n\treturn equalTupleDescs(t1, t2) ? 0 : 1;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"lib/dshash.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/defrem.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_range.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/session.h\"",
      "#include \"access/parallel.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tdcs_cmp(const void *a, const void *b);",
      "static void dccref_deletion_callback(void *arg);",
      "static EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "equalTupleDescs",
          "args": [
            "t1",
            "t2"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_get_address",
          "args": [
            "area",
            "k2->u.shared_tupdesc"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "931-957",
          "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\tdcs_cmp(const void *a, const void *b);\nstatic void dccref_deletion_callback(void *arg);\nstatic EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);\n\nstatic int\nshared_record_table_compare(const void *a, const void *b, size_t size,\n\t\t\t\t\t\t\tvoid *arg)\n{\n\tdsa_area   *area = (dsa_area *) arg;\n\tSharedRecordTableKey *k1 = (SharedRecordTableKey *) a;\n\tSharedRecordTableKey *k2 = (SharedRecordTableKey *) b;\n\tTupleDesc\tt1;\n\tTupleDesc\tt2;\n\n\tif (k1->shared)\n\t\tt1 = (TupleDesc) dsa_get_address(area, k1->u.shared_tupdesc);\n\telse\n\t\tt1 = k1->u.local_tupdesc;\n\n\tif (k2->shared)\n\t\tt2 = (TupleDesc) dsa_get_address(area, k2->u.shared_tupdesc);\n\telse\n\t\tt2 = k2->u.local_tupdesc;\n\n\treturn equalTupleDescs(t1, t2) ? 0 : 1;\n}"
  }
]