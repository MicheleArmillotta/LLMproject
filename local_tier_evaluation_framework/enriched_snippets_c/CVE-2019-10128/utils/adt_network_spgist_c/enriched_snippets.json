[
  {
    "function_name": "inet_spg_consistent_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_spgist.c",
    "lines": "372-711",
    "snippet": "static int\ninet_spg_consistent_bitmap(const inet *prefix, int nkeys, ScanKey scankeys,\n\t\t\t\t\t\t   bool leaf)\n{\n\tint\t\t\tbitmap;\n\tint\t\t\tcommonbits,\n\t\t\t\ti;\n\n\t/* Initialize result to allow visiting all children */\n\tif (leaf)\n\t\tbitmap = 1;\n\telse\n\t\tbitmap = 1 | (1 << 1) | (1 << 2) | (1 << 3);\n\n\tcommonbits = ip_bits(prefix);\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tinet\t   *argument = DatumGetInetPP(scankeys[i].sk_argument);\n\t\tStrategyNumber strategy = scankeys[i].sk_strategy;\n\t\tint\t\t\torder;\n\n\t\t/*\n\t\t * Check 0: different families\n\t\t *\n\t\t * Matching families do not help any of the strategies.\n\t\t */\n\t\tif (ip_family(argument) != ip_family(prefix))\n\t\t{\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (ip_family(argument) < ip_family(prefix))\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (ip_family(argument) > ip_family(prefix))\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* For all other cases, we can be sure there is no match */\n\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\n\t\t\t/* Other checks make no sense with different families. */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check 1: network bit count\n\t\t *\n\t\t * Network bit count (ip_bits) helps to check leaves for sub network\n\t\t * and sup network operators.  At non-leaf nodes, we know every child\n\t\t * value has greater ip_bits, so we can avoid descending in some cases\n\t\t * too.\n\t\t *\n\t\t * This check is less expensive than checking the address bits, so we\n\t\t * are doing this before, but it has to be done after for the basic\n\t\t * comparison strategies, because ip_bits only affect their results\n\t\t * when the common network bits are the same.\n\t\t */\n\t\tswitch (strategy)\n\t\t{\n\t\t\tcase RTSubStrategyNumber:\n\t\t\t\tif (commonbits <= ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\n\t\t\tcase RTSubEqualStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\n\t\t\tcase RTSuperStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument) - 1)\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits >= ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTSuperEqualStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits > ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTEqualStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\telse if (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bitmap)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check 2: common network bits\n\t\t *\n\t\t * Compare available common prefix bits to the query, but not beyond\n\t\t * either the query's netmask or the minimum netmask among the\n\t\t * represented values.  If these bits don't match the query, we can\n\t\t * eliminate some cases.\n\t\t */\n\t\torder = bitncmp(ip_addr(prefix), ip_addr(argument),\n\t\t\t\t\t\tMin(commonbits, ip_bits(argument)));\n\n\t\tif (order != 0)\n\t\t{\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (order > 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (order < 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* For all other cases, we can be sure there is no match */\n\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Remaining checks make no sense when common bits don't match.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check 3: next network bit\n\t\t *\n\t\t * We can filter out branch 2 or 3 using the next network bit of the\n\t\t * argument, if it is available.\n\t\t *\n\t\t * This check matters for the performance of the search. The results\n\t\t * would be correct without it.\n\t\t */\n\t\tif (bitmap & ((1 << 2) | (1 << 3)) &&\n\t\t\tcommonbits < ip_bits(argument))\n\t\t{\n\t\t\tint\t\t\tnextbit;\n\n\t\t\tnextbit = ip_addr(argument)[commonbits / 8] &\n\t\t\t\t(1 << (7 - commonbits % 8));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 2);\n\t\t\t\t\telse\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 3);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Remaining checks are only for the basic comparison strategies. This\n\t\t * test relies on the strategy number ordering defined in stratnum.h.\n\t\t */\n\t\tif (strategy < RTEqualStrategyNumber ||\n\t\t\tstrategy > RTGreaterEqualStrategyNumber)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check 4: network bit count\n\t\t *\n\t\t * At this point, we know that the common network bits of the prefix\n\t\t * and the argument are the same, so we can go forward and check the\n\t\t * ip_bits.\n\t\t */\n\t\tswitch (strategy)\n\t\t{\n\t\t\tcase RTLessStrategyNumber:\n\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits > ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bitmap)\n\t\t\tbreak;\n\n\t\t/* Remaining checks don't make sense with different ip_bits. */\n\t\tif (commonbits != ip_bits(argument))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check 5: next host bit\n\t\t *\n\t\t * We can filter out branch 0 or 1 using the next host bit of the\n\t\t * argument, if it is available.\n\t\t *\n\t\t * This check matters for the performance of the search. The results\n\t\t * would be correct without it.  There is no point in running it for\n\t\t * leafs as we have to check the whole address on the next step.\n\t\t */\n\t\tif (!leaf && bitmap & (1 | (1 << 1)) &&\n\t\t\tcommonbits < ip_maxbits(argument))\n\t\t{\n\t\t\tint\t\t\tnextbit;\n\n\t\t\tnextbit = ip_addr(argument)[commonbits / 8] &\n\t\t\t\t(1 << (7 - commonbits % 8));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (nextbit)\n\t\t\t\t\t\tbitmap &= (1 << 1) | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 2) | (1 << 3);\n\t\t\t\t\telse\n\t\t\t\t\t\tbitmap &= (1 << 1) | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check 6: whole address\n\t\t *\n\t\t * This is the last check for correctness of the basic comparison\n\t\t * strategies.  It's only appropriate at leaf entries.\n\t\t */\n\t\tif (leaf)\n\t\t{\n\t\t\t/* Redo ordering comparison using all address bits */\n\t\t\torder = bitncmp(ip_addr(prefix), ip_addr(argument),\n\t\t\t\t\t\t\tip_maxbits(prefix));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\t\tif (order >= 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (order > 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTEqualStrategyNumber:\n\t\t\t\t\tif (order != 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\t\tif (order < 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (order <= 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tif (order == 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bitmap;\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/spgist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tinet_spg_node_number(const inet *val, int commonbits);",
      "static int inet_spg_consistent_bitmap(const inet *prefix, int nkeys,\n\t\t\t\t\t\t   ScanKey scankeys, bool leaf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitncmp",
          "args": [
            "ip_addr(prefix)",
            "ip_addr(argument)",
            "ip_maxbits(prefix)"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "bitncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network.c",
          "lines": "976-1003",
          "snippet": "int\nbitncmp(const unsigned char *l, const unsigned char *r, int n)\n{\n\tunsigned int lb,\n\t\t\t\trb;\n\tint\t\t\tx,\n\t\t\t\tb;\n\n\tb = n / 8;\n\tx = memcmp(l, r, b);\n\tif (x || (n % 8) == 0)\n\t\treturn x;\n\n\tlb = l[b];\n\trb = r[b];\n\tfor (b = n % 8; b > 0; b--)\n\t{\n\t\tif (IS_HIGHBIT_SET(lb) != IS_HIGHBIT_SET(rb))\n\t\t{\n\t\t\tif (IS_HIGHBIT_SET(lb))\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t}\n\t\tlb <<= 1;\n\t\trb <<= 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"common/ip.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq-be.h\"\n#include \"common/ip.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nint\nbitncmp(const unsigned char *l, const unsigned char *r, int n)\n{\n\tunsigned int lb,\n\t\t\t\trb;\n\tint\t\t\tx,\n\t\t\t\tb;\n\n\tb = n / 8;\n\tx = memcmp(l, r, b);\n\tif (x || (n % 8) == 0)\n\t\treturn x;\n\n\tlb = l[b];\n\trb = r[b];\n\tfor (b = n % 8; b > 0; b--)\n\t{\n\t\tif (IS_HIGHBIT_SET(lb) != IS_HIGHBIT_SET(rb))\n\t\t{\n\t\t\tif (IS_HIGHBIT_SET(lb))\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t}\n\t\tlb <<= 1;\n\t\trb <<= 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ip_maxbits",
          "args": [
            "prefix"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "argument"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "prefix"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "argument"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_maxbits",
          "args": [
            "argument"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "argument"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "argument"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "argument"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "argument"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "argument"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "argument"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "commonbits",
            "ip_bits(argument)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "argument"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "argument"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "prefix"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "argument"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "argument"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "argument"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "argument"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "argument"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "argument"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "argument"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "argument"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "prefix"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "argument"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "prefix"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "argument"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "prefix"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "argument"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetPP",
          "args": [
            "scankeys[i].sk_argument"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "prefix"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/spgist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_spg_node_number(const inet *val, int commonbits);\nstatic int inet_spg_consistent_bitmap(const inet *prefix, int nkeys,\n\t\t\t\t\t\t   ScanKey scankeys, bool leaf);\n\nstatic int\ninet_spg_consistent_bitmap(const inet *prefix, int nkeys, ScanKey scankeys,\n\t\t\t\t\t\t   bool leaf)\n{\n\tint\t\t\tbitmap;\n\tint\t\t\tcommonbits,\n\t\t\t\ti;\n\n\t/* Initialize result to allow visiting all children */\n\tif (leaf)\n\t\tbitmap = 1;\n\telse\n\t\tbitmap = 1 | (1 << 1) | (1 << 2) | (1 << 3);\n\n\tcommonbits = ip_bits(prefix);\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tinet\t   *argument = DatumGetInetPP(scankeys[i].sk_argument);\n\t\tStrategyNumber strategy = scankeys[i].sk_strategy;\n\t\tint\t\t\torder;\n\n\t\t/*\n\t\t * Check 0: different families\n\t\t *\n\t\t * Matching families do not help any of the strategies.\n\t\t */\n\t\tif (ip_family(argument) != ip_family(prefix))\n\t\t{\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (ip_family(argument) < ip_family(prefix))\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (ip_family(argument) > ip_family(prefix))\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* For all other cases, we can be sure there is no match */\n\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\n\t\t\t/* Other checks make no sense with different families. */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check 1: network bit count\n\t\t *\n\t\t * Network bit count (ip_bits) helps to check leaves for sub network\n\t\t * and sup network operators.  At non-leaf nodes, we know every child\n\t\t * value has greater ip_bits, so we can avoid descending in some cases\n\t\t * too.\n\t\t *\n\t\t * This check is less expensive than checking the address bits, so we\n\t\t * are doing this before, but it has to be done after for the basic\n\t\t * comparison strategies, because ip_bits only affect their results\n\t\t * when the common network bits are the same.\n\t\t */\n\t\tswitch (strategy)\n\t\t{\n\t\t\tcase RTSubStrategyNumber:\n\t\t\t\tif (commonbits <= ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\n\t\t\tcase RTSubEqualStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\n\t\t\tcase RTSuperStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument) - 1)\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits >= ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTSuperEqualStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits > ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTEqualStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\telse if (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bitmap)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check 2: common network bits\n\t\t *\n\t\t * Compare available common prefix bits to the query, but not beyond\n\t\t * either the query's netmask or the minimum netmask among the\n\t\t * represented values.  If these bits don't match the query, we can\n\t\t * eliminate some cases.\n\t\t */\n\t\torder = bitncmp(ip_addr(prefix), ip_addr(argument),\n\t\t\t\t\t\tMin(commonbits, ip_bits(argument)));\n\n\t\tif (order != 0)\n\t\t{\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (order > 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (order < 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* For all other cases, we can be sure there is no match */\n\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Remaining checks make no sense when common bits don't match.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check 3: next network bit\n\t\t *\n\t\t * We can filter out branch 2 or 3 using the next network bit of the\n\t\t * argument, if it is available.\n\t\t *\n\t\t * This check matters for the performance of the search. The results\n\t\t * would be correct without it.\n\t\t */\n\t\tif (bitmap & ((1 << 2) | (1 << 3)) &&\n\t\t\tcommonbits < ip_bits(argument))\n\t\t{\n\t\t\tint\t\t\tnextbit;\n\n\t\t\tnextbit = ip_addr(argument)[commonbits / 8] &\n\t\t\t\t(1 << (7 - commonbits % 8));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 2);\n\t\t\t\t\telse\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 3);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Remaining checks are only for the basic comparison strategies. This\n\t\t * test relies on the strategy number ordering defined in stratnum.h.\n\t\t */\n\t\tif (strategy < RTEqualStrategyNumber ||\n\t\t\tstrategy > RTGreaterEqualStrategyNumber)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check 4: network bit count\n\t\t *\n\t\t * At this point, we know that the common network bits of the prefix\n\t\t * and the argument are the same, so we can go forward and check the\n\t\t * ip_bits.\n\t\t */\n\t\tswitch (strategy)\n\t\t{\n\t\t\tcase RTLessStrategyNumber:\n\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits > ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bitmap)\n\t\t\tbreak;\n\n\t\t/* Remaining checks don't make sense with different ip_bits. */\n\t\tif (commonbits != ip_bits(argument))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check 5: next host bit\n\t\t *\n\t\t * We can filter out branch 0 or 1 using the next host bit of the\n\t\t * argument, if it is available.\n\t\t *\n\t\t * This check matters for the performance of the search. The results\n\t\t * would be correct without it.  There is no point in running it for\n\t\t * leafs as we have to check the whole address on the next step.\n\t\t */\n\t\tif (!leaf && bitmap & (1 | (1 << 1)) &&\n\t\t\tcommonbits < ip_maxbits(argument))\n\t\t{\n\t\t\tint\t\t\tnextbit;\n\n\t\t\tnextbit = ip_addr(argument)[commonbits / 8] &\n\t\t\t\t(1 << (7 - commonbits % 8));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (nextbit)\n\t\t\t\t\t\tbitmap &= (1 << 1) | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 2) | (1 << 3);\n\t\t\t\t\telse\n\t\t\t\t\t\tbitmap &= (1 << 1) | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check 6: whole address\n\t\t *\n\t\t * This is the last check for correctness of the basic comparison\n\t\t * strategies.  It's only appropriate at leaf entries.\n\t\t */\n\t\tif (leaf)\n\t\t{\n\t\t\t/* Redo ordering comparison using all address bits */\n\t\t\torder = bitncmp(ip_addr(prefix), ip_addr(argument),\n\t\t\t\t\t\t\tip_maxbits(prefix));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\t\tif (order >= 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (order > 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTEqualStrategyNumber:\n\t\t\t\t\tif (order != 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\t\tif (order < 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (order <= 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tif (order == 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bitmap;\n}"
  },
  {
    "function_name": "inet_spg_node_number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_spgist.c",
    "lines": "348-360",
    "snippet": "static int\ninet_spg_node_number(const inet *val, int commonbits)\n{\n\tint\t\t\tnodeN = 0;\n\n\tif (commonbits < ip_maxbits(val) &&\n\t\tip_addr(val)[commonbits / 8] & (1 << (7 - commonbits % 8)))\n\t\tnodeN |= 1;\n\tif (commonbits < ip_bits(val))\n\t\tnodeN |= 2;\n\n\treturn nodeN;\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/spgist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tinet_spg_node_number(const inet *val, int commonbits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "val"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "val"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_maxbits",
          "args": [
            "val"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/spgist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_spg_node_number(const inet *val, int commonbits);\n\nstatic int\ninet_spg_node_number(const inet *val, int commonbits)\n{\n\tint\t\t\tnodeN = 0;\n\n\tif (commonbits < ip_maxbits(val) &&\n\t\tip_addr(val)[commonbits / 8] & (1 << (7 - commonbits % 8)))\n\t\tnodeN |= 1;\n\tif (commonbits < ip_bits(val))\n\t\tnodeN |= 2;\n\n\treturn nodeN;\n}"
  },
  {
    "function_name": "inet_spg_leaf_consistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_spgist.c",
    "lines": "321-337",
    "snippet": "Datum\ninet_spg_leaf_consistent(PG_FUNCTION_ARGS)\n{\n\tspgLeafConsistentIn *in = (spgLeafConsistentIn *) PG_GETARG_POINTER(0);\n\tspgLeafConsistentOut *out = (spgLeafConsistentOut *) PG_GETARG_POINTER(1);\n\tinet\t   *leaf = DatumGetInetPP(in->leafDatum);\n\n\t/* All tests are exact. */\n\tout->recheck = false;\n\n\t/* Leaf is what it is... */\n\tout->leafValue = InetPGetDatum(leaf);\n\n\t/* Use common code to apply the tests. */\n\tPG_RETURN_BOOL(inet_spg_consistent_bitmap(leaf, in->nkeys, in->scankeys,\n\t\t\t\t\t\t\t\t\t\t\t  true));\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/spgist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int inet_spg_consistent_bitmap(const inet *prefix, int nkeys,\n\t\t\t\t\t\t   ScanKey scankeys, bool leaf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "inet_spg_consistent_bitmap(leaf, in->nkeys, in->scankeys,\n\t\t\t\t\t\t\t\t\t\t\t  true)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_spg_consistent_bitmap",
          "args": [
            "leaf",
            "in->nkeys",
            "in->scankeys",
            "true"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "inet_spg_consistent_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_spgist.c",
          "lines": "372-711",
          "snippet": "static int\ninet_spg_consistent_bitmap(const inet *prefix, int nkeys, ScanKey scankeys,\n\t\t\t\t\t\t   bool leaf)\n{\n\tint\t\t\tbitmap;\n\tint\t\t\tcommonbits,\n\t\t\t\ti;\n\n\t/* Initialize result to allow visiting all children */\n\tif (leaf)\n\t\tbitmap = 1;\n\telse\n\t\tbitmap = 1 | (1 << 1) | (1 << 2) | (1 << 3);\n\n\tcommonbits = ip_bits(prefix);\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tinet\t   *argument = DatumGetInetPP(scankeys[i].sk_argument);\n\t\tStrategyNumber strategy = scankeys[i].sk_strategy;\n\t\tint\t\t\torder;\n\n\t\t/*\n\t\t * Check 0: different families\n\t\t *\n\t\t * Matching families do not help any of the strategies.\n\t\t */\n\t\tif (ip_family(argument) != ip_family(prefix))\n\t\t{\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (ip_family(argument) < ip_family(prefix))\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (ip_family(argument) > ip_family(prefix))\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* For all other cases, we can be sure there is no match */\n\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\n\t\t\t/* Other checks make no sense with different families. */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check 1: network bit count\n\t\t *\n\t\t * Network bit count (ip_bits) helps to check leaves for sub network\n\t\t * and sup network operators.  At non-leaf nodes, we know every child\n\t\t * value has greater ip_bits, so we can avoid descending in some cases\n\t\t * too.\n\t\t *\n\t\t * This check is less expensive than checking the address bits, so we\n\t\t * are doing this before, but it has to be done after for the basic\n\t\t * comparison strategies, because ip_bits only affect their results\n\t\t * when the common network bits are the same.\n\t\t */\n\t\tswitch (strategy)\n\t\t{\n\t\t\tcase RTSubStrategyNumber:\n\t\t\t\tif (commonbits <= ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\n\t\t\tcase RTSubEqualStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\n\t\t\tcase RTSuperStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument) - 1)\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits >= ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTSuperEqualStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits > ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTEqualStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\telse if (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bitmap)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check 2: common network bits\n\t\t *\n\t\t * Compare available common prefix bits to the query, but not beyond\n\t\t * either the query's netmask or the minimum netmask among the\n\t\t * represented values.  If these bits don't match the query, we can\n\t\t * eliminate some cases.\n\t\t */\n\t\torder = bitncmp(ip_addr(prefix), ip_addr(argument),\n\t\t\t\t\t\tMin(commonbits, ip_bits(argument)));\n\n\t\tif (order != 0)\n\t\t{\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (order > 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (order < 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* For all other cases, we can be sure there is no match */\n\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Remaining checks make no sense when common bits don't match.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check 3: next network bit\n\t\t *\n\t\t * We can filter out branch 2 or 3 using the next network bit of the\n\t\t * argument, if it is available.\n\t\t *\n\t\t * This check matters for the performance of the search. The results\n\t\t * would be correct without it.\n\t\t */\n\t\tif (bitmap & ((1 << 2) | (1 << 3)) &&\n\t\t\tcommonbits < ip_bits(argument))\n\t\t{\n\t\t\tint\t\t\tnextbit;\n\n\t\t\tnextbit = ip_addr(argument)[commonbits / 8] &\n\t\t\t\t(1 << (7 - commonbits % 8));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 2);\n\t\t\t\t\telse\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 3);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Remaining checks are only for the basic comparison strategies. This\n\t\t * test relies on the strategy number ordering defined in stratnum.h.\n\t\t */\n\t\tif (strategy < RTEqualStrategyNumber ||\n\t\t\tstrategy > RTGreaterEqualStrategyNumber)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check 4: network bit count\n\t\t *\n\t\t * At this point, we know that the common network bits of the prefix\n\t\t * and the argument are the same, so we can go forward and check the\n\t\t * ip_bits.\n\t\t */\n\t\tswitch (strategy)\n\t\t{\n\t\t\tcase RTLessStrategyNumber:\n\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits > ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bitmap)\n\t\t\tbreak;\n\n\t\t/* Remaining checks don't make sense with different ip_bits. */\n\t\tif (commonbits != ip_bits(argument))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check 5: next host bit\n\t\t *\n\t\t * We can filter out branch 0 or 1 using the next host bit of the\n\t\t * argument, if it is available.\n\t\t *\n\t\t * This check matters for the performance of the search. The results\n\t\t * would be correct without it.  There is no point in running it for\n\t\t * leafs as we have to check the whole address on the next step.\n\t\t */\n\t\tif (!leaf && bitmap & (1 | (1 << 1)) &&\n\t\t\tcommonbits < ip_maxbits(argument))\n\t\t{\n\t\t\tint\t\t\tnextbit;\n\n\t\t\tnextbit = ip_addr(argument)[commonbits / 8] &\n\t\t\t\t(1 << (7 - commonbits % 8));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (nextbit)\n\t\t\t\t\t\tbitmap &= (1 << 1) | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 2) | (1 << 3);\n\t\t\t\t\telse\n\t\t\t\t\t\tbitmap &= (1 << 1) | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check 6: whole address\n\t\t *\n\t\t * This is the last check for correctness of the basic comparison\n\t\t * strategies.  It's only appropriate at leaf entries.\n\t\t */\n\t\tif (leaf)\n\t\t{\n\t\t\t/* Redo ordering comparison using all address bits */\n\t\t\torder = bitncmp(ip_addr(prefix), ip_addr(argument),\n\t\t\t\t\t\t\tip_maxbits(prefix));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\t\tif (order >= 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (order > 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTEqualStrategyNumber:\n\t\t\t\t\tif (order != 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\t\tif (order < 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (order <= 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tif (order == 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bitmap;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/spgist.h\"",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tinet_spg_node_number(const inet *val, int commonbits);",
            "static int inet_spg_consistent_bitmap(const inet *prefix, int nkeys,\n\t\t\t\t\t\t   ScanKey scankeys, bool leaf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/spgist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_spg_node_number(const inet *val, int commonbits);\nstatic int inet_spg_consistent_bitmap(const inet *prefix, int nkeys,\n\t\t\t\t\t\t   ScanKey scankeys, bool leaf);\n\nstatic int\ninet_spg_consistent_bitmap(const inet *prefix, int nkeys, ScanKey scankeys,\n\t\t\t\t\t\t   bool leaf)\n{\n\tint\t\t\tbitmap;\n\tint\t\t\tcommonbits,\n\t\t\t\ti;\n\n\t/* Initialize result to allow visiting all children */\n\tif (leaf)\n\t\tbitmap = 1;\n\telse\n\t\tbitmap = 1 | (1 << 1) | (1 << 2) | (1 << 3);\n\n\tcommonbits = ip_bits(prefix);\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tinet\t   *argument = DatumGetInetPP(scankeys[i].sk_argument);\n\t\tStrategyNumber strategy = scankeys[i].sk_strategy;\n\t\tint\t\t\torder;\n\n\t\t/*\n\t\t * Check 0: different families\n\t\t *\n\t\t * Matching families do not help any of the strategies.\n\t\t */\n\t\tif (ip_family(argument) != ip_family(prefix))\n\t\t{\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (ip_family(argument) < ip_family(prefix))\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (ip_family(argument) > ip_family(prefix))\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* For all other cases, we can be sure there is no match */\n\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\n\t\t\t/* Other checks make no sense with different families. */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check 1: network bit count\n\t\t *\n\t\t * Network bit count (ip_bits) helps to check leaves for sub network\n\t\t * and sup network operators.  At non-leaf nodes, we know every child\n\t\t * value has greater ip_bits, so we can avoid descending in some cases\n\t\t * too.\n\t\t *\n\t\t * This check is less expensive than checking the address bits, so we\n\t\t * are doing this before, but it has to be done after for the basic\n\t\t * comparison strategies, because ip_bits only affect their results\n\t\t * when the common network bits are the same.\n\t\t */\n\t\tswitch (strategy)\n\t\t{\n\t\t\tcase RTSubStrategyNumber:\n\t\t\t\tif (commonbits <= ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\n\t\t\tcase RTSubEqualStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\n\t\t\tcase RTSuperStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument) - 1)\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits >= ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTSuperEqualStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits > ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTEqualStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\telse if (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bitmap)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check 2: common network bits\n\t\t *\n\t\t * Compare available common prefix bits to the query, but not beyond\n\t\t * either the query's netmask or the minimum netmask among the\n\t\t * represented values.  If these bits don't match the query, we can\n\t\t * eliminate some cases.\n\t\t */\n\t\torder = bitncmp(ip_addr(prefix), ip_addr(argument),\n\t\t\t\t\t\tMin(commonbits, ip_bits(argument)));\n\n\t\tif (order != 0)\n\t\t{\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (order > 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (order < 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* For all other cases, we can be sure there is no match */\n\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Remaining checks make no sense when common bits don't match.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check 3: next network bit\n\t\t *\n\t\t * We can filter out branch 2 or 3 using the next network bit of the\n\t\t * argument, if it is available.\n\t\t *\n\t\t * This check matters for the performance of the search. The results\n\t\t * would be correct without it.\n\t\t */\n\t\tif (bitmap & ((1 << 2) | (1 << 3)) &&\n\t\t\tcommonbits < ip_bits(argument))\n\t\t{\n\t\t\tint\t\t\tnextbit;\n\n\t\t\tnextbit = ip_addr(argument)[commonbits / 8] &\n\t\t\t\t(1 << (7 - commonbits % 8));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 2);\n\t\t\t\t\telse\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 3);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Remaining checks are only for the basic comparison strategies. This\n\t\t * test relies on the strategy number ordering defined in stratnum.h.\n\t\t */\n\t\tif (strategy < RTEqualStrategyNumber ||\n\t\t\tstrategy > RTGreaterEqualStrategyNumber)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check 4: network bit count\n\t\t *\n\t\t * At this point, we know that the common network bits of the prefix\n\t\t * and the argument are the same, so we can go forward and check the\n\t\t * ip_bits.\n\t\t */\n\t\tswitch (strategy)\n\t\t{\n\t\t\tcase RTLessStrategyNumber:\n\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits > ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bitmap)\n\t\t\tbreak;\n\n\t\t/* Remaining checks don't make sense with different ip_bits. */\n\t\tif (commonbits != ip_bits(argument))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check 5: next host bit\n\t\t *\n\t\t * We can filter out branch 0 or 1 using the next host bit of the\n\t\t * argument, if it is available.\n\t\t *\n\t\t * This check matters for the performance of the search. The results\n\t\t * would be correct without it.  There is no point in running it for\n\t\t * leafs as we have to check the whole address on the next step.\n\t\t */\n\t\tif (!leaf && bitmap & (1 | (1 << 1)) &&\n\t\t\tcommonbits < ip_maxbits(argument))\n\t\t{\n\t\t\tint\t\t\tnextbit;\n\n\t\t\tnextbit = ip_addr(argument)[commonbits / 8] &\n\t\t\t\t(1 << (7 - commonbits % 8));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (nextbit)\n\t\t\t\t\t\tbitmap &= (1 << 1) | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 2) | (1 << 3);\n\t\t\t\t\telse\n\t\t\t\t\t\tbitmap &= (1 << 1) | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check 6: whole address\n\t\t *\n\t\t * This is the last check for correctness of the basic comparison\n\t\t * strategies.  It's only appropriate at leaf entries.\n\t\t */\n\t\tif (leaf)\n\t\t{\n\t\t\t/* Redo ordering comparison using all address bits */\n\t\t\torder = bitncmp(ip_addr(prefix), ip_addr(argument),\n\t\t\t\t\t\t\tip_maxbits(prefix));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\t\tif (order >= 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (order > 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTEqualStrategyNumber:\n\t\t\t\t\tif (order != 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\t\tif (order < 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (order <= 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tif (order == 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InetPGetDatum",
          "args": [
            "leaf"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetPP",
          "args": [
            "in->leafDatum"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/spgist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int inet_spg_consistent_bitmap(const inet *prefix, int nkeys,\n\t\t\t\t\t\t   ScanKey scankeys, bool leaf);\n\nDatum\ninet_spg_leaf_consistent(PG_FUNCTION_ARGS)\n{\n\tspgLeafConsistentIn *in = (spgLeafConsistentIn *) PG_GETARG_POINTER(0);\n\tspgLeafConsistentOut *out = (spgLeafConsistentOut *) PG_GETARG_POINTER(1);\n\tinet\t   *leaf = DatumGetInetPP(in->leafDatum);\n\n\t/* All tests are exact. */\n\tout->recheck = false;\n\n\t/* Leaf is what it is... */\n\tout->leafValue = InetPGetDatum(leaf);\n\n\t/* Use common code to apply the tests. */\n\tPG_RETURN_BOOL(inet_spg_consistent_bitmap(leaf, in->nkeys, in->scankeys,\n\t\t\t\t\t\t\t\t\t\t\t  true));\n}"
  },
  {
    "function_name": "inet_spg_inner_consistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_spgist.c",
    "lines": "237-316",
    "snippet": "Datum\ninet_spg_inner_consistent(PG_FUNCTION_ARGS)\n{\n\tspgInnerConsistentIn *in = (spgInnerConsistentIn *) PG_GETARG_POINTER(0);\n\tspgInnerConsistentOut *out = (spgInnerConsistentOut *) PG_GETARG_POINTER(1);\n\tint\t\t\ti;\n\tint\t\t\twhich;\n\n\tif (!in->hasPrefix)\n\t{\n\t\tAssert(!in->allTheSame);\n\t\tAssert(in->nNodes == 2);\n\n\t\t/* Identify which child nodes need to be visited */\n\t\twhich = 1 | (1 << 1);\n\n\t\tfor (i = 0; i < in->nkeys; i++)\n\t\t{\n\t\t\tStrategyNumber strategy = in->scankeys[i].sk_strategy;\n\t\t\tinet\t   *argument = DatumGetInetPP(in->scankeys[i].sk_argument);\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (ip_family(argument) == PGSQL_AF_INET)\n\t\t\t\t\t\twhich &= 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (ip_family(argument) == PGSQL_AF_INET6)\n\t\t\t\t\t\twhich &= (1 << 1);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* all other ops can only match addrs of same family */\n\t\t\t\t\tif (ip_family(argument) == PGSQL_AF_INET)\n\t\t\t\t\t\twhich &= 1;\n\t\t\t\t\telse\n\t\t\t\t\t\twhich &= (1 << 1);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse if (!in->allTheSame)\n\t{\n\t\tAssert(in->nNodes == 4);\n\n\t\t/* Identify which child nodes need to be visited */\n\t\twhich = inet_spg_consistent_bitmap(DatumGetInetPP(in->prefixDatum),\n\t\t\t\t\t\t\t\t\t\t   in->nkeys, in->scankeys, false);\n\t}\n\telse\n\t{\n\t\t/* Must visit all nodes; we assume there are less than 32 of 'em */\n\t\twhich = ~0;\n\t}\n\n\tout->nNodes = 0;\n\n\tif (which)\n\t{\n\t\tout->nodeNumbers = (int *) palloc(sizeof(int) * in->nNodes);\n\n\t\tfor (i = 0; i < in->nNodes; i++)\n\t\t{\n\t\t\tif (which & (1 << i))\n\t\t\t{\n\t\t\t\tout->nodeNumbers[out->nNodes] = i;\n\t\t\t\tout->nNodes++;\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/spgist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(int) * in->nNodes"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_spg_consistent_bitmap",
          "args": [
            "DatumGetInetPP(in->prefixDatum)",
            "in->nkeys",
            "in->scankeys",
            "false"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "inet_spg_consistent_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_spgist.c",
          "lines": "372-711",
          "snippet": "static int\ninet_spg_consistent_bitmap(const inet *prefix, int nkeys, ScanKey scankeys,\n\t\t\t\t\t\t   bool leaf)\n{\n\tint\t\t\tbitmap;\n\tint\t\t\tcommonbits,\n\t\t\t\ti;\n\n\t/* Initialize result to allow visiting all children */\n\tif (leaf)\n\t\tbitmap = 1;\n\telse\n\t\tbitmap = 1 | (1 << 1) | (1 << 2) | (1 << 3);\n\n\tcommonbits = ip_bits(prefix);\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tinet\t   *argument = DatumGetInetPP(scankeys[i].sk_argument);\n\t\tStrategyNumber strategy = scankeys[i].sk_strategy;\n\t\tint\t\t\torder;\n\n\t\t/*\n\t\t * Check 0: different families\n\t\t *\n\t\t * Matching families do not help any of the strategies.\n\t\t */\n\t\tif (ip_family(argument) != ip_family(prefix))\n\t\t{\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (ip_family(argument) < ip_family(prefix))\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (ip_family(argument) > ip_family(prefix))\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* For all other cases, we can be sure there is no match */\n\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\n\t\t\t/* Other checks make no sense with different families. */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check 1: network bit count\n\t\t *\n\t\t * Network bit count (ip_bits) helps to check leaves for sub network\n\t\t * and sup network operators.  At non-leaf nodes, we know every child\n\t\t * value has greater ip_bits, so we can avoid descending in some cases\n\t\t * too.\n\t\t *\n\t\t * This check is less expensive than checking the address bits, so we\n\t\t * are doing this before, but it has to be done after for the basic\n\t\t * comparison strategies, because ip_bits only affect their results\n\t\t * when the common network bits are the same.\n\t\t */\n\t\tswitch (strategy)\n\t\t{\n\t\t\tcase RTSubStrategyNumber:\n\t\t\t\tif (commonbits <= ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\n\t\t\tcase RTSubEqualStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\n\t\t\tcase RTSuperStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument) - 1)\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits >= ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTSuperEqualStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits > ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTEqualStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\telse if (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bitmap)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check 2: common network bits\n\t\t *\n\t\t * Compare available common prefix bits to the query, but not beyond\n\t\t * either the query's netmask or the minimum netmask among the\n\t\t * represented values.  If these bits don't match the query, we can\n\t\t * eliminate some cases.\n\t\t */\n\t\torder = bitncmp(ip_addr(prefix), ip_addr(argument),\n\t\t\t\t\t\tMin(commonbits, ip_bits(argument)));\n\n\t\tif (order != 0)\n\t\t{\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (order > 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (order < 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* For all other cases, we can be sure there is no match */\n\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Remaining checks make no sense when common bits don't match.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check 3: next network bit\n\t\t *\n\t\t * We can filter out branch 2 or 3 using the next network bit of the\n\t\t * argument, if it is available.\n\t\t *\n\t\t * This check matters for the performance of the search. The results\n\t\t * would be correct without it.\n\t\t */\n\t\tif (bitmap & ((1 << 2) | (1 << 3)) &&\n\t\t\tcommonbits < ip_bits(argument))\n\t\t{\n\t\t\tint\t\t\tnextbit;\n\n\t\t\tnextbit = ip_addr(argument)[commonbits / 8] &\n\t\t\t\t(1 << (7 - commonbits % 8));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 2);\n\t\t\t\t\telse\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 3);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Remaining checks are only for the basic comparison strategies. This\n\t\t * test relies on the strategy number ordering defined in stratnum.h.\n\t\t */\n\t\tif (strategy < RTEqualStrategyNumber ||\n\t\t\tstrategy > RTGreaterEqualStrategyNumber)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check 4: network bit count\n\t\t *\n\t\t * At this point, we know that the common network bits of the prefix\n\t\t * and the argument are the same, so we can go forward and check the\n\t\t * ip_bits.\n\t\t */\n\t\tswitch (strategy)\n\t\t{\n\t\t\tcase RTLessStrategyNumber:\n\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits > ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bitmap)\n\t\t\tbreak;\n\n\t\t/* Remaining checks don't make sense with different ip_bits. */\n\t\tif (commonbits != ip_bits(argument))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check 5: next host bit\n\t\t *\n\t\t * We can filter out branch 0 or 1 using the next host bit of the\n\t\t * argument, if it is available.\n\t\t *\n\t\t * This check matters for the performance of the search. The results\n\t\t * would be correct without it.  There is no point in running it for\n\t\t * leafs as we have to check the whole address on the next step.\n\t\t */\n\t\tif (!leaf && bitmap & (1 | (1 << 1)) &&\n\t\t\tcommonbits < ip_maxbits(argument))\n\t\t{\n\t\t\tint\t\t\tnextbit;\n\n\t\t\tnextbit = ip_addr(argument)[commonbits / 8] &\n\t\t\t\t(1 << (7 - commonbits % 8));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (nextbit)\n\t\t\t\t\t\tbitmap &= (1 << 1) | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 2) | (1 << 3);\n\t\t\t\t\telse\n\t\t\t\t\t\tbitmap &= (1 << 1) | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check 6: whole address\n\t\t *\n\t\t * This is the last check for correctness of the basic comparison\n\t\t * strategies.  It's only appropriate at leaf entries.\n\t\t */\n\t\tif (leaf)\n\t\t{\n\t\t\t/* Redo ordering comparison using all address bits */\n\t\t\torder = bitncmp(ip_addr(prefix), ip_addr(argument),\n\t\t\t\t\t\t\tip_maxbits(prefix));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\t\tif (order >= 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (order > 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTEqualStrategyNumber:\n\t\t\t\t\tif (order != 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\t\tif (order < 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (order <= 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tif (order == 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bitmap;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/spgist.h\"",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tinet_spg_node_number(const inet *val, int commonbits);",
            "static int inet_spg_consistent_bitmap(const inet *prefix, int nkeys,\n\t\t\t\t\t\t   ScanKey scankeys, bool leaf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/spgist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_spg_node_number(const inet *val, int commonbits);\nstatic int inet_spg_consistent_bitmap(const inet *prefix, int nkeys,\n\t\t\t\t\t\t   ScanKey scankeys, bool leaf);\n\nstatic int\ninet_spg_consistent_bitmap(const inet *prefix, int nkeys, ScanKey scankeys,\n\t\t\t\t\t\t   bool leaf)\n{\n\tint\t\t\tbitmap;\n\tint\t\t\tcommonbits,\n\t\t\t\ti;\n\n\t/* Initialize result to allow visiting all children */\n\tif (leaf)\n\t\tbitmap = 1;\n\telse\n\t\tbitmap = 1 | (1 << 1) | (1 << 2) | (1 << 3);\n\n\tcommonbits = ip_bits(prefix);\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tinet\t   *argument = DatumGetInetPP(scankeys[i].sk_argument);\n\t\tStrategyNumber strategy = scankeys[i].sk_strategy;\n\t\tint\t\t\torder;\n\n\t\t/*\n\t\t * Check 0: different families\n\t\t *\n\t\t * Matching families do not help any of the strategies.\n\t\t */\n\t\tif (ip_family(argument) != ip_family(prefix))\n\t\t{\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (ip_family(argument) < ip_family(prefix))\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (ip_family(argument) > ip_family(prefix))\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* For all other cases, we can be sure there is no match */\n\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\n\t\t\t/* Other checks make no sense with different families. */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check 1: network bit count\n\t\t *\n\t\t * Network bit count (ip_bits) helps to check leaves for sub network\n\t\t * and sup network operators.  At non-leaf nodes, we know every child\n\t\t * value has greater ip_bits, so we can avoid descending in some cases\n\t\t * too.\n\t\t *\n\t\t * This check is less expensive than checking the address bits, so we\n\t\t * are doing this before, but it has to be done after for the basic\n\t\t * comparison strategies, because ip_bits only affect their results\n\t\t * when the common network bits are the same.\n\t\t */\n\t\tswitch (strategy)\n\t\t{\n\t\t\tcase RTSubStrategyNumber:\n\t\t\t\tif (commonbits <= ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\n\t\t\tcase RTSubEqualStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\n\t\t\tcase RTSuperStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument) - 1)\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits >= ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTSuperEqualStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits > ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTEqualStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\telse if (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bitmap)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check 2: common network bits\n\t\t *\n\t\t * Compare available common prefix bits to the query, but not beyond\n\t\t * either the query's netmask or the minimum netmask among the\n\t\t * represented values.  If these bits don't match the query, we can\n\t\t * eliminate some cases.\n\t\t */\n\t\torder = bitncmp(ip_addr(prefix), ip_addr(argument),\n\t\t\t\t\t\tMin(commonbits, ip_bits(argument)));\n\n\t\tif (order != 0)\n\t\t{\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (order > 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (order < 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* For all other cases, we can be sure there is no match */\n\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Remaining checks make no sense when common bits don't match.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check 3: next network bit\n\t\t *\n\t\t * We can filter out branch 2 or 3 using the next network bit of the\n\t\t * argument, if it is available.\n\t\t *\n\t\t * This check matters for the performance of the search. The results\n\t\t * would be correct without it.\n\t\t */\n\t\tif (bitmap & ((1 << 2) | (1 << 3)) &&\n\t\t\tcommonbits < ip_bits(argument))\n\t\t{\n\t\t\tint\t\t\tnextbit;\n\n\t\t\tnextbit = ip_addr(argument)[commonbits / 8] &\n\t\t\t\t(1 << (7 - commonbits % 8));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 2);\n\t\t\t\t\telse\n\t\t\t\t\t\tbitmap &= 1 | (1 << 1) | (1 << 3);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Remaining checks are only for the basic comparison strategies. This\n\t\t * test relies on the strategy number ordering defined in stratnum.h.\n\t\t */\n\t\tif (strategy < RTEqualStrategyNumber ||\n\t\t\tstrategy > RTGreaterEqualStrategyNumber)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check 4: network bit count\n\t\t *\n\t\t * At this point, we know that the common network bits of the prefix\n\t\t * and the argument are the same, so we can go forward and check the\n\t\t * ip_bits.\n\t\t */\n\t\tswitch (strategy)\n\t\t{\n\t\t\tcase RTLessStrategyNumber:\n\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\tif (commonbits == ip_bits(argument))\n\t\t\t\t\tbitmap &= 1 | (1 << 1);\n\t\t\t\telse if (commonbits > ip_bits(argument))\n\t\t\t\t\tbitmap = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\tif (commonbits < ip_bits(argument))\n\t\t\t\t\tbitmap &= (1 << 2) | (1 << 3);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!bitmap)\n\t\t\tbreak;\n\n\t\t/* Remaining checks don't make sense with different ip_bits. */\n\t\tif (commonbits != ip_bits(argument))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check 5: next host bit\n\t\t *\n\t\t * We can filter out branch 0 or 1 using the next host bit of the\n\t\t * argument, if it is available.\n\t\t *\n\t\t * This check matters for the performance of the search. The results\n\t\t * would be correct without it.  There is no point in running it for\n\t\t * leafs as we have to check the whole address on the next step.\n\t\t */\n\t\tif (!leaf && bitmap & (1 | (1 << 1)) &&\n\t\t\tcommonbits < ip_maxbits(argument))\n\t\t{\n\t\t\tint\t\t\tnextbit;\n\n\t\t\tnextbit = ip_addr(argument)[commonbits / 8] &\n\t\t\t\t(1 << (7 - commonbits % 8));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (nextbit)\n\t\t\t\t\t\tbitmap &= (1 << 1) | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (!nextbit)\n\t\t\t\t\t\tbitmap &= 1 | (1 << 2) | (1 << 3);\n\t\t\t\t\telse\n\t\t\t\t\t\tbitmap &= (1 << 1) | (1 << 2) | (1 << 3);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check 6: whole address\n\t\t *\n\t\t * This is the last check for correctness of the basic comparison\n\t\t * strategies.  It's only appropriate at leaf entries.\n\t\t */\n\t\tif (leaf)\n\t\t{\n\t\t\t/* Redo ordering comparison using all address bits */\n\t\t\torder = bitncmp(ip_addr(prefix), ip_addr(argument),\n\t\t\t\t\t\t\tip_maxbits(prefix));\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\t\tif (order >= 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (order > 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTEqualStrategyNumber:\n\t\t\t\t\tif (order != 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\t\tif (order < 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (order <= 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tif (order == 0)\n\t\t\t\t\t\tbitmap = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!bitmap)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetInetPP",
          "args": [
            "in->prefixDatum"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "in->nNodes == 4"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "argument"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "argument"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "argument"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetPP",
          "args": [
            "in->scankeys[i].sk_argument"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "in->nNodes == 2"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!in->allTheSame"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/spgist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nDatum\ninet_spg_inner_consistent(PG_FUNCTION_ARGS)\n{\n\tspgInnerConsistentIn *in = (spgInnerConsistentIn *) PG_GETARG_POINTER(0);\n\tspgInnerConsistentOut *out = (spgInnerConsistentOut *) PG_GETARG_POINTER(1);\n\tint\t\t\ti;\n\tint\t\t\twhich;\n\n\tif (!in->hasPrefix)\n\t{\n\t\tAssert(!in->allTheSame);\n\t\tAssert(in->nNodes == 2);\n\n\t\t/* Identify which child nodes need to be visited */\n\t\twhich = 1 | (1 << 1);\n\n\t\tfor (i = 0; i < in->nkeys; i++)\n\t\t{\n\t\t\tStrategyNumber strategy = in->scankeys[i].sk_strategy;\n\t\t\tinet\t   *argument = DatumGetInetPP(in->scankeys[i].sk_argument);\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RTLessStrategyNumber:\n\t\t\t\tcase RTLessEqualStrategyNumber:\n\t\t\t\t\tif (ip_family(argument) == PGSQL_AF_INET)\n\t\t\t\t\t\twhich &= 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTGreaterEqualStrategyNumber:\n\t\t\t\tcase RTGreaterStrategyNumber:\n\t\t\t\t\tif (ip_family(argument) == PGSQL_AF_INET6)\n\t\t\t\t\t\twhich &= (1 << 1);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RTNotEqualStrategyNumber:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* all other ops can only match addrs of same family */\n\t\t\t\t\tif (ip_family(argument) == PGSQL_AF_INET)\n\t\t\t\t\t\twhich &= 1;\n\t\t\t\t\telse\n\t\t\t\t\t\twhich &= (1 << 1);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse if (!in->allTheSame)\n\t{\n\t\tAssert(in->nNodes == 4);\n\n\t\t/* Identify which child nodes need to be visited */\n\t\twhich = inet_spg_consistent_bitmap(DatumGetInetPP(in->prefixDatum),\n\t\t\t\t\t\t\t\t\t\t   in->nkeys, in->scankeys, false);\n\t}\n\telse\n\t{\n\t\t/* Must visit all nodes; we assume there are less than 32 of 'em */\n\t\twhich = ~0;\n\t}\n\n\tout->nNodes = 0;\n\n\tif (which)\n\t{\n\t\tout->nodeNumbers = (int *) palloc(sizeof(int) * in->nNodes);\n\n\t\tfor (i = 0; i < in->nNodes; i++)\n\t\t{\n\t\t\tif (which & (1 << i))\n\t\t\t{\n\t\t\t\tout->nodeNumbers[out->nNodes] = i;\n\t\t\t\tout->nNodes++;\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "inet_spg_picksplit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_spgist.c",
    "lines": "163-232",
    "snippet": "Datum\ninet_spg_picksplit(PG_FUNCTION_ARGS)\n{\n\tspgPickSplitIn *in = (spgPickSplitIn *) PG_GETARG_POINTER(0);\n\tspgPickSplitOut *out = (spgPickSplitOut *) PG_GETARG_POINTER(1);\n\tinet\t   *prefix,\n\t\t\t   *tmp;\n\tint\t\t\ti,\n\t\t\t\tcommonbits;\n\tbool\t\tdifferentFamilies = false;\n\n\t/* Initialize the prefix with the first item */\n\tprefix = DatumGetInetPP(in->datums[0]);\n\tcommonbits = ip_bits(prefix);\n\n\t/* Examine remaining items to discover minimum common prefix length */\n\tfor (i = 1; i < in->nTuples; i++)\n\t{\n\t\ttmp = DatumGetInetPP(in->datums[i]);\n\n\t\tif (ip_family(tmp) != ip_family(prefix))\n\t\t{\n\t\t\tdifferentFamilies = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ip_bits(tmp) < commonbits)\n\t\t\tcommonbits = ip_bits(tmp);\n\t\tcommonbits = bitncommon(ip_addr(prefix), ip_addr(tmp), commonbits);\n\t\tif (commonbits == 0)\n\t\t\tbreak;\n\t}\n\n\t/* Don't need labels; allocate output arrays */\n\tout->nodeLabels = NULL;\n\tout->mapTuplesToNodes = (int *) palloc(sizeof(int) * in->nTuples);\n\tout->leafTupleDatums = (Datum *) palloc(sizeof(Datum) * in->nTuples);\n\n\tif (differentFamilies)\n\t{\n\t\t/* Set up 2-node tuple */\n\t\tout->hasPrefix = false;\n\t\tout->nNodes = 2;\n\n\t\tfor (i = 0; i < in->nTuples; i++)\n\t\t{\n\t\t\ttmp = DatumGetInetPP(in->datums[i]);\n\t\t\tout->mapTuplesToNodes[i] =\n\t\t\t\t(ip_family(tmp) == PGSQL_AF_INET) ? 0 : 1;\n\t\t\tout->leafTupleDatums[i] = InetPGetDatum(tmp);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Set up 4-node tuple */\n\t\tout->hasPrefix = true;\n\t\tout->prefixDatum =\n\t\t\tInetPGetDatum(cidr_set_masklen_internal(prefix, commonbits));\n\t\tout->nNodes = 4;\n\n\t\tfor (i = 0; i < in->nTuples; i++)\n\t\t{\n\t\t\ttmp = DatumGetInetPP(in->datums[i]);\n\t\t\tout->mapTuplesToNodes[i] = inet_spg_node_number(tmp, commonbits);\n\t\t\tout->leafTupleDatums[i] = InetPGetDatum(tmp);\n\t\t}\n\t}\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/spgist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tinet_spg_node_number(const inet *val, int commonbits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InetPGetDatum",
          "args": [
            "tmp"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_spg_node_number",
          "args": [
            "tmp",
            "commonbits"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "inet_spg_node_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_spgist.c",
          "lines": "348-360",
          "snippet": "static int\ninet_spg_node_number(const inet *val, int commonbits)\n{\n\tint\t\t\tnodeN = 0;\n\n\tif (commonbits < ip_maxbits(val) &&\n\t\tip_addr(val)[commonbits / 8] & (1 << (7 - commonbits % 8)))\n\t\tnodeN |= 1;\n\tif (commonbits < ip_bits(val))\n\t\tnodeN |= 2;\n\n\treturn nodeN;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/spgist.h\"",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tinet_spg_node_number(const inet *val, int commonbits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/spgist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_spg_node_number(const inet *val, int commonbits);\n\nstatic int\ninet_spg_node_number(const inet *val, int commonbits)\n{\n\tint\t\t\tnodeN = 0;\n\n\tif (commonbits < ip_maxbits(val) &&\n\t\tip_addr(val)[commonbits / 8] & (1 << (7 - commonbits % 8)))\n\t\tnodeN |= 1;\n\tif (commonbits < ip_bits(val))\n\t\tnodeN |= 2;\n\n\treturn nodeN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetInetPP",
          "args": [
            "in->datums[i]"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InetPGetDatum",
          "args": [
            "cidr_set_masklen_internal(prefix, commonbits)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cidr_set_masklen_internal",
          "args": [
            "prefix",
            "commonbits"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "cidr_set_masklen_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network.c",
          "lines": "326-350",
          "snippet": "inet *\ncidr_set_masklen_internal(const inet *src, int bits)\n{\n\tinet\t   *dst = (inet *) palloc0(sizeof(inet));\n\n\tip_family(dst) = ip_family(src);\n\tip_bits(dst) = bits;\n\n\tif (bits > 0)\n\t{\n\t\tAssert(bits <= ip_maxbits(dst));\n\n\t\t/* Clone appropriate bytes of the address, leaving the rest 0 */\n\t\tmemcpy(ip_addr(dst), ip_addr(src), (bits + 7) / 8);\n\n\t\t/* Clear any unwanted bits in the last partial byte */\n\t\tif (bits % 8)\n\t\t\tip_addr(dst)[bits / 8] &= ~(0xFF >> (bits % 8));\n\t}\n\n\t/* Set varlena header correctly */\n\tSET_INET_VARSIZE(dst);\n\n\treturn dst;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"common/ip.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq-be.h\"\n#include \"common/ip.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\ninet *\ncidr_set_masklen_internal(const inet *src, int bits)\n{\n\tinet\t   *dst = (inet *) palloc0(sizeof(inet));\n\n\tip_family(dst) = ip_family(src);\n\tip_bits(dst) = bits;\n\n\tif (bits > 0)\n\t{\n\t\tAssert(bits <= ip_maxbits(dst));\n\n\t\t/* Clone appropriate bytes of the address, leaving the rest 0 */\n\t\tmemcpy(ip_addr(dst), ip_addr(src), (bits + 7) / 8);\n\n\t\t/* Clear any unwanted bits in the last partial byte */\n\t\tif (bits % 8)\n\t\t\tip_addr(dst)[bits / 8] &= ~(0xFF >> (bits % 8));\n\t}\n\n\t/* Set varlena header correctly */\n\tSET_INET_VARSIZE(dst);\n\n\treturn dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InetPGetDatum",
          "args": [
            "tmp"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "tmp"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetPP",
          "args": [
            "in->datums[i]"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Datum) * in->nTuples"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitncommon",
          "args": [
            "ip_addr(prefix)",
            "ip_addr(tmp)",
            "commonbits"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "bitncommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network.c",
          "lines": "1010-1042",
          "snippet": "int\nbitncommon(const unsigned char *l, const unsigned char *r, int n)\n{\n\tint\t\t\tbyte,\n\t\t\t\tnbits;\n\n\t/* number of bits to examine in last byte */\n\tnbits = n % 8;\n\n\t/* check whole bytes */\n\tfor (byte = 0; byte < n / 8; byte++)\n\t{\n\t\tif (l[byte] != r[byte])\n\t\t{\n\t\t\t/* at least one bit in the last byte is not common */\n\t\t\tnbits = 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* check bits in last partial byte */\n\tif (nbits != 0)\n\t{\n\t\t/* calculate diff of first non-matching bytes */\n\t\tunsigned int diff = l[byte] ^ r[byte];\n\n\t\t/* compare the bits from the most to the least */\n\t\twhile ((diff >> (8 - nbits)) != 0)\n\t\t\tnbits--;\n\t}\n\n\treturn (8 * byte) + nbits;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"common/ip.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq-be.h\"\n#include \"common/ip.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nint\nbitncommon(const unsigned char *l, const unsigned char *r, int n)\n{\n\tint\t\t\tbyte,\n\t\t\t\tnbits;\n\n\t/* number of bits to examine in last byte */\n\tnbits = n % 8;\n\n\t/* check whole bytes */\n\tfor (byte = 0; byte < n / 8; byte++)\n\t{\n\t\tif (l[byte] != r[byte])\n\t\t{\n\t\t\t/* at least one bit in the last byte is not common */\n\t\t\tnbits = 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* check bits in last partial byte */\n\tif (nbits != 0)\n\t{\n\t\t/* calculate diff of first non-matching bytes */\n\t\tunsigned int diff = l[byte] ^ r[byte];\n\n\t\t/* compare the bits from the most to the least */\n\t\twhile ((diff >> (8 - nbits)) != 0)\n\t\t\tnbits--;\n\t}\n\n\treturn (8 * byte) + nbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "tmp"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "prefix"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "tmp"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "tmp"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "prefix"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "tmp"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetPP",
          "args": [
            "in->datums[i]"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "prefix"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetPP",
          "args": [
            "in->datums[0]"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/spgist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_spg_node_number(const inet *val, int commonbits);\n\nDatum\ninet_spg_picksplit(PG_FUNCTION_ARGS)\n{\n\tspgPickSplitIn *in = (spgPickSplitIn *) PG_GETARG_POINTER(0);\n\tspgPickSplitOut *out = (spgPickSplitOut *) PG_GETARG_POINTER(1);\n\tinet\t   *prefix,\n\t\t\t   *tmp;\n\tint\t\t\ti,\n\t\t\t\tcommonbits;\n\tbool\t\tdifferentFamilies = false;\n\n\t/* Initialize the prefix with the first item */\n\tprefix = DatumGetInetPP(in->datums[0]);\n\tcommonbits = ip_bits(prefix);\n\n\t/* Examine remaining items to discover minimum common prefix length */\n\tfor (i = 1; i < in->nTuples; i++)\n\t{\n\t\ttmp = DatumGetInetPP(in->datums[i]);\n\n\t\tif (ip_family(tmp) != ip_family(prefix))\n\t\t{\n\t\t\tdifferentFamilies = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ip_bits(tmp) < commonbits)\n\t\t\tcommonbits = ip_bits(tmp);\n\t\tcommonbits = bitncommon(ip_addr(prefix), ip_addr(tmp), commonbits);\n\t\tif (commonbits == 0)\n\t\t\tbreak;\n\t}\n\n\t/* Don't need labels; allocate output arrays */\n\tout->nodeLabels = NULL;\n\tout->mapTuplesToNodes = (int *) palloc(sizeof(int) * in->nTuples);\n\tout->leafTupleDatums = (Datum *) palloc(sizeof(Datum) * in->nTuples);\n\n\tif (differentFamilies)\n\t{\n\t\t/* Set up 2-node tuple */\n\t\tout->hasPrefix = false;\n\t\tout->nNodes = 2;\n\n\t\tfor (i = 0; i < in->nTuples; i++)\n\t\t{\n\t\t\ttmp = DatumGetInetPP(in->datums[i]);\n\t\t\tout->mapTuplesToNodes[i] =\n\t\t\t\t(ip_family(tmp) == PGSQL_AF_INET) ? 0 : 1;\n\t\t\tout->leafTupleDatums[i] = InetPGetDatum(tmp);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Set up 4-node tuple */\n\t\tout->hasPrefix = true;\n\t\tout->prefixDatum =\n\t\t\tInetPGetDatum(cidr_set_masklen_internal(prefix, commonbits));\n\t\tout->nNodes = 4;\n\n\t\tfor (i = 0; i < in->nTuples; i++)\n\t\t{\n\t\t\ttmp = DatumGetInetPP(in->datums[i]);\n\t\t\tout->mapTuplesToNodes[i] = inet_spg_node_number(tmp, commonbits);\n\t\t\tout->leafTupleDatums[i] = InetPGetDatum(tmp);\n\t\t}\n\t}\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "inet_spg_choose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_spgist.c",
    "lines": "66-158",
    "snippet": "Datum\ninet_spg_choose(PG_FUNCTION_ARGS)\n{\n\tspgChooseIn *in = (spgChooseIn *) PG_GETARG_POINTER(0);\n\tspgChooseOut *out = (spgChooseOut *) PG_GETARG_POINTER(1);\n\tinet\t   *val = DatumGetInetPP(in->datum),\n\t\t\t   *prefix;\n\tint\t\t\tcommonbits;\n\n\t/*\n\t * If we're looking at a tuple that splits by address family, choose the\n\t * appropriate subnode.\n\t */\n\tif (!in->hasPrefix)\n\t{\n\t\t/* allTheSame isn't possible for such a tuple */\n\t\tAssert(!in->allTheSame);\n\t\tAssert(in->nNodes == 2);\n\n\t\tout->resultType = spgMatchNode;\n\t\tout->result.matchNode.nodeN = (ip_family(val) == PGSQL_AF_INET) ? 0 : 1;\n\t\tout->result.matchNode.restDatum = InetPGetDatum(val);\n\n\t\tPG_RETURN_VOID();\n\t}\n\n\t/* Else it must split by prefix */\n\tAssert(in->nNodes == 4 || in->allTheSame);\n\n\tprefix = DatumGetInetPP(in->prefixDatum);\n\tcommonbits = ip_bits(prefix);\n\n\t/*\n\t * We cannot put addresses from different families under the same inner\n\t * node, so we have to split if the new value's family is different.\n\t */\n\tif (ip_family(val) != ip_family(prefix))\n\t{\n\t\t/* Set up 2-node tuple */\n\t\tout->resultType = spgSplitTuple;\n\t\tout->result.splitTuple.prefixHasPrefix = false;\n\t\tout->result.splitTuple.prefixNNodes = 2;\n\t\tout->result.splitTuple.prefixNodeLabels = NULL;\n\n\t\t/* Identify which node the existing data goes into */\n\t\tout->result.splitTuple.childNodeN =\n\t\t\t(ip_family(prefix) == PGSQL_AF_INET) ? 0 : 1;\n\n\t\tout->result.splitTuple.postfixHasPrefix = true;\n\t\tout->result.splitTuple.postfixPrefixDatum = InetPGetDatum(prefix);\n\n\t\tPG_RETURN_VOID();\n\t}\n\n\t/*\n\t * If the new value does not match the existing prefix, we have to split.\n\t */\n\tif (ip_bits(val) < commonbits ||\n\t\tbitncmp(ip_addr(prefix), ip_addr(val), commonbits) != 0)\n\t{\n\t\t/* Determine new prefix length for the split tuple */\n\t\tcommonbits = bitncommon(ip_addr(prefix), ip_addr(val),\n\t\t\t\t\t\t\t\tMin(ip_bits(val), commonbits));\n\n\t\t/* Set up 4-node tuple */\n\t\tout->resultType = spgSplitTuple;\n\t\tout->result.splitTuple.prefixHasPrefix = true;\n\t\tout->result.splitTuple.prefixPrefixDatum =\n\t\t\tInetPGetDatum(cidr_set_masklen_internal(val, commonbits));\n\t\tout->result.splitTuple.prefixNNodes = 4;\n\t\tout->result.splitTuple.prefixNodeLabels = NULL;\n\n\t\t/* Identify which node the existing data goes into */\n\t\tout->result.splitTuple.childNodeN =\n\t\t\tinet_spg_node_number(prefix, commonbits);\n\n\t\tout->result.splitTuple.postfixHasPrefix = true;\n\t\tout->result.splitTuple.postfixPrefixDatum = InetPGetDatum(prefix);\n\n\t\tPG_RETURN_VOID();\n\t}\n\n\t/*\n\t * All OK, choose the node to descend into.  (If this tuple is marked\n\t * allTheSame, the core code will ignore our choice of nodeN; but we need\n\t * not account for that case explicitly here.)\n\t */\n\tout->resultType = spgMatchNode;\n\tout->result.matchNode.nodeN = inet_spg_node_number(val, commonbits);\n\tout->result.matchNode.restDatum = InetPGetDatum(val);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/spgist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tinet_spg_node_number(const inet *val, int commonbits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InetPGetDatum",
          "args": [
            "val"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_spg_node_number",
          "args": [
            "val",
            "commonbits"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "inet_spg_node_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_spgist.c",
          "lines": "348-360",
          "snippet": "static int\ninet_spg_node_number(const inet *val, int commonbits)\n{\n\tint\t\t\tnodeN = 0;\n\n\tif (commonbits < ip_maxbits(val) &&\n\t\tip_addr(val)[commonbits / 8] & (1 << (7 - commonbits % 8)))\n\t\tnodeN |= 1;\n\tif (commonbits < ip_bits(val))\n\t\tnodeN |= 2;\n\n\treturn nodeN;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/spgist.h\"",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tinet_spg_node_number(const inet *val, int commonbits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/spgist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_spg_node_number(const inet *val, int commonbits);\n\nstatic int\ninet_spg_node_number(const inet *val, int commonbits)\n{\n\tint\t\t\tnodeN = 0;\n\n\tif (commonbits < ip_maxbits(val) &&\n\t\tip_addr(val)[commonbits / 8] & (1 << (7 - commonbits % 8)))\n\t\tnodeN |= 1;\n\tif (commonbits < ip_bits(val))\n\t\tnodeN |= 2;\n\n\treturn nodeN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InetPGetDatum",
          "args": [
            "prefix"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InetPGetDatum",
          "args": [
            "cidr_set_masklen_internal(val, commonbits)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cidr_set_masklen_internal",
          "args": [
            "val",
            "commonbits"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "cidr_set_masklen_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network.c",
          "lines": "326-350",
          "snippet": "inet *\ncidr_set_masklen_internal(const inet *src, int bits)\n{\n\tinet\t   *dst = (inet *) palloc0(sizeof(inet));\n\n\tip_family(dst) = ip_family(src);\n\tip_bits(dst) = bits;\n\n\tif (bits > 0)\n\t{\n\t\tAssert(bits <= ip_maxbits(dst));\n\n\t\t/* Clone appropriate bytes of the address, leaving the rest 0 */\n\t\tmemcpy(ip_addr(dst), ip_addr(src), (bits + 7) / 8);\n\n\t\t/* Clear any unwanted bits in the last partial byte */\n\t\tif (bits % 8)\n\t\t\tip_addr(dst)[bits / 8] &= ~(0xFF >> (bits % 8));\n\t}\n\n\t/* Set varlena header correctly */\n\tSET_INET_VARSIZE(dst);\n\n\treturn dst;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"common/ip.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq-be.h\"\n#include \"common/ip.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\ninet *\ncidr_set_masklen_internal(const inet *src, int bits)\n{\n\tinet\t   *dst = (inet *) palloc0(sizeof(inet));\n\n\tip_family(dst) = ip_family(src);\n\tip_bits(dst) = bits;\n\n\tif (bits > 0)\n\t{\n\t\tAssert(bits <= ip_maxbits(dst));\n\n\t\t/* Clone appropriate bytes of the address, leaving the rest 0 */\n\t\tmemcpy(ip_addr(dst), ip_addr(src), (bits + 7) / 8);\n\n\t\t/* Clear any unwanted bits in the last partial byte */\n\t\tif (bits % 8)\n\t\t\tip_addr(dst)[bits / 8] &= ~(0xFF >> (bits % 8));\n\t}\n\n\t/* Set varlena header correctly */\n\tSET_INET_VARSIZE(dst);\n\n\treturn dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitncommon",
          "args": [
            "ip_addr(prefix)",
            "ip_addr(val)",
            "Min(ip_bits(val), commonbits)"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "bitncommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network.c",
          "lines": "1010-1042",
          "snippet": "int\nbitncommon(const unsigned char *l, const unsigned char *r, int n)\n{\n\tint\t\t\tbyte,\n\t\t\t\tnbits;\n\n\t/* number of bits to examine in last byte */\n\tnbits = n % 8;\n\n\t/* check whole bytes */\n\tfor (byte = 0; byte < n / 8; byte++)\n\t{\n\t\tif (l[byte] != r[byte])\n\t\t{\n\t\t\t/* at least one bit in the last byte is not common */\n\t\t\tnbits = 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* check bits in last partial byte */\n\tif (nbits != 0)\n\t{\n\t\t/* calculate diff of first non-matching bytes */\n\t\tunsigned int diff = l[byte] ^ r[byte];\n\n\t\t/* compare the bits from the most to the least */\n\t\twhile ((diff >> (8 - nbits)) != 0)\n\t\t\tnbits--;\n\t}\n\n\treturn (8 * byte) + nbits;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"common/ip.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq-be.h\"\n#include \"common/ip.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nint\nbitncommon(const unsigned char *l, const unsigned char *r, int n)\n{\n\tint\t\t\tbyte,\n\t\t\t\tnbits;\n\n\t/* number of bits to examine in last byte */\n\tnbits = n % 8;\n\n\t/* check whole bytes */\n\tfor (byte = 0; byte < n / 8; byte++)\n\t{\n\t\tif (l[byte] != r[byte])\n\t\t{\n\t\t\t/* at least one bit in the last byte is not common */\n\t\t\tnbits = 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* check bits in last partial byte */\n\tif (nbits != 0)\n\t{\n\t\t/* calculate diff of first non-matching bytes */\n\t\tunsigned int diff = l[byte] ^ r[byte];\n\n\t\t/* compare the bits from the most to the least */\n\t\twhile ((diff >> (8 - nbits)) != 0)\n\t\t\tnbits--;\n\t}\n\n\treturn (8 * byte) + nbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "ip_bits(val)",
            "commonbits"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "val"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "val"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "prefix"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitncmp",
          "args": [
            "ip_addr(prefix)",
            "ip_addr(val)",
            "commonbits"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "bitncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network.c",
          "lines": "976-1003",
          "snippet": "int\nbitncmp(const unsigned char *l, const unsigned char *r, int n)\n{\n\tunsigned int lb,\n\t\t\t\trb;\n\tint\t\t\tx,\n\t\t\t\tb;\n\n\tb = n / 8;\n\tx = memcmp(l, r, b);\n\tif (x || (n % 8) == 0)\n\t\treturn x;\n\n\tlb = l[b];\n\trb = r[b];\n\tfor (b = n % 8; b > 0; b--)\n\t{\n\t\tif (IS_HIGHBIT_SET(lb) != IS_HIGHBIT_SET(rb))\n\t\t{\n\t\t\tif (IS_HIGHBIT_SET(lb))\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t}\n\t\tlb <<= 1;\n\t\trb <<= 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"common/ip.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq-be.h\"\n#include \"common/ip.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nint\nbitncmp(const unsigned char *l, const unsigned char *r, int n)\n{\n\tunsigned int lb,\n\t\t\t\trb;\n\tint\t\t\tx,\n\t\t\t\tb;\n\n\tb = n / 8;\n\tx = memcmp(l, r, b);\n\tif (x || (n % 8) == 0)\n\t\treturn x;\n\n\tlb = l[b];\n\trb = r[b];\n\tfor (b = n % 8; b > 0; b--)\n\t{\n\t\tif (IS_HIGHBIT_SET(lb) != IS_HIGHBIT_SET(rb))\n\t\t{\n\t\t\tif (IS_HIGHBIT_SET(lb))\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t}\n\t\tlb <<= 1;\n\t\trb <<= 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "val"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "prefix"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "val"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InetPGetDatum",
          "args": [
            "prefix"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "prefix"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "prefix"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "val"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "prefix"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetPP",
          "args": [
            "in->prefixDatum"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "in->nNodes == 4 || in->allTheSame"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InetPGetDatum",
          "args": [
            "val"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "val"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "in->nNodes == 2"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!in->allTheSame"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetPP",
          "args": [
            "in->datum"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/spgist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic int\tinet_spg_node_number(const inet *val, int commonbits);\n\nDatum\ninet_spg_choose(PG_FUNCTION_ARGS)\n{\n\tspgChooseIn *in = (spgChooseIn *) PG_GETARG_POINTER(0);\n\tspgChooseOut *out = (spgChooseOut *) PG_GETARG_POINTER(1);\n\tinet\t   *val = DatumGetInetPP(in->datum),\n\t\t\t   *prefix;\n\tint\t\t\tcommonbits;\n\n\t/*\n\t * If we're looking at a tuple that splits by address family, choose the\n\t * appropriate subnode.\n\t */\n\tif (!in->hasPrefix)\n\t{\n\t\t/* allTheSame isn't possible for such a tuple */\n\t\tAssert(!in->allTheSame);\n\t\tAssert(in->nNodes == 2);\n\n\t\tout->resultType = spgMatchNode;\n\t\tout->result.matchNode.nodeN = (ip_family(val) == PGSQL_AF_INET) ? 0 : 1;\n\t\tout->result.matchNode.restDatum = InetPGetDatum(val);\n\n\t\tPG_RETURN_VOID();\n\t}\n\n\t/* Else it must split by prefix */\n\tAssert(in->nNodes == 4 || in->allTheSame);\n\n\tprefix = DatumGetInetPP(in->prefixDatum);\n\tcommonbits = ip_bits(prefix);\n\n\t/*\n\t * We cannot put addresses from different families under the same inner\n\t * node, so we have to split if the new value's family is different.\n\t */\n\tif (ip_family(val) != ip_family(prefix))\n\t{\n\t\t/* Set up 2-node tuple */\n\t\tout->resultType = spgSplitTuple;\n\t\tout->result.splitTuple.prefixHasPrefix = false;\n\t\tout->result.splitTuple.prefixNNodes = 2;\n\t\tout->result.splitTuple.prefixNodeLabels = NULL;\n\n\t\t/* Identify which node the existing data goes into */\n\t\tout->result.splitTuple.childNodeN =\n\t\t\t(ip_family(prefix) == PGSQL_AF_INET) ? 0 : 1;\n\n\t\tout->result.splitTuple.postfixHasPrefix = true;\n\t\tout->result.splitTuple.postfixPrefixDatum = InetPGetDatum(prefix);\n\n\t\tPG_RETURN_VOID();\n\t}\n\n\t/*\n\t * If the new value does not match the existing prefix, we have to split.\n\t */\n\tif (ip_bits(val) < commonbits ||\n\t\tbitncmp(ip_addr(prefix), ip_addr(val), commonbits) != 0)\n\t{\n\t\t/* Determine new prefix length for the split tuple */\n\t\tcommonbits = bitncommon(ip_addr(prefix), ip_addr(val),\n\t\t\t\t\t\t\t\tMin(ip_bits(val), commonbits));\n\n\t\t/* Set up 4-node tuple */\n\t\tout->resultType = spgSplitTuple;\n\t\tout->result.splitTuple.prefixHasPrefix = true;\n\t\tout->result.splitTuple.prefixPrefixDatum =\n\t\t\tInetPGetDatum(cidr_set_masklen_internal(val, commonbits));\n\t\tout->result.splitTuple.prefixNNodes = 4;\n\t\tout->result.splitTuple.prefixNodeLabels = NULL;\n\n\t\t/* Identify which node the existing data goes into */\n\t\tout->result.splitTuple.childNodeN =\n\t\t\tinet_spg_node_number(prefix, commonbits);\n\n\t\tout->result.splitTuple.postfixHasPrefix = true;\n\t\tout->result.splitTuple.postfixPrefixDatum = InetPGetDatum(prefix);\n\n\t\tPG_RETURN_VOID();\n\t}\n\n\t/*\n\t * All OK, choose the node to descend into.  (If this tuple is marked\n\t * allTheSame, the core code will ignore our choice of nodeN; but we need\n\t * not account for that case explicitly here.)\n\t */\n\tout->resultType = spgMatchNode;\n\tout->result.matchNode.nodeN = inet_spg_node_number(val, commonbits);\n\tout->result.matchNode.restDatum = InetPGetDatum(val);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "inet_spg_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_spgist.c",
    "lines": "49-61",
    "snippet": "Datum\ninet_spg_config(PG_FUNCTION_ARGS)\n{\n\t/* spgConfigIn *cfgin = (spgConfigIn *) PG_GETARG_POINTER(0); */\n\tspgConfigOut *cfg = (spgConfigOut *) PG_GETARG_POINTER(1);\n\n\tcfg->prefixType = CIDROID;\n\tcfg->labelType = VOIDOID;\n\tcfg->canReturnData = true;\n\tcfg->longValuesOK = false;\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/spgist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/spgist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nDatum\ninet_spg_config(PG_FUNCTION_ARGS)\n{\n\t/* spgConfigIn *cfgin = (spgConfigIn *) PG_GETARG_POINTER(0); */\n\tspgConfigOut *cfg = (spgConfigOut *) PG_GETARG_POINTER(1);\n\n\tcfg->prefixType = CIDROID;\n\tcfg->labelType = VOIDOID;\n\tcfg->canReturnData = true;\n\tcfg->longValuesOK = false;\n\n\tPG_RETURN_VOID();\n}"
  }
]