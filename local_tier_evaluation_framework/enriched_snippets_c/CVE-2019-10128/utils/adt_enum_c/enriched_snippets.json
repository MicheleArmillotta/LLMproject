[
  {
    "function_name": "enum_range_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "455-521",
    "snippet": "static ArrayType *\nenum_range_internal(Oid enumtypoid, Oid lower, Oid upper)\n{\n\tArrayType  *result;\n\tRelation\tenum_rel;\n\tRelation\tenum_idx;\n\tSysScanDesc enum_scan;\n\tHeapTuple\tenum_tuple;\n\tScanKeyData skey;\n\tDatum\t   *elems;\n\tint\t\t\tmax,\n\t\t\t\tcnt;\n\tbool\t\tleft_found;\n\n\t/*\n\t * Scan the enum members in order using pg_enum_typid_sortorder_index.\n\t * Note we must not use the syscache.  See comments for RenumberEnumType\n\t * in catalog/pg_enum.c for more info.\n\t */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_enum_enumtypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(enumtypoid));\n\n\tenum_rel = heap_open(EnumRelationId, AccessShareLock);\n\tenum_idx = index_open(EnumTypIdSortOrderIndexId, AccessShareLock);\n\tenum_scan = systable_beginscan_ordered(enum_rel, enum_idx, NULL, 1, &skey);\n\n\tmax = 64;\n\telems = (Datum *) palloc(max * sizeof(Datum));\n\tcnt = 0;\n\tleft_found = !OidIsValid(lower);\n\n\twhile (HeapTupleIsValid(enum_tuple = systable_getnext_ordered(enum_scan, ForwardScanDirection)))\n\t{\n\t\tOid\t\t\tenum_oid = HeapTupleGetOid(enum_tuple);\n\n\t\tif (!left_found && lower == enum_oid)\n\t\t\tleft_found = true;\n\n\t\tif (left_found)\n\t\t{\n\t\t\tif (cnt >= max)\n\t\t\t{\n\t\t\t\tmax *= 2;\n\t\t\t\telems = (Datum *) repalloc(elems, max * sizeof(Datum));\n\t\t\t}\n\n\t\t\telems[cnt++] = ObjectIdGetDatum(enum_oid);\n\t\t}\n\n\t\tif (OidIsValid(upper) && upper == enum_oid)\n\t\t\tbreak;\n\t}\n\n\tsystable_endscan_ordered(enum_scan);\n\tindex_close(enum_idx, AccessShareLock);\n\theap_close(enum_rel, AccessShareLock);\n\n\t/* and build the result array */\n\t/* note this hardwires some details about the representation of Oid */\n\tresult = construct_array(elems, cnt, enumtypoid, sizeof(Oid), true, 'i');\n\n\tpfree(elems);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ArrayType *enum_range_internal(Oid enumtypoid, Oid lower, Oid upper);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "elems"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "construct_array",
          "args": [
            "elems",
            "cnt",
            "enumtypoid",
            "sizeof(Oid)",
            "true",
            "'i'"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "construct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3290-3303",
          "snippet": "ArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "enum_rel",
            "AccessShareLock"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_close",
          "args": [
            "enum_idx",
            "AccessShareLock"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan_ordered",
          "args": [
            "enum_scan"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "upper"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "enum_oid"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "elems",
            "max * sizeof(Datum)"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "enum_tuple"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "enum_tuple = systable_getnext_ordered(enum_scan, ForwardScanDirection)"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext_ordered",
          "args": [
            "enum_scan",
            "ForwardScanDirection"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "lower"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "max * sizeof(Datum)"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "systable_beginscan_ordered",
          "args": [
            "enum_rel",
            "enum_idx",
            "NULL",
            "1",
            "&skey"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_open",
          "args": [
            "EnumTypIdSortOrderIndexId",
            "AccessShareLock"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "EnumRelationId",
            "AccessShareLock"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&skey",
            "Anum_pg_enum_enumtypid",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(enumtypoid)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "enumtypoid"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic ArrayType *enum_range_internal(Oid enumtypoid, Oid lower, Oid upper);\n\nstatic ArrayType *\nenum_range_internal(Oid enumtypoid, Oid lower, Oid upper)\n{\n\tArrayType  *result;\n\tRelation\tenum_rel;\n\tRelation\tenum_idx;\n\tSysScanDesc enum_scan;\n\tHeapTuple\tenum_tuple;\n\tScanKeyData skey;\n\tDatum\t   *elems;\n\tint\t\t\tmax,\n\t\t\t\tcnt;\n\tbool\t\tleft_found;\n\n\t/*\n\t * Scan the enum members in order using pg_enum_typid_sortorder_index.\n\t * Note we must not use the syscache.  See comments for RenumberEnumType\n\t * in catalog/pg_enum.c for more info.\n\t */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_enum_enumtypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(enumtypoid));\n\n\tenum_rel = heap_open(EnumRelationId, AccessShareLock);\n\tenum_idx = index_open(EnumTypIdSortOrderIndexId, AccessShareLock);\n\tenum_scan = systable_beginscan_ordered(enum_rel, enum_idx, NULL, 1, &skey);\n\n\tmax = 64;\n\telems = (Datum *) palloc(max * sizeof(Datum));\n\tcnt = 0;\n\tleft_found = !OidIsValid(lower);\n\n\twhile (HeapTupleIsValid(enum_tuple = systable_getnext_ordered(enum_scan, ForwardScanDirection)))\n\t{\n\t\tOid\t\t\tenum_oid = HeapTupleGetOid(enum_tuple);\n\n\t\tif (!left_found && lower == enum_oid)\n\t\t\tleft_found = true;\n\n\t\tif (left_found)\n\t\t{\n\t\t\tif (cnt >= max)\n\t\t\t{\n\t\t\t\tmax *= 2;\n\t\t\t\telems = (Datum *) repalloc(elems, max * sizeof(Datum));\n\t\t\t}\n\n\t\t\telems[cnt++] = ObjectIdGetDatum(enum_oid);\n\t\t}\n\n\t\tif (OidIsValid(upper) && upper == enum_oid)\n\t\t\tbreak;\n\t}\n\n\tsystable_endscan_ordered(enum_scan);\n\tindex_close(enum_idx, AccessShareLock);\n\theap_close(enum_rel, AccessShareLock);\n\n\t/* and build the result array */\n\t/* note this hardwires some details about the representation of Oid */\n\tresult = construct_array(elems, cnt, enumtypoid, sizeof(Oid), true, 'i');\n\n\tpfree(elems);\n\n\treturn result;\n}"
  },
  {
    "function_name": "enum_range_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "435-453",
    "snippet": "Datum\nenum_range_all(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tenumtypoid;\n\n\t/*\n\t * We rely on being able to get the specific enum type from the calling\n\t * expression tree.  Notice that the actual value of the argument isn't\n\t * examined at all; in particular it might be NULL.\n\t */\n\tenumtypoid = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tif (enumtypoid == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not determine actual enum type\")));\n\n\tPG_RETURN_ARRAYTYPE_P(enum_range_internal(enumtypoid,\n\t\t\t\t\t\t\t\t\t\t\t  InvalidOid, InvalidOid));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "enum_range_internal(enumtypoid,\n\t\t\t\t\t\t\t\t\t\t\t  InvalidOid, InvalidOid)"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enum_range_internal",
          "args": [
            "enumtypoid",
            "InvalidOid",
            "InvalidOid"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "enum_range_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
          "lines": "455-521",
          "snippet": "static ArrayType *\nenum_range_internal(Oid enumtypoid, Oid lower, Oid upper)\n{\n\tArrayType  *result;\n\tRelation\tenum_rel;\n\tRelation\tenum_idx;\n\tSysScanDesc enum_scan;\n\tHeapTuple\tenum_tuple;\n\tScanKeyData skey;\n\tDatum\t   *elems;\n\tint\t\t\tmax,\n\t\t\t\tcnt;\n\tbool\t\tleft_found;\n\n\t/*\n\t * Scan the enum members in order using pg_enum_typid_sortorder_index.\n\t * Note we must not use the syscache.  See comments for RenumberEnumType\n\t * in catalog/pg_enum.c for more info.\n\t */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_enum_enumtypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(enumtypoid));\n\n\tenum_rel = heap_open(EnumRelationId, AccessShareLock);\n\tenum_idx = index_open(EnumTypIdSortOrderIndexId, AccessShareLock);\n\tenum_scan = systable_beginscan_ordered(enum_rel, enum_idx, NULL, 1, &skey);\n\n\tmax = 64;\n\telems = (Datum *) palloc(max * sizeof(Datum));\n\tcnt = 0;\n\tleft_found = !OidIsValid(lower);\n\n\twhile (HeapTupleIsValid(enum_tuple = systable_getnext_ordered(enum_scan, ForwardScanDirection)))\n\t{\n\t\tOid\t\t\tenum_oid = HeapTupleGetOid(enum_tuple);\n\n\t\tif (!left_found && lower == enum_oid)\n\t\t\tleft_found = true;\n\n\t\tif (left_found)\n\t\t{\n\t\t\tif (cnt >= max)\n\t\t\t{\n\t\t\t\tmax *= 2;\n\t\t\t\telems = (Datum *) repalloc(elems, max * sizeof(Datum));\n\t\t\t}\n\n\t\t\telems[cnt++] = ObjectIdGetDatum(enum_oid);\n\t\t}\n\n\t\tif (OidIsValid(upper) && upper == enum_oid)\n\t\t\tbreak;\n\t}\n\n\tsystable_endscan_ordered(enum_scan);\n\tindex_close(enum_idx, AccessShareLock);\n\theap_close(enum_rel, AccessShareLock);\n\n\t/* and build the result array */\n\t/* note this hardwires some details about the representation of Oid */\n\tresult = construct_array(elems, cnt, enumtypoid, sizeof(Oid), true, 'i');\n\n\tpfree(elems);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *enum_range_internal(Oid enumtypoid, Oid lower, Oid upper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic ArrayType *enum_range_internal(Oid enumtypoid, Oid lower, Oid upper);\n\nstatic ArrayType *\nenum_range_internal(Oid enumtypoid, Oid lower, Oid upper)\n{\n\tArrayType  *result;\n\tRelation\tenum_rel;\n\tRelation\tenum_idx;\n\tSysScanDesc enum_scan;\n\tHeapTuple\tenum_tuple;\n\tScanKeyData skey;\n\tDatum\t   *elems;\n\tint\t\t\tmax,\n\t\t\t\tcnt;\n\tbool\t\tleft_found;\n\n\t/*\n\t * Scan the enum members in order using pg_enum_typid_sortorder_index.\n\t * Note we must not use the syscache.  See comments for RenumberEnumType\n\t * in catalog/pg_enum.c for more info.\n\t */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_enum_enumtypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(enumtypoid));\n\n\tenum_rel = heap_open(EnumRelationId, AccessShareLock);\n\tenum_idx = index_open(EnumTypIdSortOrderIndexId, AccessShareLock);\n\tenum_scan = systable_beginscan_ordered(enum_rel, enum_idx, NULL, 1, &skey);\n\n\tmax = 64;\n\telems = (Datum *) palloc(max * sizeof(Datum));\n\tcnt = 0;\n\tleft_found = !OidIsValid(lower);\n\n\twhile (HeapTupleIsValid(enum_tuple = systable_getnext_ordered(enum_scan, ForwardScanDirection)))\n\t{\n\t\tOid\t\t\tenum_oid = HeapTupleGetOid(enum_tuple);\n\n\t\tif (!left_found && lower == enum_oid)\n\t\t\tleft_found = true;\n\n\t\tif (left_found)\n\t\t{\n\t\t\tif (cnt >= max)\n\t\t\t{\n\t\t\t\tmax *= 2;\n\t\t\t\telems = (Datum *) repalloc(elems, max * sizeof(Datum));\n\t\t\t}\n\n\t\t\telems[cnt++] = ObjectIdGetDatum(enum_oid);\n\t\t}\n\n\t\tif (OidIsValid(upper) && upper == enum_oid)\n\t\t\tbreak;\n\t}\n\n\tsystable_endscan_ordered(enum_scan);\n\tindex_close(enum_idx, AccessShareLock);\n\theap_close(enum_rel, AccessShareLock);\n\n\t/* and build the result array */\n\t/* note this hardwires some details about the representation of Oid */\n\tresult = construct_array(elems, cnt, enumtypoid, sizeof(Oid), true, 'i');\n\n\tpfree(elems);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not determine actual enum type\"))"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not determine actual enum type\""
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "0"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nDatum\nenum_range_all(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tenumtypoid;\n\n\t/*\n\t * We rely on being able to get the specific enum type from the calling\n\t * expression tree.  Notice that the actual value of the argument isn't\n\t * examined at all; in particular it might be NULL.\n\t */\n\tenumtypoid = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tif (enumtypoid == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not determine actual enum type\")));\n\n\tPG_RETURN_ARRAYTYPE_P(enum_range_internal(enumtypoid,\n\t\t\t\t\t\t\t\t\t\t\t  InvalidOid, InvalidOid));\n}"
  },
  {
    "function_name": "enum_range_bounds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "404-432",
    "snippet": "Datum\nenum_range_bounds(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tlower;\n\tOid\t\t\tupper;\n\tOid\t\t\tenumtypoid;\n\n\tif (PG_ARGISNULL(0))\n\t\tlower = InvalidOid;\n\telse\n\t\tlower = PG_GETARG_OID(0);\n\tif (PG_ARGISNULL(1))\n\t\tupper = InvalidOid;\n\telse\n\t\tupper = PG_GETARG_OID(1);\n\n\t/*\n\t * We rely on being able to get the specific enum type from the calling\n\t * expression tree.  The generic type mechanism should have ensured that\n\t * both are of the same type.\n\t */\n\tenumtypoid = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tif (enumtypoid == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not determine actual enum type\")));\n\n\tPG_RETURN_ARRAYTYPE_P(enum_range_internal(enumtypoid, lower, upper));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ArrayType *enum_range_internal(Oid enumtypoid, Oid lower, Oid upper);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "enum_range_internal(enumtypoid, lower, upper)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enum_range_internal",
          "args": [
            "enumtypoid",
            "lower",
            "upper"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "enum_range_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
          "lines": "455-521",
          "snippet": "static ArrayType *\nenum_range_internal(Oid enumtypoid, Oid lower, Oid upper)\n{\n\tArrayType  *result;\n\tRelation\tenum_rel;\n\tRelation\tenum_idx;\n\tSysScanDesc enum_scan;\n\tHeapTuple\tenum_tuple;\n\tScanKeyData skey;\n\tDatum\t   *elems;\n\tint\t\t\tmax,\n\t\t\t\tcnt;\n\tbool\t\tleft_found;\n\n\t/*\n\t * Scan the enum members in order using pg_enum_typid_sortorder_index.\n\t * Note we must not use the syscache.  See comments for RenumberEnumType\n\t * in catalog/pg_enum.c for more info.\n\t */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_enum_enumtypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(enumtypoid));\n\n\tenum_rel = heap_open(EnumRelationId, AccessShareLock);\n\tenum_idx = index_open(EnumTypIdSortOrderIndexId, AccessShareLock);\n\tenum_scan = systable_beginscan_ordered(enum_rel, enum_idx, NULL, 1, &skey);\n\n\tmax = 64;\n\telems = (Datum *) palloc(max * sizeof(Datum));\n\tcnt = 0;\n\tleft_found = !OidIsValid(lower);\n\n\twhile (HeapTupleIsValid(enum_tuple = systable_getnext_ordered(enum_scan, ForwardScanDirection)))\n\t{\n\t\tOid\t\t\tenum_oid = HeapTupleGetOid(enum_tuple);\n\n\t\tif (!left_found && lower == enum_oid)\n\t\t\tleft_found = true;\n\n\t\tif (left_found)\n\t\t{\n\t\t\tif (cnt >= max)\n\t\t\t{\n\t\t\t\tmax *= 2;\n\t\t\t\telems = (Datum *) repalloc(elems, max * sizeof(Datum));\n\t\t\t}\n\n\t\t\telems[cnt++] = ObjectIdGetDatum(enum_oid);\n\t\t}\n\n\t\tif (OidIsValid(upper) && upper == enum_oid)\n\t\t\tbreak;\n\t}\n\n\tsystable_endscan_ordered(enum_scan);\n\tindex_close(enum_idx, AccessShareLock);\n\theap_close(enum_rel, AccessShareLock);\n\n\t/* and build the result array */\n\t/* note this hardwires some details about the representation of Oid */\n\tresult = construct_array(elems, cnt, enumtypoid, sizeof(Oid), true, 'i');\n\n\tpfree(elems);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *enum_range_internal(Oid enumtypoid, Oid lower, Oid upper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic ArrayType *enum_range_internal(Oid enumtypoid, Oid lower, Oid upper);\n\nstatic ArrayType *\nenum_range_internal(Oid enumtypoid, Oid lower, Oid upper)\n{\n\tArrayType  *result;\n\tRelation\tenum_rel;\n\tRelation\tenum_idx;\n\tSysScanDesc enum_scan;\n\tHeapTuple\tenum_tuple;\n\tScanKeyData skey;\n\tDatum\t   *elems;\n\tint\t\t\tmax,\n\t\t\t\tcnt;\n\tbool\t\tleft_found;\n\n\t/*\n\t * Scan the enum members in order using pg_enum_typid_sortorder_index.\n\t * Note we must not use the syscache.  See comments for RenumberEnumType\n\t * in catalog/pg_enum.c for more info.\n\t */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_enum_enumtypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(enumtypoid));\n\n\tenum_rel = heap_open(EnumRelationId, AccessShareLock);\n\tenum_idx = index_open(EnumTypIdSortOrderIndexId, AccessShareLock);\n\tenum_scan = systable_beginscan_ordered(enum_rel, enum_idx, NULL, 1, &skey);\n\n\tmax = 64;\n\telems = (Datum *) palloc(max * sizeof(Datum));\n\tcnt = 0;\n\tleft_found = !OidIsValid(lower);\n\n\twhile (HeapTupleIsValid(enum_tuple = systable_getnext_ordered(enum_scan, ForwardScanDirection)))\n\t{\n\t\tOid\t\t\tenum_oid = HeapTupleGetOid(enum_tuple);\n\n\t\tif (!left_found && lower == enum_oid)\n\t\t\tleft_found = true;\n\n\t\tif (left_found)\n\t\t{\n\t\t\tif (cnt >= max)\n\t\t\t{\n\t\t\t\tmax *= 2;\n\t\t\t\telems = (Datum *) repalloc(elems, max * sizeof(Datum));\n\t\t\t}\n\n\t\t\telems[cnt++] = ObjectIdGetDatum(enum_oid);\n\t\t}\n\n\t\tif (OidIsValid(upper) && upper == enum_oid)\n\t\t\tbreak;\n\t}\n\n\tsystable_endscan_ordered(enum_scan);\n\tindex_close(enum_idx, AccessShareLock);\n\theap_close(enum_rel, AccessShareLock);\n\n\t/* and build the result array */\n\t/* note this hardwires some details about the representation of Oid */\n\tresult = construct_array(elems, cnt, enumtypoid, sizeof(Oid), true, 'i');\n\n\tpfree(elems);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not determine actual enum type\"))"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not determine actual enum type\""
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "0"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic ArrayType *enum_range_internal(Oid enumtypoid, Oid lower, Oid upper);\n\nDatum\nenum_range_bounds(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tlower;\n\tOid\t\t\tupper;\n\tOid\t\t\tenumtypoid;\n\n\tif (PG_ARGISNULL(0))\n\t\tlower = InvalidOid;\n\telse\n\t\tlower = PG_GETARG_OID(0);\n\tif (PG_ARGISNULL(1))\n\t\tupper = InvalidOid;\n\telse\n\t\tupper = PG_GETARG_OID(1);\n\n\t/*\n\t * We rely on being able to get the specific enum type from the calling\n\t * expression tree.  The generic type mechanism should have ensured that\n\t * both are of the same type.\n\t */\n\tenumtypoid = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tif (enumtypoid == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not determine actual enum type\")));\n\n\tPG_RETURN_ARRAYTYPE_P(enum_range_internal(enumtypoid, lower, upper));\n}"
  },
  {
    "function_name": "enum_last",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "374-401",
    "snippet": "Datum\nenum_last(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tenumtypoid;\n\tOid\t\t\tmax;\n\n\t/*\n\t * We rely on being able to get the specific enum type from the calling\n\t * expression tree.  Notice that the actual value of the argument isn't\n\t * examined at all; in particular it might be NULL.\n\t */\n\tenumtypoid = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tif (enumtypoid == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not determine actual enum type\")));\n\n\t/* Get the OID using the index */\n\tmax = enum_endpoint(enumtypoid, BackwardScanDirection);\n\n\tif (!OidIsValid(max))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"enum %s contains no values\",\n\t\t\t\t\t\tformat_type_be(enumtypoid))));\n\n\tPG_RETURN_OID(max);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "max"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"enum %s contains no values\",\n\t\t\t\t\t\tformat_type_be(enumtypoid)))"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"enum %s contains no values\"",
            "format_type_be(enumtypoid)"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "enumtypoid"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "max"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enum_endpoint",
          "args": [
            "enumtypoid",
            "BackwardScanDirection"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "enum_endpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
          "lines": "307-343",
          "snippet": "static Oid\nenum_endpoint(Oid enumtypoid, ScanDirection direction)\n{\n\tRelation\tenum_rel;\n\tRelation\tenum_idx;\n\tSysScanDesc enum_scan;\n\tHeapTuple\tenum_tuple;\n\tScanKeyData skey;\n\tOid\t\t\tminmax;\n\n\t/*\n\t * Find the first/last enum member using pg_enum_typid_sortorder_index.\n\t * Note we must not use the syscache.  See comments for RenumberEnumType\n\t * in catalog/pg_enum.c for more info.\n\t */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_enum_enumtypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(enumtypoid));\n\n\tenum_rel = heap_open(EnumRelationId, AccessShareLock);\n\tenum_idx = index_open(EnumTypIdSortOrderIndexId, AccessShareLock);\n\tenum_scan = systable_beginscan_ordered(enum_rel, enum_idx, NULL,\n\t\t\t\t\t\t\t\t\t\t   1, &skey);\n\n\tenum_tuple = systable_getnext_ordered(enum_scan, direction);\n\tif (HeapTupleIsValid(enum_tuple))\n\t\tminmax = HeapTupleGetOid(enum_tuple);\n\telse\n\t\tminmax = InvalidOid;\n\n\tsystable_endscan_ordered(enum_scan);\n\tindex_close(enum_idx, AccessShareLock);\n\theap_close(enum_rel, AccessShareLock);\n\n\treturn minmax;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tenum_endpoint(Oid enumtypoid, ScanDirection direction);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic Oid\tenum_endpoint(Oid enumtypoid, ScanDirection direction);\n\nstatic Oid\nenum_endpoint(Oid enumtypoid, ScanDirection direction)\n{\n\tRelation\tenum_rel;\n\tRelation\tenum_idx;\n\tSysScanDesc enum_scan;\n\tHeapTuple\tenum_tuple;\n\tScanKeyData skey;\n\tOid\t\t\tminmax;\n\n\t/*\n\t * Find the first/last enum member using pg_enum_typid_sortorder_index.\n\t * Note we must not use the syscache.  See comments for RenumberEnumType\n\t * in catalog/pg_enum.c for more info.\n\t */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_enum_enumtypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(enumtypoid));\n\n\tenum_rel = heap_open(EnumRelationId, AccessShareLock);\n\tenum_idx = index_open(EnumTypIdSortOrderIndexId, AccessShareLock);\n\tenum_scan = systable_beginscan_ordered(enum_rel, enum_idx, NULL,\n\t\t\t\t\t\t\t\t\t\t   1, &skey);\n\n\tenum_tuple = systable_getnext_ordered(enum_scan, direction);\n\tif (HeapTupleIsValid(enum_tuple))\n\t\tminmax = HeapTupleGetOid(enum_tuple);\n\telse\n\t\tminmax = InvalidOid;\n\n\tsystable_endscan_ordered(enum_scan);\n\tindex_close(enum_idx, AccessShareLock);\n\theap_close(enum_rel, AccessShareLock);\n\n\treturn minmax;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not determine actual enum type\"))"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "0"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nDatum\nenum_last(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tenumtypoid;\n\tOid\t\t\tmax;\n\n\t/*\n\t * We rely on being able to get the specific enum type from the calling\n\t * expression tree.  Notice that the actual value of the argument isn't\n\t * examined at all; in particular it might be NULL.\n\t */\n\tenumtypoid = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tif (enumtypoid == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not determine actual enum type\")));\n\n\t/* Get the OID using the index */\n\tmax = enum_endpoint(enumtypoid, BackwardScanDirection);\n\n\tif (!OidIsValid(max))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"enum %s contains no values\",\n\t\t\t\t\t\tformat_type_be(enumtypoid))));\n\n\tPG_RETURN_OID(max);\n}"
  },
  {
    "function_name": "enum_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "345-372",
    "snippet": "Datum\nenum_first(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tenumtypoid;\n\tOid\t\t\tmin;\n\n\t/*\n\t * We rely on being able to get the specific enum type from the calling\n\t * expression tree.  Notice that the actual value of the argument isn't\n\t * examined at all; in particular it might be NULL.\n\t */\n\tenumtypoid = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tif (enumtypoid == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not determine actual enum type\")));\n\n\t/* Get the OID using the index */\n\tmin = enum_endpoint(enumtypoid, ForwardScanDirection);\n\n\tif (!OidIsValid(min))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"enum %s contains no values\",\n\t\t\t\t\t\tformat_type_be(enumtypoid))));\n\n\tPG_RETURN_OID(min);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "min"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"enum %s contains no values\",\n\t\t\t\t\t\tformat_type_be(enumtypoid)))"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"enum %s contains no values\"",
            "format_type_be(enumtypoid)"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "enumtypoid"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "min"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enum_endpoint",
          "args": [
            "enumtypoid",
            "ForwardScanDirection"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "enum_endpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
          "lines": "307-343",
          "snippet": "static Oid\nenum_endpoint(Oid enumtypoid, ScanDirection direction)\n{\n\tRelation\tenum_rel;\n\tRelation\tenum_idx;\n\tSysScanDesc enum_scan;\n\tHeapTuple\tenum_tuple;\n\tScanKeyData skey;\n\tOid\t\t\tminmax;\n\n\t/*\n\t * Find the first/last enum member using pg_enum_typid_sortorder_index.\n\t * Note we must not use the syscache.  See comments for RenumberEnumType\n\t * in catalog/pg_enum.c for more info.\n\t */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_enum_enumtypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(enumtypoid));\n\n\tenum_rel = heap_open(EnumRelationId, AccessShareLock);\n\tenum_idx = index_open(EnumTypIdSortOrderIndexId, AccessShareLock);\n\tenum_scan = systable_beginscan_ordered(enum_rel, enum_idx, NULL,\n\t\t\t\t\t\t\t\t\t\t   1, &skey);\n\n\tenum_tuple = systable_getnext_ordered(enum_scan, direction);\n\tif (HeapTupleIsValid(enum_tuple))\n\t\tminmax = HeapTupleGetOid(enum_tuple);\n\telse\n\t\tminmax = InvalidOid;\n\n\tsystable_endscan_ordered(enum_scan);\n\tindex_close(enum_idx, AccessShareLock);\n\theap_close(enum_rel, AccessShareLock);\n\n\treturn minmax;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tenum_endpoint(Oid enumtypoid, ScanDirection direction);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic Oid\tenum_endpoint(Oid enumtypoid, ScanDirection direction);\n\nstatic Oid\nenum_endpoint(Oid enumtypoid, ScanDirection direction)\n{\n\tRelation\tenum_rel;\n\tRelation\tenum_idx;\n\tSysScanDesc enum_scan;\n\tHeapTuple\tenum_tuple;\n\tScanKeyData skey;\n\tOid\t\t\tminmax;\n\n\t/*\n\t * Find the first/last enum member using pg_enum_typid_sortorder_index.\n\t * Note we must not use the syscache.  See comments for RenumberEnumType\n\t * in catalog/pg_enum.c for more info.\n\t */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_enum_enumtypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(enumtypoid));\n\n\tenum_rel = heap_open(EnumRelationId, AccessShareLock);\n\tenum_idx = index_open(EnumTypIdSortOrderIndexId, AccessShareLock);\n\tenum_scan = systable_beginscan_ordered(enum_rel, enum_idx, NULL,\n\t\t\t\t\t\t\t\t\t\t   1, &skey);\n\n\tenum_tuple = systable_getnext_ordered(enum_scan, direction);\n\tif (HeapTupleIsValid(enum_tuple))\n\t\tminmax = HeapTupleGetOid(enum_tuple);\n\telse\n\t\tminmax = InvalidOid;\n\n\tsystable_endscan_ordered(enum_scan);\n\tindex_close(enum_idx, AccessShareLock);\n\theap_close(enum_rel, AccessShareLock);\n\n\treturn minmax;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not determine actual enum type\"))"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "0"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nDatum\nenum_first(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tenumtypoid;\n\tOid\t\t\tmin;\n\n\t/*\n\t * We rely on being able to get the specific enum type from the calling\n\t * expression tree.  Notice that the actual value of the argument isn't\n\t * examined at all; in particular it might be NULL.\n\t */\n\tenumtypoid = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tif (enumtypoid == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not determine actual enum type\")));\n\n\t/* Get the OID using the index */\n\tmin = enum_endpoint(enumtypoid, ForwardScanDirection);\n\n\tif (!OidIsValid(min))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"enum %s contains no values\",\n\t\t\t\t\t\tformat_type_be(enumtypoid))));\n\n\tPG_RETURN_OID(min);\n}"
  },
  {
    "function_name": "enum_endpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "307-343",
    "snippet": "static Oid\nenum_endpoint(Oid enumtypoid, ScanDirection direction)\n{\n\tRelation\tenum_rel;\n\tRelation\tenum_idx;\n\tSysScanDesc enum_scan;\n\tHeapTuple\tenum_tuple;\n\tScanKeyData skey;\n\tOid\t\t\tminmax;\n\n\t/*\n\t * Find the first/last enum member using pg_enum_typid_sortorder_index.\n\t * Note we must not use the syscache.  See comments for RenumberEnumType\n\t * in catalog/pg_enum.c for more info.\n\t */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_enum_enumtypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(enumtypoid));\n\n\tenum_rel = heap_open(EnumRelationId, AccessShareLock);\n\tenum_idx = index_open(EnumTypIdSortOrderIndexId, AccessShareLock);\n\tenum_scan = systable_beginscan_ordered(enum_rel, enum_idx, NULL,\n\t\t\t\t\t\t\t\t\t\t   1, &skey);\n\n\tenum_tuple = systable_getnext_ordered(enum_scan, direction);\n\tif (HeapTupleIsValid(enum_tuple))\n\t\tminmax = HeapTupleGetOid(enum_tuple);\n\telse\n\t\tminmax = InvalidOid;\n\n\tsystable_endscan_ordered(enum_scan);\n\tindex_close(enum_idx, AccessShareLock);\n\theap_close(enum_rel, AccessShareLock);\n\n\treturn minmax;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tenum_endpoint(Oid enumtypoid, ScanDirection direction);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "enum_rel",
            "AccessShareLock"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_close",
          "args": [
            "enum_idx",
            "AccessShareLock"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan_ordered",
          "args": [
            "enum_scan"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "enum_tuple"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "enum_tuple"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext_ordered",
          "args": [
            "enum_scan",
            "direction"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan_ordered",
          "args": [
            "enum_rel",
            "enum_idx",
            "NULL",
            "1",
            "&skey"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_open",
          "args": [
            "EnumTypIdSortOrderIndexId",
            "AccessShareLock"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "EnumRelationId",
            "AccessShareLock"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&skey",
            "Anum_pg_enum_enumtypid",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(enumtypoid)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "enumtypoid"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic Oid\tenum_endpoint(Oid enumtypoid, ScanDirection direction);\n\nstatic Oid\nenum_endpoint(Oid enumtypoid, ScanDirection direction)\n{\n\tRelation\tenum_rel;\n\tRelation\tenum_idx;\n\tSysScanDesc enum_scan;\n\tHeapTuple\tenum_tuple;\n\tScanKeyData skey;\n\tOid\t\t\tminmax;\n\n\t/*\n\t * Find the first/last enum member using pg_enum_typid_sortorder_index.\n\t * Note we must not use the syscache.  See comments for RenumberEnumType\n\t * in catalog/pg_enum.c for more info.\n\t */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_enum_enumtypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(enumtypoid));\n\n\tenum_rel = heap_open(EnumRelationId, AccessShareLock);\n\tenum_idx = index_open(EnumTypIdSortOrderIndexId, AccessShareLock);\n\tenum_scan = systable_beginscan_ordered(enum_rel, enum_idx, NULL,\n\t\t\t\t\t\t\t\t\t\t   1, &skey);\n\n\tenum_tuple = systable_getnext_ordered(enum_scan, direction);\n\tif (HeapTupleIsValid(enum_tuple))\n\t\tminmax = HeapTupleGetOid(enum_tuple);\n\telse\n\t\tminmax = InvalidOid;\n\n\tsystable_endscan_ordered(enum_scan);\n\tindex_close(enum_idx, AccessShareLock);\n\theap_close(enum_rel, AccessShareLock);\n\n\treturn minmax;\n}"
  },
  {
    "function_name": "enum_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "293-300",
    "snippet": "Datum\nenum_cmp(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_INT32(enum_cmp_internal(a, b, fcinfo));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "enum_cmp_internal(a, b, fcinfo)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enum_cmp_internal",
          "args": [
            "a",
            "b",
            "fcinfo"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "enum_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
          "lines": "167-219",
          "snippet": "static int\nenum_cmp_internal(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)\n{\n\tTypeCacheEntry *tcache;\n\n\t/*\n\t * We don't need the typcache except in the hopefully-uncommon case that\n\t * one or both Oids are odd.  This means that cursory testing of code that\n\t * fails to pass flinfo to an enum comparison function might not disclose\n\t * the oversight.  To make such errors more obvious, Assert that we have a\n\t * place to cache even when we take a fast-path exit.\n\t */\n\tAssert(fcinfo->flinfo != NULL);\n\n\t/* Equal OIDs are equal no matter what */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Fast path: even-numbered Oids are known to compare correctly */\n\tif ((arg1 & 1) == 0 && (arg2 & 1) == 0)\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/* Locate the typcache entry for the enum type */\n\ttcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (tcache == NULL)\n\t{\n\t\tHeapTuple\tenum_tup;\n\t\tForm_pg_enum en;\n\t\tOid\t\t\ttypeoid;\n\n\t\t/* Get the OID of the enum type containing arg1 */\n\t\tenum_tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(arg1));\n\t\tif (!HeapTupleIsValid(enum_tup))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1)));\n\t\ten = (Form_pg_enum) GETSTRUCT(enum_tup);\n\t\ttypeoid = en->enumtypid;\n\t\tReleaseSysCache(enum_tup);\n\t\t/* Now locate and remember the typcache entry */\n\t\ttcache = lookup_type_cache(typeoid, 0);\n\t\tfcinfo->flinfo->fn_extra = (void *) tcache;\n\t}\n\n\t/* The remaining comparison logic is in typcache.c */\n\treturn compare_values_of_enum(tcache, arg1, arg2);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic int\nenum_cmp_internal(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)\n{\n\tTypeCacheEntry *tcache;\n\n\t/*\n\t * We don't need the typcache except in the hopefully-uncommon case that\n\t * one or both Oids are odd.  This means that cursory testing of code that\n\t * fails to pass flinfo to an enum comparison function might not disclose\n\t * the oversight.  To make such errors more obvious, Assert that we have a\n\t * place to cache even when we take a fast-path exit.\n\t */\n\tAssert(fcinfo->flinfo != NULL);\n\n\t/* Equal OIDs are equal no matter what */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Fast path: even-numbered Oids are known to compare correctly */\n\tif ((arg1 & 1) == 0 && (arg2 & 1) == 0)\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/* Locate the typcache entry for the enum type */\n\ttcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (tcache == NULL)\n\t{\n\t\tHeapTuple\tenum_tup;\n\t\tForm_pg_enum en;\n\t\tOid\t\t\ttypeoid;\n\n\t\t/* Get the OID of the enum type containing arg1 */\n\t\tenum_tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(arg1));\n\t\tif (!HeapTupleIsValid(enum_tup))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1)));\n\t\ten = (Form_pg_enum) GETSTRUCT(enum_tup);\n\t\ttypeoid = en->enumtypid;\n\t\tReleaseSysCache(enum_tup);\n\t\t/* Now locate and remember the typcache entry */\n\t\ttcache = lookup_type_cache(typeoid, 0);\n\t\tfcinfo->flinfo->fn_extra = (void *) tcache;\n\t}\n\n\t/* The remaining comparison logic is in typcache.c */\n\treturn compare_values_of_enum(tcache, arg1, arg2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nDatum\nenum_cmp(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_INT32(enum_cmp_internal(a, b, fcinfo));\n}"
  },
  {
    "function_name": "enum_larger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "284-291",
    "snippet": "Datum\nenum_larger(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_OID(enum_cmp_internal(a, b, fcinfo) > 0 ? a : b);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "enum_cmp_internal(a, b, fcinfo) > 0 ? a : b"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enum_cmp_internal",
          "args": [
            "a",
            "b",
            "fcinfo"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "enum_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
          "lines": "167-219",
          "snippet": "static int\nenum_cmp_internal(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)\n{\n\tTypeCacheEntry *tcache;\n\n\t/*\n\t * We don't need the typcache except in the hopefully-uncommon case that\n\t * one or both Oids are odd.  This means that cursory testing of code that\n\t * fails to pass flinfo to an enum comparison function might not disclose\n\t * the oversight.  To make such errors more obvious, Assert that we have a\n\t * place to cache even when we take a fast-path exit.\n\t */\n\tAssert(fcinfo->flinfo != NULL);\n\n\t/* Equal OIDs are equal no matter what */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Fast path: even-numbered Oids are known to compare correctly */\n\tif ((arg1 & 1) == 0 && (arg2 & 1) == 0)\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/* Locate the typcache entry for the enum type */\n\ttcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (tcache == NULL)\n\t{\n\t\tHeapTuple\tenum_tup;\n\t\tForm_pg_enum en;\n\t\tOid\t\t\ttypeoid;\n\n\t\t/* Get the OID of the enum type containing arg1 */\n\t\tenum_tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(arg1));\n\t\tif (!HeapTupleIsValid(enum_tup))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1)));\n\t\ten = (Form_pg_enum) GETSTRUCT(enum_tup);\n\t\ttypeoid = en->enumtypid;\n\t\tReleaseSysCache(enum_tup);\n\t\t/* Now locate and remember the typcache entry */\n\t\ttcache = lookup_type_cache(typeoid, 0);\n\t\tfcinfo->flinfo->fn_extra = (void *) tcache;\n\t}\n\n\t/* The remaining comparison logic is in typcache.c */\n\treturn compare_values_of_enum(tcache, arg1, arg2);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic int\nenum_cmp_internal(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)\n{\n\tTypeCacheEntry *tcache;\n\n\t/*\n\t * We don't need the typcache except in the hopefully-uncommon case that\n\t * one or both Oids are odd.  This means that cursory testing of code that\n\t * fails to pass flinfo to an enum comparison function might not disclose\n\t * the oversight.  To make such errors more obvious, Assert that we have a\n\t * place to cache even when we take a fast-path exit.\n\t */\n\tAssert(fcinfo->flinfo != NULL);\n\n\t/* Equal OIDs are equal no matter what */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Fast path: even-numbered Oids are known to compare correctly */\n\tif ((arg1 & 1) == 0 && (arg2 & 1) == 0)\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/* Locate the typcache entry for the enum type */\n\ttcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (tcache == NULL)\n\t{\n\t\tHeapTuple\tenum_tup;\n\t\tForm_pg_enum en;\n\t\tOid\t\t\ttypeoid;\n\n\t\t/* Get the OID of the enum type containing arg1 */\n\t\tenum_tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(arg1));\n\t\tif (!HeapTupleIsValid(enum_tup))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1)));\n\t\ten = (Form_pg_enum) GETSTRUCT(enum_tup);\n\t\ttypeoid = en->enumtypid;\n\t\tReleaseSysCache(enum_tup);\n\t\t/* Now locate and remember the typcache entry */\n\t\ttcache = lookup_type_cache(typeoid, 0);\n\t\tfcinfo->flinfo->fn_extra = (void *) tcache;\n\t}\n\n\t/* The remaining comparison logic is in typcache.c */\n\treturn compare_values_of_enum(tcache, arg1, arg2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nDatum\nenum_larger(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_OID(enum_cmp_internal(a, b, fcinfo) > 0 ? a : b);\n}"
  },
  {
    "function_name": "enum_smaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "275-282",
    "snippet": "Datum\nenum_smaller(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_OID(enum_cmp_internal(a, b, fcinfo) < 0 ? a : b);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "enum_cmp_internal(a, b, fcinfo) < 0 ? a : b"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enum_cmp_internal",
          "args": [
            "a",
            "b",
            "fcinfo"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "enum_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
          "lines": "167-219",
          "snippet": "static int\nenum_cmp_internal(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)\n{\n\tTypeCacheEntry *tcache;\n\n\t/*\n\t * We don't need the typcache except in the hopefully-uncommon case that\n\t * one or both Oids are odd.  This means that cursory testing of code that\n\t * fails to pass flinfo to an enum comparison function might not disclose\n\t * the oversight.  To make such errors more obvious, Assert that we have a\n\t * place to cache even when we take a fast-path exit.\n\t */\n\tAssert(fcinfo->flinfo != NULL);\n\n\t/* Equal OIDs are equal no matter what */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Fast path: even-numbered Oids are known to compare correctly */\n\tif ((arg1 & 1) == 0 && (arg2 & 1) == 0)\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/* Locate the typcache entry for the enum type */\n\ttcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (tcache == NULL)\n\t{\n\t\tHeapTuple\tenum_tup;\n\t\tForm_pg_enum en;\n\t\tOid\t\t\ttypeoid;\n\n\t\t/* Get the OID of the enum type containing arg1 */\n\t\tenum_tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(arg1));\n\t\tif (!HeapTupleIsValid(enum_tup))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1)));\n\t\ten = (Form_pg_enum) GETSTRUCT(enum_tup);\n\t\ttypeoid = en->enumtypid;\n\t\tReleaseSysCache(enum_tup);\n\t\t/* Now locate and remember the typcache entry */\n\t\ttcache = lookup_type_cache(typeoid, 0);\n\t\tfcinfo->flinfo->fn_extra = (void *) tcache;\n\t}\n\n\t/* The remaining comparison logic is in typcache.c */\n\treturn compare_values_of_enum(tcache, arg1, arg2);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic int\nenum_cmp_internal(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)\n{\n\tTypeCacheEntry *tcache;\n\n\t/*\n\t * We don't need the typcache except in the hopefully-uncommon case that\n\t * one or both Oids are odd.  This means that cursory testing of code that\n\t * fails to pass flinfo to an enum comparison function might not disclose\n\t * the oversight.  To make such errors more obvious, Assert that we have a\n\t * place to cache even when we take a fast-path exit.\n\t */\n\tAssert(fcinfo->flinfo != NULL);\n\n\t/* Equal OIDs are equal no matter what */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Fast path: even-numbered Oids are known to compare correctly */\n\tif ((arg1 & 1) == 0 && (arg2 & 1) == 0)\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/* Locate the typcache entry for the enum type */\n\ttcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (tcache == NULL)\n\t{\n\t\tHeapTuple\tenum_tup;\n\t\tForm_pg_enum en;\n\t\tOid\t\t\ttypeoid;\n\n\t\t/* Get the OID of the enum type containing arg1 */\n\t\tenum_tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(arg1));\n\t\tif (!HeapTupleIsValid(enum_tup))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1)));\n\t\ten = (Form_pg_enum) GETSTRUCT(enum_tup);\n\t\ttypeoid = en->enumtypid;\n\t\tReleaseSysCache(enum_tup);\n\t\t/* Now locate and remember the typcache entry */\n\t\ttcache = lookup_type_cache(typeoid, 0);\n\t\tfcinfo->flinfo->fn_extra = (void *) tcache;\n\t}\n\n\t/* The remaining comparison logic is in typcache.c */\n\treturn compare_values_of_enum(tcache, arg1, arg2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nDatum\nenum_smaller(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_OID(enum_cmp_internal(a, b, fcinfo) < 0 ? a : b);\n}"
  },
  {
    "function_name": "enum_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "266-273",
    "snippet": "Datum\nenum_gt(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(enum_cmp_internal(a, b, fcinfo) > 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "enum_cmp_internal(a, b, fcinfo) > 0"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enum_cmp_internal",
          "args": [
            "a",
            "b",
            "fcinfo"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "enum_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
          "lines": "167-219",
          "snippet": "static int\nenum_cmp_internal(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)\n{\n\tTypeCacheEntry *tcache;\n\n\t/*\n\t * We don't need the typcache except in the hopefully-uncommon case that\n\t * one or both Oids are odd.  This means that cursory testing of code that\n\t * fails to pass flinfo to an enum comparison function might not disclose\n\t * the oversight.  To make such errors more obvious, Assert that we have a\n\t * place to cache even when we take a fast-path exit.\n\t */\n\tAssert(fcinfo->flinfo != NULL);\n\n\t/* Equal OIDs are equal no matter what */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Fast path: even-numbered Oids are known to compare correctly */\n\tif ((arg1 & 1) == 0 && (arg2 & 1) == 0)\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/* Locate the typcache entry for the enum type */\n\ttcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (tcache == NULL)\n\t{\n\t\tHeapTuple\tenum_tup;\n\t\tForm_pg_enum en;\n\t\tOid\t\t\ttypeoid;\n\n\t\t/* Get the OID of the enum type containing arg1 */\n\t\tenum_tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(arg1));\n\t\tif (!HeapTupleIsValid(enum_tup))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1)));\n\t\ten = (Form_pg_enum) GETSTRUCT(enum_tup);\n\t\ttypeoid = en->enumtypid;\n\t\tReleaseSysCache(enum_tup);\n\t\t/* Now locate and remember the typcache entry */\n\t\ttcache = lookup_type_cache(typeoid, 0);\n\t\tfcinfo->flinfo->fn_extra = (void *) tcache;\n\t}\n\n\t/* The remaining comparison logic is in typcache.c */\n\treturn compare_values_of_enum(tcache, arg1, arg2);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic int\nenum_cmp_internal(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)\n{\n\tTypeCacheEntry *tcache;\n\n\t/*\n\t * We don't need the typcache except in the hopefully-uncommon case that\n\t * one or both Oids are odd.  This means that cursory testing of code that\n\t * fails to pass flinfo to an enum comparison function might not disclose\n\t * the oversight.  To make such errors more obvious, Assert that we have a\n\t * place to cache even when we take a fast-path exit.\n\t */\n\tAssert(fcinfo->flinfo != NULL);\n\n\t/* Equal OIDs are equal no matter what */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Fast path: even-numbered Oids are known to compare correctly */\n\tif ((arg1 & 1) == 0 && (arg2 & 1) == 0)\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/* Locate the typcache entry for the enum type */\n\ttcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (tcache == NULL)\n\t{\n\t\tHeapTuple\tenum_tup;\n\t\tForm_pg_enum en;\n\t\tOid\t\t\ttypeoid;\n\n\t\t/* Get the OID of the enum type containing arg1 */\n\t\tenum_tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(arg1));\n\t\tif (!HeapTupleIsValid(enum_tup))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1)));\n\t\ten = (Form_pg_enum) GETSTRUCT(enum_tup);\n\t\ttypeoid = en->enumtypid;\n\t\tReleaseSysCache(enum_tup);\n\t\t/* Now locate and remember the typcache entry */\n\t\ttcache = lookup_type_cache(typeoid, 0);\n\t\tfcinfo->flinfo->fn_extra = (void *) tcache;\n\t}\n\n\t/* The remaining comparison logic is in typcache.c */\n\treturn compare_values_of_enum(tcache, arg1, arg2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nDatum\nenum_gt(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(enum_cmp_internal(a, b, fcinfo) > 0);\n}"
  },
  {
    "function_name": "enum_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "257-264",
    "snippet": "Datum\nenum_ge(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(enum_cmp_internal(a, b, fcinfo) >= 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "enum_cmp_internal(a, b, fcinfo) >= 0"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enum_cmp_internal",
          "args": [
            "a",
            "b",
            "fcinfo"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "enum_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
          "lines": "167-219",
          "snippet": "static int\nenum_cmp_internal(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)\n{\n\tTypeCacheEntry *tcache;\n\n\t/*\n\t * We don't need the typcache except in the hopefully-uncommon case that\n\t * one or both Oids are odd.  This means that cursory testing of code that\n\t * fails to pass flinfo to an enum comparison function might not disclose\n\t * the oversight.  To make such errors more obvious, Assert that we have a\n\t * place to cache even when we take a fast-path exit.\n\t */\n\tAssert(fcinfo->flinfo != NULL);\n\n\t/* Equal OIDs are equal no matter what */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Fast path: even-numbered Oids are known to compare correctly */\n\tif ((arg1 & 1) == 0 && (arg2 & 1) == 0)\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/* Locate the typcache entry for the enum type */\n\ttcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (tcache == NULL)\n\t{\n\t\tHeapTuple\tenum_tup;\n\t\tForm_pg_enum en;\n\t\tOid\t\t\ttypeoid;\n\n\t\t/* Get the OID of the enum type containing arg1 */\n\t\tenum_tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(arg1));\n\t\tif (!HeapTupleIsValid(enum_tup))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1)));\n\t\ten = (Form_pg_enum) GETSTRUCT(enum_tup);\n\t\ttypeoid = en->enumtypid;\n\t\tReleaseSysCache(enum_tup);\n\t\t/* Now locate and remember the typcache entry */\n\t\ttcache = lookup_type_cache(typeoid, 0);\n\t\tfcinfo->flinfo->fn_extra = (void *) tcache;\n\t}\n\n\t/* The remaining comparison logic is in typcache.c */\n\treturn compare_values_of_enum(tcache, arg1, arg2);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic int\nenum_cmp_internal(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)\n{\n\tTypeCacheEntry *tcache;\n\n\t/*\n\t * We don't need the typcache except in the hopefully-uncommon case that\n\t * one or both Oids are odd.  This means that cursory testing of code that\n\t * fails to pass flinfo to an enum comparison function might not disclose\n\t * the oversight.  To make such errors more obvious, Assert that we have a\n\t * place to cache even when we take a fast-path exit.\n\t */\n\tAssert(fcinfo->flinfo != NULL);\n\n\t/* Equal OIDs are equal no matter what */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Fast path: even-numbered Oids are known to compare correctly */\n\tif ((arg1 & 1) == 0 && (arg2 & 1) == 0)\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/* Locate the typcache entry for the enum type */\n\ttcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (tcache == NULL)\n\t{\n\t\tHeapTuple\tenum_tup;\n\t\tForm_pg_enum en;\n\t\tOid\t\t\ttypeoid;\n\n\t\t/* Get the OID of the enum type containing arg1 */\n\t\tenum_tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(arg1));\n\t\tif (!HeapTupleIsValid(enum_tup))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1)));\n\t\ten = (Form_pg_enum) GETSTRUCT(enum_tup);\n\t\ttypeoid = en->enumtypid;\n\t\tReleaseSysCache(enum_tup);\n\t\t/* Now locate and remember the typcache entry */\n\t\ttcache = lookup_type_cache(typeoid, 0);\n\t\tfcinfo->flinfo->fn_extra = (void *) tcache;\n\t}\n\n\t/* The remaining comparison logic is in typcache.c */\n\treturn compare_values_of_enum(tcache, arg1, arg2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nDatum\nenum_ge(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(enum_cmp_internal(a, b, fcinfo) >= 0);\n}"
  },
  {
    "function_name": "enum_ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "248-255",
    "snippet": "Datum\nenum_ne(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(a != b);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "a != b"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nDatum\nenum_ne(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(a != b);\n}"
  },
  {
    "function_name": "enum_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "239-246",
    "snippet": "Datum\nenum_eq(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(a == b);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "a == b"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nDatum\nenum_eq(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(a == b);\n}"
  },
  {
    "function_name": "enum_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "230-237",
    "snippet": "Datum\nenum_le(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(enum_cmp_internal(a, b, fcinfo) <= 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "enum_cmp_internal(a, b, fcinfo) <= 0"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enum_cmp_internal",
          "args": [
            "a",
            "b",
            "fcinfo"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "enum_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
          "lines": "167-219",
          "snippet": "static int\nenum_cmp_internal(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)\n{\n\tTypeCacheEntry *tcache;\n\n\t/*\n\t * We don't need the typcache except in the hopefully-uncommon case that\n\t * one or both Oids are odd.  This means that cursory testing of code that\n\t * fails to pass flinfo to an enum comparison function might not disclose\n\t * the oversight.  To make such errors more obvious, Assert that we have a\n\t * place to cache even when we take a fast-path exit.\n\t */\n\tAssert(fcinfo->flinfo != NULL);\n\n\t/* Equal OIDs are equal no matter what */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Fast path: even-numbered Oids are known to compare correctly */\n\tif ((arg1 & 1) == 0 && (arg2 & 1) == 0)\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/* Locate the typcache entry for the enum type */\n\ttcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (tcache == NULL)\n\t{\n\t\tHeapTuple\tenum_tup;\n\t\tForm_pg_enum en;\n\t\tOid\t\t\ttypeoid;\n\n\t\t/* Get the OID of the enum type containing arg1 */\n\t\tenum_tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(arg1));\n\t\tif (!HeapTupleIsValid(enum_tup))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1)));\n\t\ten = (Form_pg_enum) GETSTRUCT(enum_tup);\n\t\ttypeoid = en->enumtypid;\n\t\tReleaseSysCache(enum_tup);\n\t\t/* Now locate and remember the typcache entry */\n\t\ttcache = lookup_type_cache(typeoid, 0);\n\t\tfcinfo->flinfo->fn_extra = (void *) tcache;\n\t}\n\n\t/* The remaining comparison logic is in typcache.c */\n\treturn compare_values_of_enum(tcache, arg1, arg2);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic int\nenum_cmp_internal(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)\n{\n\tTypeCacheEntry *tcache;\n\n\t/*\n\t * We don't need the typcache except in the hopefully-uncommon case that\n\t * one or both Oids are odd.  This means that cursory testing of code that\n\t * fails to pass flinfo to an enum comparison function might not disclose\n\t * the oversight.  To make such errors more obvious, Assert that we have a\n\t * place to cache even when we take a fast-path exit.\n\t */\n\tAssert(fcinfo->flinfo != NULL);\n\n\t/* Equal OIDs are equal no matter what */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Fast path: even-numbered Oids are known to compare correctly */\n\tif ((arg1 & 1) == 0 && (arg2 & 1) == 0)\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/* Locate the typcache entry for the enum type */\n\ttcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (tcache == NULL)\n\t{\n\t\tHeapTuple\tenum_tup;\n\t\tForm_pg_enum en;\n\t\tOid\t\t\ttypeoid;\n\n\t\t/* Get the OID of the enum type containing arg1 */\n\t\tenum_tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(arg1));\n\t\tif (!HeapTupleIsValid(enum_tup))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1)));\n\t\ten = (Form_pg_enum) GETSTRUCT(enum_tup);\n\t\ttypeoid = en->enumtypid;\n\t\tReleaseSysCache(enum_tup);\n\t\t/* Now locate and remember the typcache entry */\n\t\ttcache = lookup_type_cache(typeoid, 0);\n\t\tfcinfo->flinfo->fn_extra = (void *) tcache;\n\t}\n\n\t/* The remaining comparison logic is in typcache.c */\n\treturn compare_values_of_enum(tcache, arg1, arg2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nDatum\nenum_le(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(enum_cmp_internal(a, b, fcinfo) <= 0);\n}"
  },
  {
    "function_name": "enum_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "221-228",
    "snippet": "Datum\nenum_lt(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(enum_cmp_internal(a, b, fcinfo) < 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "enum_cmp_internal(a, b, fcinfo) < 0"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enum_cmp_internal",
          "args": [
            "a",
            "b",
            "fcinfo"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "enum_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
          "lines": "167-219",
          "snippet": "static int\nenum_cmp_internal(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)\n{\n\tTypeCacheEntry *tcache;\n\n\t/*\n\t * We don't need the typcache except in the hopefully-uncommon case that\n\t * one or both Oids are odd.  This means that cursory testing of code that\n\t * fails to pass flinfo to an enum comparison function might not disclose\n\t * the oversight.  To make such errors more obvious, Assert that we have a\n\t * place to cache even when we take a fast-path exit.\n\t */\n\tAssert(fcinfo->flinfo != NULL);\n\n\t/* Equal OIDs are equal no matter what */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Fast path: even-numbered Oids are known to compare correctly */\n\tif ((arg1 & 1) == 0 && (arg2 & 1) == 0)\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/* Locate the typcache entry for the enum type */\n\ttcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (tcache == NULL)\n\t{\n\t\tHeapTuple\tenum_tup;\n\t\tForm_pg_enum en;\n\t\tOid\t\t\ttypeoid;\n\n\t\t/* Get the OID of the enum type containing arg1 */\n\t\tenum_tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(arg1));\n\t\tif (!HeapTupleIsValid(enum_tup))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1)));\n\t\ten = (Form_pg_enum) GETSTRUCT(enum_tup);\n\t\ttypeoid = en->enumtypid;\n\t\tReleaseSysCache(enum_tup);\n\t\t/* Now locate and remember the typcache entry */\n\t\ttcache = lookup_type_cache(typeoid, 0);\n\t\tfcinfo->flinfo->fn_extra = (void *) tcache;\n\t}\n\n\t/* The remaining comparison logic is in typcache.c */\n\treturn compare_values_of_enum(tcache, arg1, arg2);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic int\nenum_cmp_internal(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)\n{\n\tTypeCacheEntry *tcache;\n\n\t/*\n\t * We don't need the typcache except in the hopefully-uncommon case that\n\t * one or both Oids are odd.  This means that cursory testing of code that\n\t * fails to pass flinfo to an enum comparison function might not disclose\n\t * the oversight.  To make such errors more obvious, Assert that we have a\n\t * place to cache even when we take a fast-path exit.\n\t */\n\tAssert(fcinfo->flinfo != NULL);\n\n\t/* Equal OIDs are equal no matter what */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Fast path: even-numbered Oids are known to compare correctly */\n\tif ((arg1 & 1) == 0 && (arg2 & 1) == 0)\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/* Locate the typcache entry for the enum type */\n\ttcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (tcache == NULL)\n\t{\n\t\tHeapTuple\tenum_tup;\n\t\tForm_pg_enum en;\n\t\tOid\t\t\ttypeoid;\n\n\t\t/* Get the OID of the enum type containing arg1 */\n\t\tenum_tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(arg1));\n\t\tif (!HeapTupleIsValid(enum_tup))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1)));\n\t\ten = (Form_pg_enum) GETSTRUCT(enum_tup);\n\t\ttypeoid = en->enumtypid;\n\t\tReleaseSysCache(enum_tup);\n\t\t/* Now locate and remember the typcache entry */\n\t\ttcache = lookup_type_cache(typeoid, 0);\n\t\tfcinfo->flinfo->fn_extra = (void *) tcache;\n\t}\n\n\t/* The remaining comparison logic is in typcache.c */\n\treturn compare_values_of_enum(tcache, arg1, arg2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nDatum\nenum_lt(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ta = PG_GETARG_OID(0);\n\tOid\t\t\tb = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(enum_cmp_internal(a, b, fcinfo) < 0);\n}"
  },
  {
    "function_name": "enum_cmp_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "167-219",
    "snippet": "static int\nenum_cmp_internal(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)\n{\n\tTypeCacheEntry *tcache;\n\n\t/*\n\t * We don't need the typcache except in the hopefully-uncommon case that\n\t * one or both Oids are odd.  This means that cursory testing of code that\n\t * fails to pass flinfo to an enum comparison function might not disclose\n\t * the oversight.  To make such errors more obvious, Assert that we have a\n\t * place to cache even when we take a fast-path exit.\n\t */\n\tAssert(fcinfo->flinfo != NULL);\n\n\t/* Equal OIDs are equal no matter what */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Fast path: even-numbered Oids are known to compare correctly */\n\tif ((arg1 & 1) == 0 && (arg2 & 1) == 0)\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/* Locate the typcache entry for the enum type */\n\ttcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (tcache == NULL)\n\t{\n\t\tHeapTuple\tenum_tup;\n\t\tForm_pg_enum en;\n\t\tOid\t\t\ttypeoid;\n\n\t\t/* Get the OID of the enum type containing arg1 */\n\t\tenum_tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(arg1));\n\t\tif (!HeapTupleIsValid(enum_tup))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1)));\n\t\ten = (Form_pg_enum) GETSTRUCT(enum_tup);\n\t\ttypeoid = en->enumtypid;\n\t\tReleaseSysCache(enum_tup);\n\t\t/* Now locate and remember the typcache entry */\n\t\ttcache = lookup_type_cache(typeoid, 0);\n\t\tfcinfo->flinfo->fn_extra = (void *) tcache;\n\t}\n\n\t/* The remaining comparison logic is in typcache.c */\n\treturn compare_values_of_enum(tcache, arg1, arg2);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compare_values_of_enum",
          "args": [
            "tcache",
            "arg1",
            "arg2"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "compare_values_of_enum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "2225-2293",
          "snippet": "int\ncompare_values_of_enum(TypeCacheEntry *tcache, Oid arg1, Oid arg2)\n{\n\tTypeCacheEnumData *enumdata;\n\tEnumItem   *item1;\n\tEnumItem   *item2;\n\n\t/*\n\t * Equal OIDs are certainly equal --- this case was probably handled by\n\t * our caller, but we may as well check.\n\t */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Load up the cache if first time through */\n\tif (tcache->enumData == NULL)\n\t\tload_enum_cache_data(tcache);\n\tenumdata = tcache->enumData;\n\n\t/*\n\t * If both OIDs are known-sorted, we can just compare them directly.\n\t */\n\tif (enum_known_sorted(enumdata, arg1) &&\n\t\tenum_known_sorted(enumdata, arg2))\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/*\n\t * Slow path: we have to identify their actual sort-order positions.\n\t */\n\titem1 = find_enumitem(enumdata, arg1);\n\titem2 = find_enumitem(enumdata, arg2);\n\n\tif (item1 == NULL || item2 == NULL)\n\t{\n\t\t/*\n\t\t * We couldn't find one or both values.  That means the enum has\n\t\t * changed under us, so re-initialize the cache and try again. We\n\t\t * don't bother retrying the known-sorted case in this path.\n\t\t */\n\t\tload_enum_cache_data(tcache);\n\t\tenumdata = tcache->enumData;\n\n\t\titem1 = find_enumitem(enumdata, arg1);\n\t\titem2 = find_enumitem(enumdata, arg2);\n\n\t\t/*\n\t\t * If we still can't find the values, complain: we must have corrupt\n\t\t * data.\n\t\t */\n\t\tif (item1 == NULL)\n\t\t\telog(ERROR, \"enum value %u not found in cache for enum %s\",\n\t\t\t\t arg1, format_type_be(tcache->type_id));\n\t\tif (item2 == NULL)\n\t\t\telog(ERROR, \"enum value %u not found in cache for enum %s\",\n\t\t\t\t arg2, format_type_be(tcache->type_id));\n\t}\n\n\tif (item1->sort_order < item2->sort_order)\n\t\treturn -1;\n\telse if (item1->sort_order > item2->sort_order)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void load_enum_cache_data(TypeCacheEntry *tcache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void load_enum_cache_data(TypeCacheEntry *tcache);\n\nint\ncompare_values_of_enum(TypeCacheEntry *tcache, Oid arg1, Oid arg2)\n{\n\tTypeCacheEnumData *enumdata;\n\tEnumItem   *item1;\n\tEnumItem   *item2;\n\n\t/*\n\t * Equal OIDs are certainly equal --- this case was probably handled by\n\t * our caller, but we may as well check.\n\t */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Load up the cache if first time through */\n\tif (tcache->enumData == NULL)\n\t\tload_enum_cache_data(tcache);\n\tenumdata = tcache->enumData;\n\n\t/*\n\t * If both OIDs are known-sorted, we can just compare them directly.\n\t */\n\tif (enum_known_sorted(enumdata, arg1) &&\n\t\tenum_known_sorted(enumdata, arg2))\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/*\n\t * Slow path: we have to identify their actual sort-order positions.\n\t */\n\titem1 = find_enumitem(enumdata, arg1);\n\titem2 = find_enumitem(enumdata, arg2);\n\n\tif (item1 == NULL || item2 == NULL)\n\t{\n\t\t/*\n\t\t * We couldn't find one or both values.  That means the enum has\n\t\t * changed under us, so re-initialize the cache and try again. We\n\t\t * don't bother retrying the known-sorted case in this path.\n\t\t */\n\t\tload_enum_cache_data(tcache);\n\t\tenumdata = tcache->enumData;\n\n\t\titem1 = find_enumitem(enumdata, arg1);\n\t\titem2 = find_enumitem(enumdata, arg2);\n\n\t\t/*\n\t\t * If we still can't find the values, complain: we must have corrupt\n\t\t * data.\n\t\t */\n\t\tif (item1 == NULL)\n\t\t\telog(ERROR, \"enum value %u not found in cache for enum %s\",\n\t\t\t\t arg1, format_type_be(tcache->type_id));\n\t\tif (item2 == NULL)\n\t\t\telog(ERROR, \"enum value %u not found in cache for enum %s\",\n\t\t\t\t arg2, format_type_be(tcache->type_id));\n\t}\n\n\tif (item1->sort_order < item2->sort_order)\n\t\treturn -1;\n\telse if (item1->sort_order > item2->sort_order)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "typeoid",
            "0"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "enum_tup"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "enum_tup"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1))"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid internal value for enum: %u\"",
            "arg1"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_BINARY_REPRESENTATION"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "enum_tup"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "ENUMOID",
            "ObjectIdGetDatum(arg1)"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "arg1"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "fcinfo->flinfo != NULL"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic int\nenum_cmp_internal(Oid arg1, Oid arg2, FunctionCallInfo fcinfo)\n{\n\tTypeCacheEntry *tcache;\n\n\t/*\n\t * We don't need the typcache except in the hopefully-uncommon case that\n\t * one or both Oids are odd.  This means that cursory testing of code that\n\t * fails to pass flinfo to an enum comparison function might not disclose\n\t * the oversight.  To make such errors more obvious, Assert that we have a\n\t * place to cache even when we take a fast-path exit.\n\t */\n\tAssert(fcinfo->flinfo != NULL);\n\n\t/* Equal OIDs are equal no matter what */\n\tif (arg1 == arg2)\n\t\treturn 0;\n\n\t/* Fast path: even-numbered Oids are known to compare correctly */\n\tif ((arg1 & 1) == 0 && (arg2 & 1) == 0)\n\t{\n\t\tif (arg1 < arg2)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/* Locate the typcache entry for the enum type */\n\ttcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (tcache == NULL)\n\t{\n\t\tHeapTuple\tenum_tup;\n\t\tForm_pg_enum en;\n\t\tOid\t\t\ttypeoid;\n\n\t\t/* Get the OID of the enum type containing arg1 */\n\t\tenum_tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(arg1));\n\t\tif (!HeapTupleIsValid(enum_tup))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\t\targ1)));\n\t\ten = (Form_pg_enum) GETSTRUCT(enum_tup);\n\t\ttypeoid = en->enumtypid;\n\t\tReleaseSysCache(enum_tup);\n\t\t/* Now locate and remember the typcache entry */\n\t\ttcache = lookup_type_cache(typeoid, 0);\n\t\tfcinfo->flinfo->fn_extra = (void *) tcache;\n\t}\n\n\t/* The remaining comparison logic is in typcache.c */\n\treturn compare_values_of_enum(tcache, arg1, arg2);\n}"
  },
  {
    "function_name": "enum_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "136-158",
    "snippet": "Datum\nenum_send(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tenumval = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\tHeapTuple\ttup;\n\tForm_pg_enum en;\n\n\ttup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(enumval));\n\tif (!HeapTupleIsValid(tup))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\tenumval)));\n\ten = (Form_pg_enum) GETSTRUCT(tup);\n\n\tpq_begintypsend(&buf);\n\tpq_sendtext(&buf, NameStr(en->enumlabel), strlen(NameStr(en->enumlabel)));\n\n\tReleaseSysCache(tup);\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tup"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_sendtext",
          "args": [
            "&buf",
            "NameStr(en->enumlabel)",
            "strlen(NameStr(en->enumlabel))"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "NameStr(en->enumlabel)"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "en->enumlabel"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "en->enumlabel"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tup"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\tenumval))"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid internal value for enum: %u\"",
            "enumval"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_BINARY_REPRESENTATION"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tup"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "ENUMOID",
            "ObjectIdGetDatum(enumval)"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "enumval"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nDatum\nenum_send(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tenumval = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\tHeapTuple\ttup;\n\tForm_pg_enum en;\n\n\ttup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(enumval));\n\tif (!HeapTupleIsValid(tup))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\tenumval)));\n\ten = (Form_pg_enum) GETSTRUCT(tup);\n\n\tpq_begintypsend(&buf);\n\tpq_sendtext(&buf, NameStr(en->enumlabel), strlen(NameStr(en->enumlabel)));\n\n\tReleaseSysCache(tup);\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "enum_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "97-134",
    "snippet": "Datum\nenum_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tOid\t\t\tenumtypoid = PG_GETARG_OID(1);\n\tOid\t\t\tenumoid;\n\tHeapTuple\ttup;\n\tchar\t   *name;\n\tint\t\t\tnbytes;\n\n\tname = pq_getmsgtext(buf, buf->len - buf->cursor, &nbytes);\n\n\t/* must check length to prevent Assert failure within SearchSysCache */\n\tif (strlen(name) >= NAMEDATALEN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input value for enum %s: \\\"%s\\\"\",\n\t\t\t\t\t\tformat_type_be(enumtypoid),\n\t\t\t\t\t\tname)));\n\n\ttup = SearchSysCache2(ENUMTYPOIDNAME,\n\t\t\t\t\t\t  ObjectIdGetDatum(enumtypoid),\n\t\t\t\t\t\t  CStringGetDatum(name));\n\tif (!HeapTupleIsValid(tup))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input value for enum %s: \\\"%s\\\"\",\n\t\t\t\t\t\tformat_type_be(enumtypoid),\n\t\t\t\t\t\tname)));\n\n\tenumoid = HeapTupleGetOid(tup);\n\n\tReleaseSysCache(tup);\n\n\tpfree(name);\n\n\tPG_RETURN_OID(enumoid);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "enumoid"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "name"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tup"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "tup"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input value for enum %s: \\\"%s\\\"\",\n\t\t\t\t\t\tformat_type_be(enumtypoid),\n\t\t\t\t\t\tname))"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input value for enum %s: \\\"%s\\\"\"",
            "format_type_be(enumtypoid)",
            "name"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "enumtypoid"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tup"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache2",
          "args": [
            "ENUMTYPOIDNAME",
            "ObjectIdGetDatum(enumtypoid)",
            "CStringGetDatum(name)"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1122-1131",
          "snippet": "HeapTuple\nSearchSysCache2(int cacheId,\n\t\t\t\tDatum key1, Datum key2)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 2);\n\n\treturn SearchCatCache2(SysCache[cacheId], key1, key2);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache2(int cacheId,\n\t\t\t\tDatum key1, Datum key2)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 2);\n\n\treturn SearchCatCache2(SysCache[cacheId], key1, key2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "name"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "enumtypoid"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input value for enum %s: \\\"%s\\\"\",\n\t\t\t\t\t\tformat_type_be(enumtypoid),\n\t\t\t\t\t\tname))"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgtext",
          "args": [
            "buf",
            "buf->len - buf->cursor",
            "&nbytes"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nDatum\nenum_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tOid\t\t\tenumtypoid = PG_GETARG_OID(1);\n\tOid\t\t\tenumoid;\n\tHeapTuple\ttup;\n\tchar\t   *name;\n\tint\t\t\tnbytes;\n\n\tname = pq_getmsgtext(buf, buf->len - buf->cursor, &nbytes);\n\n\t/* must check length to prevent Assert failure within SearchSysCache */\n\tif (strlen(name) >= NAMEDATALEN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input value for enum %s: \\\"%s\\\"\",\n\t\t\t\t\t\tformat_type_be(enumtypoid),\n\t\t\t\t\t\tname)));\n\n\ttup = SearchSysCache2(ENUMTYPOIDNAME,\n\t\t\t\t\t\t  ObjectIdGetDatum(enumtypoid),\n\t\t\t\t\t\t  CStringGetDatum(name));\n\tif (!HeapTupleIsValid(tup))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input value for enum %s: \\\"%s\\\"\",\n\t\t\t\t\t\tformat_type_be(enumtypoid),\n\t\t\t\t\t\tname)));\n\n\tenumoid = HeapTupleGetOid(tup);\n\n\tReleaseSysCache(tup);\n\n\tpfree(name);\n\n\tPG_RETURN_OID(enumoid);\n}"
  },
  {
    "function_name": "enum_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "73-94",
    "snippet": "Datum\nenum_out(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tenumval = PG_GETARG_OID(0);\n\tchar\t   *result;\n\tHeapTuple\ttup;\n\tForm_pg_enum en;\n\n\ttup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(enumval));\n\tif (!HeapTupleIsValid(tup))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\tenumval)));\n\ten = (Form_pg_enum) GETSTRUCT(tup);\n\n\tresult = pstrdup(NameStr(en->enumlabel));\n\n\tReleaseSysCache(tup);\n\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tup"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "NameStr(en->enumlabel)"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "en->enumlabel"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tup"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\tenumval))"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid internal value for enum: %u\"",
            "enumval"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_BINARY_REPRESENTATION"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tup"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "ENUMOID",
            "ObjectIdGetDatum(enumval)"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "enumval"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nDatum\nenum_out(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tenumval = PG_GETARG_OID(0);\n\tchar\t   *result;\n\tHeapTuple\ttup;\n\tForm_pg_enum en;\n\n\ttup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(enumval));\n\tif (!HeapTupleIsValid(tup))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid internal value for enum: %u\",\n\t\t\t\t\t\tenumval)));\n\ten = (Form_pg_enum) GETSTRUCT(tup);\n\n\tresult = pstrdup(NameStr(en->enumlabel));\n\n\tReleaseSysCache(tup);\n\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "enum_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/enum.c",
    "lines": "36-71",
    "snippet": "Datum\nenum_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *name = PG_GETARG_CSTRING(0);\n\tOid\t\t\tenumtypoid = PG_GETARG_OID(1);\n\tOid\t\t\tenumoid;\n\tHeapTuple\ttup;\n\n\t/* must check length to prevent Assert failure within SearchSysCache */\n\tif (strlen(name) >= NAMEDATALEN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input value for enum %s: \\\"%s\\\"\",\n\t\t\t\t\t\tformat_type_be(enumtypoid),\n\t\t\t\t\t\tname)));\n\n\ttup = SearchSysCache2(ENUMTYPOIDNAME,\n\t\t\t\t\t\t  ObjectIdGetDatum(enumtypoid),\n\t\t\t\t\t\t  CStringGetDatum(name));\n\tif (!HeapTupleIsValid(tup))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input value for enum %s: \\\"%s\\\"\",\n\t\t\t\t\t\tformat_type_be(enumtypoid),\n\t\t\t\t\t\tname)));\n\n\t/*\n\t * This comes from pg_enum.oid and stores system oids in user tables. This\n\t * oid must be preserved by binary upgrades.\n\t */\n\tenumoid = HeapTupleGetOid(tup);\n\n\tReleaseSysCache(tup);\n\n\tPG_RETURN_OID(enumoid);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_enum.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "enumoid"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tup"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "tup"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input value for enum %s: \\\"%s\\\"\",\n\t\t\t\t\t\tformat_type_be(enumtypoid),\n\t\t\t\t\t\tname))"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input value for enum %s: \\\"%s\\\"\"",
            "format_type_be(enumtypoid)",
            "name"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "enumtypoid"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tup"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache2",
          "args": [
            "ENUMTYPOIDNAME",
            "ObjectIdGetDatum(enumtypoid)",
            "CStringGetDatum(name)"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1122-1131",
          "snippet": "HeapTuple\nSearchSysCache2(int cacheId,\n\t\t\t\tDatum key1, Datum key2)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 2);\n\n\treturn SearchCatCache2(SysCache[cacheId], key1, key2);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache2(int cacheId,\n\t\t\t\tDatum key1, Datum key2)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 2);\n\n\treturn SearchCatCache2(SysCache[cacheId], key1, key2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "name"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "enumtypoid"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input value for enum %s: \\\"%s\\\"\",\n\t\t\t\t\t\tformat_type_be(enumtypoid),\n\t\t\t\t\t\tname))"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nDatum\nenum_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *name = PG_GETARG_CSTRING(0);\n\tOid\t\t\tenumtypoid = PG_GETARG_OID(1);\n\tOid\t\t\tenumoid;\n\tHeapTuple\ttup;\n\n\t/* must check length to prevent Assert failure within SearchSysCache */\n\tif (strlen(name) >= NAMEDATALEN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input value for enum %s: \\\"%s\\\"\",\n\t\t\t\t\t\tformat_type_be(enumtypoid),\n\t\t\t\t\t\tname)));\n\n\ttup = SearchSysCache2(ENUMTYPOIDNAME,\n\t\t\t\t\t\t  ObjectIdGetDatum(enumtypoid),\n\t\t\t\t\t\t  CStringGetDatum(name));\n\tif (!HeapTupleIsValid(tup))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input value for enum %s: \\\"%s\\\"\",\n\t\t\t\t\t\tformat_type_be(enumtypoid),\n\t\t\t\t\t\tname)));\n\n\t/*\n\t * This comes from pg_enum.oid and stores system oids in user tables. This\n\t * oid must be preserved by binary upgrades.\n\t */\n\tenumoid = HeapTupleGetOid(tup);\n\n\tReleaseSysCache(tup);\n\n\tPG_RETURN_OID(enumoid);\n}"
  }
]