[
  {
    "function_name": "btrecordimagecmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "1778-1782",
    "snippet": "Datum\nbtrecordimagecmp(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_INT32(record_image_cmp(fcinfo));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "record_image_cmp(fcinfo)"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_image_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "record_image_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
          "lines": "1290-1523",
          "snippet": "static int\nrecord_image_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * The same type should have the same length (or both should be\n\t\t * variable).\n\t\t */\n\t\tAssert(att1->attlen == att2->attlen);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tint\t\t\tcmpresult = 0;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tif (att1->attlen == -1)\n\t\t\t{\n\t\t\t\tSize\t\tlen1,\n\t\t\t\t\t\t\tlen2;\n\t\t\t\tstruct varlena *arg1val;\n\t\t\t\tstruct varlena *arg2val;\n\n\t\t\t\tlen1 = toast_raw_datum_size(values1[i1]);\n\t\t\t\tlen2 = toast_raw_datum_size(values2[i2]);\n\t\t\t\targ1val = PG_DETOAST_DATUM_PACKED(values1[i1]);\n\t\t\t\targ2val = PG_DETOAST_DATUM_PACKED(values2[i2]);\n\n\t\t\t\tcmpresult = memcmp(VARDATA_ANY(arg1val),\n\t\t\t\t\t\t\t\t   VARDATA_ANY(arg2val),\n\t\t\t\t\t\t\t\t   Min(len1, len2) - VARHDRSZ);\n\t\t\t\tif ((cmpresult == 0) && (len1 != len2))\n\t\t\t\t\tcmpresult = (len1 < len2) ? -1 : 1;\n\n\t\t\t\tif ((Pointer) arg1val != (Pointer) values1[i1])\n\t\t\t\t\tpfree(arg1val);\n\t\t\t\tif ((Pointer) arg2val != (Pointer) values2[i2])\n\t\t\t\t\tpfree(arg2val);\n\t\t\t}\n\t\t\telse if (att1->attbyval)\n\t\t\t{\n\t\t\t\tif (values1[i1] != values2[i2])\n\t\t\t\t\tcmpresult = (values1[i1] < values2[i2]) ? -1 : 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcmpresult = memcmp(DatumGetPointer(values1[i1]),\n\t\t\t\t\t\t\t\t   DatumGetPointer(values2[i2]),\n\t\t\t\t\t\t\t\t   att1->attlen);\n\t\t\t}\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nrecord_image_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * The same type should have the same length (or both should be\n\t\t * variable).\n\t\t */\n\t\tAssert(att1->attlen == att2->attlen);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tint\t\t\tcmpresult = 0;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tif (att1->attlen == -1)\n\t\t\t{\n\t\t\t\tSize\t\tlen1,\n\t\t\t\t\t\t\tlen2;\n\t\t\t\tstruct varlena *arg1val;\n\t\t\t\tstruct varlena *arg2val;\n\n\t\t\t\tlen1 = toast_raw_datum_size(values1[i1]);\n\t\t\t\tlen2 = toast_raw_datum_size(values2[i2]);\n\t\t\t\targ1val = PG_DETOAST_DATUM_PACKED(values1[i1]);\n\t\t\t\targ2val = PG_DETOAST_DATUM_PACKED(values2[i2]);\n\n\t\t\t\tcmpresult = memcmp(VARDATA_ANY(arg1val),\n\t\t\t\t\t\t\t\t   VARDATA_ANY(arg2val),\n\t\t\t\t\t\t\t\t   Min(len1, len2) - VARHDRSZ);\n\t\t\t\tif ((cmpresult == 0) && (len1 != len2))\n\t\t\t\t\tcmpresult = (len1 < len2) ? -1 : 1;\n\n\t\t\t\tif ((Pointer) arg1val != (Pointer) values1[i1])\n\t\t\t\t\tpfree(arg1val);\n\t\t\t\tif ((Pointer) arg2val != (Pointer) values2[i2])\n\t\t\t\t\tpfree(arg2val);\n\t\t\t}\n\t\t\telse if (att1->attbyval)\n\t\t\t{\n\t\t\t\tif (values1[i1] != values2[i2])\n\t\t\t\t\tcmpresult = (values1[i1] < values2[i2]) ? -1 : 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcmpresult = memcmp(DatumGetPointer(values1[i1]),\n\t\t\t\t\t\t\t\t   DatumGetPointer(values2[i2]),\n\t\t\t\t\t\t\t\t   att1->attlen);\n\t\t\t}\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nbtrecordimagecmp(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_INT32(record_image_cmp(fcinfo));\n}"
  },
  {
    "function_name": "record_image_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "1772-1776",
    "snippet": "Datum\nrecord_image_ge(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(record_image_cmp(fcinfo) >= 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "record_image_cmp(fcinfo) >= 0"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_image_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "record_image_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
          "lines": "1290-1523",
          "snippet": "static int\nrecord_image_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * The same type should have the same length (or both should be\n\t\t * variable).\n\t\t */\n\t\tAssert(att1->attlen == att2->attlen);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tint\t\t\tcmpresult = 0;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tif (att1->attlen == -1)\n\t\t\t{\n\t\t\t\tSize\t\tlen1,\n\t\t\t\t\t\t\tlen2;\n\t\t\t\tstruct varlena *arg1val;\n\t\t\t\tstruct varlena *arg2val;\n\n\t\t\t\tlen1 = toast_raw_datum_size(values1[i1]);\n\t\t\t\tlen2 = toast_raw_datum_size(values2[i2]);\n\t\t\t\targ1val = PG_DETOAST_DATUM_PACKED(values1[i1]);\n\t\t\t\targ2val = PG_DETOAST_DATUM_PACKED(values2[i2]);\n\n\t\t\t\tcmpresult = memcmp(VARDATA_ANY(arg1val),\n\t\t\t\t\t\t\t\t   VARDATA_ANY(arg2val),\n\t\t\t\t\t\t\t\t   Min(len1, len2) - VARHDRSZ);\n\t\t\t\tif ((cmpresult == 0) && (len1 != len2))\n\t\t\t\t\tcmpresult = (len1 < len2) ? -1 : 1;\n\n\t\t\t\tif ((Pointer) arg1val != (Pointer) values1[i1])\n\t\t\t\t\tpfree(arg1val);\n\t\t\t\tif ((Pointer) arg2val != (Pointer) values2[i2])\n\t\t\t\t\tpfree(arg2val);\n\t\t\t}\n\t\t\telse if (att1->attbyval)\n\t\t\t{\n\t\t\t\tif (values1[i1] != values2[i2])\n\t\t\t\t\tcmpresult = (values1[i1] < values2[i2]) ? -1 : 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcmpresult = memcmp(DatumGetPointer(values1[i1]),\n\t\t\t\t\t\t\t\t   DatumGetPointer(values2[i2]),\n\t\t\t\t\t\t\t\t   att1->attlen);\n\t\t\t}\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nrecord_image_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * The same type should have the same length (or both should be\n\t\t * variable).\n\t\t */\n\t\tAssert(att1->attlen == att2->attlen);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tint\t\t\tcmpresult = 0;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tif (att1->attlen == -1)\n\t\t\t{\n\t\t\t\tSize\t\tlen1,\n\t\t\t\t\t\t\tlen2;\n\t\t\t\tstruct varlena *arg1val;\n\t\t\t\tstruct varlena *arg2val;\n\n\t\t\t\tlen1 = toast_raw_datum_size(values1[i1]);\n\t\t\t\tlen2 = toast_raw_datum_size(values2[i2]);\n\t\t\t\targ1val = PG_DETOAST_DATUM_PACKED(values1[i1]);\n\t\t\t\targ2val = PG_DETOAST_DATUM_PACKED(values2[i2]);\n\n\t\t\t\tcmpresult = memcmp(VARDATA_ANY(arg1val),\n\t\t\t\t\t\t\t\t   VARDATA_ANY(arg2val),\n\t\t\t\t\t\t\t\t   Min(len1, len2) - VARHDRSZ);\n\t\t\t\tif ((cmpresult == 0) && (len1 != len2))\n\t\t\t\t\tcmpresult = (len1 < len2) ? -1 : 1;\n\n\t\t\t\tif ((Pointer) arg1val != (Pointer) values1[i1])\n\t\t\t\t\tpfree(arg1val);\n\t\t\t\tif ((Pointer) arg2val != (Pointer) values2[i2])\n\t\t\t\t\tpfree(arg2val);\n\t\t\t}\n\t\t\telse if (att1->attbyval)\n\t\t\t{\n\t\t\t\tif (values1[i1] != values2[i2])\n\t\t\t\t\tcmpresult = (values1[i1] < values2[i2]) ? -1 : 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcmpresult = memcmp(DatumGetPointer(values1[i1]),\n\t\t\t\t\t\t\t\t   DatumGetPointer(values2[i2]),\n\t\t\t\t\t\t\t\t   att1->attlen);\n\t\t\t}\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_image_ge(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(record_image_cmp(fcinfo) >= 0);\n}"
  },
  {
    "function_name": "record_image_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "1766-1770",
    "snippet": "Datum\nrecord_image_le(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(record_image_cmp(fcinfo) <= 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "record_image_cmp(fcinfo) <= 0"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_image_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "record_image_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
          "lines": "1290-1523",
          "snippet": "static int\nrecord_image_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * The same type should have the same length (or both should be\n\t\t * variable).\n\t\t */\n\t\tAssert(att1->attlen == att2->attlen);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tint\t\t\tcmpresult = 0;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tif (att1->attlen == -1)\n\t\t\t{\n\t\t\t\tSize\t\tlen1,\n\t\t\t\t\t\t\tlen2;\n\t\t\t\tstruct varlena *arg1val;\n\t\t\t\tstruct varlena *arg2val;\n\n\t\t\t\tlen1 = toast_raw_datum_size(values1[i1]);\n\t\t\t\tlen2 = toast_raw_datum_size(values2[i2]);\n\t\t\t\targ1val = PG_DETOAST_DATUM_PACKED(values1[i1]);\n\t\t\t\targ2val = PG_DETOAST_DATUM_PACKED(values2[i2]);\n\n\t\t\t\tcmpresult = memcmp(VARDATA_ANY(arg1val),\n\t\t\t\t\t\t\t\t   VARDATA_ANY(arg2val),\n\t\t\t\t\t\t\t\t   Min(len1, len2) - VARHDRSZ);\n\t\t\t\tif ((cmpresult == 0) && (len1 != len2))\n\t\t\t\t\tcmpresult = (len1 < len2) ? -1 : 1;\n\n\t\t\t\tif ((Pointer) arg1val != (Pointer) values1[i1])\n\t\t\t\t\tpfree(arg1val);\n\t\t\t\tif ((Pointer) arg2val != (Pointer) values2[i2])\n\t\t\t\t\tpfree(arg2val);\n\t\t\t}\n\t\t\telse if (att1->attbyval)\n\t\t\t{\n\t\t\t\tif (values1[i1] != values2[i2])\n\t\t\t\t\tcmpresult = (values1[i1] < values2[i2]) ? -1 : 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcmpresult = memcmp(DatumGetPointer(values1[i1]),\n\t\t\t\t\t\t\t\t   DatumGetPointer(values2[i2]),\n\t\t\t\t\t\t\t\t   att1->attlen);\n\t\t\t}\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nrecord_image_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * The same type should have the same length (or both should be\n\t\t * variable).\n\t\t */\n\t\tAssert(att1->attlen == att2->attlen);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tint\t\t\tcmpresult = 0;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tif (att1->attlen == -1)\n\t\t\t{\n\t\t\t\tSize\t\tlen1,\n\t\t\t\t\t\t\tlen2;\n\t\t\t\tstruct varlena *arg1val;\n\t\t\t\tstruct varlena *arg2val;\n\n\t\t\t\tlen1 = toast_raw_datum_size(values1[i1]);\n\t\t\t\tlen2 = toast_raw_datum_size(values2[i2]);\n\t\t\t\targ1val = PG_DETOAST_DATUM_PACKED(values1[i1]);\n\t\t\t\targ2val = PG_DETOAST_DATUM_PACKED(values2[i2]);\n\n\t\t\t\tcmpresult = memcmp(VARDATA_ANY(arg1val),\n\t\t\t\t\t\t\t\t   VARDATA_ANY(arg2val),\n\t\t\t\t\t\t\t\t   Min(len1, len2) - VARHDRSZ);\n\t\t\t\tif ((cmpresult == 0) && (len1 != len2))\n\t\t\t\t\tcmpresult = (len1 < len2) ? -1 : 1;\n\n\t\t\t\tif ((Pointer) arg1val != (Pointer) values1[i1])\n\t\t\t\t\tpfree(arg1val);\n\t\t\t\tif ((Pointer) arg2val != (Pointer) values2[i2])\n\t\t\t\t\tpfree(arg2val);\n\t\t\t}\n\t\t\telse if (att1->attbyval)\n\t\t\t{\n\t\t\t\tif (values1[i1] != values2[i2])\n\t\t\t\t\tcmpresult = (values1[i1] < values2[i2]) ? -1 : 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcmpresult = memcmp(DatumGetPointer(values1[i1]),\n\t\t\t\t\t\t\t\t   DatumGetPointer(values2[i2]),\n\t\t\t\t\t\t\t\t   att1->attlen);\n\t\t\t}\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_image_le(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(record_image_cmp(fcinfo) <= 0);\n}"
  },
  {
    "function_name": "record_image_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "1760-1764",
    "snippet": "Datum\nrecord_image_gt(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(record_image_cmp(fcinfo) > 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "record_image_cmp(fcinfo) > 0"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_image_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "record_image_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
          "lines": "1290-1523",
          "snippet": "static int\nrecord_image_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * The same type should have the same length (or both should be\n\t\t * variable).\n\t\t */\n\t\tAssert(att1->attlen == att2->attlen);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tint\t\t\tcmpresult = 0;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tif (att1->attlen == -1)\n\t\t\t{\n\t\t\t\tSize\t\tlen1,\n\t\t\t\t\t\t\tlen2;\n\t\t\t\tstruct varlena *arg1val;\n\t\t\t\tstruct varlena *arg2val;\n\n\t\t\t\tlen1 = toast_raw_datum_size(values1[i1]);\n\t\t\t\tlen2 = toast_raw_datum_size(values2[i2]);\n\t\t\t\targ1val = PG_DETOAST_DATUM_PACKED(values1[i1]);\n\t\t\t\targ2val = PG_DETOAST_DATUM_PACKED(values2[i2]);\n\n\t\t\t\tcmpresult = memcmp(VARDATA_ANY(arg1val),\n\t\t\t\t\t\t\t\t   VARDATA_ANY(arg2val),\n\t\t\t\t\t\t\t\t   Min(len1, len2) - VARHDRSZ);\n\t\t\t\tif ((cmpresult == 0) && (len1 != len2))\n\t\t\t\t\tcmpresult = (len1 < len2) ? -1 : 1;\n\n\t\t\t\tif ((Pointer) arg1val != (Pointer) values1[i1])\n\t\t\t\t\tpfree(arg1val);\n\t\t\t\tif ((Pointer) arg2val != (Pointer) values2[i2])\n\t\t\t\t\tpfree(arg2val);\n\t\t\t}\n\t\t\telse if (att1->attbyval)\n\t\t\t{\n\t\t\t\tif (values1[i1] != values2[i2])\n\t\t\t\t\tcmpresult = (values1[i1] < values2[i2]) ? -1 : 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcmpresult = memcmp(DatumGetPointer(values1[i1]),\n\t\t\t\t\t\t\t\t   DatumGetPointer(values2[i2]),\n\t\t\t\t\t\t\t\t   att1->attlen);\n\t\t\t}\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nrecord_image_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * The same type should have the same length (or both should be\n\t\t * variable).\n\t\t */\n\t\tAssert(att1->attlen == att2->attlen);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tint\t\t\tcmpresult = 0;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tif (att1->attlen == -1)\n\t\t\t{\n\t\t\t\tSize\t\tlen1,\n\t\t\t\t\t\t\tlen2;\n\t\t\t\tstruct varlena *arg1val;\n\t\t\t\tstruct varlena *arg2val;\n\n\t\t\t\tlen1 = toast_raw_datum_size(values1[i1]);\n\t\t\t\tlen2 = toast_raw_datum_size(values2[i2]);\n\t\t\t\targ1val = PG_DETOAST_DATUM_PACKED(values1[i1]);\n\t\t\t\targ2val = PG_DETOAST_DATUM_PACKED(values2[i2]);\n\n\t\t\t\tcmpresult = memcmp(VARDATA_ANY(arg1val),\n\t\t\t\t\t\t\t\t   VARDATA_ANY(arg2val),\n\t\t\t\t\t\t\t\t   Min(len1, len2) - VARHDRSZ);\n\t\t\t\tif ((cmpresult == 0) && (len1 != len2))\n\t\t\t\t\tcmpresult = (len1 < len2) ? -1 : 1;\n\n\t\t\t\tif ((Pointer) arg1val != (Pointer) values1[i1])\n\t\t\t\t\tpfree(arg1val);\n\t\t\t\tif ((Pointer) arg2val != (Pointer) values2[i2])\n\t\t\t\t\tpfree(arg2val);\n\t\t\t}\n\t\t\telse if (att1->attbyval)\n\t\t\t{\n\t\t\t\tif (values1[i1] != values2[i2])\n\t\t\t\t\tcmpresult = (values1[i1] < values2[i2]) ? -1 : 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcmpresult = memcmp(DatumGetPointer(values1[i1]),\n\t\t\t\t\t\t\t\t   DatumGetPointer(values2[i2]),\n\t\t\t\t\t\t\t\t   att1->attlen);\n\t\t\t}\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_image_gt(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(record_image_cmp(fcinfo) > 0);\n}"
  },
  {
    "function_name": "record_image_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "1754-1758",
    "snippet": "Datum\nrecord_image_lt(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(record_image_cmp(fcinfo) < 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "record_image_cmp(fcinfo) < 0"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_image_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "record_image_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
          "lines": "1290-1523",
          "snippet": "static int\nrecord_image_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * The same type should have the same length (or both should be\n\t\t * variable).\n\t\t */\n\t\tAssert(att1->attlen == att2->attlen);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tint\t\t\tcmpresult = 0;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tif (att1->attlen == -1)\n\t\t\t{\n\t\t\t\tSize\t\tlen1,\n\t\t\t\t\t\t\tlen2;\n\t\t\t\tstruct varlena *arg1val;\n\t\t\t\tstruct varlena *arg2val;\n\n\t\t\t\tlen1 = toast_raw_datum_size(values1[i1]);\n\t\t\t\tlen2 = toast_raw_datum_size(values2[i2]);\n\t\t\t\targ1val = PG_DETOAST_DATUM_PACKED(values1[i1]);\n\t\t\t\targ2val = PG_DETOAST_DATUM_PACKED(values2[i2]);\n\n\t\t\t\tcmpresult = memcmp(VARDATA_ANY(arg1val),\n\t\t\t\t\t\t\t\t   VARDATA_ANY(arg2val),\n\t\t\t\t\t\t\t\t   Min(len1, len2) - VARHDRSZ);\n\t\t\t\tif ((cmpresult == 0) && (len1 != len2))\n\t\t\t\t\tcmpresult = (len1 < len2) ? -1 : 1;\n\n\t\t\t\tif ((Pointer) arg1val != (Pointer) values1[i1])\n\t\t\t\t\tpfree(arg1val);\n\t\t\t\tif ((Pointer) arg2val != (Pointer) values2[i2])\n\t\t\t\t\tpfree(arg2val);\n\t\t\t}\n\t\t\telse if (att1->attbyval)\n\t\t\t{\n\t\t\t\tif (values1[i1] != values2[i2])\n\t\t\t\t\tcmpresult = (values1[i1] < values2[i2]) ? -1 : 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcmpresult = memcmp(DatumGetPointer(values1[i1]),\n\t\t\t\t\t\t\t\t   DatumGetPointer(values2[i2]),\n\t\t\t\t\t\t\t\t   att1->attlen);\n\t\t\t}\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nrecord_image_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * The same type should have the same length (or both should be\n\t\t * variable).\n\t\t */\n\t\tAssert(att1->attlen == att2->attlen);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tint\t\t\tcmpresult = 0;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tif (att1->attlen == -1)\n\t\t\t{\n\t\t\t\tSize\t\tlen1,\n\t\t\t\t\t\t\tlen2;\n\t\t\t\tstruct varlena *arg1val;\n\t\t\t\tstruct varlena *arg2val;\n\n\t\t\t\tlen1 = toast_raw_datum_size(values1[i1]);\n\t\t\t\tlen2 = toast_raw_datum_size(values2[i2]);\n\t\t\t\targ1val = PG_DETOAST_DATUM_PACKED(values1[i1]);\n\t\t\t\targ2val = PG_DETOAST_DATUM_PACKED(values2[i2]);\n\n\t\t\t\tcmpresult = memcmp(VARDATA_ANY(arg1val),\n\t\t\t\t\t\t\t\t   VARDATA_ANY(arg2val),\n\t\t\t\t\t\t\t\t   Min(len1, len2) - VARHDRSZ);\n\t\t\t\tif ((cmpresult == 0) && (len1 != len2))\n\t\t\t\t\tcmpresult = (len1 < len2) ? -1 : 1;\n\n\t\t\t\tif ((Pointer) arg1val != (Pointer) values1[i1])\n\t\t\t\t\tpfree(arg1val);\n\t\t\t\tif ((Pointer) arg2val != (Pointer) values2[i2])\n\t\t\t\t\tpfree(arg2val);\n\t\t\t}\n\t\t\telse if (att1->attbyval)\n\t\t\t{\n\t\t\t\tif (values1[i1] != values2[i2])\n\t\t\t\t\tcmpresult = (values1[i1] < values2[i2]) ? -1 : 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcmpresult = memcmp(DatumGetPointer(values1[i1]),\n\t\t\t\t\t\t\t\t   DatumGetPointer(values2[i2]),\n\t\t\t\t\t\t\t\t   att1->attlen);\n\t\t\t}\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_image_lt(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(record_image_cmp(fcinfo) < 0);\n}"
  },
  {
    "function_name": "record_image_ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "1748-1752",
    "snippet": "Datum\nrecord_image_ne(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(!DatumGetBool(record_image_eq(fcinfo)));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "!DatumGetBool(record_image_eq(fcinfo))"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "record_image_eq(fcinfo)"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_image_eq",
          "args": [
            "fcinfo"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "record_image_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
          "lines": "1534-1746",
          "snippet": "Datum\nrecord_image_eq(PG_FUNCTION_ARGS)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tbool\t\tresult = true;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tif (nulls1[i1] || nulls2[i2])\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tif (att1->attlen == -1)\n\t\t\t{\n\t\t\t\tSize\t\tlen1,\n\t\t\t\t\t\t\tlen2;\n\n\t\t\t\tlen1 = toast_raw_datum_size(values1[i1]);\n\t\t\t\tlen2 = toast_raw_datum_size(values2[i2]);\n\t\t\t\t/* No need to de-toast if lengths don't match. */\n\t\t\t\tif (len1 != len2)\n\t\t\t\t\tresult = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstruct varlena *arg1val;\n\t\t\t\t\tstruct varlena *arg2val;\n\n\t\t\t\t\targ1val = PG_DETOAST_DATUM_PACKED(values1[i1]);\n\t\t\t\t\targ2val = PG_DETOAST_DATUM_PACKED(values2[i2]);\n\n\t\t\t\t\tresult = (memcmp(VARDATA_ANY(arg1val),\n\t\t\t\t\t\t\t\t\t VARDATA_ANY(arg2val),\n\t\t\t\t\t\t\t\t\t len1 - VARHDRSZ) == 0);\n\n\t\t\t\t\t/* Only free memory if it's a copy made here. */\n\t\t\t\t\tif ((Pointer) arg1val != (Pointer) values1[i1])\n\t\t\t\t\t\tpfree(arg1val);\n\t\t\t\t\tif ((Pointer) arg2val != (Pointer) values2[i2])\n\t\t\t\t\t\tpfree(arg2val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (att1->attbyval)\n\t\t\t{\n\t\t\t\tresult = (values1[i1] == values2[i2]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = (memcmp(DatumGetPointer(values1[i1]),\n\t\t\t\t\t\t\t\t DatumGetPointer(values2[i2]),\n\t\t\t\t\t\t\t\t att1->attlen) == 0);\n\t\t\t}\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_image_eq(PG_FUNCTION_ARGS)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tbool\t\tresult = true;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tif (nulls1[i1] || nulls2[i2])\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tif (att1->attlen == -1)\n\t\t\t{\n\t\t\t\tSize\t\tlen1,\n\t\t\t\t\t\t\tlen2;\n\n\t\t\t\tlen1 = toast_raw_datum_size(values1[i1]);\n\t\t\t\tlen2 = toast_raw_datum_size(values2[i2]);\n\t\t\t\t/* No need to de-toast if lengths don't match. */\n\t\t\t\tif (len1 != len2)\n\t\t\t\t\tresult = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstruct varlena *arg1val;\n\t\t\t\t\tstruct varlena *arg2val;\n\n\t\t\t\t\targ1val = PG_DETOAST_DATUM_PACKED(values1[i1]);\n\t\t\t\t\targ2val = PG_DETOAST_DATUM_PACKED(values2[i2]);\n\n\t\t\t\t\tresult = (memcmp(VARDATA_ANY(arg1val),\n\t\t\t\t\t\t\t\t\t VARDATA_ANY(arg2val),\n\t\t\t\t\t\t\t\t\t len1 - VARHDRSZ) == 0);\n\n\t\t\t\t\t/* Only free memory if it's a copy made here. */\n\t\t\t\t\tif ((Pointer) arg1val != (Pointer) values1[i1])\n\t\t\t\t\t\tpfree(arg1val);\n\t\t\t\t\tif ((Pointer) arg2val != (Pointer) values2[i2])\n\t\t\t\t\t\tpfree(arg2val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (att1->attbyval)\n\t\t\t{\n\t\t\t\tresult = (values1[i1] == values2[i2]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = (memcmp(DatumGetPointer(values1[i1]),\n\t\t\t\t\t\t\t\t DatumGetPointer(values2[i2]),\n\t\t\t\t\t\t\t\t att1->attlen) == 0);\n\t\t\t}\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_image_ne(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(!DatumGetBool(record_image_eq(fcinfo)));\n}"
  },
  {
    "function_name": "record_image_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "1534-1746",
    "snippet": "Datum\nrecord_image_eq(PG_FUNCTION_ARGS)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tbool\t\tresult = true;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tif (nulls1[i1] || nulls2[i2])\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tif (att1->attlen == -1)\n\t\t\t{\n\t\t\t\tSize\t\tlen1,\n\t\t\t\t\t\t\tlen2;\n\n\t\t\t\tlen1 = toast_raw_datum_size(values1[i1]);\n\t\t\t\tlen2 = toast_raw_datum_size(values2[i2]);\n\t\t\t\t/* No need to de-toast if lengths don't match. */\n\t\t\t\tif (len1 != len2)\n\t\t\t\t\tresult = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstruct varlena *arg1val;\n\t\t\t\t\tstruct varlena *arg2val;\n\n\t\t\t\t\targ1val = PG_DETOAST_DATUM_PACKED(values1[i1]);\n\t\t\t\t\targ2val = PG_DETOAST_DATUM_PACKED(values2[i2]);\n\n\t\t\t\t\tresult = (memcmp(VARDATA_ANY(arg1val),\n\t\t\t\t\t\t\t\t\t VARDATA_ANY(arg2val),\n\t\t\t\t\t\t\t\t\t len1 - VARHDRSZ) == 0);\n\n\t\t\t\t\t/* Only free memory if it's a copy made here. */\n\t\t\t\t\tif ((Pointer) arg1val != (Pointer) values1[i1])\n\t\t\t\t\t\tpfree(arg1val);\n\t\t\t\t\tif ((Pointer) arg2val != (Pointer) values2[i2])\n\t\t\t\t\t\tpfree(arg2val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (att1->attbyval)\n\t\t\t{\n\t\t\t\tresult = (values1[i1] == values2[i2]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = (memcmp(DatumGetPointer(values1[i1]),\n\t\t\t\t\t\t\t\t DatumGetPointer(values2[i2]),\n\t\t\t\t\t\t\t\t att1->attlen) == 0);\n\t\t\t}\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "record2",
            "1"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "record1",
            "0"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseTupleDesc",
          "args": [
            "tupdesc2"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseTupleDesc",
          "args": [
            "tupdesc1"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "nulls2"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\"))"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot compare record types with different numbers of columns\""
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATATYPE_MISMATCH"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "DatumGetPointer(values1[i1])",
            "DatumGetPointer(values2[i2])",
            "att1->attlen"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "values2[i2]"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "values1[i1]"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARDATA_ANY(arg1val)",
            "VARDATA_ANY(arg2val)",
            "len1 - VARHDRSZ"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2val"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1val"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM_PACKED",
          "args": [
            "values2[i2]"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM_PACKED",
          "args": [
            "values1[i1]"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "values2[i2]"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "values1[i1]"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1))"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "att2->atttypid"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc2",
            "i2"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc1",
            "i1"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc2",
            "i2"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc1",
            "i1"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_deform_tuple",
          "args": [
            "&tuple2",
            "tupdesc2",
            "values2",
            "nulls2"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "ncolumns2 * sizeof(bool)"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_deform_tuple",
          "args": [
            "&tuple1",
            "tupdesc1",
            "values1",
            "nulls1"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "my_extra->columns",
            "0",
            "ncols * sizeof(ColumnCompareData)"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData)"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "ncolumns1",
            "ncolumns2"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerSetInvalid",
          "args": [
            "&(tuple2.t_self)"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatumLength",
          "args": [
            "record2"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerSetInvalid",
          "args": [
            "&(tuple1.t_self)"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatumLength",
          "args": [
            "record1"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc",
          "args": [
            "tupType2",
            "tupTypmod2"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1674-1681",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypMod",
          "args": [
            "record2"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypeId",
          "args": [
            "record2"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypMod",
          "args": [
            "record1"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypeId",
          "args": [
            "record1"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_HEAPTUPLEHEADER",
          "args": [
            "1"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_HEAPTUPLEHEADER",
          "args": [
            "0"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_image_eq(PG_FUNCTION_ARGS)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tbool\t\tresult = true;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tif (nulls1[i1] || nulls2[i2])\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tif (att1->attlen == -1)\n\t\t\t{\n\t\t\t\tSize\t\tlen1,\n\t\t\t\t\t\t\tlen2;\n\n\t\t\t\tlen1 = toast_raw_datum_size(values1[i1]);\n\t\t\t\tlen2 = toast_raw_datum_size(values2[i2]);\n\t\t\t\t/* No need to de-toast if lengths don't match. */\n\t\t\t\tif (len1 != len2)\n\t\t\t\t\tresult = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstruct varlena *arg1val;\n\t\t\t\t\tstruct varlena *arg2val;\n\n\t\t\t\t\targ1val = PG_DETOAST_DATUM_PACKED(values1[i1]);\n\t\t\t\t\targ2val = PG_DETOAST_DATUM_PACKED(values2[i2]);\n\n\t\t\t\t\tresult = (memcmp(VARDATA_ANY(arg1val),\n\t\t\t\t\t\t\t\t\t VARDATA_ANY(arg2val),\n\t\t\t\t\t\t\t\t\t len1 - VARHDRSZ) == 0);\n\n\t\t\t\t\t/* Only free memory if it's a copy made here. */\n\t\t\t\t\tif ((Pointer) arg1val != (Pointer) values1[i1])\n\t\t\t\t\t\tpfree(arg1val);\n\t\t\t\t\tif ((Pointer) arg2val != (Pointer) values2[i2])\n\t\t\t\t\t\tpfree(arg2val);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (att1->attbyval)\n\t\t\t{\n\t\t\t\tresult = (values1[i1] == values2[i2]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = (memcmp(DatumGetPointer(values1[i1]),\n\t\t\t\t\t\t\t\t DatumGetPointer(values2[i2]),\n\t\t\t\t\t\t\t\t att1->attlen) == 0);\n\t\t\t}\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "record_image_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "1290-1523",
    "snippet": "static int\nrecord_image_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * The same type should have the same length (or both should be\n\t\t * variable).\n\t\t */\n\t\tAssert(att1->attlen == att2->attlen);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tint\t\t\tcmpresult = 0;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tif (att1->attlen == -1)\n\t\t\t{\n\t\t\t\tSize\t\tlen1,\n\t\t\t\t\t\t\tlen2;\n\t\t\t\tstruct varlena *arg1val;\n\t\t\t\tstruct varlena *arg2val;\n\n\t\t\t\tlen1 = toast_raw_datum_size(values1[i1]);\n\t\t\t\tlen2 = toast_raw_datum_size(values2[i2]);\n\t\t\t\targ1val = PG_DETOAST_DATUM_PACKED(values1[i1]);\n\t\t\t\targ2val = PG_DETOAST_DATUM_PACKED(values2[i2]);\n\n\t\t\t\tcmpresult = memcmp(VARDATA_ANY(arg1val),\n\t\t\t\t\t\t\t\t   VARDATA_ANY(arg2val),\n\t\t\t\t\t\t\t\t   Min(len1, len2) - VARHDRSZ);\n\t\t\t\tif ((cmpresult == 0) && (len1 != len2))\n\t\t\t\t\tcmpresult = (len1 < len2) ? -1 : 1;\n\n\t\t\t\tif ((Pointer) arg1val != (Pointer) values1[i1])\n\t\t\t\t\tpfree(arg1val);\n\t\t\t\tif ((Pointer) arg2val != (Pointer) values2[i2])\n\t\t\t\t\tpfree(arg2val);\n\t\t\t}\n\t\t\telse if (att1->attbyval)\n\t\t\t{\n\t\t\t\tif (values1[i1] != values2[i2])\n\t\t\t\t\tcmpresult = (values1[i1] < values2[i2]) ? -1 : 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcmpresult = memcmp(DatumGetPointer(values1[i1]),\n\t\t\t\t\t\t\t\t   DatumGetPointer(values2[i2]),\n\t\t\t\t\t\t\t\t   att1->attlen);\n\t\t\t}\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "record2",
            "1"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "record1",
            "0"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseTupleDesc",
          "args": [
            "tupdesc2"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseTupleDesc",
          "args": [
            "tupdesc1"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "nulls2"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\"))"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot compare record types with different numbers of columns\""
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATATYPE_MISMATCH"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "DatumGetPointer(values1[i1])",
            "DatumGetPointer(values2[i2])",
            "att1->attlen"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "values2[i2]"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "values1[i1]"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARDATA_ANY(arg1val)",
            "VARDATA_ANY(arg2val)",
            "Min(len1, len2) - VARHDRSZ"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "len1",
            "len2"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2val"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1val"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM_PACKED",
          "args": [
            "values2[i2]"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM_PACKED",
          "args": [
            "values1[i1]"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "values2[i2]"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "values1[i1]"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "att1->attlen == att2->attlen"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1))"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "att2->atttypid"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc2",
            "i2"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc1",
            "i1"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc2",
            "i2"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc1",
            "i1"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_deform_tuple",
          "args": [
            "&tuple2",
            "tupdesc2",
            "values2",
            "nulls2"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "ncolumns2 * sizeof(bool)"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_deform_tuple",
          "args": [
            "&tuple1",
            "tupdesc1",
            "values1",
            "nulls1"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "my_extra->columns",
            "0",
            "ncols * sizeof(ColumnCompareData)"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData)"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "ncolumns1",
            "ncolumns2"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerSetInvalid",
          "args": [
            "&(tuple2.t_self)"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatumLength",
          "args": [
            "record2"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerSetInvalid",
          "args": [
            "&(tuple1.t_self)"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatumLength",
          "args": [
            "record1"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc",
          "args": [
            "tupType2",
            "tupTypmod2"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1674-1681",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypMod",
          "args": [
            "record2"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypeId",
          "args": [
            "record2"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypMod",
          "args": [
            "record1"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypeId",
          "args": [
            "record1"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_HEAPTUPLEHEADER",
          "args": [
            "1"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_HEAPTUPLEHEADER",
          "args": [
            "0"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nrecord_image_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * The same type should have the same length (or both should be\n\t\t * variable).\n\t\t */\n\t\tAssert(att1->attlen == att2->attlen);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tint\t\t\tcmpresult = 0;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tif (att1->attlen == -1)\n\t\t\t{\n\t\t\t\tSize\t\tlen1,\n\t\t\t\t\t\t\tlen2;\n\t\t\t\tstruct varlena *arg1val;\n\t\t\t\tstruct varlena *arg2val;\n\n\t\t\t\tlen1 = toast_raw_datum_size(values1[i1]);\n\t\t\t\tlen2 = toast_raw_datum_size(values2[i2]);\n\t\t\t\targ1val = PG_DETOAST_DATUM_PACKED(values1[i1]);\n\t\t\t\targ2val = PG_DETOAST_DATUM_PACKED(values2[i2]);\n\n\t\t\t\tcmpresult = memcmp(VARDATA_ANY(arg1val),\n\t\t\t\t\t\t\t\t   VARDATA_ANY(arg2val),\n\t\t\t\t\t\t\t\t   Min(len1, len2) - VARHDRSZ);\n\t\t\t\tif ((cmpresult == 0) && (len1 != len2))\n\t\t\t\t\tcmpresult = (len1 < len2) ? -1 : 1;\n\n\t\t\t\tif ((Pointer) arg1val != (Pointer) values1[i1])\n\t\t\t\t\tpfree(arg1val);\n\t\t\t\tif ((Pointer) arg2val != (Pointer) values2[i2])\n\t\t\t\t\tpfree(arg2val);\n\t\t\t}\n\t\t\telse if (att1->attbyval)\n\t\t\t{\n\t\t\t\tif (values1[i1] != values2[i2])\n\t\t\t\t\tcmpresult = (values1[i1] < values2[i2]) ? -1 : 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcmpresult = memcmp(DatumGetPointer(values1[i1]),\n\t\t\t\t\t\t\t\t   DatumGetPointer(values2[i2]),\n\t\t\t\t\t\t\t\t   att1->attlen);\n\t\t\t}\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}"
  },
  {
    "function_name": "btrecordcmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "1272-1276",
    "snippet": "Datum\nbtrecordcmp(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_INT32(record_cmp(fcinfo));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "record_cmp(fcinfo)"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "record_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
          "lines": "783-1014",
          "snippet": "static int\nrecord_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\t\tTypeCacheEntry *typentry;\n\t\tOid\t\t\tcollation;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * If they're not same collation, we don't complain here, but the\n\t\t * comparison function might.\n\t\t */\n\t\tcollation = att1->attcollation;\n\t\tif (collation != att2->attcollation)\n\t\t\tcollation = InvalidOid;\n\n\t\t/*\n\t\t * Lookup the comparison function if not done already\n\t\t */\n\t\ttypentry = my_extra->columns[j].typentry;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != att1->atttypid)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(att1->atttypid,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id))));\n\t\t\tmy_extra->columns[j].typentry = typentry;\n\t\t}\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tFunctionCallInfoData locfcinfo;\n\t\t\tint32\t\tcmpresult;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\t\t\tlocfcinfo.arg[0] = values1[i1];\n\t\t\tlocfcinfo.arg[1] = values2[i2];\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nrecord_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\t\tTypeCacheEntry *typentry;\n\t\tOid\t\t\tcollation;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * If they're not same collation, we don't complain here, but the\n\t\t * comparison function might.\n\t\t */\n\t\tcollation = att1->attcollation;\n\t\tif (collation != att2->attcollation)\n\t\t\tcollation = InvalidOid;\n\n\t\t/*\n\t\t * Lookup the comparison function if not done already\n\t\t */\n\t\ttypentry = my_extra->columns[j].typentry;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != att1->atttypid)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(att1->atttypid,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id))));\n\t\t\tmy_extra->columns[j].typentry = typentry;\n\t\t}\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tFunctionCallInfoData locfcinfo;\n\t\t\tint32\t\tcmpresult;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\t\t\tlocfcinfo.arg[0] = values1[i1];\n\t\t\tlocfcinfo.arg[1] = values2[i2];\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nbtrecordcmp(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_INT32(record_cmp(fcinfo));\n}"
  },
  {
    "function_name": "record_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "1266-1270",
    "snippet": "Datum\nrecord_ge(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(record_cmp(fcinfo) >= 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "record_cmp(fcinfo) >= 0"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "record_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
          "lines": "783-1014",
          "snippet": "static int\nrecord_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\t\tTypeCacheEntry *typentry;\n\t\tOid\t\t\tcollation;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * If they're not same collation, we don't complain here, but the\n\t\t * comparison function might.\n\t\t */\n\t\tcollation = att1->attcollation;\n\t\tif (collation != att2->attcollation)\n\t\t\tcollation = InvalidOid;\n\n\t\t/*\n\t\t * Lookup the comparison function if not done already\n\t\t */\n\t\ttypentry = my_extra->columns[j].typentry;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != att1->atttypid)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(att1->atttypid,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id))));\n\t\t\tmy_extra->columns[j].typentry = typentry;\n\t\t}\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tFunctionCallInfoData locfcinfo;\n\t\t\tint32\t\tcmpresult;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\t\t\tlocfcinfo.arg[0] = values1[i1];\n\t\t\tlocfcinfo.arg[1] = values2[i2];\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nrecord_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\t\tTypeCacheEntry *typentry;\n\t\tOid\t\t\tcollation;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * If they're not same collation, we don't complain here, but the\n\t\t * comparison function might.\n\t\t */\n\t\tcollation = att1->attcollation;\n\t\tif (collation != att2->attcollation)\n\t\t\tcollation = InvalidOid;\n\n\t\t/*\n\t\t * Lookup the comparison function if not done already\n\t\t */\n\t\ttypentry = my_extra->columns[j].typentry;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != att1->atttypid)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(att1->atttypid,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id))));\n\t\t\tmy_extra->columns[j].typentry = typentry;\n\t\t}\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tFunctionCallInfoData locfcinfo;\n\t\t\tint32\t\tcmpresult;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\t\t\tlocfcinfo.arg[0] = values1[i1];\n\t\t\tlocfcinfo.arg[1] = values2[i2];\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_ge(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(record_cmp(fcinfo) >= 0);\n}"
  },
  {
    "function_name": "record_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "1260-1264",
    "snippet": "Datum\nrecord_le(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(record_cmp(fcinfo) <= 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "record_cmp(fcinfo) <= 0"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "record_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
          "lines": "783-1014",
          "snippet": "static int\nrecord_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\t\tTypeCacheEntry *typentry;\n\t\tOid\t\t\tcollation;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * If they're not same collation, we don't complain here, but the\n\t\t * comparison function might.\n\t\t */\n\t\tcollation = att1->attcollation;\n\t\tif (collation != att2->attcollation)\n\t\t\tcollation = InvalidOid;\n\n\t\t/*\n\t\t * Lookup the comparison function if not done already\n\t\t */\n\t\ttypentry = my_extra->columns[j].typentry;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != att1->atttypid)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(att1->atttypid,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id))));\n\t\t\tmy_extra->columns[j].typentry = typentry;\n\t\t}\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tFunctionCallInfoData locfcinfo;\n\t\t\tint32\t\tcmpresult;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\t\t\tlocfcinfo.arg[0] = values1[i1];\n\t\t\tlocfcinfo.arg[1] = values2[i2];\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nrecord_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\t\tTypeCacheEntry *typentry;\n\t\tOid\t\t\tcollation;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * If they're not same collation, we don't complain here, but the\n\t\t * comparison function might.\n\t\t */\n\t\tcollation = att1->attcollation;\n\t\tif (collation != att2->attcollation)\n\t\t\tcollation = InvalidOid;\n\n\t\t/*\n\t\t * Lookup the comparison function if not done already\n\t\t */\n\t\ttypentry = my_extra->columns[j].typentry;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != att1->atttypid)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(att1->atttypid,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id))));\n\t\t\tmy_extra->columns[j].typentry = typentry;\n\t\t}\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tFunctionCallInfoData locfcinfo;\n\t\t\tint32\t\tcmpresult;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\t\t\tlocfcinfo.arg[0] = values1[i1];\n\t\t\tlocfcinfo.arg[1] = values2[i2];\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_le(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(record_cmp(fcinfo) <= 0);\n}"
  },
  {
    "function_name": "record_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "1254-1258",
    "snippet": "Datum\nrecord_gt(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(record_cmp(fcinfo) > 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "record_cmp(fcinfo) > 0"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "record_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
          "lines": "783-1014",
          "snippet": "static int\nrecord_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\t\tTypeCacheEntry *typentry;\n\t\tOid\t\t\tcollation;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * If they're not same collation, we don't complain here, but the\n\t\t * comparison function might.\n\t\t */\n\t\tcollation = att1->attcollation;\n\t\tif (collation != att2->attcollation)\n\t\t\tcollation = InvalidOid;\n\n\t\t/*\n\t\t * Lookup the comparison function if not done already\n\t\t */\n\t\ttypentry = my_extra->columns[j].typentry;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != att1->atttypid)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(att1->atttypid,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id))));\n\t\t\tmy_extra->columns[j].typentry = typentry;\n\t\t}\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tFunctionCallInfoData locfcinfo;\n\t\t\tint32\t\tcmpresult;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\t\t\tlocfcinfo.arg[0] = values1[i1];\n\t\t\tlocfcinfo.arg[1] = values2[i2];\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nrecord_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\t\tTypeCacheEntry *typentry;\n\t\tOid\t\t\tcollation;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * If they're not same collation, we don't complain here, but the\n\t\t * comparison function might.\n\t\t */\n\t\tcollation = att1->attcollation;\n\t\tif (collation != att2->attcollation)\n\t\t\tcollation = InvalidOid;\n\n\t\t/*\n\t\t * Lookup the comparison function if not done already\n\t\t */\n\t\ttypentry = my_extra->columns[j].typentry;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != att1->atttypid)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(att1->atttypid,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id))));\n\t\t\tmy_extra->columns[j].typentry = typentry;\n\t\t}\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tFunctionCallInfoData locfcinfo;\n\t\t\tint32\t\tcmpresult;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\t\t\tlocfcinfo.arg[0] = values1[i1];\n\t\t\tlocfcinfo.arg[1] = values2[i2];\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_gt(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(record_cmp(fcinfo) > 0);\n}"
  },
  {
    "function_name": "record_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "1248-1252",
    "snippet": "Datum\nrecord_lt(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(record_cmp(fcinfo) < 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "record_cmp(fcinfo) < 0"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "record_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
          "lines": "783-1014",
          "snippet": "static int\nrecord_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\t\tTypeCacheEntry *typentry;\n\t\tOid\t\t\tcollation;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * If they're not same collation, we don't complain here, but the\n\t\t * comparison function might.\n\t\t */\n\t\tcollation = att1->attcollation;\n\t\tif (collation != att2->attcollation)\n\t\t\tcollation = InvalidOid;\n\n\t\t/*\n\t\t * Lookup the comparison function if not done already\n\t\t */\n\t\ttypentry = my_extra->columns[j].typentry;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != att1->atttypid)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(att1->atttypid,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id))));\n\t\t\tmy_extra->columns[j].typentry = typentry;\n\t\t}\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tFunctionCallInfoData locfcinfo;\n\t\t\tint32\t\tcmpresult;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\t\t\tlocfcinfo.arg[0] = values1[i1];\n\t\t\tlocfcinfo.arg[1] = values2[i2];\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nrecord_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\t\tTypeCacheEntry *typentry;\n\t\tOid\t\t\tcollation;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * If they're not same collation, we don't complain here, but the\n\t\t * comparison function might.\n\t\t */\n\t\tcollation = att1->attcollation;\n\t\tif (collation != att2->attcollation)\n\t\t\tcollation = InvalidOid;\n\n\t\t/*\n\t\t * Lookup the comparison function if not done already\n\t\t */\n\t\ttypentry = my_extra->columns[j].typentry;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != att1->atttypid)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(att1->atttypid,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id))));\n\t\t\tmy_extra->columns[j].typentry = typentry;\n\t\t}\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tFunctionCallInfoData locfcinfo;\n\t\t\tint32\t\tcmpresult;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\t\t\tlocfcinfo.arg[0] = values1[i1];\n\t\t\tlocfcinfo.arg[1] = values2[i2];\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_lt(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(record_cmp(fcinfo) < 0);\n}"
  },
  {
    "function_name": "record_ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "1242-1246",
    "snippet": "Datum\nrecord_ne(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(!DatumGetBool(record_eq(fcinfo)));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "!DatumGetBool(record_eq(fcinfo))"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "record_eq(fcinfo)"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_eq",
          "args": [
            "fcinfo"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "record_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
          "lines": "1025-1240",
          "snippet": "Datum\nrecord_eq(PG_FUNCTION_ARGS)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tbool\t\tresult = true;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\t\tTypeCacheEntry *typentry;\n\t\tOid\t\t\tcollation;\n\t\tFunctionCallInfoData locfcinfo;\n\t\tbool\t\toprresult;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * If they're not same collation, we don't complain here, but the\n\t\t * equality function might.\n\t\t */\n\t\tcollation = att1->attcollation;\n\t\tif (collation != att2->attcollation)\n\t\t\tcollation = InvalidOid;\n\n\t\t/*\n\t\t * Lookup the equality function if not done already\n\t\t */\n\t\ttypentry = my_extra->columns[j].typentry;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != att1->atttypid)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(att1->atttypid,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id))));\n\t\t\tmy_extra->columns[j].typentry = typentry;\n\t\t}\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tif (nulls1[i1] || nulls2[i2])\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\t\t\tlocfcinfo.arg[0] = values1[i1];\n\t\t\tlocfcinfo.arg[1] = values2[i2];\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\tif (!oprresult)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_eq(PG_FUNCTION_ARGS)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tbool\t\tresult = true;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\t\tTypeCacheEntry *typentry;\n\t\tOid\t\t\tcollation;\n\t\tFunctionCallInfoData locfcinfo;\n\t\tbool\t\toprresult;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * If they're not same collation, we don't complain here, but the\n\t\t * equality function might.\n\t\t */\n\t\tcollation = att1->attcollation;\n\t\tif (collation != att2->attcollation)\n\t\t\tcollation = InvalidOid;\n\n\t\t/*\n\t\t * Lookup the equality function if not done already\n\t\t */\n\t\ttypentry = my_extra->columns[j].typentry;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != att1->atttypid)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(att1->atttypid,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id))));\n\t\t\tmy_extra->columns[j].typentry = typentry;\n\t\t}\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tif (nulls1[i1] || nulls2[i2])\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\t\t\tlocfcinfo.arg[0] = values1[i1];\n\t\t\tlocfcinfo.arg[1] = values2[i2];\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\tif (!oprresult)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_ne(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(!DatumGetBool(record_eq(fcinfo)));\n}"
  },
  {
    "function_name": "record_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "1025-1240",
    "snippet": "Datum\nrecord_eq(PG_FUNCTION_ARGS)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tbool\t\tresult = true;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\t\tTypeCacheEntry *typentry;\n\t\tOid\t\t\tcollation;\n\t\tFunctionCallInfoData locfcinfo;\n\t\tbool\t\toprresult;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * If they're not same collation, we don't complain here, but the\n\t\t * equality function might.\n\t\t */\n\t\tcollation = att1->attcollation;\n\t\tif (collation != att2->attcollation)\n\t\t\tcollation = InvalidOid;\n\n\t\t/*\n\t\t * Lookup the equality function if not done already\n\t\t */\n\t\ttypentry = my_extra->columns[j].typentry;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != att1->atttypid)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(att1->atttypid,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id))));\n\t\t\tmy_extra->columns[j].typentry = typentry;\n\t\t}\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tif (nulls1[i1] || nulls2[i2])\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\t\t\tlocfcinfo.arg[0] = values1[i1];\n\t\t\tlocfcinfo.arg[1] = values2[i2];\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\tif (!oprresult)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "record2",
            "1"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "record1",
            "0"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseTupleDesc",
          "args": [
            "tupdesc2"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseTupleDesc",
          "args": [
            "tupdesc1"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "nulls2"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\"))"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot compare record types with different numbers of columns\""
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATATYPE_MISMATCH"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCallInvoke(&locfcinfo)"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&locfcinfo"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "locfcinfo",
            "&typentry->eq_opr_finfo",
            "2",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id)))"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "typentry->type_id"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->eq_opr_finfo.fn_oid"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "att1->atttypid",
            "TYPECACHE_EQ_OPR_FINFO"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1))"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc2",
            "i2"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc1",
            "i1"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc2",
            "i2"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc1",
            "i1"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_deform_tuple",
          "args": [
            "&tuple2",
            "tupdesc2",
            "values2",
            "nulls2"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "ncolumns2 * sizeof(bool)"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_deform_tuple",
          "args": [
            "&tuple1",
            "tupdesc1",
            "values1",
            "nulls1"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "my_extra->columns",
            "0",
            "ncols * sizeof(ColumnCompareData)"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData)"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "ncolumns1",
            "ncolumns2"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerSetInvalid",
          "args": [
            "&(tuple2.t_self)"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatumLength",
          "args": [
            "record2"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerSetInvalid",
          "args": [
            "&(tuple1.t_self)"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatumLength",
          "args": [
            "record1"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc",
          "args": [
            "tupType2",
            "tupTypmod2"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1674-1681",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypMod",
          "args": [
            "record2"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypeId",
          "args": [
            "record2"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypMod",
          "args": [
            "record1"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypeId",
          "args": [
            "record1"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_HEAPTUPLEHEADER",
          "args": [
            "1"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_HEAPTUPLEHEADER",
          "args": [
            "0"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_eq(PG_FUNCTION_ARGS)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tbool\t\tresult = true;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\t\tTypeCacheEntry *typentry;\n\t\tOid\t\t\tcollation;\n\t\tFunctionCallInfoData locfcinfo;\n\t\tbool\t\toprresult;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * If they're not same collation, we don't complain here, but the\n\t\t * equality function might.\n\t\t */\n\t\tcollation = att1->attcollation;\n\t\tif (collation != att2->attcollation)\n\t\t\tcollation = InvalidOid;\n\n\t\t/*\n\t\t * Lookup the equality function if not done already\n\t\t */\n\t\ttypentry = my_extra->columns[j].typentry;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != att1->atttypid)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(att1->atttypid,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id))));\n\t\t\tmy_extra->columns[j].typentry = typentry;\n\t\t}\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tif (nulls1[i1] || nulls2[i2])\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\t\t\tlocfcinfo.arg[0] = values1[i1];\n\t\t\tlocfcinfo.arg[1] = values2[i2];\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\tif (!oprresult)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "record_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "783-1014",
    "snippet": "static int\nrecord_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\t\tTypeCacheEntry *typentry;\n\t\tOid\t\t\tcollation;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * If they're not same collation, we don't complain here, but the\n\t\t * comparison function might.\n\t\t */\n\t\tcollation = att1->attcollation;\n\t\tif (collation != att2->attcollation)\n\t\t\tcollation = InvalidOid;\n\n\t\t/*\n\t\t * Lookup the comparison function if not done already\n\t\t */\n\t\ttypentry = my_extra->columns[j].typentry;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != att1->atttypid)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(att1->atttypid,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id))));\n\t\t\tmy_extra->columns[j].typentry = typentry;\n\t\t}\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tFunctionCallInfoData locfcinfo;\n\t\t\tint32\t\tcmpresult;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\t\t\tlocfcinfo.arg[0] = values1[i1];\n\t\t\tlocfcinfo.arg[1] = values2[i2];\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "record2",
            "1"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "record1",
            "0"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseTupleDesc",
          "args": [
            "tupdesc2"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseTupleDesc",
          "args": [
            "tupdesc1"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "nulls2"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\"))"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot compare record types with different numbers of columns\""
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATATYPE_MISMATCH"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "FunctionCallInvoke(&locfcinfo)"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&locfcinfo"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "locfcinfo",
            "&typentry->cmp_proc_finfo",
            "2",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id)))"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "typentry->type_id"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->cmp_proc_finfo.fn_oid"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "att1->atttypid",
            "TYPECACHE_CMP_PROC_FINFO"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1))"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc2",
            "i2"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc1",
            "i1"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc2",
            "i2"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc1",
            "i1"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_deform_tuple",
          "args": [
            "&tuple2",
            "tupdesc2",
            "values2",
            "nulls2"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "ncolumns2 * sizeof(bool)"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_deform_tuple",
          "args": [
            "&tuple1",
            "tupdesc1",
            "values1",
            "nulls1"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "my_extra->columns",
            "0",
            "ncols * sizeof(ColumnCompareData)"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData)"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "ncolumns1",
            "ncolumns2"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerSetInvalid",
          "args": [
            "&(tuple2.t_self)"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatumLength",
          "args": [
            "record2"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerSetInvalid",
          "args": [
            "&(tuple1.t_self)"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatumLength",
          "args": [
            "record1"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc",
          "args": [
            "tupType2",
            "tupTypmod2"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1674-1681",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypMod",
          "args": [
            "record2"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypeId",
          "args": [
            "record2"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypMod",
          "args": [
            "record1"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypeId",
          "args": [
            "record1"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_HEAPTUPLEHEADER",
          "args": [
            "1"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_HEAPTUPLEHEADER",
          "args": [
            "0"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nrecord_cmp(FunctionCallInfo fcinfo)\n{\n\tHeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(0);\n\tHeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(1);\n\tint\t\t\tresult = 0;\n\tOid\t\t\ttupType1;\n\tOid\t\t\ttupType2;\n\tint32\t\ttupTypmod1;\n\tint32\t\ttupTypmod2;\n\tTupleDesc\ttupdesc1;\n\tTupleDesc\ttupdesc2;\n\tHeapTupleData tuple1;\n\tHeapTupleData tuple2;\n\tint\t\t\tncolumns1;\n\tint\t\t\tncolumns2;\n\tRecordCompareData *my_extra;\n\tint\t\t\tncols;\n\tDatum\t   *values1;\n\tDatum\t   *values2;\n\tbool\t   *nulls1;\n\tbool\t   *nulls2;\n\tint\t\t\ti1;\n\tint\t\t\ti2;\n\tint\t\t\tj;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuples */\n\ttupType1 = HeapTupleHeaderGetTypeId(record1);\n\ttupTypmod1 = HeapTupleHeaderGetTypMod(record1);\n\ttupdesc1 = lookup_rowtype_tupdesc(tupType1, tupTypmod1);\n\tncolumns1 = tupdesc1->natts;\n\ttupType2 = HeapTupleHeaderGetTypeId(record2);\n\ttupTypmod2 = HeapTupleHeaderGetTypMod(record2);\n\ttupdesc2 = lookup_rowtype_tupdesc(tupType2, tupTypmod2);\n\tncolumns2 = tupdesc2->natts;\n\n\t/* Build temporary HeapTuple control structures */\n\ttuple1.t_len = HeapTupleHeaderGetDatumLength(record1);\n\tItemPointerSetInvalid(&(tuple1.t_self));\n\ttuple1.t_tableOid = InvalidOid;\n\ttuple1.t_data = record1;\n\ttuple2.t_len = HeapTupleHeaderGetDatumLength(record2);\n\tItemPointerSetInvalid(&(tuple2.t_self));\n\ttuple2.t_tableOid = InvalidOid;\n\ttuple2.t_data = record2;\n\n\t/*\n\t * We arrange to look up the needed comparison info just once per series\n\t * of calls, assuming the record types don't change underneath us.\n\t */\n\tncols = Max(ncolumns1, ncolumns2);\n\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns < ncols)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordCompareData, columns) +\n\t\t\t\t\t\t\t   ncols * sizeof(ColumnCompareData));\n\t\tmy_extra = (RecordCompareData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->ncolumns = ncols;\n\t\tmy_extra->record1_type = InvalidOid;\n\t\tmy_extra->record1_typmod = 0;\n\t\tmy_extra->record2_type = InvalidOid;\n\t\tmy_extra->record2_typmod = 0;\n\t}\n\n\tif (my_extra->record1_type != tupType1 ||\n\t\tmy_extra->record1_typmod != tupTypmod1 ||\n\t\tmy_extra->record2_type != tupType2 ||\n\t\tmy_extra->record2_typmod != tupTypmod2)\n\t{\n\t\tMemSet(my_extra->columns, 0, ncols * sizeof(ColumnCompareData));\n\t\tmy_extra->record1_type = tupType1;\n\t\tmy_extra->record1_typmod = tupTypmod1;\n\t\tmy_extra->record2_type = tupType2;\n\t\tmy_extra->record2_typmod = tupTypmod2;\n\t}\n\n\t/* Break down the tuples into fields */\n\tvalues1 = (Datum *) palloc(ncolumns1 * sizeof(Datum));\n\tnulls1 = (bool *) palloc(ncolumns1 * sizeof(bool));\n\theap_deform_tuple(&tuple1, tupdesc1, values1, nulls1);\n\tvalues2 = (Datum *) palloc(ncolumns2 * sizeof(Datum));\n\tnulls2 = (bool *) palloc(ncolumns2 * sizeof(bool));\n\theap_deform_tuple(&tuple2, tupdesc2, values2, nulls2);\n\n\t/*\n\t * Scan corresponding columns, allowing for dropped columns in different\n\t * places in the two rows.  i1 and i2 are physical column indexes, j is\n\t * the logical column index.\n\t */\n\ti1 = i2 = j = 0;\n\twhile (i1 < ncolumns1 || i2 < ncolumns2)\n\t{\n\t\tForm_pg_attribute att1;\n\t\tForm_pg_attribute att2;\n\t\tTypeCacheEntry *typentry;\n\t\tOid\t\t\tcollation;\n\n\t\t/*\n\t\t * Skip dropped columns\n\t\t */\n\t\tif (i1 < ncolumns1 && TupleDescAttr(tupdesc1, i1)->attisdropped)\n\t\t{\n\t\t\ti1++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2 < ncolumns2 && TupleDescAttr(tupdesc2, i2)->attisdropped)\n\t\t{\n\t\t\ti2++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i1 >= ncolumns1 || i2 >= ncolumns2)\n\t\t\tbreak;\t\t\t\t/* we'll deal with mismatch below loop */\n\n\t\tatt1 = TupleDescAttr(tupdesc1, i1);\n\t\tatt2 = TupleDescAttr(tupdesc2, i2);\n\n\t\t/*\n\t\t * Have two matching columns, they must be same type\n\t\t */\n\t\tif (att1->atttypid != att2->atttypid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare dissimilar column types %s and %s at record column %d\",\n\t\t\t\t\t\t\tformat_type_be(att1->atttypid),\n\t\t\t\t\t\t\tformat_type_be(att2->atttypid),\n\t\t\t\t\t\t\tj + 1)));\n\n\t\t/*\n\t\t * If they're not same collation, we don't complain here, but the\n\t\t * comparison function might.\n\t\t */\n\t\tcollation = att1->attcollation;\n\t\tif (collation != att2->attcollation)\n\t\t\tcollation = InvalidOid;\n\n\t\t/*\n\t\t * Lookup the comparison function if not done already\n\t\t */\n\t\ttypentry = my_extra->columns[j].typentry;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != att1->atttypid)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(att1->atttypid,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(typentry->type_id))));\n\t\t\tmy_extra->columns[j].typentry = typentry;\n\t\t}\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (!nulls1[i1] || !nulls2[i2])\n\t\t{\n\t\t\tFunctionCallInfoData locfcinfo;\n\t\t\tint32\t\tcmpresult;\n\n\t\t\tif (nulls1[i1])\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nulls2[i2])\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Compare the pair of elements */\n\t\t\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\t\t\tlocfcinfo.arg[0] = values1[i1];\n\t\t\tlocfcinfo.arg[1] = values2[i2];\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\t\tif (cmpresult < 0)\n\t\t\t{\n\t\t\t\t/* arg1 is less than arg2 */\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cmpresult > 0)\n\t\t\t{\n\t\t\t\t/* arg1 is greater than arg2 */\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* equal, so continue to next column */\n\t\ti1++, i2++, j++;\n\t}\n\n\t/*\n\t * If we didn't break out of the loop early, check for column count\n\t * mismatch.  (We do not report such mismatch if we found unequal column\n\t * values; is that a feature or a bug?)\n\t */\n\tif (result == 0)\n\t{\n\t\tif (i1 != ncolumns1 || i2 != ncolumns2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"cannot compare record types with different numbers of columns\")));\n\t}\n\n\tpfree(values1);\n\tpfree(nulls1);\n\tpfree(values2);\n\tpfree(nulls2);\n\tReleaseTupleDesc(tupdesc1);\n\tReleaseTupleDesc(tupdesc2);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(record1, 0);\n\tPG_FREE_IF_COPY(record2, 1);\n\n\treturn result;\n}"
  },
  {
    "function_name": "record_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "647-769",
    "snippet": "Datum\nrecord_send(PG_FUNCTION_ARGS)\n{\n\tHeapTupleHeader rec = PG_GETARG_HEAPTUPLEHEADER(0);\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tuple;\n\tRecordIOData *my_extra;\n\tint\t\t\tncolumns;\n\tint\t\t\tvalidcols;\n\tint\t\t\ti;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tStringInfoData buf;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuple itself */\n\ttupType = HeapTupleHeaderGetTypeId(rec);\n\ttupTypmod = HeapTupleHeaderGetTypMod(rec);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\tncolumns = tupdesc->natts;\n\n\t/* Build a temporary HeapTuple control structure */\n\ttuple.t_len = HeapTupleHeaderGetDatumLength(rec);\n\tItemPointerSetInvalid(&(tuple.t_self));\n\ttuple.t_tableOid = InvalidOid;\n\ttuple.t_data = rec;\n\n\t/*\n\t * We arrange to look up the needed I/O info just once per series of\n\t * calls, assuming the record type doesn't change underneath us.\n\t */\n\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns != ncolumns)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t\t\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->record_type = InvalidOid;\n\t\tmy_extra->record_typmod = 0;\n\t}\n\n\tif (my_extra->record_type != tupType ||\n\t\tmy_extra->record_typmod != tupTypmod)\n\t{\n\t\tMemSet(my_extra, 0,\n\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\tmy_extra->record_type = tupType;\n\t\tmy_extra->record_typmod = tupTypmod;\n\t\tmy_extra->ncolumns = ncolumns;\n\t}\n\n\tvalues = (Datum *) palloc(ncolumns * sizeof(Datum));\n\tnulls = (bool *) palloc(ncolumns * sizeof(bool));\n\n\t/* Break down the tuple into fields */\n\theap_deform_tuple(&tuple, tupdesc, values, nulls);\n\n\t/* And build the result string */\n\tpq_begintypsend(&buf);\n\n\t/* Need to scan to count nondeleted columns */\n\tvalidcols = 0;\n\tfor (i = 0; i < ncolumns; i++)\n\t{\n\t\tif (!TupleDescAttr(tupdesc, i)->attisdropped)\n\t\t\tvalidcols++;\n\t}\n\tpq_sendint32(&buf, validcols);\n\n\tfor (i = 0; i < ncolumns; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\t\tColumnIOData *column_info = &my_extra->columns[i];\n\t\tOid\t\t\tcolumn_type = att->atttypid;\n\t\tDatum\t\tattr;\n\t\tbytea\t   *outputbytes;\n\n\t\t/* Ignore dropped columns in datatype */\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\n\t\tpq_sendint32(&buf, column_type);\n\n\t\tif (nulls[i])\n\t\t{\n\t\t\t/* emit -1 data length to signify a NULL */\n\t\t\tpq_sendint32(&buf, -1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Convert the column value to binary\n\t\t */\n\t\tif (column_info->column_type != column_type)\n\t\t{\n\t\t\tgetTypeBinaryOutputInfo(column_type,\n\t\t\t\t\t\t\t\t\t&column_info->typiofunc,\n\t\t\t\t\t\t\t\t\t&column_info->typisvarlena);\n\t\t\tfmgr_info_cxt(column_info->typiofunc, &column_info->proc,\n\t\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\t\tcolumn_info->column_type = column_type;\n\t\t}\n\n\t\tattr = values[i];\n\t\toutputbytes = SendFunctionCall(&column_info->proc, attr);\n\t\tpq_sendint32(&buf, VARSIZE(outputbytes) - VARHDRSZ);\n\t\tpq_sendbytes(&buf, VARDATA(outputbytes),\n\t\t\t\t\t VARSIZE(outputbytes) - VARHDRSZ);\n\t}\n\n\tpfree(values);\n\tpfree(nulls);\n\tReleaseTupleDesc(tupdesc);\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseTupleDesc",
          "args": [
            "tupdesc"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "nulls"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_sendbytes",
          "args": [
            "&buf",
            "VARDATA(outputbytes)",
            "VARSIZE(outputbytes) - VARHDRSZ"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "outputbytes"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "outputbytes"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "VARSIZE(outputbytes) - VARHDRSZ"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "outputbytes"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendFunctionCall",
          "args": [
            "&column_info->proc",
            "attr"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "OidSendFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1851-1858",
          "snippet": "bytea *\nOidSendFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn SendFunctionCall(&flinfo, val);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nbytea *\nOidSendFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn SendFunctionCall(&flinfo, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "column_info->typiofunc",
            "&column_info->proc",
            "fcinfo->flinfo->fn_mcxt"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTypeBinaryOutputInfo",
          "args": [
            "column_type",
            "&column_info->typiofunc",
            "&column_info->typisvarlena"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "getTypeBinaryOutputInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2739-2765",
          "snippet": "void\ngetTypeBinaryOutputInfo(Oid type, Oid *typSend, bool *typIsVarlena)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typsend))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typSend = pt->typsend;\n\t*typIsVarlena = (!pt->typbyval) && (pt->typlen == -1);\n\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\ngetTypeBinaryOutputInfo(Oid type, Oid *typSend, bool *typIsVarlena)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typsend))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typSend = pt->typsend;\n\t*typIsVarlena = (!pt->typbyval) && (pt->typlen == -1);\n\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "-1"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "column_type"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "validcols"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_deform_tuple",
          "args": [
            "&tuple",
            "tupdesc",
            "values",
            "nulls"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "ncolumns * sizeof(bool)"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "my_extra",
            "0",
            "offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData)"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "offsetof(RecordIOData, columns) +\n\t\t\t\t\t\t\t   ncolumns * sizeof(ColumnIOData)"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ItemPointerSetInvalid",
          "args": [
            "&(tuple.t_self)"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatumLength",
          "args": [
            "rec"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc",
          "args": [
            "tupType",
            "tupTypmod"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1674-1681",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypMod",
          "args": [
            "rec"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypeId",
          "args": [
            "rec"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_HEAPTUPLEHEADER",
          "args": [
            "0"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_send(PG_FUNCTION_ARGS)\n{\n\tHeapTupleHeader rec = PG_GETARG_HEAPTUPLEHEADER(0);\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tuple;\n\tRecordIOData *my_extra;\n\tint\t\t\tncolumns;\n\tint\t\t\tvalidcols;\n\tint\t\t\ti;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tStringInfoData buf;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuple itself */\n\ttupType = HeapTupleHeaderGetTypeId(rec);\n\ttupTypmod = HeapTupleHeaderGetTypMod(rec);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\tncolumns = tupdesc->natts;\n\n\t/* Build a temporary HeapTuple control structure */\n\ttuple.t_len = HeapTupleHeaderGetDatumLength(rec);\n\tItemPointerSetInvalid(&(tuple.t_self));\n\ttuple.t_tableOid = InvalidOid;\n\ttuple.t_data = rec;\n\n\t/*\n\t * We arrange to look up the needed I/O info just once per series of\n\t * calls, assuming the record type doesn't change underneath us.\n\t */\n\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns != ncolumns)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t\t\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->record_type = InvalidOid;\n\t\tmy_extra->record_typmod = 0;\n\t}\n\n\tif (my_extra->record_type != tupType ||\n\t\tmy_extra->record_typmod != tupTypmod)\n\t{\n\t\tMemSet(my_extra, 0,\n\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\tmy_extra->record_type = tupType;\n\t\tmy_extra->record_typmod = tupTypmod;\n\t\tmy_extra->ncolumns = ncolumns;\n\t}\n\n\tvalues = (Datum *) palloc(ncolumns * sizeof(Datum));\n\tnulls = (bool *) palloc(ncolumns * sizeof(bool));\n\n\t/* Break down the tuple into fields */\n\theap_deform_tuple(&tuple, tupdesc, values, nulls);\n\n\t/* And build the result string */\n\tpq_begintypsend(&buf);\n\n\t/* Need to scan to count nondeleted columns */\n\tvalidcols = 0;\n\tfor (i = 0; i < ncolumns; i++)\n\t{\n\t\tif (!TupleDescAttr(tupdesc, i)->attisdropped)\n\t\t\tvalidcols++;\n\t}\n\tpq_sendint32(&buf, validcols);\n\n\tfor (i = 0; i < ncolumns; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\t\tColumnIOData *column_info = &my_extra->columns[i];\n\t\tOid\t\t\tcolumn_type = att->atttypid;\n\t\tDatum\t\tattr;\n\t\tbytea\t   *outputbytes;\n\n\t\t/* Ignore dropped columns in datatype */\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\n\t\tpq_sendint32(&buf, column_type);\n\n\t\tif (nulls[i])\n\t\t{\n\t\t\t/* emit -1 data length to signify a NULL */\n\t\t\tpq_sendint32(&buf, -1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Convert the column value to binary\n\t\t */\n\t\tif (column_info->column_type != column_type)\n\t\t{\n\t\t\tgetTypeBinaryOutputInfo(column_type,\n\t\t\t\t\t\t\t\t\t&column_info->typiofunc,\n\t\t\t\t\t\t\t\t\t&column_info->typisvarlena);\n\t\t\tfmgr_info_cxt(column_info->typiofunc, &column_info->proc,\n\t\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\t\tcolumn_info->column_type = column_type;\n\t\t}\n\n\t\tattr = values[i];\n\t\toutputbytes = SendFunctionCall(&column_info->proc, attr);\n\t\tpq_sendint32(&buf, VARSIZE(outputbytes) - VARHDRSZ);\n\t\tpq_sendbytes(&buf, VARDATA(outputbytes),\n\t\t\t\t\t VARSIZE(outputbytes) - VARHDRSZ);\n\t}\n\n\tpfree(values);\n\tpfree(nulls);\n\tReleaseTupleDesc(tupdesc);\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "record_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "451-642",
    "snippet": "Datum\nrecord_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tOid\t\t\ttupType = PG_GETARG_OID(1);\n\tint32\t\ttupTypmod = PG_GETARG_INT32(2);\n\tHeapTupleHeader result;\n\tTupleDesc\ttupdesc;\n\tHeapTuple\ttuple;\n\tRecordIOData *my_extra;\n\tint\t\t\tncolumns;\n\tint\t\t\tusercols;\n\tint\t\t\tvalidcols;\n\tint\t\t\ti;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/*\n\t * Give a friendly error message if we did not get enough info to identify\n\t * the target record type.  (lookup_rowtype_tupdesc would fail anyway, but\n\t * with a non-user-friendly message.)  In ordinary SQL usage, we'll get -1\n\t * for typmod, since composite types and RECORD have no type modifiers at\n\t * the SQL level, and thus must fail for RECORD.  However some callers can\n\t * supply a valid typmod, and then we can do something useful for RECORD.\n\t */\n\tif (tupType == RECORDOID && tupTypmod < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"input of anonymous composite types is not implemented\")));\n\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\tncolumns = tupdesc->natts;\n\n\t/*\n\t * We arrange to look up the needed I/O info just once per series of\n\t * calls, assuming the record type doesn't change underneath us.\n\t */\n\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns != ncolumns)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t\t\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->record_type = InvalidOid;\n\t\tmy_extra->record_typmod = 0;\n\t}\n\n\tif (my_extra->record_type != tupType ||\n\t\tmy_extra->record_typmod != tupTypmod)\n\t{\n\t\tMemSet(my_extra, 0,\n\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\tmy_extra->record_type = tupType;\n\t\tmy_extra->record_typmod = tupTypmod;\n\t\tmy_extra->ncolumns = ncolumns;\n\t}\n\n\tvalues = (Datum *) palloc(ncolumns * sizeof(Datum));\n\tnulls = (bool *) palloc(ncolumns * sizeof(bool));\n\n\t/* Fetch number of columns user thinks it has */\n\tusercols = pq_getmsgint(buf, 4);\n\n\t/* Need to scan to count nondeleted columns */\n\tvalidcols = 0;\n\tfor (i = 0; i < ncolumns; i++)\n\t{\n\t\tif (!TupleDescAttr(tupdesc, i)->attisdropped)\n\t\t\tvalidcols++;\n\t}\n\tif (usercols != validcols)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"wrong number of columns: %d, expected %d\",\n\t\t\t\t\t\tusercols, validcols)));\n\n\t/* Process each column */\n\tfor (i = 0; i < ncolumns; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\t\tColumnIOData *column_info = &my_extra->columns[i];\n\t\tOid\t\t\tcolumn_type = att->atttypid;\n\t\tOid\t\t\tcoltypoid;\n\t\tint\t\t\titemlen;\n\t\tStringInfoData item_buf;\n\t\tStringInfo\tbufptr;\n\t\tchar\t\tcsave;\n\n\t\t/* Ignore dropped columns in datatype, but fill with nulls */\n\t\tif (att->attisdropped)\n\t\t{\n\t\t\tvalues[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Verify column datatype */\n\t\tcoltypoid = pq_getmsgint(buf, sizeof(Oid));\n\t\tif (coltypoid != column_type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"wrong data type: %u, expected %u\",\n\t\t\t\t\t\t\tcoltypoid, column_type)));\n\n\t\t/* Get and check the item length */\n\t\titemlen = pq_getmsgint(buf, 4);\n\t\tif (itemlen < -1 || itemlen > (buf->len - buf->cursor))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"insufficient data left in message\")));\n\n\t\tif (itemlen == -1)\n\t\t{\n\t\t\t/* -1 length means NULL */\n\t\t\tbufptr = NULL;\n\t\t\tnulls[i] = true;\n\t\t\tcsave = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Rather than copying data around, we just set up a phony\n\t\t\t * StringInfo pointing to the correct portion of the input buffer.\n\t\t\t * We assume we can scribble on the input buffer so as to maintain\n\t\t\t * the convention that StringInfos have a trailing null.\n\t\t\t */\n\t\t\titem_buf.data = &buf->data[buf->cursor];\n\t\t\titem_buf.maxlen = itemlen + 1;\n\t\t\titem_buf.len = itemlen;\n\t\t\titem_buf.cursor = 0;\n\n\t\t\tbuf->cursor += itemlen;\n\n\t\t\tcsave = buf->data[buf->cursor];\n\t\t\tbuf->data[buf->cursor] = '\\0';\n\n\t\t\tbufptr = &item_buf;\n\t\t\tnulls[i] = false;\n\t\t}\n\n\t\t/* Now call the column's receiveproc */\n\t\tif (column_info->column_type != column_type)\n\t\t{\n\t\t\tgetTypeBinaryInputInfo(column_type,\n\t\t\t\t\t\t\t\t   &column_info->typiofunc,\n\t\t\t\t\t\t\t\t   &column_info->typioparam);\n\t\t\tfmgr_info_cxt(column_info->typiofunc, &column_info->proc,\n\t\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\t\tcolumn_info->column_type = column_type;\n\t\t}\n\n\t\tvalues[i] = ReceiveFunctionCall(&column_info->proc,\n\t\t\t\t\t\t\t\t\t\tbufptr,\n\t\t\t\t\t\t\t\t\t\tcolumn_info->typioparam,\n\t\t\t\t\t\t\t\t\t\tatt->atttypmod);\n\n\t\tif (bufptr)\n\t\t{\n\t\t\t/* Trouble if it didn't eat the whole buffer */\n\t\t\tif (item_buf.cursor != itemlen)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"improper binary format in record column %d\",\n\t\t\t\t\t\t\t\ti + 1)));\n\n\t\t\tbuf->data[buf->cursor] = csave;\n\t\t}\n\t}\n\n\ttuple = heap_form_tuple(tupdesc, values, nulls);\n\n\t/*\n\t * We cannot return tuple->t_data because heap_form_tuple allocates it as\n\t * part of a larger chunk, and our caller may expect to be able to pfree\n\t * our result.  So must copy the info into a new palloc chunk.\n\t */\n\tresult = (HeapTupleHeader) palloc(tuple->t_len);\n\tmemcpy(result, tuple->t_data, tuple->t_len);\n\n\theap_freetuple(tuple);\n\tpfree(values);\n\tpfree(nulls);\n\tReleaseTupleDesc(tupdesc);\n\n\tPG_RETURN_HEAPTUPLEHEADER(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_HEAPTUPLEHEADER",
          "args": [
            "result"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseTupleDesc",
          "args": [
            "tupdesc"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "nulls"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_freetuple",
          "args": [
            "tuple"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result",
            "tuple->t_data",
            "tuple->t_len"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "tuple->t_len"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_form_tuple",
          "args": [
            "tupdesc",
            "values",
            "nulls"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"improper binary format in record column %d\",\n\t\t\t\t\t\t\t\ti + 1))"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"improper binary format in record column %d\"",
            "i + 1"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_BINARY_REPRESENTATION"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReceiveFunctionCall",
          "args": [
            "&column_info->proc",
            "bufptr",
            "column_info->typioparam",
            "att->atttypmod"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "OidReceiveFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1841-1849",
          "snippet": "Datum\nOidReceiveFunctionCall(Oid functionId, StringInfo buf,\n\t\t\t\t\t   Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn ReceiveFunctionCall(&flinfo, buf, typioparam, typmod);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidReceiveFunctionCall(Oid functionId, StringInfo buf,\n\t\t\t\t\t   Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn ReceiveFunctionCall(&flinfo, buf, typioparam, typmod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "column_info->typiofunc",
            "&column_info->proc",
            "fcinfo->flinfo->fn_mcxt"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTypeBinaryInputInfo",
          "args": [
            "column_type",
            "&column_info->typiofunc",
            "&column_info->typioparam"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "getTypeBinaryInputInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2706-2732",
          "snippet": "void\ngetTypeBinaryInputInfo(Oid type, Oid *typReceive, Oid *typIOParam)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typreceive))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typReceive = pt->typreceive;\n\t*typIOParam = getTypeIOParam(typeTuple);\n\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\ngetTypeBinaryInputInfo(Oid type, Oid *typReceive, Oid *typIOParam)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typreceive))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typReceive = pt->typreceive;\n\t*typIOParam = getTypeIOParam(typeTuple);\n\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"insufficient data left in message\"))"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "4"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"wrong data type: %u, expected %u\",\n\t\t\t\t\t\t\tcoltypoid, column_type))"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(Oid)"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"wrong number of columns: %d, expected %d\",\n\t\t\t\t\t\tusercols, validcols))"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "4"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "my_extra",
            "0",
            "offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData)"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "offsetof(RecordIOData, columns) +\n\t\t\t\t\t\t\t   ncolumns * sizeof(ColumnIOData)"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc",
          "args": [
            "tupType",
            "tupTypmod"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1674-1681",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"input of anonymous composite types is not implemented\"))"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tOid\t\t\ttupType = PG_GETARG_OID(1);\n\tint32\t\ttupTypmod = PG_GETARG_INT32(2);\n\tHeapTupleHeader result;\n\tTupleDesc\ttupdesc;\n\tHeapTuple\ttuple;\n\tRecordIOData *my_extra;\n\tint\t\t\tncolumns;\n\tint\t\t\tusercols;\n\tint\t\t\tvalidcols;\n\tint\t\t\ti;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/*\n\t * Give a friendly error message if we did not get enough info to identify\n\t * the target record type.  (lookup_rowtype_tupdesc would fail anyway, but\n\t * with a non-user-friendly message.)  In ordinary SQL usage, we'll get -1\n\t * for typmod, since composite types and RECORD have no type modifiers at\n\t * the SQL level, and thus must fail for RECORD.  However some callers can\n\t * supply a valid typmod, and then we can do something useful for RECORD.\n\t */\n\tif (tupType == RECORDOID && tupTypmod < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"input of anonymous composite types is not implemented\")));\n\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\tncolumns = tupdesc->natts;\n\n\t/*\n\t * We arrange to look up the needed I/O info just once per series of\n\t * calls, assuming the record type doesn't change underneath us.\n\t */\n\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns != ncolumns)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t\t\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->record_type = InvalidOid;\n\t\tmy_extra->record_typmod = 0;\n\t}\n\n\tif (my_extra->record_type != tupType ||\n\t\tmy_extra->record_typmod != tupTypmod)\n\t{\n\t\tMemSet(my_extra, 0,\n\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\tmy_extra->record_type = tupType;\n\t\tmy_extra->record_typmod = tupTypmod;\n\t\tmy_extra->ncolumns = ncolumns;\n\t}\n\n\tvalues = (Datum *) palloc(ncolumns * sizeof(Datum));\n\tnulls = (bool *) palloc(ncolumns * sizeof(bool));\n\n\t/* Fetch number of columns user thinks it has */\n\tusercols = pq_getmsgint(buf, 4);\n\n\t/* Need to scan to count nondeleted columns */\n\tvalidcols = 0;\n\tfor (i = 0; i < ncolumns; i++)\n\t{\n\t\tif (!TupleDescAttr(tupdesc, i)->attisdropped)\n\t\t\tvalidcols++;\n\t}\n\tif (usercols != validcols)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"wrong number of columns: %d, expected %d\",\n\t\t\t\t\t\tusercols, validcols)));\n\n\t/* Process each column */\n\tfor (i = 0; i < ncolumns; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\t\tColumnIOData *column_info = &my_extra->columns[i];\n\t\tOid\t\t\tcolumn_type = att->atttypid;\n\t\tOid\t\t\tcoltypoid;\n\t\tint\t\t\titemlen;\n\t\tStringInfoData item_buf;\n\t\tStringInfo\tbufptr;\n\t\tchar\t\tcsave;\n\n\t\t/* Ignore dropped columns in datatype, but fill with nulls */\n\t\tif (att->attisdropped)\n\t\t{\n\t\t\tvalues[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Verify column datatype */\n\t\tcoltypoid = pq_getmsgint(buf, sizeof(Oid));\n\t\tif (coltypoid != column_type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"wrong data type: %u, expected %u\",\n\t\t\t\t\t\t\tcoltypoid, column_type)));\n\n\t\t/* Get and check the item length */\n\t\titemlen = pq_getmsgint(buf, 4);\n\t\tif (itemlen < -1 || itemlen > (buf->len - buf->cursor))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"insufficient data left in message\")));\n\n\t\tif (itemlen == -1)\n\t\t{\n\t\t\t/* -1 length means NULL */\n\t\t\tbufptr = NULL;\n\t\t\tnulls[i] = true;\n\t\t\tcsave = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Rather than copying data around, we just set up a phony\n\t\t\t * StringInfo pointing to the correct portion of the input buffer.\n\t\t\t * We assume we can scribble on the input buffer so as to maintain\n\t\t\t * the convention that StringInfos have a trailing null.\n\t\t\t */\n\t\t\titem_buf.data = &buf->data[buf->cursor];\n\t\t\titem_buf.maxlen = itemlen + 1;\n\t\t\titem_buf.len = itemlen;\n\t\t\titem_buf.cursor = 0;\n\n\t\t\tbuf->cursor += itemlen;\n\n\t\t\tcsave = buf->data[buf->cursor];\n\t\t\tbuf->data[buf->cursor] = '\\0';\n\n\t\t\tbufptr = &item_buf;\n\t\t\tnulls[i] = false;\n\t\t}\n\n\t\t/* Now call the column's receiveproc */\n\t\tif (column_info->column_type != column_type)\n\t\t{\n\t\t\tgetTypeBinaryInputInfo(column_type,\n\t\t\t\t\t\t\t\t   &column_info->typiofunc,\n\t\t\t\t\t\t\t\t   &column_info->typioparam);\n\t\t\tfmgr_info_cxt(column_info->typiofunc, &column_info->proc,\n\t\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\t\tcolumn_info->column_type = column_type;\n\t\t}\n\n\t\tvalues[i] = ReceiveFunctionCall(&column_info->proc,\n\t\t\t\t\t\t\t\t\t\tbufptr,\n\t\t\t\t\t\t\t\t\t\tcolumn_info->typioparam,\n\t\t\t\t\t\t\t\t\t\tatt->atttypmod);\n\n\t\tif (bufptr)\n\t\t{\n\t\t\t/* Trouble if it didn't eat the whole buffer */\n\t\t\tif (item_buf.cursor != itemlen)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"improper binary format in record column %d\",\n\t\t\t\t\t\t\t\ti + 1)));\n\n\t\t\tbuf->data[buf->cursor] = csave;\n\t\t}\n\t}\n\n\ttuple = heap_form_tuple(tupdesc, values, nulls);\n\n\t/*\n\t * We cannot return tuple->t_data because heap_form_tuple allocates it as\n\t * part of a larger chunk, and our caller may expect to be able to pfree\n\t * our result.  So must copy the info into a new palloc chunk.\n\t */\n\tresult = (HeapTupleHeader) palloc(tuple->t_len);\n\tmemcpy(result, tuple->t_data, tuple->t_len);\n\n\theap_freetuple(tuple);\n\tpfree(values);\n\tpfree(nulls);\n\tReleaseTupleDesc(tupdesc);\n\n\tPG_RETURN_HEAPTUPLEHEADER(result);\n}"
  },
  {
    "function_name": "record_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "300-446",
    "snippet": "Datum\nrecord_out(PG_FUNCTION_ARGS)\n{\n\tHeapTupleHeader rec = PG_GETARG_HEAPTUPLEHEADER(0);\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tuple;\n\tRecordIOData *my_extra;\n\tbool\t\tneedComma = false;\n\tint\t\t\tncolumns;\n\tint\t\t\ti;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tStringInfoData buf;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuple itself */\n\ttupType = HeapTupleHeaderGetTypeId(rec);\n\ttupTypmod = HeapTupleHeaderGetTypMod(rec);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\tncolumns = tupdesc->natts;\n\n\t/* Build a temporary HeapTuple control structure */\n\ttuple.t_len = HeapTupleHeaderGetDatumLength(rec);\n\tItemPointerSetInvalid(&(tuple.t_self));\n\ttuple.t_tableOid = InvalidOid;\n\ttuple.t_data = rec;\n\n\t/*\n\t * We arrange to look up the needed I/O info just once per series of\n\t * calls, assuming the record type doesn't change underneath us.\n\t */\n\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns != ncolumns)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t\t\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->record_type = InvalidOid;\n\t\tmy_extra->record_typmod = 0;\n\t}\n\n\tif (my_extra->record_type != tupType ||\n\t\tmy_extra->record_typmod != tupTypmod)\n\t{\n\t\tMemSet(my_extra, 0,\n\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\tmy_extra->record_type = tupType;\n\t\tmy_extra->record_typmod = tupTypmod;\n\t\tmy_extra->ncolumns = ncolumns;\n\t}\n\n\tvalues = (Datum *) palloc(ncolumns * sizeof(Datum));\n\tnulls = (bool *) palloc(ncolumns * sizeof(bool));\n\n\t/* Break down the tuple into fields */\n\theap_deform_tuple(&tuple, tupdesc, values, nulls);\n\n\t/* And build the result string */\n\tinitStringInfo(&buf);\n\n\tappendStringInfoChar(&buf, '(');\n\n\tfor (i = 0; i < ncolumns; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\t\tColumnIOData *column_info = &my_extra->columns[i];\n\t\tOid\t\t\tcolumn_type = att->atttypid;\n\t\tDatum\t\tattr;\n\t\tchar\t   *value;\n\t\tchar\t   *tmp;\n\t\tbool\t\tnq;\n\n\t\t/* Ignore dropped columns in datatype */\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\n\t\tif (needComma)\n\t\t\tappendStringInfoChar(&buf, ',');\n\t\tneedComma = true;\n\n\t\tif (nulls[i])\n\t\t{\n\t\t\t/* emit nothing... */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Convert the column value to text\n\t\t */\n\t\tif (column_info->column_type != column_type)\n\t\t{\n\t\t\tgetTypeOutputInfo(column_type,\n\t\t\t\t\t\t\t  &column_info->typiofunc,\n\t\t\t\t\t\t\t  &column_info->typisvarlena);\n\t\t\tfmgr_info_cxt(column_info->typiofunc, &column_info->proc,\n\t\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\t\tcolumn_info->column_type = column_type;\n\t\t}\n\n\t\tattr = values[i];\n\t\tvalue = OutputFunctionCall(&column_info->proc, attr);\n\n\t\t/* Detect whether we need double quotes for this value */\n\t\tnq = (value[0] == '\\0');\t/* force quotes for empty string */\n\t\tfor (tmp = value; *tmp; tmp++)\n\t\t{\n\t\t\tchar\t\tch = *tmp;\n\n\t\t\tif (ch == '\"' || ch == '\\\\' ||\n\t\t\t\tch == '(' || ch == ')' || ch == ',' ||\n\t\t\t\tisspace((unsigned char) ch))\n\t\t\t{\n\t\t\t\tnq = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* And emit the string */\n\t\tif (nq)\n\t\t\tappendStringInfoCharMacro(&buf, '\"');\n\t\tfor (tmp = value; *tmp; tmp++)\n\t\t{\n\t\t\tchar\t\tch = *tmp;\n\n\t\t\tif (ch == '\"' || ch == '\\\\')\n\t\t\t\tappendStringInfoCharMacro(&buf, ch);\n\t\t\tappendStringInfoCharMacro(&buf, ch);\n\t\t}\n\t\tif (nq)\n\t\t\tappendStringInfoCharMacro(&buf, '\"');\n\t}\n\n\tappendStringInfoChar(&buf, ')');\n\n\tpfree(values);\n\tpfree(nulls);\n\tReleaseTupleDesc(tupdesc);\n\n\tPG_RETURN_CSTRING(buf.data);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "buf.data"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseTupleDesc",
          "args": [
            "tupdesc"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "nulls"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "')'"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "&buf",
            "'\"'"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "&buf",
            "ch"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "&buf",
            "ch"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "&buf",
            "'\"'"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) ch"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputFunctionCall",
          "args": [
            "&column_info->proc",
            "attr"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "OidOutputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1832-1839",
          "snippet": "char *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nchar *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "column_info->typiofunc",
            "&column_info->proc",
            "fcinfo->flinfo->fn_mcxt"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTypeOutputInfo",
          "args": [
            "column_type",
            "&column_info->typiofunc",
            "&column_info->typisvarlena"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "getTypeOutputInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2673-2699",
          "snippet": "void\ngetTypeOutputInfo(Oid type, Oid *typOutput, bool *typIsVarlena)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typoutput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no output function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typOutput = pt->typoutput;\n\t*typIsVarlena = (!pt->typbyval) && (pt->typlen == -1);\n\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\ngetTypeOutputInfo(Oid type, Oid *typOutput, bool *typIsVarlena)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typoutput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no output function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typOutput = pt->typoutput;\n\t*typIsVarlena = (!pt->typbyval) && (pt->typlen == -1);\n\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "'('"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_deform_tuple",
          "args": [
            "&tuple",
            "tupdesc",
            "values",
            "nulls"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "ncolumns * sizeof(bool)"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "my_extra",
            "0",
            "offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "offsetof(RecordIOData, columns) +\n\t\t\t\t\t\t\t   ncolumns * sizeof(ColumnIOData)"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ItemPointerSetInvalid",
          "args": [
            "&(tuple.t_self)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatumLength",
          "args": [
            "rec"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc",
          "args": [
            "tupType",
            "tupTypmod"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1674-1681",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypMod",
          "args": [
            "rec"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypeId",
          "args": [
            "rec"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_HEAPTUPLEHEADER",
          "args": [
            "0"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_out(PG_FUNCTION_ARGS)\n{\n\tHeapTupleHeader rec = PG_GETARG_HEAPTUPLEHEADER(0);\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tuple;\n\tRecordIOData *my_extra;\n\tbool\t\tneedComma = false;\n\tint\t\t\tncolumns;\n\tint\t\t\ti;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tStringInfoData buf;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/* Extract type info from the tuple itself */\n\ttupType = HeapTupleHeaderGetTypeId(rec);\n\ttupTypmod = HeapTupleHeaderGetTypMod(rec);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\tncolumns = tupdesc->natts;\n\n\t/* Build a temporary HeapTuple control structure */\n\ttuple.t_len = HeapTupleHeaderGetDatumLength(rec);\n\tItemPointerSetInvalid(&(tuple.t_self));\n\ttuple.t_tableOid = InvalidOid;\n\ttuple.t_data = rec;\n\n\t/*\n\t * We arrange to look up the needed I/O info just once per series of\n\t * calls, assuming the record type doesn't change underneath us.\n\t */\n\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns != ncolumns)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t\t\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->record_type = InvalidOid;\n\t\tmy_extra->record_typmod = 0;\n\t}\n\n\tif (my_extra->record_type != tupType ||\n\t\tmy_extra->record_typmod != tupTypmod)\n\t{\n\t\tMemSet(my_extra, 0,\n\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\tmy_extra->record_type = tupType;\n\t\tmy_extra->record_typmod = tupTypmod;\n\t\tmy_extra->ncolumns = ncolumns;\n\t}\n\n\tvalues = (Datum *) palloc(ncolumns * sizeof(Datum));\n\tnulls = (bool *) palloc(ncolumns * sizeof(bool));\n\n\t/* Break down the tuple into fields */\n\theap_deform_tuple(&tuple, tupdesc, values, nulls);\n\n\t/* And build the result string */\n\tinitStringInfo(&buf);\n\n\tappendStringInfoChar(&buf, '(');\n\n\tfor (i = 0; i < ncolumns; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\t\tColumnIOData *column_info = &my_extra->columns[i];\n\t\tOid\t\t\tcolumn_type = att->atttypid;\n\t\tDatum\t\tattr;\n\t\tchar\t   *value;\n\t\tchar\t   *tmp;\n\t\tbool\t\tnq;\n\n\t\t/* Ignore dropped columns in datatype */\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\n\t\tif (needComma)\n\t\t\tappendStringInfoChar(&buf, ',');\n\t\tneedComma = true;\n\n\t\tif (nulls[i])\n\t\t{\n\t\t\t/* emit nothing... */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Convert the column value to text\n\t\t */\n\t\tif (column_info->column_type != column_type)\n\t\t{\n\t\t\tgetTypeOutputInfo(column_type,\n\t\t\t\t\t\t\t  &column_info->typiofunc,\n\t\t\t\t\t\t\t  &column_info->typisvarlena);\n\t\t\tfmgr_info_cxt(column_info->typiofunc, &column_info->proc,\n\t\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\t\tcolumn_info->column_type = column_type;\n\t\t}\n\n\t\tattr = values[i];\n\t\tvalue = OutputFunctionCall(&column_info->proc, attr);\n\n\t\t/* Detect whether we need double quotes for this value */\n\t\tnq = (value[0] == '\\0');\t/* force quotes for empty string */\n\t\tfor (tmp = value; *tmp; tmp++)\n\t\t{\n\t\t\tchar\t\tch = *tmp;\n\n\t\t\tif (ch == '\"' || ch == '\\\\' ||\n\t\t\t\tch == '(' || ch == ')' || ch == ',' ||\n\t\t\t\tisspace((unsigned char) ch))\n\t\t\t{\n\t\t\t\tnq = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* And emit the string */\n\t\tif (nq)\n\t\t\tappendStringInfoCharMacro(&buf, '\"');\n\t\tfor (tmp = value; *tmp; tmp++)\n\t\t{\n\t\t\tchar\t\tch = *tmp;\n\n\t\t\tif (ch == '\"' || ch == '\\\\')\n\t\t\t\tappendStringInfoCharMacro(&buf, ch);\n\t\t\tappendStringInfoCharMacro(&buf, ch);\n\t\t}\n\t\tif (nq)\n\t\t\tappendStringInfoCharMacro(&buf, '\"');\n\t}\n\n\tappendStringInfoChar(&buf, ')');\n\n\tpfree(values);\n\tpfree(nulls);\n\tReleaseTupleDesc(tupdesc);\n\n\tPG_RETURN_CSTRING(buf.data);\n}"
  },
  {
    "function_name": "record_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rowtypes.c",
    "lines": "72-295",
    "snippet": "Datum\nrecord_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *string = PG_GETARG_CSTRING(0);\n\tOid\t\t\ttupType = PG_GETARG_OID(1);\n\tint32\t\ttupTypmod = PG_GETARG_INT32(2);\n\tHeapTupleHeader result;\n\tTupleDesc\ttupdesc;\n\tHeapTuple\ttuple;\n\tRecordIOData *my_extra;\n\tbool\t\tneedComma = false;\n\tint\t\t\tncolumns;\n\tint\t\t\ti;\n\tchar\t   *ptr;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tStringInfoData buf;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/*\n\t * Give a friendly error message if we did not get enough info to identify\n\t * the target record type.  (lookup_rowtype_tupdesc would fail anyway, but\n\t * with a non-user-friendly message.)  In ordinary SQL usage, we'll get -1\n\t * for typmod, since composite types and RECORD have no type modifiers at\n\t * the SQL level, and thus must fail for RECORD.  However some callers can\n\t * supply a valid typmod, and then we can do something useful for RECORD.\n\t */\n\tif (tupType == RECORDOID && tupTypmod < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"input of anonymous composite types is not implemented\")));\n\n\t/*\n\t * This comes from the composite type's pg_type.oid and stores system oids\n\t * in user tables, specifically DatumTupleFields. This oid must be\n\t * preserved by binary upgrades.\n\t */\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\tncolumns = tupdesc->natts;\n\n\t/*\n\t * We arrange to look up the needed I/O info just once per series of\n\t * calls, assuming the record type doesn't change underneath us.\n\t */\n\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns != ncolumns)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t\t\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->record_type = InvalidOid;\n\t\tmy_extra->record_typmod = 0;\n\t}\n\n\tif (my_extra->record_type != tupType ||\n\t\tmy_extra->record_typmod != tupTypmod)\n\t{\n\t\tMemSet(my_extra, 0,\n\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\tmy_extra->record_type = tupType;\n\t\tmy_extra->record_typmod = tupTypmod;\n\t\tmy_extra->ncolumns = ncolumns;\n\t}\n\n\tvalues = (Datum *) palloc(ncolumns * sizeof(Datum));\n\tnulls = (bool *) palloc(ncolumns * sizeof(bool));\n\n\t/*\n\t * Scan the string.  We use \"buf\" to accumulate the de-quoted data for\n\t * each column, which is then fed to the appropriate input converter.\n\t */\n\tptr = string;\n\t/* Allow leading whitespace */\n\twhile (*ptr && isspace((unsigned char) *ptr))\n\t\tptr++;\n\tif (*ptr++ != '(')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\", string),\n\t\t\t\t errdetail(\"Missing left parenthesis.\")));\n\n\tinitStringInfo(&buf);\n\n\tfor (i = 0; i < ncolumns; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\t\tColumnIOData *column_info = &my_extra->columns[i];\n\t\tOid\t\t\tcolumn_type = att->atttypid;\n\t\tchar\t   *column_data;\n\n\t\t/* Ignore dropped columns in datatype, but fill with nulls */\n\t\tif (att->attisdropped)\n\t\t{\n\t\t\tvalues[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (needComma)\n\t\t{\n\t\t\t/* Skip comma that separates prior field from this one */\n\t\t\tif (*ptr == ',')\n\t\t\t\tptr++;\n\t\t\telse\n\t\t\t\t/* *ptr must be ')' */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\", string),\n\t\t\t\t\t\t errdetail(\"Too few columns.\")));\n\t\t}\n\n\t\t/* Check for null: completely empty input means null */\n\t\tif (*ptr == ',' || *ptr == ')')\n\t\t{\n\t\t\tcolumn_data = NULL;\n\t\t\tnulls[i] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Extract string for this column */\n\t\t\tbool\t\tinquote = false;\n\n\t\t\tresetStringInfo(&buf);\n\t\t\twhile (inquote || !(*ptr == ',' || *ptr == ')'))\n\t\t\t{\n\t\t\t\tchar\t\tch = *ptr++;\n\n\t\t\t\tif (ch == '\\0')\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\tif (ch == '\\\\')\n\t\t\t\t{\n\t\t\t\t\tif (*ptr == '\\0')\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\t\tappendStringInfoChar(&buf, *ptr++);\n\t\t\t\t}\n\t\t\t\telse if (ch == '\"')\n\t\t\t\t{\n\t\t\t\t\tif (!inquote)\n\t\t\t\t\t\tinquote = true;\n\t\t\t\t\telse if (*ptr == '\"')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* doubled quote within quote sequence */\n\t\t\t\t\t\tappendStringInfoChar(&buf, *ptr++);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tinquote = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoChar(&buf, ch);\n\t\t\t}\n\n\t\t\tcolumn_data = buf.data;\n\t\t\tnulls[i] = false;\n\t\t}\n\n\t\t/*\n\t\t * Convert the column value\n\t\t */\n\t\tif (column_info->column_type != column_type)\n\t\t{\n\t\t\tgetTypeInputInfo(column_type,\n\t\t\t\t\t\t\t &column_info->typiofunc,\n\t\t\t\t\t\t\t &column_info->typioparam);\n\t\t\tfmgr_info_cxt(column_info->typiofunc, &column_info->proc,\n\t\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\t\tcolumn_info->column_type = column_type;\n\t\t}\n\n\t\tvalues[i] = InputFunctionCall(&column_info->proc,\n\t\t\t\t\t\t\t\t\t  column_data,\n\t\t\t\t\t\t\t\t\t  column_info->typioparam,\n\t\t\t\t\t\t\t\t\t  att->atttypmod);\n\n\t\t/*\n\t\t * Prep for next column\n\t\t */\n\t\tneedComma = true;\n\t}\n\n\tif (*ptr++ != ')')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\", string),\n\t\t\t\t errdetail(\"Too many columns.\")));\n\t/* Allow trailing whitespace */\n\twhile (*ptr && isspace((unsigned char) *ptr))\n\t\tptr++;\n\tif (*ptr)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\", string),\n\t\t\t\t errdetail(\"Junk after right parenthesis.\")));\n\n\ttuple = heap_form_tuple(tupdesc, values, nulls);\n\n\t/*\n\t * We cannot return tuple->t_data because heap_form_tuple allocates it as\n\t * part of a larger chunk, and our caller may expect to be able to pfree\n\t * our result.  So must copy the info into a new palloc chunk.\n\t */\n\tresult = (HeapTupleHeader) palloc(tuple->t_len);\n\tmemcpy(result, tuple->t_data, tuple->t_len);\n\n\theap_freetuple(tuple);\n\tpfree(buf.data);\n\tpfree(values);\n\tpfree(nulls);\n\tReleaseTupleDesc(tupdesc);\n\n\tPG_RETURN_HEAPTUPLEHEADER(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_HEAPTUPLEHEADER",
          "args": [
            "result"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseTupleDesc",
          "args": [
            "tupdesc"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "nulls"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_freetuple",
          "args": [
            "tuple"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result",
            "tuple->t_data",
            "tuple->t_len"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "tuple->t_len"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_form_tuple",
          "args": [
            "tupdesc",
            "values",
            "nulls"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\", string),\n\t\t\t\t errdetail(\"Junk after right parenthesis.\"))"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Junk after right parenthesis.\""
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"malformed record literal: \\\"%s\\\"\"",
            "string"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *ptr"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\", string),\n\t\t\t\t errdetail(\"Too many columns.\"))"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InputFunctionCall",
          "args": [
            "&column_info->proc",
            "column_data",
            "column_info->typioparam",
            "att->atttypmod"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "OidInputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1823-1830",
          "snippet": "Datum\nOidInputFunctionCall(Oid functionId, char *str, Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn InputFunctionCall(&flinfo, str, typioparam, typmod);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidInputFunctionCall(Oid functionId, char *str, Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn InputFunctionCall(&flinfo, str, typioparam, typmod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "column_info->typiofunc",
            "&column_info->proc",
            "fcinfo->flinfo->fn_mcxt"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTypeInputInfo",
          "args": [
            "column_type",
            "&column_info->typiofunc",
            "&column_info->typioparam"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "getTypeInputInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2640-2666",
          "snippet": "void\ngetTypeInputInfo(Oid type, Oid *typInput, Oid *typIOParam)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typinput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no input function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typInput = pt->typinput;\n\t*typIOParam = getTypeIOParam(typeTuple);\n\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\ngetTypeInputInfo(Oid type, Oid *typInput, Oid *typIOParam)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typinput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no input function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typInput = pt->typinput;\n\t*typIOParam = getTypeIOParam(typeTuple);\n\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "ch"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "*ptr++"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "*ptr++"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\"))"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\"))"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resetStringInfo",
          "args": [
            "&buf"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\", string),\n\t\t\t\t\t\t errdetail(\"Too few columns.\"))"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\", string),\n\t\t\t\t errdetail(\"Missing left parenthesis.\"))"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "my_extra",
            "0",
            "offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "offsetof(RecordIOData, columns) +\n\t\t\t\t\t\t\t   ncolumns * sizeof(ColumnIOData)"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc",
          "args": [
            "tupType",
            "tupTypmod"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1674-1681",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"input of anonymous composite types is not implemented\"))"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nrecord_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *string = PG_GETARG_CSTRING(0);\n\tOid\t\t\ttupType = PG_GETARG_OID(1);\n\tint32\t\ttupTypmod = PG_GETARG_INT32(2);\n\tHeapTupleHeader result;\n\tTupleDesc\ttupdesc;\n\tHeapTuple\ttuple;\n\tRecordIOData *my_extra;\n\tbool\t\tneedComma = false;\n\tint\t\t\tncolumns;\n\tint\t\t\ti;\n\tchar\t   *ptr;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tStringInfoData buf;\n\n\tcheck_stack_depth();\t\t/* recurses for record-type columns */\n\n\t/*\n\t * Give a friendly error message if we did not get enough info to identify\n\t * the target record type.  (lookup_rowtype_tupdesc would fail anyway, but\n\t * with a non-user-friendly message.)  In ordinary SQL usage, we'll get -1\n\t * for typmod, since composite types and RECORD have no type modifiers at\n\t * the SQL level, and thus must fail for RECORD.  However some callers can\n\t * supply a valid typmod, and then we can do something useful for RECORD.\n\t */\n\tif (tupType == RECORDOID && tupTypmod < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"input of anonymous composite types is not implemented\")));\n\n\t/*\n\t * This comes from the composite type's pg_type.oid and stores system oids\n\t * in user tables, specifically DatumTupleFields. This oid must be\n\t * preserved by binary upgrades.\n\t */\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\tncolumns = tupdesc->natts;\n\n\t/*\n\t * We arrange to look up the needed I/O info just once per series of\n\t * calls, assuming the record type doesn't change underneath us.\n\t */\n\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL ||\n\t\tmy_extra->ncolumns != ncolumns)\n\t{\n\t\tfcinfo->flinfo->fn_extra =\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t\t\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->record_type = InvalidOid;\n\t\tmy_extra->record_typmod = 0;\n\t}\n\n\tif (my_extra->record_type != tupType ||\n\t\tmy_extra->record_typmod != tupTypmod)\n\t{\n\t\tMemSet(my_extra, 0,\n\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\tmy_extra->record_type = tupType;\n\t\tmy_extra->record_typmod = tupTypmod;\n\t\tmy_extra->ncolumns = ncolumns;\n\t}\n\n\tvalues = (Datum *) palloc(ncolumns * sizeof(Datum));\n\tnulls = (bool *) palloc(ncolumns * sizeof(bool));\n\n\t/*\n\t * Scan the string.  We use \"buf\" to accumulate the de-quoted data for\n\t * each column, which is then fed to the appropriate input converter.\n\t */\n\tptr = string;\n\t/* Allow leading whitespace */\n\twhile (*ptr && isspace((unsigned char) *ptr))\n\t\tptr++;\n\tif (*ptr++ != '(')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\", string),\n\t\t\t\t errdetail(\"Missing left parenthesis.\")));\n\n\tinitStringInfo(&buf);\n\n\tfor (i = 0; i < ncolumns; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\t\tColumnIOData *column_info = &my_extra->columns[i];\n\t\tOid\t\t\tcolumn_type = att->atttypid;\n\t\tchar\t   *column_data;\n\n\t\t/* Ignore dropped columns in datatype, but fill with nulls */\n\t\tif (att->attisdropped)\n\t\t{\n\t\t\tvalues[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (needComma)\n\t\t{\n\t\t\t/* Skip comma that separates prior field from this one */\n\t\t\tif (*ptr == ',')\n\t\t\t\tptr++;\n\t\t\telse\n\t\t\t\t/* *ptr must be ')' */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\", string),\n\t\t\t\t\t\t errdetail(\"Too few columns.\")));\n\t\t}\n\n\t\t/* Check for null: completely empty input means null */\n\t\tif (*ptr == ',' || *ptr == ')')\n\t\t{\n\t\t\tcolumn_data = NULL;\n\t\t\tnulls[i] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Extract string for this column */\n\t\t\tbool\t\tinquote = false;\n\n\t\t\tresetStringInfo(&buf);\n\t\t\twhile (inquote || !(*ptr == ',' || *ptr == ')'))\n\t\t\t{\n\t\t\t\tchar\t\tch = *ptr++;\n\n\t\t\t\tif (ch == '\\0')\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\tif (ch == '\\\\')\n\t\t\t\t{\n\t\t\t\t\tif (*ptr == '\\0')\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\t\tappendStringInfoChar(&buf, *ptr++);\n\t\t\t\t}\n\t\t\t\telse if (ch == '\"')\n\t\t\t\t{\n\t\t\t\t\tif (!inquote)\n\t\t\t\t\t\tinquote = true;\n\t\t\t\t\telse if (*ptr == '\"')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* doubled quote within quote sequence */\n\t\t\t\t\t\tappendStringInfoChar(&buf, *ptr++);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tinquote = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoChar(&buf, ch);\n\t\t\t}\n\n\t\t\tcolumn_data = buf.data;\n\t\t\tnulls[i] = false;\n\t\t}\n\n\t\t/*\n\t\t * Convert the column value\n\t\t */\n\t\tif (column_info->column_type != column_type)\n\t\t{\n\t\t\tgetTypeInputInfo(column_type,\n\t\t\t\t\t\t\t &column_info->typiofunc,\n\t\t\t\t\t\t\t &column_info->typioparam);\n\t\t\tfmgr_info_cxt(column_info->typiofunc, &column_info->proc,\n\t\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\t\tcolumn_info->column_type = column_type;\n\t\t}\n\n\t\tvalues[i] = InputFunctionCall(&column_info->proc,\n\t\t\t\t\t\t\t\t\t  column_data,\n\t\t\t\t\t\t\t\t\t  column_info->typioparam,\n\t\t\t\t\t\t\t\t\t  att->atttypmod);\n\n\t\t/*\n\t\t * Prep for next column\n\t\t */\n\t\tneedComma = true;\n\t}\n\n\tif (*ptr++ != ')')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\", string),\n\t\t\t\t errdetail(\"Too many columns.\")));\n\t/* Allow trailing whitespace */\n\twhile (*ptr && isspace((unsigned char) *ptr))\n\t\tptr++;\n\tif (*ptr)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed record literal: \\\"%s\\\"\", string),\n\t\t\t\t errdetail(\"Junk after right parenthesis.\")));\n\n\ttuple = heap_form_tuple(tupdesc, values, nulls);\n\n\t/*\n\t * We cannot return tuple->t_data because heap_form_tuple allocates it as\n\t * part of a larger chunk, and our caller may expect to be able to pfree\n\t * our result.  So must copy the info into a new palloc chunk.\n\t */\n\tresult = (HeapTupleHeader) palloc(tuple->t_len);\n\tmemcpy(result, tuple->t_data, tuple->t_len);\n\n\theap_freetuple(tuple);\n\tpfree(buf.data);\n\tpfree(values);\n\tpfree(nulls);\n\tReleaseTupleDesc(tupdesc);\n\n\tPG_RETURN_HEAPTUPLEHEADER(result);\n}"
  }
]