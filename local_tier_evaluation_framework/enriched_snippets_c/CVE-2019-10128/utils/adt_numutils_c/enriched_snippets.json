[
  {
    "function_name": "pg_strtouint64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
    "lines": "404-414",
    "snippet": "uint64\npg_strtouint64(const char *str, char **endptr, int base)\n{\n#ifdef _MSC_VER\t\t\t\t\t/* MSVC only */\n\treturn _strtoui64(str, endptr, base);\n#elif defined(HAVE_STRTOULL) && SIZEOF_LONG < 8\n\treturn strtoull(str, endptr, base);\n#else\n\treturn strtoul(str, endptr, base);\n#endif\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "str",
            "endptr",
            "base"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "str",
            "endptr",
            "base"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_strtoui64",
          "args": [
            "str",
            "endptr",
            "base"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nuint64\npg_strtouint64(const char *str, char **endptr, int base)\n{\n#ifdef _MSC_VER\t\t\t\t\t/* MSVC only */\n\treturn _strtoui64(str, endptr, base);\n#elif defined(HAVE_STRTOULL) && SIZEOF_LONG < 8\n\treturn strtoull(str, endptr, base);\n#else\n\treturn strtoul(str, endptr, base);\n#endif\n}"
  },
  {
    "function_name": "pg_ltostr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
    "lines": "333-392",
    "snippet": "char *\npg_ltostr(char *str, int32 value)\n{\n\tchar\t   *start;\n\tchar\t   *end;\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (value < 0)\n\t{\n\t\t*str++ = '-';\n\n\t\t/* Mark the position we must reverse the string from. */\n\t\tstart = str;\n\n\t\t/* Compute the result string backwards. */\n\t\tdo\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\t\t\t/* As above, we expect remainder to be negative. */\n\t\t\t*str++ = '0' - remainder;\n\t\t} while (value != 0);\n\t}\n\telse\n\t{\n\t\t/* Mark the position we must reverse the string from. */\n\t\tstart = str;\n\n\t\t/* Compute the result string backwards. */\n\t\tdo\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\t\t\t*str++ = '0' + remainder;\n\t\t} while (value != 0);\n\t}\n\n\t/* Remember the end+1 and back up 'str' to the last character. */\n\tend = str--;\n\n\t/* Reverse string. */\n\twhile (start < str)\n\t{\n\t\tchar\t\tswap = *start;\n\n\t\t*start++ = *str;\n\t\t*str-- = swap;\n\t}\n\n\treturn end;\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nchar *\npg_ltostr(char *str, int32 value)\n{\n\tchar\t   *start;\n\tchar\t   *end;\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (value < 0)\n\t{\n\t\t*str++ = '-';\n\n\t\t/* Mark the position we must reverse the string from. */\n\t\tstart = str;\n\n\t\t/* Compute the result string backwards. */\n\t\tdo\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\t\t\t/* As above, we expect remainder to be negative. */\n\t\t\t*str++ = '0' - remainder;\n\t\t} while (value != 0);\n\t}\n\telse\n\t{\n\t\t/* Mark the position we must reverse the string from. */\n\t\tstart = str;\n\n\t\t/* Compute the result string backwards. */\n\t\tdo\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\t\t\t*str++ = '0' + remainder;\n\t\t} while (value != 0);\n\t}\n\n\t/* Remember the end+1 and back up 'str' to the last character. */\n\tend = str--;\n\n\t/* Reverse string. */\n\twhile (start < str)\n\t{\n\t\tchar\t\tswap = *start;\n\n\t\t*start++ = *str;\n\t\t*str-- = swap;\n\t}\n\n\treturn end;\n}"
  },
  {
    "function_name": "pg_ltostr_zeropad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
    "lines": "256-313",
    "snippet": "char *\npg_ltostr_zeropad(char *str, int32 value, int32 minwidth)\n{\n\tchar\t   *start = str;\n\tchar\t   *end = &str[minwidth];\n\tint32\t\tnum = value;\n\n\tAssert(minwidth > 0);\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (num < 0)\n\t{\n\t\t*start++ = '-';\n\t\tminwidth--;\n\n\t\t/*\n\t\t * Build the number starting at the last digit.  Here remainder will\n\t\t * be a negative number, so we must reverse the sign before adding '0'\n\t\t * in order to get the correct ASCII digit.\n\t\t */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' - remainder;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Build the number starting at the last digit */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' + remainder;\n\t\t}\n\t}\n\n\t/*\n\t * If minwidth was not high enough to fit the number then num won't have\n\t * been divided down to zero.  We punt the problem to pg_ltostr(), which\n\t * will generate a correct answer in the minimum valid width.\n\t */\n\tif (num != 0)\n\t\treturn pg_ltostr(str, value);\n\n\t/* Otherwise, return last output character + 1 */\n\treturn end;\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_ltostr",
          "args": [
            "str",
            "value"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "pg_ltostr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
          "lines": "333-392",
          "snippet": "char *\npg_ltostr(char *str, int32 value)\n{\n\tchar\t   *start;\n\tchar\t   *end;\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (value < 0)\n\t{\n\t\t*str++ = '-';\n\n\t\t/* Mark the position we must reverse the string from. */\n\t\tstart = str;\n\n\t\t/* Compute the result string backwards. */\n\t\tdo\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\t\t\t/* As above, we expect remainder to be negative. */\n\t\t\t*str++ = '0' - remainder;\n\t\t} while (value != 0);\n\t}\n\telse\n\t{\n\t\t/* Mark the position we must reverse the string from. */\n\t\tstart = str;\n\n\t\t/* Compute the result string backwards. */\n\t\tdo\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\t\t\t*str++ = '0' + remainder;\n\t\t} while (value != 0);\n\t}\n\n\t/* Remember the end+1 and back up 'str' to the last character. */\n\tend = str--;\n\n\t/* Reverse string. */\n\twhile (start < str)\n\t{\n\t\tchar\t\tswap = *start;\n\n\t\t*start++ = *str;\n\t\t*str-- = swap;\n\t}\n\n\treturn end;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include <ctype.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nchar *\npg_ltostr(char *str, int32 value)\n{\n\tchar\t   *start;\n\tchar\t   *end;\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (value < 0)\n\t{\n\t\t*str++ = '-';\n\n\t\t/* Mark the position we must reverse the string from. */\n\t\tstart = str;\n\n\t\t/* Compute the result string backwards. */\n\t\tdo\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\t\t\t/* As above, we expect remainder to be negative. */\n\t\t\t*str++ = '0' - remainder;\n\t\t} while (value != 0);\n\t}\n\telse\n\t{\n\t\t/* Mark the position we must reverse the string from. */\n\t\tstart = str;\n\n\t\t/* Compute the result string backwards. */\n\t\tdo\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\t\t\t*str++ = '0' + remainder;\n\t\t} while (value != 0);\n\t}\n\n\t/* Remember the end+1 and back up 'str' to the last character. */\n\tend = str--;\n\n\t/* Reverse string. */\n\twhile (start < str)\n\t{\n\t\tchar\t\tswap = *start;\n\n\t\t*start++ = *str;\n\t\t*str-- = swap;\n\t}\n\n\treturn end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "minwidth > 0"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nchar *\npg_ltostr_zeropad(char *str, int32 value, int32 minwidth)\n{\n\tchar\t   *start = str;\n\tchar\t   *end = &str[minwidth];\n\tint32\t\tnum = value;\n\n\tAssert(minwidth > 0);\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (num < 0)\n\t{\n\t\t*start++ = '-';\n\t\tminwidth--;\n\n\t\t/*\n\t\t * Build the number starting at the last digit.  Here remainder will\n\t\t * be a negative number, so we must reverse the sign before adding '0'\n\t\t * in order to get the correct ASCII digit.\n\t\t */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' - remainder;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Build the number starting at the last digit */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' + remainder;\n\t\t}\n\t}\n\n\t/*\n\t * If minwidth was not high enough to fit the number then num won't have\n\t * been divided down to zero.  We punt the problem to pg_ltostr(), which\n\t * will generate a correct answer in the minimum valid width.\n\t */\n\tif (num != 0)\n\t\treturn pg_ltostr(str, value);\n\n\t/* Otherwise, return last output character + 1 */\n\treturn end;\n}"
  },
  {
    "function_name": "pg_lltoa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
    "lines": "185-231",
    "snippet": "void\npg_lltoa(int64 value, char *a)\n{\n\tchar\t   *start = a;\n\tbool\t\tneg = false;\n\n\t/*\n\t * Avoid problems with the most negative integer not being representable\n\t * as a positive integer.\n\t */\n\tif (value == PG_INT64_MIN)\n\t{\n\t\tmemcpy(a, \"-9223372036854775808\", 21);\n\t\treturn;\n\t}\n\telse if (value < 0)\n\t{\n\t\tvalue = -value;\n\t\tneg = true;\n\t}\n\n\t/* Compute the result string backwards. */\n\tdo\n\t{\n\t\tint64\t\tremainder;\n\t\tint64\t\toldval = value;\n\n\t\tvalue /= 10;\n\t\tremainder = oldval - value * 10;\n\t\t*a++ = '0' + remainder;\n\t} while (value != 0);\n\n\tif (neg)\n\t\t*a++ = '-';\n\n\t/* Add trailing NUL byte, and back up 'a' to the last character. */\n\t*a-- = '\\0';\n\n\t/* Reverse string. */\n\twhile (start < a)\n\t{\n\t\tchar\t\tswap = *start;\n\n\t\t*start++ = *a;\n\t\t*a-- = swap;\n\t}\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "a",
            "\"-9223372036854775808\"",
            "21"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nvoid\npg_lltoa(int64 value, char *a)\n{\n\tchar\t   *start = a;\n\tbool\t\tneg = false;\n\n\t/*\n\t * Avoid problems with the most negative integer not being representable\n\t * as a positive integer.\n\t */\n\tif (value == PG_INT64_MIN)\n\t{\n\t\tmemcpy(a, \"-9223372036854775808\", 21);\n\t\treturn;\n\t}\n\telse if (value < 0)\n\t{\n\t\tvalue = -value;\n\t\tneg = true;\n\t}\n\n\t/* Compute the result string backwards. */\n\tdo\n\t{\n\t\tint64\t\tremainder;\n\t\tint64\t\toldval = value;\n\n\t\tvalue /= 10;\n\t\tremainder = oldval - value * 10;\n\t\t*a++ = '0' + remainder;\n\t} while (value != 0);\n\n\tif (neg)\n\t\t*a++ = '-';\n\n\t/* Add trailing NUL byte, and back up 'a' to the last character. */\n\t*a-- = '\\0';\n\n\t/* Reverse string. */\n\twhile (start < a)\n\t{\n\t\tchar\t\tswap = *start;\n\n\t\t*start++ = *a;\n\t\t*a-- = swap;\n\t}\n}"
  },
  {
    "function_name": "pg_ltoa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
    "lines": "131-177",
    "snippet": "void\npg_ltoa(int32 value, char *a)\n{\n\tchar\t   *start = a;\n\tbool\t\tneg = false;\n\n\t/*\n\t * Avoid problems with the most negative integer not being representable\n\t * as a positive integer.\n\t */\n\tif (value == PG_INT32_MIN)\n\t{\n\t\tmemcpy(a, \"-2147483648\", 12);\n\t\treturn;\n\t}\n\telse if (value < 0)\n\t{\n\t\tvalue = -value;\n\t\tneg = true;\n\t}\n\n\t/* Compute the result string backwards. */\n\tdo\n\t{\n\t\tint32\t\tremainder;\n\t\tint32\t\toldval = value;\n\n\t\tvalue /= 10;\n\t\tremainder = oldval - value * 10;\n\t\t*a++ = '0' + remainder;\n\t} while (value != 0);\n\n\tif (neg)\n\t\t*a++ = '-';\n\n\t/* Add trailing NUL byte, and back up 'a' to the last character. */\n\t*a-- = '\\0';\n\n\t/* Reverse string. */\n\twhile (start < a)\n\t{\n\t\tchar\t\tswap = *start;\n\n\t\t*start++ = *a;\n\t\t*a-- = swap;\n\t}\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "a",
            "\"-2147483648\"",
            "12"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nvoid\npg_ltoa(int32 value, char *a)\n{\n\tchar\t   *start = a;\n\tbool\t\tneg = false;\n\n\t/*\n\t * Avoid problems with the most negative integer not being representable\n\t * as a positive integer.\n\t */\n\tif (value == PG_INT32_MIN)\n\t{\n\t\tmemcpy(a, \"-2147483648\", 12);\n\t\treturn;\n\t}\n\telse if (value < 0)\n\t{\n\t\tvalue = -value;\n\t\tneg = true;\n\t}\n\n\t/* Compute the result string backwards. */\n\tdo\n\t{\n\t\tint32\t\tremainder;\n\t\tint32\t\toldval = value;\n\n\t\tvalue /= 10;\n\t\tremainder = oldval - value * 10;\n\t\t*a++ = '0' + remainder;\n\t} while (value != 0);\n\n\tif (neg)\n\t\t*a++ = '-';\n\n\t/* Add trailing NUL byte, and back up 'a' to the last character. */\n\t*a-- = '\\0';\n\n\t/* Reverse string. */\n\twhile (start < a)\n\t{\n\t\tchar\t\tswap = *start;\n\n\t\t*start++ = *a;\n\t\t*a-- = swap;\n\t}\n}"
  },
  {
    "function_name": "pg_itoa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
    "lines": "119-123",
    "snippet": "void\npg_itoa(int16 i, char *a)\n{\n\tpg_ltoa((int32) i, a);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_ltoa",
          "args": [
            "(int32) i",
            "a"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "pg_ltoa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
          "lines": "131-177",
          "snippet": "void\npg_ltoa(int32 value, char *a)\n{\n\tchar\t   *start = a;\n\tbool\t\tneg = false;\n\n\t/*\n\t * Avoid problems with the most negative integer not being representable\n\t * as a positive integer.\n\t */\n\tif (value == PG_INT32_MIN)\n\t{\n\t\tmemcpy(a, \"-2147483648\", 12);\n\t\treturn;\n\t}\n\telse if (value < 0)\n\t{\n\t\tvalue = -value;\n\t\tneg = true;\n\t}\n\n\t/* Compute the result string backwards. */\n\tdo\n\t{\n\t\tint32\t\tremainder;\n\t\tint32\t\toldval = value;\n\n\t\tvalue /= 10;\n\t\tremainder = oldval - value * 10;\n\t\t*a++ = '0' + remainder;\n\t} while (value != 0);\n\n\tif (neg)\n\t\t*a++ = '-';\n\n\t/* Add trailing NUL byte, and back up 'a' to the last character. */\n\t*a-- = '\\0';\n\n\t/* Reverse string. */\n\twhile (start < a)\n\t{\n\t\tchar\t\tswap = *start;\n\n\t\t*start++ = *a;\n\t\t*a-- = swap;\n\t}\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include <ctype.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nvoid\npg_ltoa(int32 value, char *a)\n{\n\tchar\t   *start = a;\n\tbool\t\tneg = false;\n\n\t/*\n\t * Avoid problems with the most negative integer not being representable\n\t * as a positive integer.\n\t */\n\tif (value == PG_INT32_MIN)\n\t{\n\t\tmemcpy(a, \"-2147483648\", 12);\n\t\treturn;\n\t}\n\telse if (value < 0)\n\t{\n\t\tvalue = -value;\n\t\tneg = true;\n\t}\n\n\t/* Compute the result string backwards. */\n\tdo\n\t{\n\t\tint32\t\tremainder;\n\t\tint32\t\toldval = value;\n\n\t\tvalue /= 10;\n\t\tremainder = oldval - value * 10;\n\t\t*a++ = '0' + remainder;\n\t} while (value != 0);\n\n\tif (neg)\n\t\t*a++ = '-';\n\n\t/* Add trailing NUL byte, and back up 'a' to the last character. */\n\t*a-- = '\\0';\n\n\t/* Reverse string. */\n\twhile (start < a)\n\t{\n\t\tchar\t\tswap = *start;\n\n\t\t*start++ = *a;\n\t\t*a-- = swap;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nvoid\npg_itoa(int16 i, char *a)\n{\n\tpg_ltoa((int32) i, a);\n}"
  },
  {
    "function_name": "pg_atoi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
    "lines": "36-109",
    "snippet": "int32\npg_atoi(const char *s, int size, int c)\n{\n\tlong\t\tl;\n\tchar\t   *badp;\n\n\t/*\n\t * Some versions of strtol treat the empty string as an error, but some\n\t * seem not to.  Make an explicit test to be sure we catch it.\n\t */\n\tif (s == NULL)\n\t\telog(ERROR, \"NULL pointer\");\n\tif (*s == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\terrno = 0;\n\tl = strtol(s, &badp, 10);\n\n\t/* We made no progress parsing the string, so bail out */\n\tif (s == badp)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\tswitch (size)\n\t{\n\t\tcase sizeof(int32):\n\t\t\tif (errno == ERANGE\n#if defined(HAVE_LONG_INT_64)\n\t\t\t/* won't get ERANGE on these with 64-bit longs... */\n\t\t\t\t|| l < INT_MIN || l > INT_MAX\n#endif\n\t\t\t\t)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\", s,\n\t\t\t\t\t\t\t\t\"integer\")));\n\t\t\tbreak;\n\t\tcase sizeof(int16):\n\t\t\tif (errno == ERANGE || l < SHRT_MIN || l > SHRT_MAX)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\", s,\n\t\t\t\t\t\t\t\t\"smallint\")));\n\t\t\tbreak;\n\t\tcase sizeof(int8):\n\t\t\tif (errno == ERANGE || l < SCHAR_MIN || l > SCHAR_MAX)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for 8-bit integer\", s)));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported result size: %d\", size);\n\t}\n\n\t/*\n\t * Skip any trailing whitespace; if anything but whitespace remains before\n\t * the terminating character, bail out\n\t */\n\twhile (*badp && *badp != c && isspace((unsigned char) *badp))\n\t\tbadp++;\n\n\tif (*badp && *badp != c)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\treturn (int32) l;\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts))"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input syntax for integer: \\\"%s\\\"\"",
            "s"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *badp"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unsupported result size: %d\"",
            "size"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for 8-bit integer\", s))"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\", s,\n\t\t\t\t\t\t\t\t\"smallint\"))"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\", s,\n\t\t\t\t\t\t\t\t\"integer\"))"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts))"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "s",
            "&badp",
            "10"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts))"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nint32\npg_atoi(const char *s, int size, int c)\n{\n\tlong\t\tl;\n\tchar\t   *badp;\n\n\t/*\n\t * Some versions of strtol treat the empty string as an error, but some\n\t * seem not to.  Make an explicit test to be sure we catch it.\n\t */\n\tif (s == NULL)\n\t\telog(ERROR, \"NULL pointer\");\n\tif (*s == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\terrno = 0;\n\tl = strtol(s, &badp, 10);\n\n\t/* We made no progress parsing the string, so bail out */\n\tif (s == badp)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\tswitch (size)\n\t{\n\t\tcase sizeof(int32):\n\t\t\tif (errno == ERANGE\n#if defined(HAVE_LONG_INT_64)\n\t\t\t/* won't get ERANGE on these with 64-bit longs... */\n\t\t\t\t|| l < INT_MIN || l > INT_MAX\n#endif\n\t\t\t\t)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\", s,\n\t\t\t\t\t\t\t\t\"integer\")));\n\t\t\tbreak;\n\t\tcase sizeof(int16):\n\t\t\tif (errno == ERANGE || l < SHRT_MIN || l > SHRT_MAX)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\", s,\n\t\t\t\t\t\t\t\t\"smallint\")));\n\t\t\tbreak;\n\t\tcase sizeof(int8):\n\t\t\tif (errno == ERANGE || l < SCHAR_MIN || l > SCHAR_MAX)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for 8-bit integer\", s)));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported result size: %d\", size);\n\t}\n\n\t/*\n\t * Skip any trailing whitespace; if anything but whitespace remains before\n\t * the terminating character, bail out\n\t */\n\twhile (*badp && *badp != c && isspace((unsigned char) *badp))\n\t\tbadp++;\n\n\tif (*badp && *badp != c)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\treturn (int32) l;\n}"
  }
]