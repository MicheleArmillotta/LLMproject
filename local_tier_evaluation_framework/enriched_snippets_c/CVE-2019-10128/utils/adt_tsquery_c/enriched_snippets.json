[
  {
    "function_name": "tsquerytree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "1347-1384",
    "snippet": "Datum\ntsquerytree(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(0);\n\tINFIX\t\tnrm;\n\ttext\t   *res;\n\tQueryItem  *q;\n\tint\t\t\tlen;\n\n\tif (query->size == 0)\n\t{\n\t\tres = (text *) palloc(VARHDRSZ);\n\t\tSET_VARSIZE(res, VARHDRSZ);\n\t\tPG_RETURN_POINTER(res);\n\t}\n\n\tq = clean_NOT(GETQUERY(query), &len);\n\n\tif (!q)\n\t{\n\t\tres = cstring_to_text(\"T\");\n\t}\n\telse\n\t{\n\t\tnrm.curpol = q;\n\t\tnrm.buflen = 32;\n\t\tnrm.cur = nrm.buf = (char *) palloc(sizeof(char) * nrm.buflen);\n\t\t*(nrm.cur) = '\\0';\n\t\tnrm.op = GETOPERAND(query);\n\t\tinfix(&nrm, -1, false);\n\t\tres = cstring_to_text_with_len(nrm.buf, nrm.cur - nrm.buf);\n\t\tpfree(q);\n\t}\n\n\tPG_FREE_IF_COPY(query, 0);\n\n\tPG_RETURN_TEXT_P(res);\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "res"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "0"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "q"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "nrm.buf",
            "nrm.cur - nrm.buf"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "infix",
          "args": [
            "&nrm",
            "-1",
            "false"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "infix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "976-1129",
          "snippet": "static void\ninfix(INFIX *in, int parentPriority, bool rightPhraseOp)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->curpol->type == QI_VAL)\n\t{\n\t\tQueryOperand *curpol = &in->curpol->qoperand;\n\t\tchar\t   *op = in->op + curpol->distance;\n\t\tint\t\t\tclen;\n\n\t\tRESIZEBUF(in, curpol->length * (pg_database_encoding_max_length() + 1) + 2 + 6);\n\t\t*(in->cur) = '\\'';\n\t\tin->cur++;\n\t\twhile (*op)\n\t\t{\n\t\t\tif (t_iseq(op, '\\''))\n\t\t\t{\n\t\t\t\t*(in->cur) = '\\'';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\telse if (t_iseq(op, '\\\\'))\n\t\t\t{\n\t\t\t\t*(in->cur) = '\\\\';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tCOPYCHAR(in->cur, op);\n\n\t\t\tclen = pg_mblen(op);\n\t\t\top += clen;\n\t\t\tin->cur += clen;\n\t\t}\n\t\t*(in->cur) = '\\'';\n\t\tin->cur++;\n\t\tif (curpol->weight || curpol->prefix)\n\t\t{\n\t\t\t*(in->cur) = ':';\n\t\t\tin->cur++;\n\t\t\tif (curpol->prefix)\n\t\t\t{\n\t\t\t\t*(in->cur) = '*';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 3))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'A';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 2))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'B';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 1))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'C';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & 1)\n\t\t\t{\n\t\t\t\t*(in->cur) = 'D';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t}\n\t\t*(in->cur) = '\\0';\n\t\tin->curpol++;\n\t}\n\telse if (in->curpol->qoperator.oper == OP_NOT)\n\t{\n\t\tint\t\t\tpriority = QO_PRIORITY(in->curpol);\n\n\t\tif (priority < parentPriority)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \"( \");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t\tRESIZEBUF(in, 1);\n\t\t*(in->cur) = '!';\n\t\tin->cur++;\n\t\t*(in->cur) = '\\0';\n\t\tin->curpol++;\n\n\t\tinfix(in, priority, false);\n\t\tif (priority < parentPriority)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \" )\");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t}\n\telse\n\t{\n\t\tint8\t\top = in->curpol->qoperator.oper;\n\t\tint\t\t\tpriority = QO_PRIORITY(in->curpol);\n\t\tint16\t\tdistance = in->curpol->qoperator.distance;\n\t\tINFIX\t\tnrm;\n\t\tbool\t\tneedParenthesis = false;\n\n\t\tin->curpol++;\n\t\tif (priority < parentPriority ||\n\t\t/* phrase operator depends on order */\n\t\t\t(op == OP_PHRASE && rightPhraseOp))\n\t\t{\n\t\t\tneedParenthesis = true;\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \"( \");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\n\t\tnrm.curpol = in->curpol;\n\t\tnrm.op = in->op;\n\t\tnrm.buflen = 16;\n\t\tnrm.cur = nrm.buf = (char *) palloc(sizeof(char) * nrm.buflen);\n\n\t\t/* get right operand */\n\t\tinfix(&nrm, priority, (op == OP_PHRASE));\n\n\t\t/* get & print left operand */\n\t\tin->curpol = nrm.curpol;\n\t\tinfix(in, priority, false);\n\n\t\t/* print operator & right operand */\n\t\tRESIZEBUF(in, 3 + (2 + 10 /* distance */ ) + (nrm.cur - nrm.buf));\n\t\tswitch (op)\n\t\t{\n\t\t\tcase OP_OR:\n\t\t\t\tsprintf(in->cur, \" | %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tcase OP_AND:\n\t\t\t\tsprintf(in->cur, \" & %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tcase OP_PHRASE:\n\t\t\t\tif (distance != 1)\n\t\t\t\t\tsprintf(in->cur, \" <%d> %s\", distance, nrm.buf);\n\t\t\t\telse\n\t\t\t\t\tsprintf(in->cur, \" <-> %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* OP_NOT is handled in above if-branch */\n\t\t\t\telog(ERROR, \"unrecognized operator type: %d\", op);\n\t\t}\n\t\tin->cur = strchr(in->cur, '\\0');\n\t\tpfree(nrm.buf);\n\n\t\tif (needParenthesis)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \" )\");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic void\ninfix(INFIX *in, int parentPriority, bool rightPhraseOp)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->curpol->type == QI_VAL)\n\t{\n\t\tQueryOperand *curpol = &in->curpol->qoperand;\n\t\tchar\t   *op = in->op + curpol->distance;\n\t\tint\t\t\tclen;\n\n\t\tRESIZEBUF(in, curpol->length * (pg_database_encoding_max_length() + 1) + 2 + 6);\n\t\t*(in->cur) = '\\'';\n\t\tin->cur++;\n\t\twhile (*op)\n\t\t{\n\t\t\tif (t_iseq(op, '\\''))\n\t\t\t{\n\t\t\t\t*(in->cur) = '\\'';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\telse if (t_iseq(op, '\\\\'))\n\t\t\t{\n\t\t\t\t*(in->cur) = '\\\\';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tCOPYCHAR(in->cur, op);\n\n\t\t\tclen = pg_mblen(op);\n\t\t\top += clen;\n\t\t\tin->cur += clen;\n\t\t}\n\t\t*(in->cur) = '\\'';\n\t\tin->cur++;\n\t\tif (curpol->weight || curpol->prefix)\n\t\t{\n\t\t\t*(in->cur) = ':';\n\t\t\tin->cur++;\n\t\t\tif (curpol->prefix)\n\t\t\t{\n\t\t\t\t*(in->cur) = '*';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 3))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'A';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 2))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'B';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 1))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'C';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & 1)\n\t\t\t{\n\t\t\t\t*(in->cur) = 'D';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t}\n\t\t*(in->cur) = '\\0';\n\t\tin->curpol++;\n\t}\n\telse if (in->curpol->qoperator.oper == OP_NOT)\n\t{\n\t\tint\t\t\tpriority = QO_PRIORITY(in->curpol);\n\n\t\tif (priority < parentPriority)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \"( \");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t\tRESIZEBUF(in, 1);\n\t\t*(in->cur) = '!';\n\t\tin->cur++;\n\t\t*(in->cur) = '\\0';\n\t\tin->curpol++;\n\n\t\tinfix(in, priority, false);\n\t\tif (priority < parentPriority)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \" )\");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t}\n\telse\n\t{\n\t\tint8\t\top = in->curpol->qoperator.oper;\n\t\tint\t\t\tpriority = QO_PRIORITY(in->curpol);\n\t\tint16\t\tdistance = in->curpol->qoperator.distance;\n\t\tINFIX\t\tnrm;\n\t\tbool\t\tneedParenthesis = false;\n\n\t\tin->curpol++;\n\t\tif (priority < parentPriority ||\n\t\t/* phrase operator depends on order */\n\t\t\t(op == OP_PHRASE && rightPhraseOp))\n\t\t{\n\t\t\tneedParenthesis = true;\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \"( \");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\n\t\tnrm.curpol = in->curpol;\n\t\tnrm.op = in->op;\n\t\tnrm.buflen = 16;\n\t\tnrm.cur = nrm.buf = (char *) palloc(sizeof(char) * nrm.buflen);\n\n\t\t/* get right operand */\n\t\tinfix(&nrm, priority, (op == OP_PHRASE));\n\n\t\t/* get & print left operand */\n\t\tin->curpol = nrm.curpol;\n\t\tinfix(in, priority, false);\n\n\t\t/* print operator & right operand */\n\t\tRESIZEBUF(in, 3 + (2 + 10 /* distance */ ) + (nrm.cur - nrm.buf));\n\t\tswitch (op)\n\t\t{\n\t\t\tcase OP_OR:\n\t\t\t\tsprintf(in->cur, \" | %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tcase OP_AND:\n\t\t\t\tsprintf(in->cur, \" & %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tcase OP_PHRASE:\n\t\t\t\tif (distance != 1)\n\t\t\t\t\tsprintf(in->cur, \" <%d> %s\", distance, nrm.buf);\n\t\t\t\telse\n\t\t\t\t\tsprintf(in->cur, \" <-> %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* OP_NOT is handled in above if-branch */\n\t\t\t\telog(ERROR, \"unrecognized operator type: %d\", op);\n\t\t}\n\t\tin->cur = strchr(in->cur, '\\0');\n\t\tpfree(nrm.buf);\n\n\t\tif (needParenthesis)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \" )\");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "query"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(char) * nrm.buflen"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "\"T\""
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_NOT",
          "args": [
            "GETQUERY(query)",
            "&len"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "clean_NOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "188-194",
          "snippet": "QueryItem *\nclean_NOT(QueryItem *ptr, int *len)\n{\n\tNODE\t   *root = maketree(ptr);\n\n\treturn plaintree(clean_NOT_intree(root), len);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nQueryItem *\nclean_NOT(QueryItem *ptr, int *len)\n{\n\tNODE\t   *root = maketree(ptr);\n\n\treturn plaintree(clean_NOT_intree(root), len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "query"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "res"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "res",
            "VARHDRSZ"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "0"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nDatum\ntsquerytree(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(0);\n\tINFIX\t\tnrm;\n\ttext\t   *res;\n\tQueryItem  *q;\n\tint\t\t\tlen;\n\n\tif (query->size == 0)\n\t{\n\t\tres = (text *) palloc(VARHDRSZ);\n\t\tSET_VARSIZE(res, VARHDRSZ);\n\t\tPG_RETURN_POINTER(res);\n\t}\n\n\tq = clean_NOT(GETQUERY(query), &len);\n\n\tif (!q)\n\t{\n\t\tres = cstring_to_text(\"T\");\n\t}\n\telse\n\t{\n\t\tnrm.curpol = q;\n\t\tnrm.buflen = 32;\n\t\tnrm.cur = nrm.buf = (char *) palloc(sizeof(char) * nrm.buflen);\n\t\t*(nrm.cur) = '\\0';\n\t\tnrm.op = GETOPERAND(query);\n\t\tinfix(&nrm, -1, false);\n\t\tres = cstring_to_text_with_len(nrm.buf, nrm.cur - nrm.buf);\n\t\tpfree(q);\n\t}\n\n\tPG_FREE_IF_COPY(query, 0);\n\n\tPG_RETURN_TEXT_P(res);\n}"
  },
  {
    "function_name": "tsqueryrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "1211-1341",
    "snippet": "Datum\ntsqueryrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTSQuery\t\tquery;\n\tint\t\t\ti,\n\t\t\t\tlen;\n\tQueryItem  *item;\n\tint\t\t\tdatalen;\n\tchar\t   *ptr;\n\tuint32\t\tsize;\n\tconst char **operands;\n\tbool\t\tneedcleanup;\n\n\tsize = pq_getmsgint(buf, sizeof(uint32));\n\tif (size > (MaxAllocSize / sizeof(QueryItem)))\n\t\telog(ERROR, \"invalid size of tsquery\");\n\n\t/* Allocate space to temporarily hold operand strings */\n\toperands = palloc(size * sizeof(char *));\n\n\t/* Allocate space for all the QueryItems. */\n\tlen = HDRSIZETQ + sizeof(QueryItem) * size;\n\tquery = (TSQuery) palloc0(len);\n\tquery->size = size;\n\titem = GETQUERY(query);\n\n\tdatalen = 0;\n\tfor (i = 0; i < size; i++)\n\t{\n\t\titem->type = (int8) pq_getmsgint(buf, sizeof(int8));\n\n\t\tif (item->type == QI_VAL)\n\t\t{\n\t\t\tsize_t\t\tval_len;\t/* length after recoding to server\n\t\t\t\t\t\t\t\t\t * encoding */\n\t\t\tuint8\t\tweight;\n\t\t\tuint8\t\tprefix;\n\t\t\tconst char *val;\n\t\t\tpg_crc32\tvalcrc;\n\n\t\t\tweight = (uint8) pq_getmsgint(buf, sizeof(uint8));\n\t\t\tprefix = (uint8) pq_getmsgint(buf, sizeof(uint8));\n\t\t\tval = pq_getmsgstring(buf);\n\t\t\tval_len = strlen(val);\n\n\t\t\t/* Sanity checks */\n\n\t\t\tif (weight > 0xF)\n\t\t\t\telog(ERROR, \"invalid tsquery: invalid weight bitmap\");\n\n\t\t\tif (val_len > MAXSTRLEN)\n\t\t\t\telog(ERROR, \"invalid tsquery: operand too long\");\n\n\t\t\tif (datalen > MAXSTRPOS)\n\t\t\t\telog(ERROR, \"invalid tsquery: total operand length exceeded\");\n\n\t\t\t/* Looks valid. */\n\n\t\t\tINIT_LEGACY_CRC32(valcrc);\n\t\t\tCOMP_LEGACY_CRC32(valcrc, val, val_len);\n\t\t\tFIN_LEGACY_CRC32(valcrc);\n\n\t\t\titem->qoperand.weight = weight;\n\t\t\titem->qoperand.prefix = (prefix) ? true : false;\n\t\t\titem->qoperand.valcrc = (int32) valcrc;\n\t\t\titem->qoperand.length = val_len;\n\t\t\titem->qoperand.distance = datalen;\n\n\t\t\t/*\n\t\t\t * Operand strings are copied to the final struct after this loop;\n\t\t\t * here we just collect them to an array\n\t\t\t */\n\t\t\toperands[i] = val;\n\n\t\t\tdatalen += val_len + 1; /* + 1 for the '\\0' terminator */\n\t\t}\n\t\telse if (item->type == QI_OPR)\n\t\t{\n\t\t\tint8\t\toper;\n\n\t\t\toper = (int8) pq_getmsgint(buf, sizeof(int8));\n\t\t\tif (oper != OP_NOT && oper != OP_OR && oper != OP_AND && oper != OP_PHRASE)\n\t\t\t\telog(ERROR, \"invalid tsquery: unrecognized operator type %d\",\n\t\t\t\t\t (int) oper);\n\t\t\tif (i == size - 1)\n\t\t\t\telog(ERROR, \"invalid pointer to right operand\");\n\n\t\t\titem->qoperator.oper = oper;\n\t\t\tif (oper == OP_PHRASE)\n\t\t\t\titem->qoperator.distance = (int16) pq_getmsgint(buf, sizeof(int16));\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unrecognized tsquery node type: %d\", item->type);\n\n\t\titem++;\n\t}\n\n\t/* Enlarge buffer to make room for the operand values. */\n\tquery = (TSQuery) repalloc(query, len + datalen);\n\titem = GETQUERY(query);\n\tptr = GETOPERAND(query);\n\n\t/*\n\t * Fill in the left-pointers. Checks that the tree is well-formed as a\n\t * side-effect.\n\t */\n\tfindoprnd(item, size, &needcleanup);\n\n\t/* Can't have found any QI_VALSTOP nodes */\n\tAssert(!needcleanup);\n\n\t/* Copy operands to output struct */\n\tfor (i = 0; i < size; i++)\n\t{\n\t\tif (item->type == QI_VAL)\n\t\t{\n\t\t\tmemcpy(ptr, operands[i], item->qoperand.length + 1);\n\t\t\tptr += item->qoperand.length + 1;\n\t\t}\n\t\titem++;\n\t}\n\n\tpfree(operands);\n\n\tAssert(ptr - GETOPERAND(query) == datalen);\n\n\tSET_VARSIZE(query, len + datalen);\n\n\tPG_RETURN_TSQUERY(query);\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TSQUERY",
          "args": [
            "query"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "query",
            "len + datalen"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ptr - GETOPERAND(query) == datalen"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "query"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "operands"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "operands[i]",
            "item->qoperand.length + 1"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!needcleanup"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findoprnd",
          "args": [
            "item",
            "size",
            "&needcleanup"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "findoprnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "791-802",
          "snippet": "static void\nfindoprnd(QueryItem *ptr, int size, bool *needcleanup)\n{\n\tuint32\t\tpos;\n\n\t*needcleanup = false;\n\tpos = 0;\n\tfindoprnd_recurse(ptr, &pos, size, needcleanup);\n\n\tif (pos != size)\n\t\telog(ERROR, \"malformed tsquery: extra nodes\");\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic void\nfindoprnd(QueryItem *ptr, int size, bool *needcleanup)\n{\n\tuint32\t\tpos;\n\n\t*needcleanup = false;\n\tpos = 0;\n\tfindoprnd_recurse(ptr, &pos, size, needcleanup);\n\n\tif (pos != size)\n\t\telog(ERROR, \"malformed tsquery: extra nodes\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "query"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "query"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "query",
            "len + datalen"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized tsquery node type: %d\"",
            "item->type"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(int16)"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(int8)"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FIN_LEGACY_CRC32",
          "args": [
            "valcrc"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMP_LEGACY_CRC32",
          "args": [
            "valcrc",
            "val",
            "val_len"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LEGACY_CRC32",
          "args": [
            "valcrc"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "val"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgstring",
          "args": [
            "buf"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(uint8)"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(uint8)"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(int8)"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "query"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "len"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "size * sizeof(char *)"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(uint32)"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nDatum\ntsqueryrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTSQuery\t\tquery;\n\tint\t\t\ti,\n\t\t\t\tlen;\n\tQueryItem  *item;\n\tint\t\t\tdatalen;\n\tchar\t   *ptr;\n\tuint32\t\tsize;\n\tconst char **operands;\n\tbool\t\tneedcleanup;\n\n\tsize = pq_getmsgint(buf, sizeof(uint32));\n\tif (size > (MaxAllocSize / sizeof(QueryItem)))\n\t\telog(ERROR, \"invalid size of tsquery\");\n\n\t/* Allocate space to temporarily hold operand strings */\n\toperands = palloc(size * sizeof(char *));\n\n\t/* Allocate space for all the QueryItems. */\n\tlen = HDRSIZETQ + sizeof(QueryItem) * size;\n\tquery = (TSQuery) palloc0(len);\n\tquery->size = size;\n\titem = GETQUERY(query);\n\n\tdatalen = 0;\n\tfor (i = 0; i < size; i++)\n\t{\n\t\titem->type = (int8) pq_getmsgint(buf, sizeof(int8));\n\n\t\tif (item->type == QI_VAL)\n\t\t{\n\t\t\tsize_t\t\tval_len;\t/* length after recoding to server\n\t\t\t\t\t\t\t\t\t * encoding */\n\t\t\tuint8\t\tweight;\n\t\t\tuint8\t\tprefix;\n\t\t\tconst char *val;\n\t\t\tpg_crc32\tvalcrc;\n\n\t\t\tweight = (uint8) pq_getmsgint(buf, sizeof(uint8));\n\t\t\tprefix = (uint8) pq_getmsgint(buf, sizeof(uint8));\n\t\t\tval = pq_getmsgstring(buf);\n\t\t\tval_len = strlen(val);\n\n\t\t\t/* Sanity checks */\n\n\t\t\tif (weight > 0xF)\n\t\t\t\telog(ERROR, \"invalid tsquery: invalid weight bitmap\");\n\n\t\t\tif (val_len > MAXSTRLEN)\n\t\t\t\telog(ERROR, \"invalid tsquery: operand too long\");\n\n\t\t\tif (datalen > MAXSTRPOS)\n\t\t\t\telog(ERROR, \"invalid tsquery: total operand length exceeded\");\n\n\t\t\t/* Looks valid. */\n\n\t\t\tINIT_LEGACY_CRC32(valcrc);\n\t\t\tCOMP_LEGACY_CRC32(valcrc, val, val_len);\n\t\t\tFIN_LEGACY_CRC32(valcrc);\n\n\t\t\titem->qoperand.weight = weight;\n\t\t\titem->qoperand.prefix = (prefix) ? true : false;\n\t\t\titem->qoperand.valcrc = (int32) valcrc;\n\t\t\titem->qoperand.length = val_len;\n\t\t\titem->qoperand.distance = datalen;\n\n\t\t\t/*\n\t\t\t * Operand strings are copied to the final struct after this loop;\n\t\t\t * here we just collect them to an array\n\t\t\t */\n\t\t\toperands[i] = val;\n\n\t\t\tdatalen += val_len + 1; /* + 1 for the '\\0' terminator */\n\t\t}\n\t\telse if (item->type == QI_OPR)\n\t\t{\n\t\t\tint8\t\toper;\n\n\t\t\toper = (int8) pq_getmsgint(buf, sizeof(int8));\n\t\t\tif (oper != OP_NOT && oper != OP_OR && oper != OP_AND && oper != OP_PHRASE)\n\t\t\t\telog(ERROR, \"invalid tsquery: unrecognized operator type %d\",\n\t\t\t\t\t (int) oper);\n\t\t\tif (i == size - 1)\n\t\t\t\telog(ERROR, \"invalid pointer to right operand\");\n\n\t\t\titem->qoperator.oper = oper;\n\t\t\tif (oper == OP_PHRASE)\n\t\t\t\titem->qoperator.distance = (int16) pq_getmsgint(buf, sizeof(int16));\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unrecognized tsquery node type: %d\", item->type);\n\n\t\titem++;\n\t}\n\n\t/* Enlarge buffer to make room for the operand values. */\n\tquery = (TSQuery) repalloc(query, len + datalen);\n\titem = GETQUERY(query);\n\tptr = GETOPERAND(query);\n\n\t/*\n\t * Fill in the left-pointers. Checks that the tree is well-formed as a\n\t * side-effect.\n\t */\n\tfindoprnd(item, size, &needcleanup);\n\n\t/* Can't have found any QI_VALSTOP nodes */\n\tAssert(!needcleanup);\n\n\t/* Copy operands to output struct */\n\tfor (i = 0; i < size; i++)\n\t{\n\t\tif (item->type == QI_VAL)\n\t\t{\n\t\t\tmemcpy(ptr, operands[i], item->qoperand.length + 1);\n\t\t\tptr += item->qoperand.length + 1;\n\t\t}\n\t\titem++;\n\t}\n\n\tpfree(operands);\n\n\tAssert(ptr - GETOPERAND(query) == datalen);\n\n\tSET_VARSIZE(query, len + datalen);\n\n\tPG_RETURN_TSQUERY(query);\n}"
  },
  {
    "function_name": "tsquerysend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "1173-1209",
    "snippet": "Datum\ntsquerysend(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(0);\n\tStringInfoData buf;\n\tint\t\t\ti;\n\tQueryItem  *item = GETQUERY(query);\n\n\tpq_begintypsend(&buf);\n\n\tpq_sendint32(&buf, query->size);\n\tfor (i = 0; i < query->size; i++)\n\t{\n\t\tpq_sendint8(&buf, item->type);\n\n\t\tswitch (item->type)\n\t\t{\n\t\t\tcase QI_VAL:\n\t\t\t\tpq_sendint8(&buf, item->qoperand.weight);\n\t\t\t\tpq_sendint8(&buf, item->qoperand.prefix);\n\t\t\t\tpq_sendstring(&buf, GETOPERAND(query) + item->qoperand.distance);\n\t\t\t\tbreak;\n\t\t\tcase QI_OPR:\n\t\t\t\tpq_sendint8(&buf, item->qoperator.oper);\n\t\t\t\tif (item->qoperator.oper == OP_PHRASE)\n\t\t\t\t\tpq_sendint16(&buf, item->qoperator.distance);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized tsquery node type: %d\", item->type);\n\t\t}\n\t\titem++;\n\t}\n\n\tPG_FREE_IF_COPY(query, 0);\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "0"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized tsquery node type: %d\"",
            "item->type"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_sendint16",
          "args": [
            "&buf",
            "item->qoperator.distance"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint8",
          "args": [
            "&buf",
            "item->qoperator.oper"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendstring",
          "args": [
            "&buf",
            "GETOPERAND(query) + item->qoperand.distance"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "query"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint8",
          "args": [
            "&buf",
            "item->qoperand.prefix"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint8",
          "args": [
            "&buf",
            "item->qoperand.weight"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint8",
          "args": [
            "&buf",
            "item->type"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "query->size"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "query"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "0"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nDatum\ntsquerysend(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(0);\n\tStringInfoData buf;\n\tint\t\t\ti;\n\tQueryItem  *item = GETQUERY(query);\n\n\tpq_begintypsend(&buf);\n\n\tpq_sendint32(&buf, query->size);\n\tfor (i = 0; i < query->size; i++)\n\t{\n\t\tpq_sendint8(&buf, item->type);\n\n\t\tswitch (item->type)\n\t\t{\n\t\t\tcase QI_VAL:\n\t\t\t\tpq_sendint8(&buf, item->qoperand.weight);\n\t\t\t\tpq_sendint8(&buf, item->qoperand.prefix);\n\t\t\t\tpq_sendstring(&buf, GETOPERAND(query) + item->qoperand.distance);\n\t\t\t\tbreak;\n\t\t\tcase QI_OPR:\n\t\t\t\tpq_sendint8(&buf, item->qoperator.oper);\n\t\t\t\tif (item->qoperator.oper == OP_PHRASE)\n\t\t\t\t\tpq_sendint16(&buf, item->qoperator.distance);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized tsquery node type: %d\", item->type);\n\t\t}\n\t\titem++;\n\t}\n\n\tPG_FREE_IF_COPY(query, 0);\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "tsqueryout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "1131-1153",
    "snippet": "Datum\ntsqueryout(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(0);\n\tINFIX\t\tnrm;\n\n\tif (query->size == 0)\n\t{\n\t\tchar\t   *b = palloc(1);\n\n\t\t*b = '\\0';\n\t\tPG_RETURN_POINTER(b);\n\t}\n\tnrm.curpol = GETQUERY(query);\n\tnrm.buflen = 32;\n\tnrm.cur = nrm.buf = (char *) palloc(sizeof(char) * nrm.buflen);\n\t*(nrm.cur) = '\\0';\n\tnrm.op = GETOPERAND(query);\n\tinfix(&nrm, -1 /* lowest priority */ , false);\n\n\tPG_FREE_IF_COPY(query, 0);\n\tPG_RETURN_CSTRING(nrm.buf);\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "nrm.buf"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "0"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "infix",
          "args": [
            "&nrm",
            "-1/* lowest priority */",
            "false"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "infix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "976-1129",
          "snippet": "static void\ninfix(INFIX *in, int parentPriority, bool rightPhraseOp)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->curpol->type == QI_VAL)\n\t{\n\t\tQueryOperand *curpol = &in->curpol->qoperand;\n\t\tchar\t   *op = in->op + curpol->distance;\n\t\tint\t\t\tclen;\n\n\t\tRESIZEBUF(in, curpol->length * (pg_database_encoding_max_length() + 1) + 2 + 6);\n\t\t*(in->cur) = '\\'';\n\t\tin->cur++;\n\t\twhile (*op)\n\t\t{\n\t\t\tif (t_iseq(op, '\\''))\n\t\t\t{\n\t\t\t\t*(in->cur) = '\\'';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\telse if (t_iseq(op, '\\\\'))\n\t\t\t{\n\t\t\t\t*(in->cur) = '\\\\';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tCOPYCHAR(in->cur, op);\n\n\t\t\tclen = pg_mblen(op);\n\t\t\top += clen;\n\t\t\tin->cur += clen;\n\t\t}\n\t\t*(in->cur) = '\\'';\n\t\tin->cur++;\n\t\tif (curpol->weight || curpol->prefix)\n\t\t{\n\t\t\t*(in->cur) = ':';\n\t\t\tin->cur++;\n\t\t\tif (curpol->prefix)\n\t\t\t{\n\t\t\t\t*(in->cur) = '*';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 3))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'A';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 2))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'B';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 1))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'C';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & 1)\n\t\t\t{\n\t\t\t\t*(in->cur) = 'D';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t}\n\t\t*(in->cur) = '\\0';\n\t\tin->curpol++;\n\t}\n\telse if (in->curpol->qoperator.oper == OP_NOT)\n\t{\n\t\tint\t\t\tpriority = QO_PRIORITY(in->curpol);\n\n\t\tif (priority < parentPriority)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \"( \");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t\tRESIZEBUF(in, 1);\n\t\t*(in->cur) = '!';\n\t\tin->cur++;\n\t\t*(in->cur) = '\\0';\n\t\tin->curpol++;\n\n\t\tinfix(in, priority, false);\n\t\tif (priority < parentPriority)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \" )\");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t}\n\telse\n\t{\n\t\tint8\t\top = in->curpol->qoperator.oper;\n\t\tint\t\t\tpriority = QO_PRIORITY(in->curpol);\n\t\tint16\t\tdistance = in->curpol->qoperator.distance;\n\t\tINFIX\t\tnrm;\n\t\tbool\t\tneedParenthesis = false;\n\n\t\tin->curpol++;\n\t\tif (priority < parentPriority ||\n\t\t/* phrase operator depends on order */\n\t\t\t(op == OP_PHRASE && rightPhraseOp))\n\t\t{\n\t\t\tneedParenthesis = true;\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \"( \");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\n\t\tnrm.curpol = in->curpol;\n\t\tnrm.op = in->op;\n\t\tnrm.buflen = 16;\n\t\tnrm.cur = nrm.buf = (char *) palloc(sizeof(char) * nrm.buflen);\n\n\t\t/* get right operand */\n\t\tinfix(&nrm, priority, (op == OP_PHRASE));\n\n\t\t/* get & print left operand */\n\t\tin->curpol = nrm.curpol;\n\t\tinfix(in, priority, false);\n\n\t\t/* print operator & right operand */\n\t\tRESIZEBUF(in, 3 + (2 + 10 /* distance */ ) + (nrm.cur - nrm.buf));\n\t\tswitch (op)\n\t\t{\n\t\t\tcase OP_OR:\n\t\t\t\tsprintf(in->cur, \" | %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tcase OP_AND:\n\t\t\t\tsprintf(in->cur, \" & %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tcase OP_PHRASE:\n\t\t\t\tif (distance != 1)\n\t\t\t\t\tsprintf(in->cur, \" <%d> %s\", distance, nrm.buf);\n\t\t\t\telse\n\t\t\t\t\tsprintf(in->cur, \" <-> %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* OP_NOT is handled in above if-branch */\n\t\t\t\telog(ERROR, \"unrecognized operator type: %d\", op);\n\t\t}\n\t\tin->cur = strchr(in->cur, '\\0');\n\t\tpfree(nrm.buf);\n\n\t\tif (needParenthesis)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \" )\");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic void\ninfix(INFIX *in, int parentPriority, bool rightPhraseOp)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->curpol->type == QI_VAL)\n\t{\n\t\tQueryOperand *curpol = &in->curpol->qoperand;\n\t\tchar\t   *op = in->op + curpol->distance;\n\t\tint\t\t\tclen;\n\n\t\tRESIZEBUF(in, curpol->length * (pg_database_encoding_max_length() + 1) + 2 + 6);\n\t\t*(in->cur) = '\\'';\n\t\tin->cur++;\n\t\twhile (*op)\n\t\t{\n\t\t\tif (t_iseq(op, '\\''))\n\t\t\t{\n\t\t\t\t*(in->cur) = '\\'';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\telse if (t_iseq(op, '\\\\'))\n\t\t\t{\n\t\t\t\t*(in->cur) = '\\\\';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tCOPYCHAR(in->cur, op);\n\n\t\t\tclen = pg_mblen(op);\n\t\t\top += clen;\n\t\t\tin->cur += clen;\n\t\t}\n\t\t*(in->cur) = '\\'';\n\t\tin->cur++;\n\t\tif (curpol->weight || curpol->prefix)\n\t\t{\n\t\t\t*(in->cur) = ':';\n\t\t\tin->cur++;\n\t\t\tif (curpol->prefix)\n\t\t\t{\n\t\t\t\t*(in->cur) = '*';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 3))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'A';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 2))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'B';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 1))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'C';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & 1)\n\t\t\t{\n\t\t\t\t*(in->cur) = 'D';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t}\n\t\t*(in->cur) = '\\0';\n\t\tin->curpol++;\n\t}\n\telse if (in->curpol->qoperator.oper == OP_NOT)\n\t{\n\t\tint\t\t\tpriority = QO_PRIORITY(in->curpol);\n\n\t\tif (priority < parentPriority)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \"( \");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t\tRESIZEBUF(in, 1);\n\t\t*(in->cur) = '!';\n\t\tin->cur++;\n\t\t*(in->cur) = '\\0';\n\t\tin->curpol++;\n\n\t\tinfix(in, priority, false);\n\t\tif (priority < parentPriority)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \" )\");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t}\n\telse\n\t{\n\t\tint8\t\top = in->curpol->qoperator.oper;\n\t\tint\t\t\tpriority = QO_PRIORITY(in->curpol);\n\t\tint16\t\tdistance = in->curpol->qoperator.distance;\n\t\tINFIX\t\tnrm;\n\t\tbool\t\tneedParenthesis = false;\n\n\t\tin->curpol++;\n\t\tif (priority < parentPriority ||\n\t\t/* phrase operator depends on order */\n\t\t\t(op == OP_PHRASE && rightPhraseOp))\n\t\t{\n\t\t\tneedParenthesis = true;\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \"( \");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\n\t\tnrm.curpol = in->curpol;\n\t\tnrm.op = in->op;\n\t\tnrm.buflen = 16;\n\t\tnrm.cur = nrm.buf = (char *) palloc(sizeof(char) * nrm.buflen);\n\n\t\t/* get right operand */\n\t\tinfix(&nrm, priority, (op == OP_PHRASE));\n\n\t\t/* get & print left operand */\n\t\tin->curpol = nrm.curpol;\n\t\tinfix(in, priority, false);\n\n\t\t/* print operator & right operand */\n\t\tRESIZEBUF(in, 3 + (2 + 10 /* distance */ ) + (nrm.cur - nrm.buf));\n\t\tswitch (op)\n\t\t{\n\t\t\tcase OP_OR:\n\t\t\t\tsprintf(in->cur, \" | %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tcase OP_AND:\n\t\t\t\tsprintf(in->cur, \" & %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tcase OP_PHRASE:\n\t\t\t\tif (distance != 1)\n\t\t\t\t\tsprintf(in->cur, \" <%d> %s\", distance, nrm.buf);\n\t\t\t\telse\n\t\t\t\t\tsprintf(in->cur, \" <-> %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* OP_NOT is handled in above if-branch */\n\t\t\t\telog(ERROR, \"unrecognized operator type: %d\", op);\n\t\t}\n\t\tin->cur = strchr(in->cur, '\\0');\n\t\tpfree(nrm.buf);\n\n\t\tif (needParenthesis)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \" )\");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "query"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(char) * nrm.buflen"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "query"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "b"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "0"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nDatum\ntsqueryout(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(0);\n\tINFIX\t\tnrm;\n\n\tif (query->size == 0)\n\t{\n\t\tchar\t   *b = palloc(1);\n\n\t\t*b = '\\0';\n\t\tPG_RETURN_POINTER(b);\n\t}\n\tnrm.curpol = GETQUERY(query);\n\tnrm.buflen = 32;\n\tnrm.cur = nrm.buf = (char *) palloc(sizeof(char) * nrm.buflen);\n\t*(nrm.cur) = '\\0';\n\tnrm.op = GETOPERAND(query);\n\tinfix(&nrm, -1 /* lowest priority */ , false);\n\n\tPG_FREE_IF_COPY(query, 0);\n\tPG_RETURN_CSTRING(nrm.buf);\n}"
  },
  {
    "function_name": "infix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "976-1129",
    "snippet": "static void\ninfix(INFIX *in, int parentPriority, bool rightPhraseOp)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->curpol->type == QI_VAL)\n\t{\n\t\tQueryOperand *curpol = &in->curpol->qoperand;\n\t\tchar\t   *op = in->op + curpol->distance;\n\t\tint\t\t\tclen;\n\n\t\tRESIZEBUF(in, curpol->length * (pg_database_encoding_max_length() + 1) + 2 + 6);\n\t\t*(in->cur) = '\\'';\n\t\tin->cur++;\n\t\twhile (*op)\n\t\t{\n\t\t\tif (t_iseq(op, '\\''))\n\t\t\t{\n\t\t\t\t*(in->cur) = '\\'';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\telse if (t_iseq(op, '\\\\'))\n\t\t\t{\n\t\t\t\t*(in->cur) = '\\\\';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tCOPYCHAR(in->cur, op);\n\n\t\t\tclen = pg_mblen(op);\n\t\t\top += clen;\n\t\t\tin->cur += clen;\n\t\t}\n\t\t*(in->cur) = '\\'';\n\t\tin->cur++;\n\t\tif (curpol->weight || curpol->prefix)\n\t\t{\n\t\t\t*(in->cur) = ':';\n\t\t\tin->cur++;\n\t\t\tif (curpol->prefix)\n\t\t\t{\n\t\t\t\t*(in->cur) = '*';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 3))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'A';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 2))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'B';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 1))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'C';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & 1)\n\t\t\t{\n\t\t\t\t*(in->cur) = 'D';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t}\n\t\t*(in->cur) = '\\0';\n\t\tin->curpol++;\n\t}\n\telse if (in->curpol->qoperator.oper == OP_NOT)\n\t{\n\t\tint\t\t\tpriority = QO_PRIORITY(in->curpol);\n\n\t\tif (priority < parentPriority)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \"( \");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t\tRESIZEBUF(in, 1);\n\t\t*(in->cur) = '!';\n\t\tin->cur++;\n\t\t*(in->cur) = '\\0';\n\t\tin->curpol++;\n\n\t\tinfix(in, priority, false);\n\t\tif (priority < parentPriority)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \" )\");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t}\n\telse\n\t{\n\t\tint8\t\top = in->curpol->qoperator.oper;\n\t\tint\t\t\tpriority = QO_PRIORITY(in->curpol);\n\t\tint16\t\tdistance = in->curpol->qoperator.distance;\n\t\tINFIX\t\tnrm;\n\t\tbool\t\tneedParenthesis = false;\n\n\t\tin->curpol++;\n\t\tif (priority < parentPriority ||\n\t\t/* phrase operator depends on order */\n\t\t\t(op == OP_PHRASE && rightPhraseOp))\n\t\t{\n\t\t\tneedParenthesis = true;\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \"( \");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\n\t\tnrm.curpol = in->curpol;\n\t\tnrm.op = in->op;\n\t\tnrm.buflen = 16;\n\t\tnrm.cur = nrm.buf = (char *) palloc(sizeof(char) * nrm.buflen);\n\n\t\t/* get right operand */\n\t\tinfix(&nrm, priority, (op == OP_PHRASE));\n\n\t\t/* get & print left operand */\n\t\tin->curpol = nrm.curpol;\n\t\tinfix(in, priority, false);\n\n\t\t/* print operator & right operand */\n\t\tRESIZEBUF(in, 3 + (2 + 10 /* distance */ ) + (nrm.cur - nrm.buf));\n\t\tswitch (op)\n\t\t{\n\t\t\tcase OP_OR:\n\t\t\t\tsprintf(in->cur, \" | %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tcase OP_AND:\n\t\t\t\tsprintf(in->cur, \" & %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tcase OP_PHRASE:\n\t\t\t\tif (distance != 1)\n\t\t\t\t\tsprintf(in->cur, \" <%d> %s\", distance, nrm.buf);\n\t\t\t\telse\n\t\t\t\t\tsprintf(in->cur, \" <-> %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* OP_NOT is handled in above if-branch */\n\t\t\t\telog(ERROR, \"unrecognized operator type: %d\", op);\n\t\t}\n\t\tin->cur = strchr(in->cur, '\\0');\n\t\tpfree(nrm.buf);\n\n\t\tif (needParenthesis)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \" )\");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "in->cur",
            "'\\0'"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "in->cur",
            "\" )\""
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RESIZEBUF",
          "args": [
            "in",
            "2"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "nrm.buf"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "in->cur",
            "'\\0'"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized operator type: %d\"",
            "op"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "in->cur",
            "\" <-> %s\"",
            "nrm.buf"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "in->cur",
            "\" <%d> %s\"",
            "distance",
            "nrm.buf"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "in->cur",
            "\" & %s\"",
            "nrm.buf"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "in->cur",
            "\" | %s\"",
            "nrm.buf"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RESIZEBUF",
          "args": [
            "in",
            "3 + (2 + 10 /* distance */ ) + (nrm.cur - nrm.buf)"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "infix",
          "args": [
            "in",
            "priority",
            "false"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "infix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "976-1129",
          "snippet": "static void\ninfix(INFIX *in, int parentPriority, bool rightPhraseOp)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->curpol->type == QI_VAL)\n\t{\n\t\tQueryOperand *curpol = &in->curpol->qoperand;\n\t\tchar\t   *op = in->op + curpol->distance;\n\t\tint\t\t\tclen;\n\n\t\tRESIZEBUF(in, curpol->length * (pg_database_encoding_max_length() + 1) + 2 + 6);\n\t\t*(in->cur) = '\\'';\n\t\tin->cur++;\n\t\twhile (*op)\n\t\t{\n\t\t\tif (t_iseq(op, '\\''))\n\t\t\t{\n\t\t\t\t*(in->cur) = '\\'';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\telse if (t_iseq(op, '\\\\'))\n\t\t\t{\n\t\t\t\t*(in->cur) = '\\\\';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tCOPYCHAR(in->cur, op);\n\n\t\t\tclen = pg_mblen(op);\n\t\t\top += clen;\n\t\t\tin->cur += clen;\n\t\t}\n\t\t*(in->cur) = '\\'';\n\t\tin->cur++;\n\t\tif (curpol->weight || curpol->prefix)\n\t\t{\n\t\t\t*(in->cur) = ':';\n\t\t\tin->cur++;\n\t\t\tif (curpol->prefix)\n\t\t\t{\n\t\t\t\t*(in->cur) = '*';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 3))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'A';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 2))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'B';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 1))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'C';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & 1)\n\t\t\t{\n\t\t\t\t*(in->cur) = 'D';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t}\n\t\t*(in->cur) = '\\0';\n\t\tin->curpol++;\n\t}\n\telse if (in->curpol->qoperator.oper == OP_NOT)\n\t{\n\t\tint\t\t\tpriority = QO_PRIORITY(in->curpol);\n\n\t\tif (priority < parentPriority)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \"( \");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t\tRESIZEBUF(in, 1);\n\t\t*(in->cur) = '!';\n\t\tin->cur++;\n\t\t*(in->cur) = '\\0';\n\t\tin->curpol++;\n\n\t\tinfix(in, priority, false);\n\t\tif (priority < parentPriority)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \" )\");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t}\n\telse\n\t{\n\t\tint8\t\top = in->curpol->qoperator.oper;\n\t\tint\t\t\tpriority = QO_PRIORITY(in->curpol);\n\t\tint16\t\tdistance = in->curpol->qoperator.distance;\n\t\tINFIX\t\tnrm;\n\t\tbool\t\tneedParenthesis = false;\n\n\t\tin->curpol++;\n\t\tif (priority < parentPriority ||\n\t\t/* phrase operator depends on order */\n\t\t\t(op == OP_PHRASE && rightPhraseOp))\n\t\t{\n\t\t\tneedParenthesis = true;\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \"( \");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\n\t\tnrm.curpol = in->curpol;\n\t\tnrm.op = in->op;\n\t\tnrm.buflen = 16;\n\t\tnrm.cur = nrm.buf = (char *) palloc(sizeof(char) * nrm.buflen);\n\n\t\t/* get right operand */\n\t\tinfix(&nrm, priority, (op == OP_PHRASE));\n\n\t\t/* get & print left operand */\n\t\tin->curpol = nrm.curpol;\n\t\tinfix(in, priority, false);\n\n\t\t/* print operator & right operand */\n\t\tRESIZEBUF(in, 3 + (2 + 10 /* distance */ ) + (nrm.cur - nrm.buf));\n\t\tswitch (op)\n\t\t{\n\t\t\tcase OP_OR:\n\t\t\t\tsprintf(in->cur, \" | %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tcase OP_AND:\n\t\t\t\tsprintf(in->cur, \" & %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tcase OP_PHRASE:\n\t\t\t\tif (distance != 1)\n\t\t\t\t\tsprintf(in->cur, \" <%d> %s\", distance, nrm.buf);\n\t\t\t\telse\n\t\t\t\t\tsprintf(in->cur, \" <-> %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* OP_NOT is handled in above if-branch */\n\t\t\t\telog(ERROR, \"unrecognized operator type: %d\", op);\n\t\t}\n\t\tin->cur = strchr(in->cur, '\\0');\n\t\tpfree(nrm.buf);\n\n\t\tif (needParenthesis)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \" )\");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(char) * nrm.buflen"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "in->cur",
            "'\\0'"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "in->cur",
            "\"( \""
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RESIZEBUF",
          "args": [
            "in",
            "2"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QO_PRIORITY",
          "args": [
            "in->curpol"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "in->cur",
            "'\\0'"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "in->cur",
            "\" )\""
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RESIZEBUF",
          "args": [
            "in",
            "2"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RESIZEBUF",
          "args": [
            "in",
            "1"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "in->cur",
            "'\\0'"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "in->cur",
            "\"( \""
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RESIZEBUF",
          "args": [
            "in",
            "2"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QO_PRIORITY",
          "args": [
            "in->curpol"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "op"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "COPYCHAR",
          "args": [
            "in->cur",
            "op"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_iseq",
          "args": [
            "op",
            "'\\\\'"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "text_isequal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4281-4287",
          "snippet": "static bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RESIZEBUF",
          "args": [
            "in",
            "curpol->length * (pg_database_encoding_max_length() + 1) + 2 + 6"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic void\ninfix(INFIX *in, int parentPriority, bool rightPhraseOp)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->curpol->type == QI_VAL)\n\t{\n\t\tQueryOperand *curpol = &in->curpol->qoperand;\n\t\tchar\t   *op = in->op + curpol->distance;\n\t\tint\t\t\tclen;\n\n\t\tRESIZEBUF(in, curpol->length * (pg_database_encoding_max_length() + 1) + 2 + 6);\n\t\t*(in->cur) = '\\'';\n\t\tin->cur++;\n\t\twhile (*op)\n\t\t{\n\t\t\tif (t_iseq(op, '\\''))\n\t\t\t{\n\t\t\t\t*(in->cur) = '\\'';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\telse if (t_iseq(op, '\\\\'))\n\t\t\t{\n\t\t\t\t*(in->cur) = '\\\\';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tCOPYCHAR(in->cur, op);\n\n\t\t\tclen = pg_mblen(op);\n\t\t\top += clen;\n\t\t\tin->cur += clen;\n\t\t}\n\t\t*(in->cur) = '\\'';\n\t\tin->cur++;\n\t\tif (curpol->weight || curpol->prefix)\n\t\t{\n\t\t\t*(in->cur) = ':';\n\t\t\tin->cur++;\n\t\t\tif (curpol->prefix)\n\t\t\t{\n\t\t\t\t*(in->cur) = '*';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 3))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'A';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 2))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'B';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & (1 << 1))\n\t\t\t{\n\t\t\t\t*(in->cur) = 'C';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t\tif (curpol->weight & 1)\n\t\t\t{\n\t\t\t\t*(in->cur) = 'D';\n\t\t\t\tin->cur++;\n\t\t\t}\n\t\t}\n\t\t*(in->cur) = '\\0';\n\t\tin->curpol++;\n\t}\n\telse if (in->curpol->qoperator.oper == OP_NOT)\n\t{\n\t\tint\t\t\tpriority = QO_PRIORITY(in->curpol);\n\n\t\tif (priority < parentPriority)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \"( \");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t\tRESIZEBUF(in, 1);\n\t\t*(in->cur) = '!';\n\t\tin->cur++;\n\t\t*(in->cur) = '\\0';\n\t\tin->curpol++;\n\n\t\tinfix(in, priority, false);\n\t\tif (priority < parentPriority)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \" )\");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t}\n\telse\n\t{\n\t\tint8\t\top = in->curpol->qoperator.oper;\n\t\tint\t\t\tpriority = QO_PRIORITY(in->curpol);\n\t\tint16\t\tdistance = in->curpol->qoperator.distance;\n\t\tINFIX\t\tnrm;\n\t\tbool\t\tneedParenthesis = false;\n\n\t\tin->curpol++;\n\t\tif (priority < parentPriority ||\n\t\t/* phrase operator depends on order */\n\t\t\t(op == OP_PHRASE && rightPhraseOp))\n\t\t{\n\t\t\tneedParenthesis = true;\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \"( \");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\n\t\tnrm.curpol = in->curpol;\n\t\tnrm.op = in->op;\n\t\tnrm.buflen = 16;\n\t\tnrm.cur = nrm.buf = (char *) palloc(sizeof(char) * nrm.buflen);\n\n\t\t/* get right operand */\n\t\tinfix(&nrm, priority, (op == OP_PHRASE));\n\n\t\t/* get & print left operand */\n\t\tin->curpol = nrm.curpol;\n\t\tinfix(in, priority, false);\n\n\t\t/* print operator & right operand */\n\t\tRESIZEBUF(in, 3 + (2 + 10 /* distance */ ) + (nrm.cur - nrm.buf));\n\t\tswitch (op)\n\t\t{\n\t\t\tcase OP_OR:\n\t\t\t\tsprintf(in->cur, \" | %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tcase OP_AND:\n\t\t\t\tsprintf(in->cur, \" & %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tcase OP_PHRASE:\n\t\t\t\tif (distance != 1)\n\t\t\t\t\tsprintf(in->cur, \" <%d> %s\", distance, nrm.buf);\n\t\t\t\telse\n\t\t\t\t\tsprintf(in->cur, \" <-> %s\", nrm.buf);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* OP_NOT is handled in above if-branch */\n\t\t\t\telog(ERROR, \"unrecognized operator type: %d\", op);\n\t\t}\n\t\tin->cur = strchr(in->cur, '\\0');\n\t\tpfree(nrm.buf);\n\n\t\tif (needParenthesis)\n\t\t{\n\t\t\tRESIZEBUF(in, 2);\n\t\t\tsprintf(in->cur, \" )\");\n\t\t\tin->cur = strchr(in->cur, '\\0');\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "tsqueryin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "942-948",
    "snippet": "Datum\ntsqueryin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *in = PG_GETARG_CSTRING(0);\n\n\tPG_RETURN_TSQUERY(parse_tsquery(in, pushval_asis, PointerGetDatum(NULL), 0));\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TSQUERY",
          "args": [
            "parse_tsquery(in, pushval_asis, PointerGetDatum(NULL), 0)"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_tsquery",
          "args": [
            "in",
            "pushval_asis",
            "PointerGetDatum(NULL)",
            "0"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "parse_tsquery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "816-930",
          "snippet": "TSQuery\nparse_tsquery(char *buf,\n\t\t\t  PushFunction pushval,\n\t\t\t  Datum opaque,\n\t\t\t  int flags)\n{\n\tstruct TSQueryParserStateData state;\n\tint\t\t\ti;\n\tTSQuery\t\tquery;\n\tint\t\t\tcommonlen;\n\tQueryItem  *ptr;\n\tListCell   *cell;\n\tbool\t\tneedcleanup;\n\tint\t\t\ttsv_flags = P_TSV_OPR_IS_DELIM | P_TSV_IS_TSQUERY;\n\n\t/* plain should not be used with web */\n\tAssert((flags & (P_TSQ_PLAIN | P_TSQ_WEB)) != (P_TSQ_PLAIN | P_TSQ_WEB));\n\n\t/* select suitable tokenizer */\n\tif (flags & P_TSQ_PLAIN)\n\t\tstate.gettoken = gettoken_query_plain;\n\telse if (flags & P_TSQ_WEB)\n\t{\n\t\tstate.gettoken = gettoken_query_websearch;\n\t\ttsv_flags |= P_TSV_IS_WEB;\n\t}\n\telse\n\t\tstate.gettoken = gettoken_query_standard;\n\n\t/* init state */\n\tstate.buffer = buf;\n\tstate.buf = buf;\n\tstate.count = 0;\n\tstate.in_quotes = false;\n\tstate.state = WAITFIRSTOPERAND;\n\tstate.polstr = NIL;\n\n\t/* init value parser's state */\n\tstate.valstate = init_tsvector_parser(state.buffer, tsv_flags);\n\n\t/* init list of operand */\n\tstate.sumlen = 0;\n\tstate.lenop = 64;\n\tstate.curop = state.op = (char *) palloc(state.lenop);\n\t*(state.curop) = '\\0';\n\n\t/* parse query & make polish notation (postfix, but in reverse order) */\n\tmakepol(&state, pushval, opaque);\n\n\tclose_tsvector_parser(state.valstate);\n\n\tif (list_length(state.polstr) == 0)\n\t{\n\t\tereport(NOTICE,\n\t\t\t\t(errmsg(\"text-search query doesn't contain lexemes: \\\"%s\\\"\",\n\t\t\t\t\t\tstate.buffer)));\n\t\tquery = (TSQuery) palloc(HDRSIZETQ);\n\t\tSET_VARSIZE(query, HDRSIZETQ);\n\t\tquery->size = 0;\n\t\treturn query;\n\t}\n\n\tif (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tcommonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);\n\n\t/* Pack the QueryItems in the final TSQuery struct to return to caller */\n\tquery = (TSQuery) palloc0(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = list_length(state.polstr);\n\tptr = GETQUERY(query);\n\n\t/* Copy QueryItems to TSQuery */\n\ti = 0;\n\tforeach(cell, state.polstr)\n\t{\n\t\tQueryItem  *item = (QueryItem *) lfirst(cell);\n\n\t\tswitch (item->type)\n\t\t{\n\t\t\tcase QI_VAL:\n\t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperand));\n\t\t\t\tbreak;\n\t\t\tcase QI_VALSTOP:\n\t\t\t\tptr[i].type = QI_VALSTOP;\n\t\t\t\tbreak;\n\t\t\tcase QI_OPR:\n\t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperator));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized QueryItem type: %d\", item->type);\n\t\t}\n\t\ti++;\n\t}\n\n\t/* Copy all the operand strings to TSQuery */\n\tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);\n\tpfree(state.op);\n\n\t/*\n\t * Set left operand pointers for every operator.  While we're at it,\n\t * detect whether there are any QI_VALSTOP nodes.\n\t */\n\tfindoprnd(ptr, query->size, &needcleanup);\n\n\t/*\n\t * If there are QI_VALSTOP nodes, delete them and simplify the tree.\n\t */\n\tif (needcleanup)\n\t\tquery = cleanup_tsquery_stopwords(query);\n\n\treturn query;\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nTSQuery\nparse_tsquery(char *buf,\n\t\t\t  PushFunction pushval,\n\t\t\t  Datum opaque,\n\t\t\t  int flags)\n{\n\tstruct TSQueryParserStateData state;\n\tint\t\t\ti;\n\tTSQuery\t\tquery;\n\tint\t\t\tcommonlen;\n\tQueryItem  *ptr;\n\tListCell   *cell;\n\tbool\t\tneedcleanup;\n\tint\t\t\ttsv_flags = P_TSV_OPR_IS_DELIM | P_TSV_IS_TSQUERY;\n\n\t/* plain should not be used with web */\n\tAssert((flags & (P_TSQ_PLAIN | P_TSQ_WEB)) != (P_TSQ_PLAIN | P_TSQ_WEB));\n\n\t/* select suitable tokenizer */\n\tif (flags & P_TSQ_PLAIN)\n\t\tstate.gettoken = gettoken_query_plain;\n\telse if (flags & P_TSQ_WEB)\n\t{\n\t\tstate.gettoken = gettoken_query_websearch;\n\t\ttsv_flags |= P_TSV_IS_WEB;\n\t}\n\telse\n\t\tstate.gettoken = gettoken_query_standard;\n\n\t/* init state */\n\tstate.buffer = buf;\n\tstate.buf = buf;\n\tstate.count = 0;\n\tstate.in_quotes = false;\n\tstate.state = WAITFIRSTOPERAND;\n\tstate.polstr = NIL;\n\n\t/* init value parser's state */\n\tstate.valstate = init_tsvector_parser(state.buffer, tsv_flags);\n\n\t/* init list of operand */\n\tstate.sumlen = 0;\n\tstate.lenop = 64;\n\tstate.curop = state.op = (char *) palloc(state.lenop);\n\t*(state.curop) = '\\0';\n\n\t/* parse query & make polish notation (postfix, but in reverse order) */\n\tmakepol(&state, pushval, opaque);\n\n\tclose_tsvector_parser(state.valstate);\n\n\tif (list_length(state.polstr) == 0)\n\t{\n\t\tereport(NOTICE,\n\t\t\t\t(errmsg(\"text-search query doesn't contain lexemes: \\\"%s\\\"\",\n\t\t\t\t\t\tstate.buffer)));\n\t\tquery = (TSQuery) palloc(HDRSIZETQ);\n\t\tSET_VARSIZE(query, HDRSIZETQ);\n\t\tquery->size = 0;\n\t\treturn query;\n\t}\n\n\tif (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tcommonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);\n\n\t/* Pack the QueryItems in the final TSQuery struct to return to caller */\n\tquery = (TSQuery) palloc0(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = list_length(state.polstr);\n\tptr = GETQUERY(query);\n\n\t/* Copy QueryItems to TSQuery */\n\ti = 0;\n\tforeach(cell, state.polstr)\n\t{\n\t\tQueryItem  *item = (QueryItem *) lfirst(cell);\n\n\t\tswitch (item->type)\n\t\t{\n\t\t\tcase QI_VAL:\n\t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperand));\n\t\t\t\tbreak;\n\t\t\tcase QI_VALSTOP:\n\t\t\t\tptr[i].type = QI_VALSTOP;\n\t\t\t\tbreak;\n\t\t\tcase QI_OPR:\n\t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperator));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized QueryItem type: %d\", item->type);\n\t\t}\n\t\ti++;\n\t}\n\n\t/* Copy all the operand strings to TSQuery */\n\tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);\n\tpfree(state.op);\n\n\t/*\n\t * Set left operand pointers for every operator.  While we're at it,\n\t * detect whether there are any QI_VALSTOP nodes.\n\t */\n\tfindoprnd(ptr, query->size, &needcleanup);\n\n\t/*\n\t * If there are QI_VALSTOP nodes, delete them and simplify the tree.\n\t */\n\tif (needcleanup)\n\t\tquery = cleanup_tsquery_stopwords(query);\n\n\treturn query;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nDatum\ntsqueryin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *in = PG_GETARG_CSTRING(0);\n\n\tPG_RETURN_TSQUERY(parse_tsquery(in, pushval_asis, PointerGetDatum(NULL), 0));\n}"
  },
  {
    "function_name": "pushval_asis",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "932-937",
    "snippet": "static void\npushval_asis(Datum opaque, TSQueryParserState state, char *strval, int lenval,\n\t\t\t int16 weight, bool prefix)\n{\n\tpushValue(state, strval, lenval, weight, prefix);\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pushValue",
          "args": [
            "state",
            "strval",
            "lenval",
            "weight",
            "prefix"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "pushValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "593-623",
          "snippet": "void\npushValue(TSQueryParserState state, char *strval, int lenval, int16 weight, bool prefix)\n{\n\tpg_crc32\tvalcrc;\n\n\tif (lenval >= MAXSTRLEN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"word is too long in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\tstate->buffer)));\n\n\tINIT_LEGACY_CRC32(valcrc);\n\tCOMP_LEGACY_CRC32(valcrc, strval, lenval);\n\tFIN_LEGACY_CRC32(valcrc);\n\tpushValue_internal(state, valcrc, state->curop - state->op, lenval, weight, prefix);\n\n\t/* append the value string to state.op, enlarging buffer if needed first */\n\twhile (state->curop - state->op + lenval + 1 >= state->lenop)\n\t{\n\t\tint\t\t\tused = state->curop - state->op;\n\n\t\tstate->lenop *= 2;\n\t\tstate->op = (char *) repalloc((void *) state->op, state->lenop);\n\t\tstate->curop = state->op + used;\n\t}\n\tmemcpy((void *) state->curop, (void *) strval, lenval);\n\tstate->curop += lenval;\n\t*(state->curop) = '\\0';\n\tstate->curop++;\n\tstate->sumlen += lenval + 1 /* \\0 */ ;\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nvoid\npushValue(TSQueryParserState state, char *strval, int lenval, int16 weight, bool prefix)\n{\n\tpg_crc32\tvalcrc;\n\n\tif (lenval >= MAXSTRLEN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"word is too long in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\tstate->buffer)));\n\n\tINIT_LEGACY_CRC32(valcrc);\n\tCOMP_LEGACY_CRC32(valcrc, strval, lenval);\n\tFIN_LEGACY_CRC32(valcrc);\n\tpushValue_internal(state, valcrc, state->curop - state->op, lenval, weight, prefix);\n\n\t/* append the value string to state.op, enlarging buffer if needed first */\n\twhile (state->curop - state->op + lenval + 1 >= state->lenop)\n\t{\n\t\tint\t\t\tused = state->curop - state->op;\n\n\t\tstate->lenop *= 2;\n\t\tstate->op = (char *) repalloc((void *) state->op, state->lenop);\n\t\tstate->curop = state->op + used;\n\t}\n\tmemcpy((void *) state->curop, (void *) strval, lenval);\n\tstate->curop += lenval;\n\t*(state->curop) = '\\0';\n\tstate->curop++;\n\tstate->sumlen += lenval + 1 /* \\0 */ ;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic void\npushval_asis(Datum opaque, TSQueryParserState state, char *strval, int lenval,\n\t\t\t int16 weight, bool prefix)\n{\n\tpushValue(state, strval, lenval, weight, prefix);\n}"
  },
  {
    "function_name": "parse_tsquery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "816-930",
    "snippet": "TSQuery\nparse_tsquery(char *buf,\n\t\t\t  PushFunction pushval,\n\t\t\t  Datum opaque,\n\t\t\t  int flags)\n{\n\tstruct TSQueryParserStateData state;\n\tint\t\t\ti;\n\tTSQuery\t\tquery;\n\tint\t\t\tcommonlen;\n\tQueryItem  *ptr;\n\tListCell   *cell;\n\tbool\t\tneedcleanup;\n\tint\t\t\ttsv_flags = P_TSV_OPR_IS_DELIM | P_TSV_IS_TSQUERY;\n\n\t/* plain should not be used with web */\n\tAssert((flags & (P_TSQ_PLAIN | P_TSQ_WEB)) != (P_TSQ_PLAIN | P_TSQ_WEB));\n\n\t/* select suitable tokenizer */\n\tif (flags & P_TSQ_PLAIN)\n\t\tstate.gettoken = gettoken_query_plain;\n\telse if (flags & P_TSQ_WEB)\n\t{\n\t\tstate.gettoken = gettoken_query_websearch;\n\t\ttsv_flags |= P_TSV_IS_WEB;\n\t}\n\telse\n\t\tstate.gettoken = gettoken_query_standard;\n\n\t/* init state */\n\tstate.buffer = buf;\n\tstate.buf = buf;\n\tstate.count = 0;\n\tstate.in_quotes = false;\n\tstate.state = WAITFIRSTOPERAND;\n\tstate.polstr = NIL;\n\n\t/* init value parser's state */\n\tstate.valstate = init_tsvector_parser(state.buffer, tsv_flags);\n\n\t/* init list of operand */\n\tstate.sumlen = 0;\n\tstate.lenop = 64;\n\tstate.curop = state.op = (char *) palloc(state.lenop);\n\t*(state.curop) = '\\0';\n\n\t/* parse query & make polish notation (postfix, but in reverse order) */\n\tmakepol(&state, pushval, opaque);\n\n\tclose_tsvector_parser(state.valstate);\n\n\tif (list_length(state.polstr) == 0)\n\t{\n\t\tereport(NOTICE,\n\t\t\t\t(errmsg(\"text-search query doesn't contain lexemes: \\\"%s\\\"\",\n\t\t\t\t\t\tstate.buffer)));\n\t\tquery = (TSQuery) palloc(HDRSIZETQ);\n\t\tSET_VARSIZE(query, HDRSIZETQ);\n\t\tquery->size = 0;\n\t\treturn query;\n\t}\n\n\tif (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tcommonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);\n\n\t/* Pack the QueryItems in the final TSQuery struct to return to caller */\n\tquery = (TSQuery) palloc0(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = list_length(state.polstr);\n\tptr = GETQUERY(query);\n\n\t/* Copy QueryItems to TSQuery */\n\ti = 0;\n\tforeach(cell, state.polstr)\n\t{\n\t\tQueryItem  *item = (QueryItem *) lfirst(cell);\n\n\t\tswitch (item->type)\n\t\t{\n\t\t\tcase QI_VAL:\n\t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperand));\n\t\t\t\tbreak;\n\t\t\tcase QI_VALSTOP:\n\t\t\t\tptr[i].type = QI_VALSTOP;\n\t\t\t\tbreak;\n\t\t\tcase QI_OPR:\n\t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperator));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized QueryItem type: %d\", item->type);\n\t\t}\n\t\ti++;\n\t}\n\n\t/* Copy all the operand strings to TSQuery */\n\tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);\n\tpfree(state.op);\n\n\t/*\n\t * Set left operand pointers for every operator.  While we're at it,\n\t * detect whether there are any QI_VALSTOP nodes.\n\t */\n\tfindoprnd(ptr, query->size, &needcleanup);\n\n\t/*\n\t * If there are QI_VALSTOP nodes, delete them and simplify the tree.\n\t */\n\tif (needcleanup)\n\t\tquery = cleanup_tsquery_stopwords(query);\n\n\treturn query;\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_tsquery_stopwords",
          "args": [
            "query"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_tsquery_stopwords",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "385-444",
          "snippet": "TSQuery\ncleanup_tsquery_stopwords(TSQuery in)\n{\n\tint32\t\tlen,\n\t\t\t\tlenstr,\n\t\t\t\tcommonlen,\n\t\t\t\ti;\n\tNODE\t   *root;\n\tint\t\t\tladd,\n\t\t\t\tradd;\n\tTSQuery\t\tout;\n\tQueryItem  *items;\n\tchar\t   *operands;\n\n\tif (in->size == 0)\n\t\treturn in;\n\n\t/* eliminate stop words */\n\troot = clean_stopword_intree(maketree(GETQUERY(in)), &ladd, &radd);\n\tif (root == NULL)\n\t{\n\t\tereport(NOTICE,\n\t\t\t\t(errmsg(\"text-search query contains only stop words or doesn't contain lexemes, ignored\")));\n\t\tout = palloc(HDRSIZETQ);\n\t\tout->size = 0;\n\t\tSET_VARSIZE(out, HDRSIZETQ);\n\t\treturn out;\n\t}\n\n\t/*\n\t * Build TSQuery from plain view\n\t */\n\n\tlenstr = calcstrlen(root);\n\titems = plaintree(root, &len);\n\tcommonlen = COMPUTESIZE(len, lenstr);\n\n\tout = palloc(commonlen);\n\tSET_VARSIZE(out, commonlen);\n\tout->size = len;\n\n\tmemcpy(GETQUERY(out), items, len * sizeof(QueryItem));\n\n\titems = GETQUERY(out);\n\toperands = GETOPERAND(out);\n\tfor (i = 0; i < out->size; i++)\n\t{\n\t\tQueryOperand *op = (QueryOperand *) &items[i];\n\n\t\tif (op->type != QI_VAL)\n\t\t\tcontinue;\n\n\t\tmemcpy(operands, GETOPERAND(in) + op->distance, op->length);\n\t\toperands[op->length] = '\\0';\n\t\top->distance = operands - GETOPERAND(out);\n\t\toperands += op->length + 1;\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nTSQuery\ncleanup_tsquery_stopwords(TSQuery in)\n{\n\tint32\t\tlen,\n\t\t\t\tlenstr,\n\t\t\t\tcommonlen,\n\t\t\t\ti;\n\tNODE\t   *root;\n\tint\t\t\tladd,\n\t\t\t\tradd;\n\tTSQuery\t\tout;\n\tQueryItem  *items;\n\tchar\t   *operands;\n\n\tif (in->size == 0)\n\t\treturn in;\n\n\t/* eliminate stop words */\n\troot = clean_stopword_intree(maketree(GETQUERY(in)), &ladd, &radd);\n\tif (root == NULL)\n\t{\n\t\tereport(NOTICE,\n\t\t\t\t(errmsg(\"text-search query contains only stop words or doesn't contain lexemes, ignored\")));\n\t\tout = palloc(HDRSIZETQ);\n\t\tout->size = 0;\n\t\tSET_VARSIZE(out, HDRSIZETQ);\n\t\treturn out;\n\t}\n\n\t/*\n\t * Build TSQuery from plain view\n\t */\n\n\tlenstr = calcstrlen(root);\n\titems = plaintree(root, &len);\n\tcommonlen = COMPUTESIZE(len, lenstr);\n\n\tout = palloc(commonlen);\n\tSET_VARSIZE(out, commonlen);\n\tout->size = len;\n\n\tmemcpy(GETQUERY(out), items, len * sizeof(QueryItem));\n\n\titems = GETQUERY(out);\n\toperands = GETOPERAND(out);\n\tfor (i = 0; i < out->size; i++)\n\t{\n\t\tQueryOperand *op = (QueryOperand *) &items[i];\n\n\t\tif (op->type != QI_VAL)\n\t\t\tcontinue;\n\n\t\tmemcpy(operands, GETOPERAND(in) + op->distance, op->length);\n\t\toperands[op->length] = '\\0';\n\t\top->distance = operands - GETOPERAND(out);\n\t\toperands += op->length + 1;\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "findoprnd",
          "args": [
            "ptr",
            "query->size",
            "&needcleanup"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "findoprnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "791-802",
          "snippet": "static void\nfindoprnd(QueryItem *ptr, int size, bool *needcleanup)\n{\n\tuint32\t\tpos;\n\n\t*needcleanup = false;\n\tpos = 0;\n\tfindoprnd_recurse(ptr, &pos, size, needcleanup);\n\n\tif (pos != size)\n\t\telog(ERROR, \"malformed tsquery: extra nodes\");\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic void\nfindoprnd(QueryItem *ptr, int size, bool *needcleanup)\n{\n\tuint32\t\tpos;\n\n\t*needcleanup = false;\n\tpos = 0;\n\tfindoprnd_recurse(ptr, &pos, size, needcleanup);\n\n\tif (pos != size)\n\t\telog(ERROR, \"malformed tsquery: extra nodes\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "state.op"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *) GETOPERAND(query)",
            "(void *) state.op",
            "state.sumlen"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "query"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized QueryItem type: %d\"",
            "item->type"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&ptr[i]",
            "item",
            "sizeof(QueryOperator)"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&ptr[i]",
            "item",
            "sizeof(QueryOperand)"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "cell"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell",
            "state.polstr"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "query"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "state.polstr"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "query",
            "commonlen"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "commonlen"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COMPUTESIZE",
          "args": [
            "list_length(state.polstr)",
            "state.sumlen"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "state.polstr"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\"))"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"tsquery is too large\""
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSQUERY_TOO_BIG",
          "args": [
            "list_length(state.polstr)",
            "state.sumlen"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "state.polstr"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "query",
            "HDRSIZETQ"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "HDRSIZETQ"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "NOTICE",
            "(errmsg(\"text-search query doesn't contain lexemes: \\\"%s\\\"\",\n\t\t\t\t\t\tstate.buffer))"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "state.polstr"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_tsvector_parser",
          "args": [
            "state.valstate"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "close_tsvector_parser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_parser.c",
          "lines": "75-80",
          "snippet": "void\nclose_tsvector_parser(TSVectorParseState state)\n{\n\tpfree(state->word);\n\tpfree(state);\n}",
          "includes": [
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"postgres.h\"\n\nvoid\nclose_tsvector_parser(TSVectorParseState state)\n{\n\tpfree(state->word);\n\tpfree(state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "makepol",
          "args": [
            "&state",
            "pushval",
            "opaque"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "makepol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "685-731",
          "snippet": "static void\nmakepol(TSQueryParserState state,\n\t\tPushFunction pushval,\n\t\tDatum opaque)\n{\n\tint8\t\toperator = 0;\n\tts_tokentype type;\n\tint\t\t\tlenval = 0;\n\tchar\t   *strval = NULL;\n\tOperatorElement opstack[STACKDEPTH];\n\tint\t\t\tlenstack = 0;\n\tint16\t\tweight = 0;\n\tbool\t\tprefix;\n\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\twhile ((type = state->gettoken(state, &operator,\n\t\t\t\t\t\t\t\t   &lenval, &strval,\n\t\t\t\t\t\t\t\t   &weight, &prefix)) != PT_END)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase PT_VAL:\n\t\t\t\tpushval(opaque, state, strval, lenval, weight, prefix);\n\t\t\t\tbreak;\n\t\t\tcase PT_OPR:\n\t\t\t\tcleanOpStack(state, opstack, &lenstack, operator);\n\t\t\t\tpushOpStack(opstack, &lenstack, operator, weight);\n\t\t\t\tbreak;\n\t\t\tcase PT_OPEN:\n\t\t\t\tmakepol(state, pushval, opaque);\n\t\t\t\tbreak;\n\t\t\tcase PT_CLOSE:\n\t\t\t\tcleanOpStack(state, opstack, &lenstack, OP_OR /* lowest */ );\n\t\t\t\treturn;\n\t\t\tcase PT_ERR:\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"syntax error in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstate->buffer)));\n\t\t}\n\t}\n\n\tcleanOpStack(state, opstack, &lenstack, OP_OR /* lowest */ );\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define STACKDEPTH\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\n#define STACKDEPTH\t32\n\nstatic void\nmakepol(TSQueryParserState state,\n\t\tPushFunction pushval,\n\t\tDatum opaque)\n{\n\tint8\t\toperator = 0;\n\tts_tokentype type;\n\tint\t\t\tlenval = 0;\n\tchar\t   *strval = NULL;\n\tOperatorElement opstack[STACKDEPTH];\n\tint\t\t\tlenstack = 0;\n\tint16\t\tweight = 0;\n\tbool\t\tprefix;\n\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\twhile ((type = state->gettoken(state, &operator,\n\t\t\t\t\t\t\t\t   &lenval, &strval,\n\t\t\t\t\t\t\t\t   &weight, &prefix)) != PT_END)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase PT_VAL:\n\t\t\t\tpushval(opaque, state, strval, lenval, weight, prefix);\n\t\t\t\tbreak;\n\t\t\tcase PT_OPR:\n\t\t\t\tcleanOpStack(state, opstack, &lenstack, operator);\n\t\t\t\tpushOpStack(opstack, &lenstack, operator, weight);\n\t\t\t\tbreak;\n\t\t\tcase PT_OPEN:\n\t\t\t\tmakepol(state, pushval, opaque);\n\t\t\t\tbreak;\n\t\t\tcase PT_CLOSE:\n\t\t\t\tcleanOpStack(state, opstack, &lenstack, OP_OR /* lowest */ );\n\t\t\t\treturn;\n\t\t\tcase PT_ERR:\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"syntax error in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstate->buffer)));\n\t\t}\n\t}\n\n\tcleanOpStack(state, opstack, &lenstack, OP_OR /* lowest */ );\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_tsvector_parser",
          "args": [
            "state.buffer",
            "tsv_flags"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "init_tsvector_parser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_parser.c",
          "lines": "45-61",
          "snippet": "TSVectorParseState\ninit_tsvector_parser(char *input, int flags)\n{\n\tTSVectorParseState state;\n\n\tstate = (TSVectorParseState) palloc(sizeof(struct TSVectorParseStateData));\n\tstate->prsbuf = input;\n\tstate->bufstart = input;\n\tstate->len = 32;\n\tstate->word = (char *) palloc(state->len);\n\tstate->eml = pg_database_encoding_max_length();\n\tstate->oprisdelim = (flags & P_TSV_OPR_IS_DELIM) != 0;\n\tstate->is_tsquery = (flags & P_TSV_IS_TSQUERY) != 0;\n\tstate->is_web = (flags & P_TSV_IS_WEB) != 0;\n\n\treturn state;\n}",
          "includes": [
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"postgres.h\"\n\nTSVectorParseState\ninit_tsvector_parser(char *input, int flags)\n{\n\tTSVectorParseState state;\n\n\tstate = (TSVectorParseState) palloc(sizeof(struct TSVectorParseStateData));\n\tstate->prsbuf = input;\n\tstate->bufstart = input;\n\tstate->len = 32;\n\tstate->word = (char *) palloc(state->len);\n\tstate->eml = pg_database_encoding_max_length();\n\tstate->oprisdelim = (flags & P_TSV_OPR_IS_DELIM) != 0;\n\tstate->is_tsquery = (flags & P_TSV_IS_TSQUERY) != 0;\n\tstate->is_web = (flags & P_TSV_IS_WEB) != 0;\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "(flags & (P_TSQ_PLAIN | P_TSQ_WEB)) != (P_TSQ_PLAIN | P_TSQ_WEB)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nTSQuery\nparse_tsquery(char *buf,\n\t\t\t  PushFunction pushval,\n\t\t\t  Datum opaque,\n\t\t\t  int flags)\n{\n\tstruct TSQueryParserStateData state;\n\tint\t\t\ti;\n\tTSQuery\t\tquery;\n\tint\t\t\tcommonlen;\n\tQueryItem  *ptr;\n\tListCell   *cell;\n\tbool\t\tneedcleanup;\n\tint\t\t\ttsv_flags = P_TSV_OPR_IS_DELIM | P_TSV_IS_TSQUERY;\n\n\t/* plain should not be used with web */\n\tAssert((flags & (P_TSQ_PLAIN | P_TSQ_WEB)) != (P_TSQ_PLAIN | P_TSQ_WEB));\n\n\t/* select suitable tokenizer */\n\tif (flags & P_TSQ_PLAIN)\n\t\tstate.gettoken = gettoken_query_plain;\n\telse if (flags & P_TSQ_WEB)\n\t{\n\t\tstate.gettoken = gettoken_query_websearch;\n\t\ttsv_flags |= P_TSV_IS_WEB;\n\t}\n\telse\n\t\tstate.gettoken = gettoken_query_standard;\n\n\t/* init state */\n\tstate.buffer = buf;\n\tstate.buf = buf;\n\tstate.count = 0;\n\tstate.in_quotes = false;\n\tstate.state = WAITFIRSTOPERAND;\n\tstate.polstr = NIL;\n\n\t/* init value parser's state */\n\tstate.valstate = init_tsvector_parser(state.buffer, tsv_flags);\n\n\t/* init list of operand */\n\tstate.sumlen = 0;\n\tstate.lenop = 64;\n\tstate.curop = state.op = (char *) palloc(state.lenop);\n\t*(state.curop) = '\\0';\n\n\t/* parse query & make polish notation (postfix, but in reverse order) */\n\tmakepol(&state, pushval, opaque);\n\n\tclose_tsvector_parser(state.valstate);\n\n\tif (list_length(state.polstr) == 0)\n\t{\n\t\tereport(NOTICE,\n\t\t\t\t(errmsg(\"text-search query doesn't contain lexemes: \\\"%s\\\"\",\n\t\t\t\t\t\tstate.buffer)));\n\t\tquery = (TSQuery) palloc(HDRSIZETQ);\n\t\tSET_VARSIZE(query, HDRSIZETQ);\n\t\tquery->size = 0;\n\t\treturn query;\n\t}\n\n\tif (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tcommonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);\n\n\t/* Pack the QueryItems in the final TSQuery struct to return to caller */\n\tquery = (TSQuery) palloc0(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = list_length(state.polstr);\n\tptr = GETQUERY(query);\n\n\t/* Copy QueryItems to TSQuery */\n\ti = 0;\n\tforeach(cell, state.polstr)\n\t{\n\t\tQueryItem  *item = (QueryItem *) lfirst(cell);\n\n\t\tswitch (item->type)\n\t\t{\n\t\t\tcase QI_VAL:\n\t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperand));\n\t\t\t\tbreak;\n\t\t\tcase QI_VALSTOP:\n\t\t\t\tptr[i].type = QI_VALSTOP;\n\t\t\t\tbreak;\n\t\t\tcase QI_OPR:\n\t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperator));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized QueryItem type: %d\", item->type);\n\t\t}\n\t\ti++;\n\t}\n\n\t/* Copy all the operand strings to TSQuery */\n\tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);\n\tpfree(state.op);\n\n\t/*\n\t * Set left operand pointers for every operator.  While we're at it,\n\t * detect whether there are any QI_VALSTOP nodes.\n\t */\n\tfindoprnd(ptr, query->size, &needcleanup);\n\n\t/*\n\t * If there are QI_VALSTOP nodes, delete them and simplify the tree.\n\t */\n\tif (needcleanup)\n\t\tquery = cleanup_tsquery_stopwords(query);\n\n\treturn query;\n}"
  },
  {
    "function_name": "findoprnd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "791-802",
    "snippet": "static void\nfindoprnd(QueryItem *ptr, int size, bool *needcleanup)\n{\n\tuint32\t\tpos;\n\n\t*needcleanup = false;\n\tpos = 0;\n\tfindoprnd_recurse(ptr, &pos, size, needcleanup);\n\n\tif (pos != size)\n\t\telog(ERROR, \"malformed tsquery: extra nodes\");\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"malformed tsquery: extra nodes\""
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "findoprnd_recurse",
          "args": [
            "ptr",
            "&pos",
            "size",
            "needcleanup"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "findoprnd_recurse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "733-783",
          "snippet": "static void\nfindoprnd_recurse(QueryItem *ptr, uint32 *pos, int nnodes, bool *needcleanup)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (*pos >= nnodes)\n\t\telog(ERROR, \"malformed tsquery: operand not found\");\n\n\tif (ptr[*pos].type == QI_VAL)\n\t{\n\t\t(*pos)++;\n\t}\n\telse if (ptr[*pos].type == QI_VALSTOP)\n\t{\n\t\t*needcleanup = true;\t/* we'll have to remove stop words */\n\t\t(*pos)++;\n\t}\n\telse\n\t{\n\t\tAssert(ptr[*pos].type == QI_OPR);\n\n\t\tif (ptr[*pos].qoperator.oper == OP_NOT)\n\t\t{\n\t\t\tptr[*pos].qoperator.left = 1;\t/* fixed offset */\n\t\t\t(*pos)++;\n\n\t\t\t/* process the only argument */\n\t\t\tfindoprnd_recurse(ptr, pos, nnodes, needcleanup);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tQueryOperator *curitem = &ptr[*pos].qoperator;\n\t\t\tint\t\t\ttmp = *pos; /* save current position */\n\n\t\t\tAssert(curitem->oper == OP_AND ||\n\t\t\t\t   curitem->oper == OP_OR ||\n\t\t\t\t   curitem->oper == OP_PHRASE);\n\n\t\t\t(*pos)++;\n\n\t\t\t/* process RIGHT argument */\n\t\t\tfindoprnd_recurse(ptr, pos, nnodes, needcleanup);\n\n\t\t\tcuritem->left = *pos - tmp; /* set LEFT arg's offset */\n\n\t\t\t/* process LEFT argument */\n\t\t\tfindoprnd_recurse(ptr, pos, nnodes, needcleanup);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic void\nfindoprnd_recurse(QueryItem *ptr, uint32 *pos, int nnodes, bool *needcleanup)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (*pos >= nnodes)\n\t\telog(ERROR, \"malformed tsquery: operand not found\");\n\n\tif (ptr[*pos].type == QI_VAL)\n\t{\n\t\t(*pos)++;\n\t}\n\telse if (ptr[*pos].type == QI_VALSTOP)\n\t{\n\t\t*needcleanup = true;\t/* we'll have to remove stop words */\n\t\t(*pos)++;\n\t}\n\telse\n\t{\n\t\tAssert(ptr[*pos].type == QI_OPR);\n\n\t\tif (ptr[*pos].qoperator.oper == OP_NOT)\n\t\t{\n\t\t\tptr[*pos].qoperator.left = 1;\t/* fixed offset */\n\t\t\t(*pos)++;\n\n\t\t\t/* process the only argument */\n\t\t\tfindoprnd_recurse(ptr, pos, nnodes, needcleanup);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tQueryOperator *curitem = &ptr[*pos].qoperator;\n\t\t\tint\t\t\ttmp = *pos; /* save current position */\n\n\t\t\tAssert(curitem->oper == OP_AND ||\n\t\t\t\t   curitem->oper == OP_OR ||\n\t\t\t\t   curitem->oper == OP_PHRASE);\n\n\t\t\t(*pos)++;\n\n\t\t\t/* process RIGHT argument */\n\t\t\tfindoprnd_recurse(ptr, pos, nnodes, needcleanup);\n\n\t\t\tcuritem->left = *pos - tmp; /* set LEFT arg's offset */\n\n\t\t\t/* process LEFT argument */\n\t\t\tfindoprnd_recurse(ptr, pos, nnodes, needcleanup);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic void\nfindoprnd(QueryItem *ptr, int size, bool *needcleanup)\n{\n\tuint32\t\tpos;\n\n\t*needcleanup = false;\n\tpos = 0;\n\tfindoprnd_recurse(ptr, &pos, size, needcleanup);\n\n\tif (pos != size)\n\t\telog(ERROR, \"malformed tsquery: extra nodes\");\n}"
  },
  {
    "function_name": "findoprnd_recurse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "733-783",
    "snippet": "static void\nfindoprnd_recurse(QueryItem *ptr, uint32 *pos, int nnodes, bool *needcleanup)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (*pos >= nnodes)\n\t\telog(ERROR, \"malformed tsquery: operand not found\");\n\n\tif (ptr[*pos].type == QI_VAL)\n\t{\n\t\t(*pos)++;\n\t}\n\telse if (ptr[*pos].type == QI_VALSTOP)\n\t{\n\t\t*needcleanup = true;\t/* we'll have to remove stop words */\n\t\t(*pos)++;\n\t}\n\telse\n\t{\n\t\tAssert(ptr[*pos].type == QI_OPR);\n\n\t\tif (ptr[*pos].qoperator.oper == OP_NOT)\n\t\t{\n\t\t\tptr[*pos].qoperator.left = 1;\t/* fixed offset */\n\t\t\t(*pos)++;\n\n\t\t\t/* process the only argument */\n\t\t\tfindoprnd_recurse(ptr, pos, nnodes, needcleanup);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tQueryOperator *curitem = &ptr[*pos].qoperator;\n\t\t\tint\t\t\ttmp = *pos; /* save current position */\n\n\t\t\tAssert(curitem->oper == OP_AND ||\n\t\t\t\t   curitem->oper == OP_OR ||\n\t\t\t\t   curitem->oper == OP_PHRASE);\n\n\t\t\t(*pos)++;\n\n\t\t\t/* process RIGHT argument */\n\t\t\tfindoprnd_recurse(ptr, pos, nnodes, needcleanup);\n\n\t\t\tcuritem->left = *pos - tmp; /* set LEFT arg's offset */\n\n\t\t\t/* process LEFT argument */\n\t\t\tfindoprnd_recurse(ptr, pos, nnodes, needcleanup);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "findoprnd_recurse",
          "args": [
            "ptr",
            "pos",
            "nnodes",
            "needcleanup"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "findoprnd_recurse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "733-783",
          "snippet": "static void\nfindoprnd_recurse(QueryItem *ptr, uint32 *pos, int nnodes, bool *needcleanup)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (*pos >= nnodes)\n\t\telog(ERROR, \"malformed tsquery: operand not found\");\n\n\tif (ptr[*pos].type == QI_VAL)\n\t{\n\t\t(*pos)++;\n\t}\n\telse if (ptr[*pos].type == QI_VALSTOP)\n\t{\n\t\t*needcleanup = true;\t/* we'll have to remove stop words */\n\t\t(*pos)++;\n\t}\n\telse\n\t{\n\t\tAssert(ptr[*pos].type == QI_OPR);\n\n\t\tif (ptr[*pos].qoperator.oper == OP_NOT)\n\t\t{\n\t\t\tptr[*pos].qoperator.left = 1;\t/* fixed offset */\n\t\t\t(*pos)++;\n\n\t\t\t/* process the only argument */\n\t\t\tfindoprnd_recurse(ptr, pos, nnodes, needcleanup);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tQueryOperator *curitem = &ptr[*pos].qoperator;\n\t\t\tint\t\t\ttmp = *pos; /* save current position */\n\n\t\t\tAssert(curitem->oper == OP_AND ||\n\t\t\t\t   curitem->oper == OP_OR ||\n\t\t\t\t   curitem->oper == OP_PHRASE);\n\n\t\t\t(*pos)++;\n\n\t\t\t/* process RIGHT argument */\n\t\t\tfindoprnd_recurse(ptr, pos, nnodes, needcleanup);\n\n\t\t\tcuritem->left = *pos - tmp; /* set LEFT arg's offset */\n\n\t\t\t/* process LEFT argument */\n\t\t\tfindoprnd_recurse(ptr, pos, nnodes, needcleanup);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "curitem->oper == OP_AND ||\n\t\t\t\t   curitem->oper == OP_OR ||\n\t\t\t\t   curitem->oper == OP_PHRASE"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ptr[*pos].type == QI_OPR"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"malformed tsquery: operand not found\""
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic void\nfindoprnd_recurse(QueryItem *ptr, uint32 *pos, int nnodes, bool *needcleanup)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (*pos >= nnodes)\n\t\telog(ERROR, \"malformed tsquery: operand not found\");\n\n\tif (ptr[*pos].type == QI_VAL)\n\t{\n\t\t(*pos)++;\n\t}\n\telse if (ptr[*pos].type == QI_VALSTOP)\n\t{\n\t\t*needcleanup = true;\t/* we'll have to remove stop words */\n\t\t(*pos)++;\n\t}\n\telse\n\t{\n\t\tAssert(ptr[*pos].type == QI_OPR);\n\n\t\tif (ptr[*pos].qoperator.oper == OP_NOT)\n\t\t{\n\t\t\tptr[*pos].qoperator.left = 1;\t/* fixed offset */\n\t\t\t(*pos)++;\n\n\t\t\t/* process the only argument */\n\t\t\tfindoprnd_recurse(ptr, pos, nnodes, needcleanup);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tQueryOperator *curitem = &ptr[*pos].qoperator;\n\t\t\tint\t\t\ttmp = *pos; /* save current position */\n\n\t\t\tAssert(curitem->oper == OP_AND ||\n\t\t\t\t   curitem->oper == OP_OR ||\n\t\t\t\t   curitem->oper == OP_PHRASE);\n\n\t\t\t(*pos)++;\n\n\t\t\t/* process RIGHT argument */\n\t\t\tfindoprnd_recurse(ptr, pos, nnodes, needcleanup);\n\n\t\t\tcuritem->left = *pos - tmp; /* set LEFT arg's offset */\n\n\t\t\t/* process LEFT argument */\n\t\t\tfindoprnd_recurse(ptr, pos, nnodes, needcleanup);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "makepol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "685-731",
    "snippet": "static void\nmakepol(TSQueryParserState state,\n\t\tPushFunction pushval,\n\t\tDatum opaque)\n{\n\tint8\t\toperator = 0;\n\tts_tokentype type;\n\tint\t\t\tlenval = 0;\n\tchar\t   *strval = NULL;\n\tOperatorElement opstack[STACKDEPTH];\n\tint\t\t\tlenstack = 0;\n\tint16\t\tweight = 0;\n\tbool\t\tprefix;\n\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\twhile ((type = state->gettoken(state, &operator,\n\t\t\t\t\t\t\t\t   &lenval, &strval,\n\t\t\t\t\t\t\t\t   &weight, &prefix)) != PT_END)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase PT_VAL:\n\t\t\t\tpushval(opaque, state, strval, lenval, weight, prefix);\n\t\t\t\tbreak;\n\t\t\tcase PT_OPR:\n\t\t\t\tcleanOpStack(state, opstack, &lenstack, operator);\n\t\t\t\tpushOpStack(opstack, &lenstack, operator, weight);\n\t\t\t\tbreak;\n\t\t\tcase PT_OPEN:\n\t\t\t\tmakepol(state, pushval, opaque);\n\t\t\t\tbreak;\n\t\t\tcase PT_CLOSE:\n\t\t\t\tcleanOpStack(state, opstack, &lenstack, OP_OR /* lowest */ );\n\t\t\t\treturn;\n\t\t\tcase PT_ERR:\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"syntax error in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstate->buffer)));\n\t\t}\n\t}\n\n\tcleanOpStack(state, opstack, &lenstack, OP_OR /* lowest */ );\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define STACKDEPTH\t32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanOpStack",
          "args": [
            "state",
            "opstack",
            "&lenstack",
            "OP_OR/* lowest */"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "cleanOpStack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "661-678",
          "snippet": "static void\ncleanOpStack(TSQueryParserState state,\n\t\t\t OperatorElement *stack, int *lenstack, int8 op)\n{\n\tint\t\t\topPriority = OP_PRIORITY(op);\n\n\twhile (*lenstack)\n\t{\n\t\t/* NOT is right associative unlike to others */\n\t\tif ((op != OP_NOT && opPriority > OP_PRIORITY(stack[*lenstack - 1].op)) ||\n\t\t\t(op == OP_NOT && opPriority >= OP_PRIORITY(stack[*lenstack - 1].op)))\n\t\t\tbreak;\n\n\t\t(*lenstack)--;\n\t\tpushOperator(state, stack[*lenstack].op,\n\t\t\t\t\t stack[*lenstack].distance);\n\t}\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic void\ncleanOpStack(TSQueryParserState state,\n\t\t\t OperatorElement *stack, int *lenstack, int8 op)\n{\n\tint\t\t\topPriority = OP_PRIORITY(op);\n\n\twhile (*lenstack)\n\t{\n\t\t/* NOT is right associative unlike to others */\n\t\tif ((op != OP_NOT && opPriority > OP_PRIORITY(stack[*lenstack - 1].op)) ||\n\t\t\t(op == OP_NOT && opPriority >= OP_PRIORITY(stack[*lenstack - 1].op)))\n\t\t\tbreak;\n\n\t\t(*lenstack)--;\n\t\tpushOperator(state, stack[*lenstack].op,\n\t\t\t\t\t stack[*lenstack].distance);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"syntax error in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstate->buffer))"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"syntax error in tsquery: \\\"%s\\\"\"",
            "state->buffer"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_SYNTAX_ERROR"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "makepol",
          "args": [
            "state",
            "pushval",
            "opaque"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "makepol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "685-731",
          "snippet": "static void\nmakepol(TSQueryParserState state,\n\t\tPushFunction pushval,\n\t\tDatum opaque)\n{\n\tint8\t\toperator = 0;\n\tts_tokentype type;\n\tint\t\t\tlenval = 0;\n\tchar\t   *strval = NULL;\n\tOperatorElement opstack[STACKDEPTH];\n\tint\t\t\tlenstack = 0;\n\tint16\t\tweight = 0;\n\tbool\t\tprefix;\n\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\twhile ((type = state->gettoken(state, &operator,\n\t\t\t\t\t\t\t\t   &lenval, &strval,\n\t\t\t\t\t\t\t\t   &weight, &prefix)) != PT_END)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase PT_VAL:\n\t\t\t\tpushval(opaque, state, strval, lenval, weight, prefix);\n\t\t\t\tbreak;\n\t\t\tcase PT_OPR:\n\t\t\t\tcleanOpStack(state, opstack, &lenstack, operator);\n\t\t\t\tpushOpStack(opstack, &lenstack, operator, weight);\n\t\t\t\tbreak;\n\t\t\tcase PT_OPEN:\n\t\t\t\tmakepol(state, pushval, opaque);\n\t\t\t\tbreak;\n\t\t\tcase PT_CLOSE:\n\t\t\t\tcleanOpStack(state, opstack, &lenstack, OP_OR /* lowest */ );\n\t\t\t\treturn;\n\t\t\tcase PT_ERR:\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"syntax error in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstate->buffer)));\n\t\t}\n\t}\n\n\tcleanOpStack(state, opstack, &lenstack, OP_OR /* lowest */ );\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pushOpStack",
          "args": [
            "opstack",
            "&lenstack",
            "operator",
            "weight"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "pushOpStack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "649-659",
          "snippet": "static void\npushOpStack(OperatorElement *stack, int *lenstack, int8 op, int16 distance)\n{\n\tif (*lenstack == STACKDEPTH)\t/* internal error */\n\t\telog(ERROR, \"tsquery stack too small\");\n\n\tstack[*lenstack].op = op;\n\tstack[*lenstack].distance = distance;\n\n\t(*lenstack)++;\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define STACKDEPTH\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\n#define STACKDEPTH\t32\n\nstatic void\npushOpStack(OperatorElement *stack, int *lenstack, int8 op, int16 distance)\n{\n\tif (*lenstack == STACKDEPTH)\t/* internal error */\n\t\telog(ERROR, \"tsquery stack too small\");\n\n\tstack[*lenstack].op = op;\n\tstack[*lenstack].distance = distance;\n\n\t(*lenstack)++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushval",
          "args": [
            "opaque",
            "state",
            "strval",
            "lenval",
            "weight",
            "prefix"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "pushval_asis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "932-937",
          "snippet": "static void\npushval_asis(Datum opaque, TSQueryParserState state, char *strval, int lenval,\n\t\t\t int16 weight, bool prefix)\n{\n\tpushValue(state, strval, lenval, weight, prefix);\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic void\npushval_asis(Datum opaque, TSQueryParserState state, char *strval, int lenval,\n\t\t\t int16 weight, bool prefix)\n{\n\tpushValue(state, strval, lenval, weight, prefix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "state->gettoken",
          "args": [
            "state",
            "&operator",
            "&lenval",
            "&strval",
            "&weight",
            "&prefix"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\n#define STACKDEPTH\t32\n\nstatic void\nmakepol(TSQueryParserState state,\n\t\tPushFunction pushval,\n\t\tDatum opaque)\n{\n\tint8\t\toperator = 0;\n\tts_tokentype type;\n\tint\t\t\tlenval = 0;\n\tchar\t   *strval = NULL;\n\tOperatorElement opstack[STACKDEPTH];\n\tint\t\t\tlenstack = 0;\n\tint16\t\tweight = 0;\n\tbool\t\tprefix;\n\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\twhile ((type = state->gettoken(state, &operator,\n\t\t\t\t\t\t\t\t   &lenval, &strval,\n\t\t\t\t\t\t\t\t   &weight, &prefix)) != PT_END)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase PT_VAL:\n\t\t\t\tpushval(opaque, state, strval, lenval, weight, prefix);\n\t\t\t\tbreak;\n\t\t\tcase PT_OPR:\n\t\t\t\tcleanOpStack(state, opstack, &lenstack, operator);\n\t\t\t\tpushOpStack(opstack, &lenstack, operator, weight);\n\t\t\t\tbreak;\n\t\t\tcase PT_OPEN:\n\t\t\t\tmakepol(state, pushval, opaque);\n\t\t\t\tbreak;\n\t\t\tcase PT_CLOSE:\n\t\t\t\tcleanOpStack(state, opstack, &lenstack, OP_OR /* lowest */ );\n\t\t\t\treturn;\n\t\t\tcase PT_ERR:\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"syntax error in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstate->buffer)));\n\t\t}\n\t}\n\n\tcleanOpStack(state, opstack, &lenstack, OP_OR /* lowest */ );\n}"
  },
  {
    "function_name": "cleanOpStack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "661-678",
    "snippet": "static void\ncleanOpStack(TSQueryParserState state,\n\t\t\t OperatorElement *stack, int *lenstack, int8 op)\n{\n\tint\t\t\topPriority = OP_PRIORITY(op);\n\n\twhile (*lenstack)\n\t{\n\t\t/* NOT is right associative unlike to others */\n\t\tif ((op != OP_NOT && opPriority > OP_PRIORITY(stack[*lenstack - 1].op)) ||\n\t\t\t(op == OP_NOT && opPriority >= OP_PRIORITY(stack[*lenstack - 1].op)))\n\t\t\tbreak;\n\n\t\t(*lenstack)--;\n\t\tpushOperator(state, stack[*lenstack].op,\n\t\t\t\t\t stack[*lenstack].distance);\n\t}\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pushOperator",
          "args": [
            "state",
            "stack[*lenstack].op",
            "stack[*lenstack].distance"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "pushOperator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "544-558",
          "snippet": "void\npushOperator(TSQueryParserState state, int8 oper, int16 distance)\n{\n\tQueryOperator *tmp;\n\n\tAssert(oper == OP_NOT || oper == OP_AND || oper == OP_OR || oper == OP_PHRASE);\n\n\ttmp = (QueryOperator *) palloc0(sizeof(QueryOperator));\n\ttmp->type = QI_OPR;\n\ttmp->oper = oper;\n\ttmp->distance = (oper == OP_PHRASE) ? distance : 0;\n\t/* left is filled in later with findoprnd */\n\n\tstate->polstr = lcons(tmp, state->polstr);\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nvoid\npushOperator(TSQueryParserState state, int8 oper, int16 distance)\n{\n\tQueryOperator *tmp;\n\n\tAssert(oper == OP_NOT || oper == OP_AND || oper == OP_OR || oper == OP_PHRASE);\n\n\ttmp = (QueryOperator *) palloc0(sizeof(QueryOperator));\n\ttmp->type = QI_OPR;\n\ttmp->oper = oper;\n\ttmp->distance = (oper == OP_PHRASE) ? distance : 0;\n\t/* left is filled in later with findoprnd */\n\n\tstate->polstr = lcons(tmp, state->polstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OP_PRIORITY",
          "args": [
            "stack[*lenstack - 1].op"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OP_PRIORITY",
          "args": [
            "stack[*lenstack - 1].op"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OP_PRIORITY",
          "args": [
            "op"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic void\ncleanOpStack(TSQueryParserState state,\n\t\t\t OperatorElement *stack, int *lenstack, int8 op)\n{\n\tint\t\t\topPriority = OP_PRIORITY(op);\n\n\twhile (*lenstack)\n\t{\n\t\t/* NOT is right associative unlike to others */\n\t\tif ((op != OP_NOT && opPriority > OP_PRIORITY(stack[*lenstack - 1].op)) ||\n\t\t\t(op == OP_NOT && opPriority >= OP_PRIORITY(stack[*lenstack - 1].op)))\n\t\t\tbreak;\n\n\t\t(*lenstack)--;\n\t\tpushOperator(state, stack[*lenstack].op,\n\t\t\t\t\t stack[*lenstack].distance);\n\t}\n}"
  },
  {
    "function_name": "pushOpStack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "649-659",
    "snippet": "static void\npushOpStack(OperatorElement *stack, int *lenstack, int8 op, int16 distance)\n{\n\tif (*lenstack == STACKDEPTH)\t/* internal error */\n\t\telog(ERROR, \"tsquery stack too small\");\n\n\tstack[*lenstack].op = op;\n\tstack[*lenstack].distance = distance;\n\n\t(*lenstack)++;\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define STACKDEPTH\t32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"tsquery stack too small\""
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\n#define STACKDEPTH\t32\n\nstatic void\npushOpStack(OperatorElement *stack, int *lenstack, int8 op, int16 distance)\n{\n\tif (*lenstack == STACKDEPTH)\t/* internal error */\n\t\telog(ERROR, \"tsquery stack too small\");\n\n\tstack[*lenstack].op = op;\n\tstack[*lenstack].distance = distance;\n\n\t(*lenstack)++;\n}"
  },
  {
    "function_name": "pushStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "629-638",
    "snippet": "void\npushStop(TSQueryParserState state)\n{\n\tQueryOperand *tmp;\n\n\ttmp = (QueryOperand *) palloc0(sizeof(QueryOperand));\n\ttmp->type = QI_VALSTOP;\n\n\tstate->polstr = lcons(tmp, state->polstr);\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lcons",
          "args": [
            "tmp",
            "state->polstr"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(QueryOperand)"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nvoid\npushStop(TSQueryParserState state)\n{\n\tQueryOperand *tmp;\n\n\ttmp = (QueryOperand *) palloc0(sizeof(QueryOperand));\n\ttmp->type = QI_VALSTOP;\n\n\tstate->polstr = lcons(tmp, state->polstr);\n}"
  },
  {
    "function_name": "pushValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "593-623",
    "snippet": "void\npushValue(TSQueryParserState state, char *strval, int lenval, int16 weight, bool prefix)\n{\n\tpg_crc32\tvalcrc;\n\n\tif (lenval >= MAXSTRLEN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"word is too long in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\tstate->buffer)));\n\n\tINIT_LEGACY_CRC32(valcrc);\n\tCOMP_LEGACY_CRC32(valcrc, strval, lenval);\n\tFIN_LEGACY_CRC32(valcrc);\n\tpushValue_internal(state, valcrc, state->curop - state->op, lenval, weight, prefix);\n\n\t/* append the value string to state.op, enlarging buffer if needed first */\n\twhile (state->curop - state->op + lenval + 1 >= state->lenop)\n\t{\n\t\tint\t\t\tused = state->curop - state->op;\n\n\t\tstate->lenop *= 2;\n\t\tstate->op = (char *) repalloc((void *) state->op, state->lenop);\n\t\tstate->curop = state->op + used;\n\t}\n\tmemcpy((void *) state->curop, (void *) strval, lenval);\n\tstate->curop += lenval;\n\t*(state->curop) = '\\0';\n\tstate->curop++;\n\tstate->sumlen += lenval + 1 /* \\0 */ ;\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *) state->curop",
            "(void *) strval",
            "lenval"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "(void *) state->op",
            "state->lenop"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushValue_internal",
          "args": [
            "state",
            "valcrc",
            "state->curop - state->op",
            "lenval",
            "weight",
            "prefix"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "pushValue_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "560-585",
          "snippet": "static void\npushValue_internal(TSQueryParserState state, pg_crc32 valcrc, int distance, int lenval, int weight, bool prefix)\n{\n\tQueryOperand *tmp;\n\n\tif (distance >= MAXSTRPOS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"value is too big in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\tstate->buffer)));\n\tif (lenval >= MAXSTRLEN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"operand is too long in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\tstate->buffer)));\n\n\ttmp = (QueryOperand *) palloc0(sizeof(QueryOperand));\n\ttmp->type = QI_VAL;\n\ttmp->weight = weight;\n\ttmp->prefix = prefix;\n\ttmp->valcrc = (int32) valcrc;\n\ttmp->length = lenval;\n\ttmp->distance = distance;\n\n\tstate->polstr = lcons(tmp, state->polstr);\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic void\npushValue_internal(TSQueryParserState state, pg_crc32 valcrc, int distance, int lenval, int weight, bool prefix)\n{\n\tQueryOperand *tmp;\n\n\tif (distance >= MAXSTRPOS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"value is too big in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\tstate->buffer)));\n\tif (lenval >= MAXSTRLEN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"operand is too long in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\tstate->buffer)));\n\n\ttmp = (QueryOperand *) palloc0(sizeof(QueryOperand));\n\ttmp->type = QI_VAL;\n\ttmp->weight = weight;\n\ttmp->prefix = prefix;\n\ttmp->valcrc = (int32) valcrc;\n\ttmp->length = lenval;\n\ttmp->distance = distance;\n\n\tstate->polstr = lcons(tmp, state->polstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FIN_LEGACY_CRC32",
          "args": [
            "valcrc"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMP_LEGACY_CRC32",
          "args": [
            "valcrc",
            "strval",
            "lenval"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LEGACY_CRC32",
          "args": [
            "valcrc"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"word is too long in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\tstate->buffer))"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"word is too long in tsquery: \\\"%s\\\"\"",
            "state->buffer"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nvoid\npushValue(TSQueryParserState state, char *strval, int lenval, int16 weight, bool prefix)\n{\n\tpg_crc32\tvalcrc;\n\n\tif (lenval >= MAXSTRLEN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"word is too long in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\tstate->buffer)));\n\n\tINIT_LEGACY_CRC32(valcrc);\n\tCOMP_LEGACY_CRC32(valcrc, strval, lenval);\n\tFIN_LEGACY_CRC32(valcrc);\n\tpushValue_internal(state, valcrc, state->curop - state->op, lenval, weight, prefix);\n\n\t/* append the value string to state.op, enlarging buffer if needed first */\n\twhile (state->curop - state->op + lenval + 1 >= state->lenop)\n\t{\n\t\tint\t\t\tused = state->curop - state->op;\n\n\t\tstate->lenop *= 2;\n\t\tstate->op = (char *) repalloc((void *) state->op, state->lenop);\n\t\tstate->curop = state->op + used;\n\t}\n\tmemcpy((void *) state->curop, (void *) strval, lenval);\n\tstate->curop += lenval;\n\t*(state->curop) = '\\0';\n\tstate->curop++;\n\tstate->sumlen += lenval + 1 /* \\0 */ ;\n}"
  },
  {
    "function_name": "pushValue_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "560-585",
    "snippet": "static void\npushValue_internal(TSQueryParserState state, pg_crc32 valcrc, int distance, int lenval, int weight, bool prefix)\n{\n\tQueryOperand *tmp;\n\n\tif (distance >= MAXSTRPOS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"value is too big in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\tstate->buffer)));\n\tif (lenval >= MAXSTRLEN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"operand is too long in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\tstate->buffer)));\n\n\ttmp = (QueryOperand *) palloc0(sizeof(QueryOperand));\n\ttmp->type = QI_VAL;\n\ttmp->weight = weight;\n\ttmp->prefix = prefix;\n\ttmp->valcrc = (int32) valcrc;\n\ttmp->length = lenval;\n\ttmp->distance = distance;\n\n\tstate->polstr = lcons(tmp, state->polstr);\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lcons",
          "args": [
            "tmp",
            "state->polstr"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(QueryOperand)"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"operand is too long in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\tstate->buffer))"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"operand is too long in tsquery: \\\"%s\\\"\"",
            "state->buffer"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"value is too big in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\tstate->buffer))"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic void\npushValue_internal(TSQueryParserState state, pg_crc32 valcrc, int distance, int lenval, int weight, bool prefix)\n{\n\tQueryOperand *tmp;\n\n\tif (distance >= MAXSTRPOS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"value is too big in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\tstate->buffer)));\n\tif (lenval >= MAXSTRLEN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"operand is too long in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\tstate->buffer)));\n\n\ttmp = (QueryOperand *) palloc0(sizeof(QueryOperand));\n\ttmp->type = QI_VAL;\n\ttmp->weight = weight;\n\ttmp->prefix = prefix;\n\ttmp->valcrc = (int32) valcrc;\n\ttmp->length = lenval;\n\ttmp->distance = distance;\n\n\tstate->polstr = lcons(tmp, state->polstr);\n}"
  },
  {
    "function_name": "pushOperator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "544-558",
    "snippet": "void\npushOperator(TSQueryParserState state, int8 oper, int16 distance)\n{\n\tQueryOperator *tmp;\n\n\tAssert(oper == OP_NOT || oper == OP_AND || oper == OP_OR || oper == OP_PHRASE);\n\n\ttmp = (QueryOperator *) palloc0(sizeof(QueryOperator));\n\ttmp->type = QI_OPR;\n\ttmp->oper = oper;\n\ttmp->distance = (oper == OP_PHRASE) ? distance : 0;\n\t/* left is filled in later with findoprnd */\n\n\tstate->polstr = lcons(tmp, state->polstr);\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lcons",
          "args": [
            "tmp",
            "state->polstr"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(QueryOperator)"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "oper == OP_NOT || oper == OP_AND || oper == OP_OR || oper == OP_PHRASE"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nvoid\npushOperator(TSQueryParserState state, int8 oper, int16 distance)\n{\n\tQueryOperator *tmp;\n\n\tAssert(oper == OP_NOT || oper == OP_AND || oper == OP_OR || oper == OP_PHRASE);\n\n\ttmp = (QueryOperator *) palloc0(sizeof(QueryOperator));\n\ttmp->type = QI_OPR;\n\ttmp->oper = oper;\n\ttmp->distance = (oper == OP_PHRASE) ? distance : 0;\n\t/* left is filled in later with findoprnd */\n\n\tstate->polstr = lcons(tmp, state->polstr);\n}"
  },
  {
    "function_name": "gettoken_query_plain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "523-539",
    "snippet": "static ts_tokentype\ngettoken_query_plain(TSQueryParserState state, int8 *operator,\n\t\t\t\t\t int *lenval, char **strval,\n\t\t\t\t\t int16 *weight, bool *prefix)\n{\n\t*weight = 0;\n\t*prefix = false;\n\n\tif (*state->buf == '\\0')\n\t\treturn PT_END;\n\n\t*strval = state->buf;\n\t*lenval = strlen(state->buf);\n\tstate->buf += *lenval;\n\tstate->count++;\n\treturn PT_VAL;\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "state->buf"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic ts_tokentype\ngettoken_query_plain(TSQueryParserState state, int8 *operator,\n\t\t\t\t\t int *lenval, char **strval,\n\t\t\t\t\t int16 *weight, bool *prefix)\n{\n\t*weight = 0;\n\t*prefix = false;\n\n\tif (*state->buf == '\\0')\n\t\treturn PT_END;\n\n\t*strval = state->buf;\n\t*lenval = strlen(state->buf);\n\tstate->buf += *lenval;\n\tstate->count++;\n\treturn PT_VAL;\n}"
  },
  {
    "function_name": "gettoken_query_websearch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "382-521",
    "snippet": "static ts_tokentype\ngettoken_query_websearch(TSQueryParserState state, int8 *operator,\n\t\t\t\t\t\t int *lenval, char **strval,\n\t\t\t\t\t\t int16 *weight, bool *prefix)\n{\n\t*weight = 0;\n\t*prefix = false;\n\n\twhile (true)\n\t{\n\t\tswitch (state->state)\n\t\t{\n\t\t\tcase WAITFIRSTOPERAND:\n\t\t\tcase WAITOPERAND:\n\t\t\t\tif (t_iseq(state->buf, '-'))\n\t\t\t\t{\n\t\t\t\t\tstate->buf++;\n\t\t\t\t\tstate->state = WAITOPERAND;\n\n\t\t\t\t\tif (state->in_quotes)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t*operator = OP_NOT;\n\t\t\t\t\treturn PT_OPR;\n\t\t\t\t}\n\t\t\t\telse if (t_iseq(state->buf, '\"'))\n\t\t\t\t{\n\t\t\t\t\tstate->buf++;\n\n\t\t\t\t\tif (!state->in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\tstate->state = WAITOPERAND;\n\n\t\t\t\t\t\tif (strchr(state->buf, '\"'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* quoted text should be ordered <-> */\n\t\t\t\t\t\t\tstate->in_quotes = true;\n\t\t\t\t\t\t\treturn PT_OPEN;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* web search tolerates missing quotes */\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* we have to provide an operand */\n\t\t\t\t\t\tstate->in_quotes = false;\n\t\t\t\t\t\tstate->state = WAITOPERATOR;\n\t\t\t\t\t\tpushStop(state);\n\t\t\t\t\t\treturn PT_CLOSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (ISOPERATOR(state->buf))\n\t\t\t\t{\n\t\t\t\t\t/* or else gettoken_tsvector() will raise an error */\n\t\t\t\t\tstate->buf++;\n\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (!t_isspace(state->buf))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We rely on the tsvector parser to parse the value for\n\t\t\t\t\t * us\n\t\t\t\t\t */\n\t\t\t\t\treset_tsvector_parser(state->valstate, state->buf);\n\t\t\t\t\tif (gettoken_tsvector(state->valstate, strval, lenval,\n\t\t\t\t\t\t\t\t\t\t  NULL, NULL, &state->buf))\n\t\t\t\t\t{\n\t\t\t\t\t\tstate->state = WAITOPERATOR;\n\t\t\t\t\t\treturn PT_VAL;\n\t\t\t\t\t}\n\t\t\t\t\telse if (state->state == WAITFIRSTOPERAND)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn PT_END;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* finally, we have to provide an operand */\n\t\t\t\t\t\tpushStop(state);\n\t\t\t\t\t\treturn PT_END;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase WAITOPERATOR:\n\t\t\t\tif (t_iseq(state->buf, '\"'))\n\t\t\t\t{\n\t\t\t\t\tif (!state->in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * put implicit AND after an operand and handle this\n\t\t\t\t\t\t * quote in WAITOPERAND\n\t\t\t\t\t\t */\n\t\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\t\t*operator = OP_AND;\n\t\t\t\t\t\treturn PT_OPR;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstate->buf++;\n\n\t\t\t\t\t\t/* just close quotes */\n\t\t\t\t\t\tstate->in_quotes = false;\n\t\t\t\t\t\treturn PT_CLOSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (parse_or_operator(state))\n\t\t\t\t{\n\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\t*operator = OP_OR;\n\t\t\t\t\treturn PT_OPR;\n\t\t\t\t}\n\t\t\t\telse if (*state->buf == '\\0')\n\t\t\t\t{\n\t\t\t\t\treturn PT_END;\n\t\t\t\t}\n\t\t\t\telse if (!t_isspace(state->buf))\n\t\t\t\t{\n\t\t\t\t\tif (state->in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* put implicit <-> after an operand */\n\t\t\t\t\t\t*operator = OP_PHRASE;\n\t\t\t\t\t\t*weight = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* put implicit AND after an operand */\n\t\t\t\t\t\t*operator = OP_AND;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\treturn PT_OPR;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tstate->buf += pg_mblen(state->buf);\n\t}\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "state->buf"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_isspace",
          "args": [
            "state->buf"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_or_operator",
          "args": [
            "state"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "parse_or_operator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "233-276",
          "snippet": "static bool\nparse_or_operator(TSQueryParserState pstate)\n{\n\tchar\t   *ptr = pstate->buf;\n\n\tif (pstate->in_quotes)\n\t\treturn false;\n\n\t/* it should begin with \"OR\" literal */\n\tif (pg_strncasecmp(ptr, \"or\", 2) != 0)\n\t\treturn false;\n\n\tptr += 2;\n\n\t/*\n\t * it shouldn't be a part of any word but somewhere later it should be\n\t * some operand\n\t */\n\tif (*ptr == '\\0')\t\t\t/* no operand */\n\t\treturn false;\n\n\t/* it shouldn't be a part of any word */\n\tif (t_iseq(ptr, '-') || t_iseq(ptr, '_') || t_isalpha(ptr) || t_isdigit(ptr))\n\t\treturn false;\n\n\tfor (;;)\n\t{\n\t\tptr += pg_mblen(ptr);\n\n\t\tif (*ptr == '\\0')\t\t/* got end of string without operand */\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Suppose, we found an operand, but could be a not correct operand.\n\t\t * So we still treat OR literal as operation with possibly incorrect\n\t\t * operand and  will not search it as lexeme\n\t\t */\n\t\tif (!t_isspace(ptr))\n\t\t\tbreak;\n\t}\n\n\tpstate->buf += 2;\n\treturn true;\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic bool\nparse_or_operator(TSQueryParserState pstate)\n{\n\tchar\t   *ptr = pstate->buf;\n\n\tif (pstate->in_quotes)\n\t\treturn false;\n\n\t/* it should begin with \"OR\" literal */\n\tif (pg_strncasecmp(ptr, \"or\", 2) != 0)\n\t\treturn false;\n\n\tptr += 2;\n\n\t/*\n\t * it shouldn't be a part of any word but somewhere later it should be\n\t * some operand\n\t */\n\tif (*ptr == '\\0')\t\t\t/* no operand */\n\t\treturn false;\n\n\t/* it shouldn't be a part of any word */\n\tif (t_iseq(ptr, '-') || t_iseq(ptr, '_') || t_isalpha(ptr) || t_isdigit(ptr))\n\t\treturn false;\n\n\tfor (;;)\n\t{\n\t\tptr += pg_mblen(ptr);\n\n\t\tif (*ptr == '\\0')\t\t/* got end of string without operand */\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Suppose, we found an operand, but could be a not correct operand.\n\t\t * So we still treat OR literal as operation with possibly incorrect\n\t\t * operand and  will not search it as lexeme\n\t\t */\n\t\tif (!t_isspace(ptr))\n\t\t\tbreak;\n\t}\n\n\tpstate->buf += 2;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_iseq",
          "args": [
            "state->buf",
            "'\"'"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "text_isequal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4281-4287",
          "snippet": "static bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushStop",
          "args": [
            "state"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "pushStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "629-638",
          "snippet": "void\npushStop(TSQueryParserState state)\n{\n\tQueryOperand *tmp;\n\n\ttmp = (QueryOperand *) palloc0(sizeof(QueryOperand));\n\ttmp->type = QI_VALSTOP;\n\n\tstate->polstr = lcons(tmp, state->polstr);\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nvoid\npushStop(TSQueryParserState state)\n{\n\tQueryOperand *tmp;\n\n\ttmp = (QueryOperand *) palloc0(sizeof(QueryOperand));\n\ttmp->type = QI_VALSTOP;\n\n\tstate->polstr = lcons(tmp, state->polstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gettoken_tsvector",
          "args": [
            "state->valstate",
            "strval",
            "lenval",
            "NULL",
            "NULL",
            "&state->buf"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "gettoken_tsvector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_parser.c",
          "lines": "154-367",
          "snippet": "bool\ngettoken_tsvector(TSVectorParseState state,\n\t\t\t\t  char **strval, int *lenval,\n\t\t\t\t  WordEntryPos **pos_ptr, int *poslen,\n\t\t\t\t  char **endptr)\n{\n\tint\t\t\toldstate = 0;\n\tchar\t   *curpos = state->word;\n\tint\t\t\tstatecode = WAITWORD;\n\n\t/*\n\t * pos is for collecting the comma delimited list of positions followed by\n\t * the actual token.\n\t */\n\tWordEntryPos *pos = NULL;\n\tint\t\t\tnpos = 0;\t\t/* elements of pos used */\n\tint\t\t\tposalen = 0;\t/* allocated size of pos */\n\n\twhile (1)\n\t{\n\t\tif (statecode == WAITWORD)\n\t\t{\n\t\t\tif (*(state->prsbuf) == '\\0')\n\t\t\t\treturn false;\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t\tstatecode = WAITENDCMPLX;\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDWORD;\n\t\t\t}\n\t\t\telse if ((state->oprisdelim && ISOPERATOR(state->prsbuf)) ||\n\t\t\t\t\t (state->is_web && t_iseq(state->prsbuf, '\"')))\n\t\t\t\tPRSSYNTAXERROR;\n\t\t\telse if (!t_isspace(state->prsbuf))\n\t\t\t{\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tstatecode = WAITENDWORD;\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITNEXTCHAR)\n\t\t{\n\t\t\tif (*(state->prsbuf) == '\\0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"there is no escaped character: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstate->bufstart)));\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tAssert(oldstate != 0);\n\t\t\t\tstatecode = oldstate;\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITENDWORD)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDWORD;\n\t\t\t}\n\t\t\telse if (t_isspace(state->prsbuf) || *(state->prsbuf) == '\\0' ||\n\t\t\t\t\t (state->oprisdelim && ISOPERATOR(state->prsbuf)) ||\n\t\t\t\t\t (state->is_web && t_iseq(state->prsbuf, '\"')))\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tRETURN_TOKEN;\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, ':'))\n\t\t\t{\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tif (state->oprisdelim)\n\t\t\t\t\tRETURN_TOKEN;\n\t\t\t\telse\n\t\t\t\t\tstatecode = INPOSINFO;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITENDCMPLX)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t{\n\t\t\t\tstatecode = WAITCHARCMPLX;\n\t\t\t}\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDCMPLX;\n\t\t\t}\n\t\t\telse if (*(state->prsbuf) == '\\0')\n\t\t\t\tPRSSYNTAXERROR;\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITCHARCMPLX)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tstatecode = WAITENDCMPLX;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tif (state->oprisdelim)\n\t\t\t\t{\n\t\t\t\t\t/* state->prsbuf+=pg_mblen(state->prsbuf); */\n\t\t\t\t\tRETURN_TOKEN;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstatecode = WAITPOSINFO;\n\t\t\t\tcontinue;\t\t/* recheck current character */\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITPOSINFO)\n\t\t{\n\t\t\tif (t_iseq(state->prsbuf, ':'))\n\t\t\t\tstatecode = INPOSINFO;\n\t\t\telse\n\t\t\t\tRETURN_TOKEN;\n\t\t}\n\t\telse if (statecode == INPOSINFO)\n\t\t{\n\t\t\tif (t_isdigit(state->prsbuf))\n\t\t\t{\n\t\t\t\tif (posalen == 0)\n\t\t\t\t{\n\t\t\t\t\tposalen = 4;\n\t\t\t\t\tpos = (WordEntryPos *) palloc(sizeof(WordEntryPos) * posalen);\n\t\t\t\t\tnpos = 0;\n\t\t\t\t}\n\t\t\t\telse if (npos + 1 >= posalen)\n\t\t\t\t{\n\t\t\t\t\tposalen *= 2;\n\t\t\t\t\tpos = (WordEntryPos *) repalloc(pos, sizeof(WordEntryPos) * posalen);\n\t\t\t\t}\n\t\t\t\tnpos++;\n\t\t\t\tWEP_SETPOS(pos[npos - 1], LIMITPOS(atoi(state->prsbuf)));\n\t\t\t\t/* we cannot get here in tsquery, so no need for 2 errmsgs */\n\t\t\t\tif (WEP_GETPOS(pos[npos - 1]) == 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t errmsg(\"wrong position info in tsvector: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstate->bufstart)));\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 0);\n\t\t\t\tstatecode = WAITPOSDELIM;\n\t\t\t}\n\t\t\telse\n\t\t\t\tPRSSYNTAXERROR;\n\t\t}\n\t\telse if (statecode == WAITPOSDELIM)\n\t\t{\n\t\t\tif (t_iseq(state->prsbuf, ','))\n\t\t\t\tstatecode = INPOSINFO;\n\t\t\telse if (t_iseq(state->prsbuf, 'a') || t_iseq(state->prsbuf, 'A') || t_iseq(state->prsbuf, '*'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 3);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'b') || t_iseq(state->prsbuf, 'B'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 2);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'c') || t_iseq(state->prsbuf, 'C'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 1);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'd') || t_iseq(state->prsbuf, 'D'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 0);\n\t\t\t}\n\t\t\telse if (t_isspace(state->prsbuf) ||\n\t\t\t\t\t *(state->prsbuf) == '\\0')\n\t\t\t\tRETURN_TOKEN;\n\t\t\telse if (!t_isdigit(state->prsbuf))\n\t\t\t\tPRSSYNTAXERROR;\n\t\t}\n\t\telse\t\t\t\t\t/* internal error */\n\t\t\telog(ERROR, \"unrecognized state in gettoken_tsvector: %d\",\n\t\t\t\t statecode);\n\n\t\t/* get next char */\n\t\tstate->prsbuf += pg_mblen(state->prsbuf);\n\t}\n}",
          "includes": [
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PRSSYNTAXERROR prssyntaxerror(state)",
            "#define WAITCHARCMPLX\t8",
            "#define WAITPOSDELIM\t7",
            "#define INPOSINFO\t\t6",
            "#define WAITPOSINFO\t\t5",
            "#define WAITENDCMPLX\t4",
            "#define WAITNEXTCHAR\t3",
            "#define WAITENDWORD\t\t2",
            "#define WAITWORD\t\t1",
            "#define RETURN_TOKEN \\\ndo { \\\n\tif (pos_ptr != NULL) \\\n\t{ \\\n\t\t*pos_ptr = pos; \\\n\t\t*poslen = npos; \\\n\t} \\\n\telse if (pos != NULL) \\\n\t\tpfree(pos); \\\n\t\\\n\tif (strval != NULL) \\\n\t\t*strval = state->word; \\\n\tif (lenval != NULL) \\\n\t\t*lenval = curpos - state->word; \\\n\tif (endptr != NULL) \\\n\t\t*endptr = state->prsbuf; \\\n\treturn true; \\\n} while(0)",
            "#define RESIZEPRSBUF \\\ndo { \\\n\tint clen = curpos - state->word; \\\n\tif ( clen + state->eml >= state->len ) \\\n\t{ \\\n\t\tstate->len *= 2; \\\n\t\tstate->word = (char *) repalloc(state->word, state->len); \\\n\t\tcurpos = state->word + clen; \\\n\t} \\\n} while (0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"postgres.h\"\n\n#define PRSSYNTAXERROR prssyntaxerror(state)\n#define WAITCHARCMPLX\t8\n#define WAITPOSDELIM\t7\n#define INPOSINFO\t\t6\n#define WAITPOSINFO\t\t5\n#define WAITENDCMPLX\t4\n#define WAITNEXTCHAR\t3\n#define WAITENDWORD\t\t2\n#define WAITWORD\t\t1\n#define RETURN_TOKEN \\\ndo { \\\n\tif (pos_ptr != NULL) \\\n\t{ \\\n\t\t*pos_ptr = pos; \\\n\t\t*poslen = npos; \\\n\t} \\\n\telse if (pos != NULL) \\\n\t\tpfree(pos); \\\n\t\\\n\tif (strval != NULL) \\\n\t\t*strval = state->word; \\\n\tif (lenval != NULL) \\\n\t\t*lenval = curpos - state->word; \\\n\tif (endptr != NULL) \\\n\t\t*endptr = state->prsbuf; \\\n\treturn true; \\\n} while(0)\n#define RESIZEPRSBUF \\\ndo { \\\n\tint clen = curpos - state->word; \\\n\tif ( clen + state->eml >= state->len ) \\\n\t{ \\\n\t\tstate->len *= 2; \\\n\t\tstate->word = (char *) repalloc(state->word, state->len); \\\n\t\tcurpos = state->word + clen; \\\n\t} \\\n} while (0)\n\nbool\ngettoken_tsvector(TSVectorParseState state,\n\t\t\t\t  char **strval, int *lenval,\n\t\t\t\t  WordEntryPos **pos_ptr, int *poslen,\n\t\t\t\t  char **endptr)\n{\n\tint\t\t\toldstate = 0;\n\tchar\t   *curpos = state->word;\n\tint\t\t\tstatecode = WAITWORD;\n\n\t/*\n\t * pos is for collecting the comma delimited list of positions followed by\n\t * the actual token.\n\t */\n\tWordEntryPos *pos = NULL;\n\tint\t\t\tnpos = 0;\t\t/* elements of pos used */\n\tint\t\t\tposalen = 0;\t/* allocated size of pos */\n\n\twhile (1)\n\t{\n\t\tif (statecode == WAITWORD)\n\t\t{\n\t\t\tif (*(state->prsbuf) == '\\0')\n\t\t\t\treturn false;\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t\tstatecode = WAITENDCMPLX;\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDWORD;\n\t\t\t}\n\t\t\telse if ((state->oprisdelim && ISOPERATOR(state->prsbuf)) ||\n\t\t\t\t\t (state->is_web && t_iseq(state->prsbuf, '\"')))\n\t\t\t\tPRSSYNTAXERROR;\n\t\t\telse if (!t_isspace(state->prsbuf))\n\t\t\t{\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tstatecode = WAITENDWORD;\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITNEXTCHAR)\n\t\t{\n\t\t\tif (*(state->prsbuf) == '\\0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"there is no escaped character: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstate->bufstart)));\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tAssert(oldstate != 0);\n\t\t\t\tstatecode = oldstate;\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITENDWORD)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDWORD;\n\t\t\t}\n\t\t\telse if (t_isspace(state->prsbuf) || *(state->prsbuf) == '\\0' ||\n\t\t\t\t\t (state->oprisdelim && ISOPERATOR(state->prsbuf)) ||\n\t\t\t\t\t (state->is_web && t_iseq(state->prsbuf, '\"')))\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tRETURN_TOKEN;\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, ':'))\n\t\t\t{\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tif (state->oprisdelim)\n\t\t\t\t\tRETURN_TOKEN;\n\t\t\t\telse\n\t\t\t\t\tstatecode = INPOSINFO;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITENDCMPLX)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t{\n\t\t\t\tstatecode = WAITCHARCMPLX;\n\t\t\t}\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDCMPLX;\n\t\t\t}\n\t\t\telse if (*(state->prsbuf) == '\\0')\n\t\t\t\tPRSSYNTAXERROR;\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITCHARCMPLX)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tstatecode = WAITENDCMPLX;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tif (state->oprisdelim)\n\t\t\t\t{\n\t\t\t\t\t/* state->prsbuf+=pg_mblen(state->prsbuf); */\n\t\t\t\t\tRETURN_TOKEN;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstatecode = WAITPOSINFO;\n\t\t\t\tcontinue;\t\t/* recheck current character */\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITPOSINFO)\n\t\t{\n\t\t\tif (t_iseq(state->prsbuf, ':'))\n\t\t\t\tstatecode = INPOSINFO;\n\t\t\telse\n\t\t\t\tRETURN_TOKEN;\n\t\t}\n\t\telse if (statecode == INPOSINFO)\n\t\t{\n\t\t\tif (t_isdigit(state->prsbuf))\n\t\t\t{\n\t\t\t\tif (posalen == 0)\n\t\t\t\t{\n\t\t\t\t\tposalen = 4;\n\t\t\t\t\tpos = (WordEntryPos *) palloc(sizeof(WordEntryPos) * posalen);\n\t\t\t\t\tnpos = 0;\n\t\t\t\t}\n\t\t\t\telse if (npos + 1 >= posalen)\n\t\t\t\t{\n\t\t\t\t\tposalen *= 2;\n\t\t\t\t\tpos = (WordEntryPos *) repalloc(pos, sizeof(WordEntryPos) * posalen);\n\t\t\t\t}\n\t\t\t\tnpos++;\n\t\t\t\tWEP_SETPOS(pos[npos - 1], LIMITPOS(atoi(state->prsbuf)));\n\t\t\t\t/* we cannot get here in tsquery, so no need for 2 errmsgs */\n\t\t\t\tif (WEP_GETPOS(pos[npos - 1]) == 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t errmsg(\"wrong position info in tsvector: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstate->bufstart)));\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 0);\n\t\t\t\tstatecode = WAITPOSDELIM;\n\t\t\t}\n\t\t\telse\n\t\t\t\tPRSSYNTAXERROR;\n\t\t}\n\t\telse if (statecode == WAITPOSDELIM)\n\t\t{\n\t\t\tif (t_iseq(state->prsbuf, ','))\n\t\t\t\tstatecode = INPOSINFO;\n\t\t\telse if (t_iseq(state->prsbuf, 'a') || t_iseq(state->prsbuf, 'A') || t_iseq(state->prsbuf, '*'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 3);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'b') || t_iseq(state->prsbuf, 'B'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 2);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'c') || t_iseq(state->prsbuf, 'C'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 1);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'd') || t_iseq(state->prsbuf, 'D'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 0);\n\t\t\t}\n\t\t\telse if (t_isspace(state->prsbuf) ||\n\t\t\t\t\t *(state->prsbuf) == '\\0')\n\t\t\t\tRETURN_TOKEN;\n\t\t\telse if (!t_isdigit(state->prsbuf))\n\t\t\t\tPRSSYNTAXERROR;\n\t\t}\n\t\telse\t\t\t\t\t/* internal error */\n\t\t\telog(ERROR, \"unrecognized state in gettoken_tsvector: %d\",\n\t\t\t\t statecode);\n\n\t\t/* get next char */\n\t\tstate->prsbuf += pg_mblen(state->prsbuf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_tsvector_parser",
          "args": [
            "state->valstate",
            "state->buf"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "reset_tsvector_parser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_parser.c",
          "lines": "66-70",
          "snippet": "void\nreset_tsvector_parser(TSVectorParseState state, char *input)\n{\n\tstate->prsbuf = input;\n}",
          "includes": [
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"postgres.h\"\n\nvoid\nreset_tsvector_parser(TSVectorParseState state, char *input)\n{\n\tstate->prsbuf = input;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_isspace",
          "args": [
            "state->buf"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISOPERATOR",
          "args": [
            "state->buf"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "state->buf",
            "'\"'"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic ts_tokentype\ngettoken_query_websearch(TSQueryParserState state, int8 *operator,\n\t\t\t\t\t\t int *lenval, char **strval,\n\t\t\t\t\t\t int16 *weight, bool *prefix)\n{\n\t*weight = 0;\n\t*prefix = false;\n\n\twhile (true)\n\t{\n\t\tswitch (state->state)\n\t\t{\n\t\t\tcase WAITFIRSTOPERAND:\n\t\t\tcase WAITOPERAND:\n\t\t\t\tif (t_iseq(state->buf, '-'))\n\t\t\t\t{\n\t\t\t\t\tstate->buf++;\n\t\t\t\t\tstate->state = WAITOPERAND;\n\n\t\t\t\t\tif (state->in_quotes)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t*operator = OP_NOT;\n\t\t\t\t\treturn PT_OPR;\n\t\t\t\t}\n\t\t\t\telse if (t_iseq(state->buf, '\"'))\n\t\t\t\t{\n\t\t\t\t\tstate->buf++;\n\n\t\t\t\t\tif (!state->in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\tstate->state = WAITOPERAND;\n\n\t\t\t\t\t\tif (strchr(state->buf, '\"'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* quoted text should be ordered <-> */\n\t\t\t\t\t\t\tstate->in_quotes = true;\n\t\t\t\t\t\t\treturn PT_OPEN;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* web search tolerates missing quotes */\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* we have to provide an operand */\n\t\t\t\t\t\tstate->in_quotes = false;\n\t\t\t\t\t\tstate->state = WAITOPERATOR;\n\t\t\t\t\t\tpushStop(state);\n\t\t\t\t\t\treturn PT_CLOSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (ISOPERATOR(state->buf))\n\t\t\t\t{\n\t\t\t\t\t/* or else gettoken_tsvector() will raise an error */\n\t\t\t\t\tstate->buf++;\n\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (!t_isspace(state->buf))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We rely on the tsvector parser to parse the value for\n\t\t\t\t\t * us\n\t\t\t\t\t */\n\t\t\t\t\treset_tsvector_parser(state->valstate, state->buf);\n\t\t\t\t\tif (gettoken_tsvector(state->valstate, strval, lenval,\n\t\t\t\t\t\t\t\t\t\t  NULL, NULL, &state->buf))\n\t\t\t\t\t{\n\t\t\t\t\t\tstate->state = WAITOPERATOR;\n\t\t\t\t\t\treturn PT_VAL;\n\t\t\t\t\t}\n\t\t\t\t\telse if (state->state == WAITFIRSTOPERAND)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn PT_END;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* finally, we have to provide an operand */\n\t\t\t\t\t\tpushStop(state);\n\t\t\t\t\t\treturn PT_END;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase WAITOPERATOR:\n\t\t\t\tif (t_iseq(state->buf, '\"'))\n\t\t\t\t{\n\t\t\t\t\tif (!state->in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * put implicit AND after an operand and handle this\n\t\t\t\t\t\t * quote in WAITOPERAND\n\t\t\t\t\t\t */\n\t\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\t\t*operator = OP_AND;\n\t\t\t\t\t\treturn PT_OPR;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstate->buf++;\n\n\t\t\t\t\t\t/* just close quotes */\n\t\t\t\t\t\tstate->in_quotes = false;\n\t\t\t\t\t\treturn PT_CLOSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (parse_or_operator(state))\n\t\t\t\t{\n\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\t*operator = OP_OR;\n\t\t\t\t\treturn PT_OPR;\n\t\t\t\t}\n\t\t\t\telse if (*state->buf == '\\0')\n\t\t\t\t{\n\t\t\t\t\treturn PT_END;\n\t\t\t\t}\n\t\t\t\telse if (!t_isspace(state->buf))\n\t\t\t\t{\n\t\t\t\t\tif (state->in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* put implicit <-> after an operand */\n\t\t\t\t\t\t*operator = OP_PHRASE;\n\t\t\t\t\t\t*weight = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* put implicit AND after an operand */\n\t\t\t\t\t\t*operator = OP_AND;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\treturn PT_OPR;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tstate->buf += pg_mblen(state->buf);\n\t}\n}"
  },
  {
    "function_name": "gettoken_query_standard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "278-380",
    "snippet": "static ts_tokentype\ngettoken_query_standard(TSQueryParserState state, int8 *operator,\n\t\t\t\t\t\tint *lenval, char **strval,\n\t\t\t\t\t\tint16 *weight, bool *prefix)\n{\n\t*weight = 0;\n\t*prefix = false;\n\n\twhile (true)\n\t{\n\t\tswitch (state->state)\n\t\t{\n\t\t\tcase WAITFIRSTOPERAND:\n\t\t\tcase WAITOPERAND:\n\t\t\t\tif (t_iseq(state->buf, '!'))\n\t\t\t\t{\n\t\t\t\t\tstate->buf++;\n\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\t*operator = OP_NOT;\n\t\t\t\t\treturn PT_OPR;\n\t\t\t\t}\n\t\t\t\telse if (t_iseq(state->buf, '('))\n\t\t\t\t{\n\t\t\t\t\tstate->buf++;\n\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\tstate->count++;\n\t\t\t\t\treturn PT_OPEN;\n\t\t\t\t}\n\t\t\t\telse if (t_iseq(state->buf, ':'))\n\t\t\t\t{\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t errmsg(\"syntax error in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstate->buffer)));\n\t\t\t\t}\n\t\t\t\telse if (!t_isspace(state->buf))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We rely on the tsvector parser to parse the value for\n\t\t\t\t\t * us\n\t\t\t\t\t */\n\t\t\t\t\treset_tsvector_parser(state->valstate, state->buf);\n\t\t\t\t\tif (gettoken_tsvector(state->valstate, strval, lenval,\n\t\t\t\t\t\t\t\t\t\t  NULL, NULL, &state->buf))\n\t\t\t\t\t{\n\t\t\t\t\t\tstate->buf = get_modifiers(state->buf, weight, prefix);\n\t\t\t\t\t\tstate->state = WAITOPERATOR;\n\t\t\t\t\t\treturn PT_VAL;\n\t\t\t\t\t}\n\t\t\t\t\telse if (state->state == WAITFIRSTOPERAND)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn PT_END;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t\t errmsg(\"no operand in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tstate->buffer)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase WAITOPERATOR:\n\t\t\t\tif (t_iseq(state->buf, '&'))\n\t\t\t\t{\n\t\t\t\t\tstate->buf++;\n\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\t*operator = OP_AND;\n\t\t\t\t\treturn PT_OPR;\n\t\t\t\t}\n\t\t\t\telse if (t_iseq(state->buf, '|'))\n\t\t\t\t{\n\t\t\t\t\tstate->buf++;\n\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\t*operator = OP_OR;\n\t\t\t\t\treturn PT_OPR;\n\t\t\t\t}\n\t\t\t\telse if (parse_phrase_operator(state, weight))\n\t\t\t\t{\n\t\t\t\t\t/* weight var is used as storage for distance */\n\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\t*operator = OP_PHRASE;\n\t\t\t\t\treturn PT_OPR;\n\t\t\t\t}\n\t\t\t\telse if (t_iseq(state->buf, ')'))\n\t\t\t\t{\n\t\t\t\t\tstate->buf++;\n\t\t\t\t\tstate->count--;\n\t\t\t\t\treturn (state->count < 0) ? PT_ERR : PT_CLOSE;\n\t\t\t\t}\n\t\t\t\telse if (*state->buf == '\\0')\n\t\t\t\t{\n\t\t\t\t\treturn (state->count) ? PT_ERR : PT_END;\n\t\t\t\t}\n\t\t\t\telse if (!t_isspace(state->buf))\n\t\t\t\t{\n\t\t\t\t\treturn PT_ERR;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tstate->buf += pg_mblen(state->buf);\n\t}\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "state->buf"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_isspace",
          "args": [
            "state->buf"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_iseq",
          "args": [
            "state->buf",
            "')'"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "text_isequal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4281-4287",
          "snippet": "static bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_phrase_operator",
          "args": [
            "state",
            "weight"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "parse_phrase_operator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "154-227",
          "snippet": "static bool\nparse_phrase_operator(TSQueryParserState pstate, int16 *distance)\n{\n\tenum\n\t{\n\t\tPHRASE_OPEN = 0,\n\t\tPHRASE_DIST,\n\t\tPHRASE_CLOSE,\n\t\tPHRASE_FINISH\n\t}\t\t\tstate = PHRASE_OPEN;\n\tchar\t   *ptr = pstate->buf;\n\tchar\t   *endptr;\n\tlong\t\tl = 1;\t\t\t/* default distance */\n\n\twhile (*ptr)\n\t{\n\t\tswitch (state)\n\t\t{\n\t\t\tcase PHRASE_OPEN:\n\t\t\t\tif (t_iseq(ptr, '<'))\n\t\t\t\t{\n\t\t\t\t\tstate = PHRASE_DIST;\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tcase PHRASE_DIST:\n\t\t\t\tif (t_iseq(ptr, '-'))\n\t\t\t\t{\n\t\t\t\t\tstate = PHRASE_CLOSE;\n\t\t\t\t\tptr++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!t_isdigit(ptr))\n\t\t\t\t\treturn false;\n\n\t\t\t\terrno = 0;\n\t\t\t\tl = strtol(ptr, &endptr, 10);\n\t\t\t\tif (ptr == endptr)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (errno == ERANGE || l < 0 || l > MAXENTRYPOS)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"distance in phrase operator should not be greater than %d\",\n\t\t\t\t\t\t\t\t\tMAXENTRYPOS)));\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate = PHRASE_CLOSE;\n\t\t\t\t\tptr = endptr;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PHRASE_CLOSE:\n\t\t\t\tif (t_iseq(ptr, '>'))\n\t\t\t\t{\n\t\t\t\t\tstate = PHRASE_FINISH;\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tcase PHRASE_FINISH:\n\t\t\t\t*distance = (int16) l;\n\t\t\t\tpstate->buf = ptr;\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic bool\nparse_phrase_operator(TSQueryParserState pstate, int16 *distance)\n{\n\tenum\n\t{\n\t\tPHRASE_OPEN = 0,\n\t\tPHRASE_DIST,\n\t\tPHRASE_CLOSE,\n\t\tPHRASE_FINISH\n\t}\t\t\tstate = PHRASE_OPEN;\n\tchar\t   *ptr = pstate->buf;\n\tchar\t   *endptr;\n\tlong\t\tl = 1;\t\t\t/* default distance */\n\n\twhile (*ptr)\n\t{\n\t\tswitch (state)\n\t\t{\n\t\t\tcase PHRASE_OPEN:\n\t\t\t\tif (t_iseq(ptr, '<'))\n\t\t\t\t{\n\t\t\t\t\tstate = PHRASE_DIST;\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tcase PHRASE_DIST:\n\t\t\t\tif (t_iseq(ptr, '-'))\n\t\t\t\t{\n\t\t\t\t\tstate = PHRASE_CLOSE;\n\t\t\t\t\tptr++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!t_isdigit(ptr))\n\t\t\t\t\treturn false;\n\n\t\t\t\terrno = 0;\n\t\t\t\tl = strtol(ptr, &endptr, 10);\n\t\t\t\tif (ptr == endptr)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (errno == ERANGE || l < 0 || l > MAXENTRYPOS)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"distance in phrase operator should not be greater than %d\",\n\t\t\t\t\t\t\t\t\tMAXENTRYPOS)));\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate = PHRASE_CLOSE;\n\t\t\t\t\tptr = endptr;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PHRASE_CLOSE:\n\t\t\t\tif (t_iseq(ptr, '>'))\n\t\t\t\t{\n\t\t\t\t\tstate = PHRASE_FINISH;\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tcase PHRASE_FINISH:\n\t\t\t\t*distance = (int16) l;\n\t\t\t\tpstate->buf = ptr;\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t\t errmsg(\"no operand in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tstate->buffer))"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"no operand in tsquery: \\\"%s\\\"\"",
            "state->buffer"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_SYNTAX_ERROR"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_modifiers",
          "args": [
            "state->buf",
            "weight",
            "prefix"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "get_modifiers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
          "lines": "103-143",
          "snippet": "static char *\nget_modifiers(char *buf, int16 *weight, bool *prefix)\n{\n\t*weight = 0;\n\t*prefix = false;\n\n\tif (!t_iseq(buf, ':'))\n\t\treturn buf;\n\n\tbuf++;\n\twhile (*buf && pg_mblen(buf) == 1)\n\t{\n\t\tswitch (*buf)\n\t\t{\n\t\t\tcase 'a':\n\t\t\tcase 'A':\n\t\t\t\t*weight |= 1 << 3;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\tcase 'B':\n\t\t\t\t*weight |= 1 << 2;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\tcase 'C':\n\t\t\t\t*weight |= 1 << 1;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\tcase 'D':\n\t\t\t\t*weight |= 1;\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\t*prefix = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn buf;\n\t\t}\n\t\tbuf++;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include \"utils/pg_crc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic char *\nget_modifiers(char *buf, int16 *weight, bool *prefix)\n{\n\t*weight = 0;\n\t*prefix = false;\n\n\tif (!t_iseq(buf, ':'))\n\t\treturn buf;\n\n\tbuf++;\n\twhile (*buf && pg_mblen(buf) == 1)\n\t{\n\t\tswitch (*buf)\n\t\t{\n\t\t\tcase 'a':\n\t\t\tcase 'A':\n\t\t\t\t*weight |= 1 << 3;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\tcase 'B':\n\t\t\t\t*weight |= 1 << 2;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\tcase 'C':\n\t\t\t\t*weight |= 1 << 1;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\tcase 'D':\n\t\t\t\t*weight |= 1;\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\t*prefix = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn buf;\n\t\t}\n\t\tbuf++;\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gettoken_tsvector",
          "args": [
            "state->valstate",
            "strval",
            "lenval",
            "NULL",
            "NULL",
            "&state->buf"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "gettoken_tsvector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_parser.c",
          "lines": "154-367",
          "snippet": "bool\ngettoken_tsvector(TSVectorParseState state,\n\t\t\t\t  char **strval, int *lenval,\n\t\t\t\t  WordEntryPos **pos_ptr, int *poslen,\n\t\t\t\t  char **endptr)\n{\n\tint\t\t\toldstate = 0;\n\tchar\t   *curpos = state->word;\n\tint\t\t\tstatecode = WAITWORD;\n\n\t/*\n\t * pos is for collecting the comma delimited list of positions followed by\n\t * the actual token.\n\t */\n\tWordEntryPos *pos = NULL;\n\tint\t\t\tnpos = 0;\t\t/* elements of pos used */\n\tint\t\t\tposalen = 0;\t/* allocated size of pos */\n\n\twhile (1)\n\t{\n\t\tif (statecode == WAITWORD)\n\t\t{\n\t\t\tif (*(state->prsbuf) == '\\0')\n\t\t\t\treturn false;\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t\tstatecode = WAITENDCMPLX;\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDWORD;\n\t\t\t}\n\t\t\telse if ((state->oprisdelim && ISOPERATOR(state->prsbuf)) ||\n\t\t\t\t\t (state->is_web && t_iseq(state->prsbuf, '\"')))\n\t\t\t\tPRSSYNTAXERROR;\n\t\t\telse if (!t_isspace(state->prsbuf))\n\t\t\t{\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tstatecode = WAITENDWORD;\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITNEXTCHAR)\n\t\t{\n\t\t\tif (*(state->prsbuf) == '\\0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"there is no escaped character: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstate->bufstart)));\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tAssert(oldstate != 0);\n\t\t\t\tstatecode = oldstate;\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITENDWORD)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDWORD;\n\t\t\t}\n\t\t\telse if (t_isspace(state->prsbuf) || *(state->prsbuf) == '\\0' ||\n\t\t\t\t\t (state->oprisdelim && ISOPERATOR(state->prsbuf)) ||\n\t\t\t\t\t (state->is_web && t_iseq(state->prsbuf, '\"')))\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tRETURN_TOKEN;\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, ':'))\n\t\t\t{\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tif (state->oprisdelim)\n\t\t\t\t\tRETURN_TOKEN;\n\t\t\t\telse\n\t\t\t\t\tstatecode = INPOSINFO;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITENDCMPLX)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t{\n\t\t\t\tstatecode = WAITCHARCMPLX;\n\t\t\t}\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDCMPLX;\n\t\t\t}\n\t\t\telse if (*(state->prsbuf) == '\\0')\n\t\t\t\tPRSSYNTAXERROR;\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITCHARCMPLX)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tstatecode = WAITENDCMPLX;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tif (state->oprisdelim)\n\t\t\t\t{\n\t\t\t\t\t/* state->prsbuf+=pg_mblen(state->prsbuf); */\n\t\t\t\t\tRETURN_TOKEN;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstatecode = WAITPOSINFO;\n\t\t\t\tcontinue;\t\t/* recheck current character */\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITPOSINFO)\n\t\t{\n\t\t\tif (t_iseq(state->prsbuf, ':'))\n\t\t\t\tstatecode = INPOSINFO;\n\t\t\telse\n\t\t\t\tRETURN_TOKEN;\n\t\t}\n\t\telse if (statecode == INPOSINFO)\n\t\t{\n\t\t\tif (t_isdigit(state->prsbuf))\n\t\t\t{\n\t\t\t\tif (posalen == 0)\n\t\t\t\t{\n\t\t\t\t\tposalen = 4;\n\t\t\t\t\tpos = (WordEntryPos *) palloc(sizeof(WordEntryPos) * posalen);\n\t\t\t\t\tnpos = 0;\n\t\t\t\t}\n\t\t\t\telse if (npos + 1 >= posalen)\n\t\t\t\t{\n\t\t\t\t\tposalen *= 2;\n\t\t\t\t\tpos = (WordEntryPos *) repalloc(pos, sizeof(WordEntryPos) * posalen);\n\t\t\t\t}\n\t\t\t\tnpos++;\n\t\t\t\tWEP_SETPOS(pos[npos - 1], LIMITPOS(atoi(state->prsbuf)));\n\t\t\t\t/* we cannot get here in tsquery, so no need for 2 errmsgs */\n\t\t\t\tif (WEP_GETPOS(pos[npos - 1]) == 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t errmsg(\"wrong position info in tsvector: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstate->bufstart)));\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 0);\n\t\t\t\tstatecode = WAITPOSDELIM;\n\t\t\t}\n\t\t\telse\n\t\t\t\tPRSSYNTAXERROR;\n\t\t}\n\t\telse if (statecode == WAITPOSDELIM)\n\t\t{\n\t\t\tif (t_iseq(state->prsbuf, ','))\n\t\t\t\tstatecode = INPOSINFO;\n\t\t\telse if (t_iseq(state->prsbuf, 'a') || t_iseq(state->prsbuf, 'A') || t_iseq(state->prsbuf, '*'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 3);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'b') || t_iseq(state->prsbuf, 'B'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 2);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'c') || t_iseq(state->prsbuf, 'C'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 1);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'd') || t_iseq(state->prsbuf, 'D'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 0);\n\t\t\t}\n\t\t\telse if (t_isspace(state->prsbuf) ||\n\t\t\t\t\t *(state->prsbuf) == '\\0')\n\t\t\t\tRETURN_TOKEN;\n\t\t\telse if (!t_isdigit(state->prsbuf))\n\t\t\t\tPRSSYNTAXERROR;\n\t\t}\n\t\telse\t\t\t\t\t/* internal error */\n\t\t\telog(ERROR, \"unrecognized state in gettoken_tsvector: %d\",\n\t\t\t\t statecode);\n\n\t\t/* get next char */\n\t\tstate->prsbuf += pg_mblen(state->prsbuf);\n\t}\n}",
          "includes": [
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PRSSYNTAXERROR prssyntaxerror(state)",
            "#define WAITCHARCMPLX\t8",
            "#define WAITPOSDELIM\t7",
            "#define INPOSINFO\t\t6",
            "#define WAITPOSINFO\t\t5",
            "#define WAITENDCMPLX\t4",
            "#define WAITNEXTCHAR\t3",
            "#define WAITENDWORD\t\t2",
            "#define WAITWORD\t\t1",
            "#define RETURN_TOKEN \\\ndo { \\\n\tif (pos_ptr != NULL) \\\n\t{ \\\n\t\t*pos_ptr = pos; \\\n\t\t*poslen = npos; \\\n\t} \\\n\telse if (pos != NULL) \\\n\t\tpfree(pos); \\\n\t\\\n\tif (strval != NULL) \\\n\t\t*strval = state->word; \\\n\tif (lenval != NULL) \\\n\t\t*lenval = curpos - state->word; \\\n\tif (endptr != NULL) \\\n\t\t*endptr = state->prsbuf; \\\n\treturn true; \\\n} while(0)",
            "#define RESIZEPRSBUF \\\ndo { \\\n\tint clen = curpos - state->word; \\\n\tif ( clen + state->eml >= state->len ) \\\n\t{ \\\n\t\tstate->len *= 2; \\\n\t\tstate->word = (char *) repalloc(state->word, state->len); \\\n\t\tcurpos = state->word + clen; \\\n\t} \\\n} while (0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"postgres.h\"\n\n#define PRSSYNTAXERROR prssyntaxerror(state)\n#define WAITCHARCMPLX\t8\n#define WAITPOSDELIM\t7\n#define INPOSINFO\t\t6\n#define WAITPOSINFO\t\t5\n#define WAITENDCMPLX\t4\n#define WAITNEXTCHAR\t3\n#define WAITENDWORD\t\t2\n#define WAITWORD\t\t1\n#define RETURN_TOKEN \\\ndo { \\\n\tif (pos_ptr != NULL) \\\n\t{ \\\n\t\t*pos_ptr = pos; \\\n\t\t*poslen = npos; \\\n\t} \\\n\telse if (pos != NULL) \\\n\t\tpfree(pos); \\\n\t\\\n\tif (strval != NULL) \\\n\t\t*strval = state->word; \\\n\tif (lenval != NULL) \\\n\t\t*lenval = curpos - state->word; \\\n\tif (endptr != NULL) \\\n\t\t*endptr = state->prsbuf; \\\n\treturn true; \\\n} while(0)\n#define RESIZEPRSBUF \\\ndo { \\\n\tint clen = curpos - state->word; \\\n\tif ( clen + state->eml >= state->len ) \\\n\t{ \\\n\t\tstate->len *= 2; \\\n\t\tstate->word = (char *) repalloc(state->word, state->len); \\\n\t\tcurpos = state->word + clen; \\\n\t} \\\n} while (0)\n\nbool\ngettoken_tsvector(TSVectorParseState state,\n\t\t\t\t  char **strval, int *lenval,\n\t\t\t\t  WordEntryPos **pos_ptr, int *poslen,\n\t\t\t\t  char **endptr)\n{\n\tint\t\t\toldstate = 0;\n\tchar\t   *curpos = state->word;\n\tint\t\t\tstatecode = WAITWORD;\n\n\t/*\n\t * pos is for collecting the comma delimited list of positions followed by\n\t * the actual token.\n\t */\n\tWordEntryPos *pos = NULL;\n\tint\t\t\tnpos = 0;\t\t/* elements of pos used */\n\tint\t\t\tposalen = 0;\t/* allocated size of pos */\n\n\twhile (1)\n\t{\n\t\tif (statecode == WAITWORD)\n\t\t{\n\t\t\tif (*(state->prsbuf) == '\\0')\n\t\t\t\treturn false;\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t\tstatecode = WAITENDCMPLX;\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDWORD;\n\t\t\t}\n\t\t\telse if ((state->oprisdelim && ISOPERATOR(state->prsbuf)) ||\n\t\t\t\t\t (state->is_web && t_iseq(state->prsbuf, '\"')))\n\t\t\t\tPRSSYNTAXERROR;\n\t\t\telse if (!t_isspace(state->prsbuf))\n\t\t\t{\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tstatecode = WAITENDWORD;\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITNEXTCHAR)\n\t\t{\n\t\t\tif (*(state->prsbuf) == '\\0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"there is no escaped character: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstate->bufstart)));\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tAssert(oldstate != 0);\n\t\t\t\tstatecode = oldstate;\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITENDWORD)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDWORD;\n\t\t\t}\n\t\t\telse if (t_isspace(state->prsbuf) || *(state->prsbuf) == '\\0' ||\n\t\t\t\t\t (state->oprisdelim && ISOPERATOR(state->prsbuf)) ||\n\t\t\t\t\t (state->is_web && t_iseq(state->prsbuf, '\"')))\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tRETURN_TOKEN;\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, ':'))\n\t\t\t{\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tif (state->oprisdelim)\n\t\t\t\t\tRETURN_TOKEN;\n\t\t\t\telse\n\t\t\t\t\tstatecode = INPOSINFO;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITENDCMPLX)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t{\n\t\t\t\tstatecode = WAITCHARCMPLX;\n\t\t\t}\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDCMPLX;\n\t\t\t}\n\t\t\telse if (*(state->prsbuf) == '\\0')\n\t\t\t\tPRSSYNTAXERROR;\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITCHARCMPLX)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tstatecode = WAITENDCMPLX;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tif (state->oprisdelim)\n\t\t\t\t{\n\t\t\t\t\t/* state->prsbuf+=pg_mblen(state->prsbuf); */\n\t\t\t\t\tRETURN_TOKEN;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstatecode = WAITPOSINFO;\n\t\t\t\tcontinue;\t\t/* recheck current character */\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITPOSINFO)\n\t\t{\n\t\t\tif (t_iseq(state->prsbuf, ':'))\n\t\t\t\tstatecode = INPOSINFO;\n\t\t\telse\n\t\t\t\tRETURN_TOKEN;\n\t\t}\n\t\telse if (statecode == INPOSINFO)\n\t\t{\n\t\t\tif (t_isdigit(state->prsbuf))\n\t\t\t{\n\t\t\t\tif (posalen == 0)\n\t\t\t\t{\n\t\t\t\t\tposalen = 4;\n\t\t\t\t\tpos = (WordEntryPos *) palloc(sizeof(WordEntryPos) * posalen);\n\t\t\t\t\tnpos = 0;\n\t\t\t\t}\n\t\t\t\telse if (npos + 1 >= posalen)\n\t\t\t\t{\n\t\t\t\t\tposalen *= 2;\n\t\t\t\t\tpos = (WordEntryPos *) repalloc(pos, sizeof(WordEntryPos) * posalen);\n\t\t\t\t}\n\t\t\t\tnpos++;\n\t\t\t\tWEP_SETPOS(pos[npos - 1], LIMITPOS(atoi(state->prsbuf)));\n\t\t\t\t/* we cannot get here in tsquery, so no need for 2 errmsgs */\n\t\t\t\tif (WEP_GETPOS(pos[npos - 1]) == 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t errmsg(\"wrong position info in tsvector: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstate->bufstart)));\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 0);\n\t\t\t\tstatecode = WAITPOSDELIM;\n\t\t\t}\n\t\t\telse\n\t\t\t\tPRSSYNTAXERROR;\n\t\t}\n\t\telse if (statecode == WAITPOSDELIM)\n\t\t{\n\t\t\tif (t_iseq(state->prsbuf, ','))\n\t\t\t\tstatecode = INPOSINFO;\n\t\t\telse if (t_iseq(state->prsbuf, 'a') || t_iseq(state->prsbuf, 'A') || t_iseq(state->prsbuf, '*'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 3);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'b') || t_iseq(state->prsbuf, 'B'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 2);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'c') || t_iseq(state->prsbuf, 'C'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 1);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'd') || t_iseq(state->prsbuf, 'D'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 0);\n\t\t\t}\n\t\t\telse if (t_isspace(state->prsbuf) ||\n\t\t\t\t\t *(state->prsbuf) == '\\0')\n\t\t\t\tRETURN_TOKEN;\n\t\t\telse if (!t_isdigit(state->prsbuf))\n\t\t\t\tPRSSYNTAXERROR;\n\t\t}\n\t\telse\t\t\t\t\t/* internal error */\n\t\t\telog(ERROR, \"unrecognized state in gettoken_tsvector: %d\",\n\t\t\t\t statecode);\n\n\t\t/* get next char */\n\t\tstate->prsbuf += pg_mblen(state->prsbuf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_tsvector_parser",
          "args": [
            "state->valstate",
            "state->buf"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "reset_tsvector_parser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_parser.c",
          "lines": "66-70",
          "snippet": "void\nreset_tsvector_parser(TSVectorParseState state, char *input)\n{\n\tstate->prsbuf = input;\n}",
          "includes": [
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"postgres.h\"\n\nvoid\nreset_tsvector_parser(TSVectorParseState state, char *input)\n{\n\tstate->prsbuf = input;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_isspace",
          "args": [
            "state->buf"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t errmsg(\"syntax error in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstate->buffer))"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic ts_tokentype\ngettoken_query_standard(TSQueryParserState state, int8 *operator,\n\t\t\t\t\t\tint *lenval, char **strval,\n\t\t\t\t\t\tint16 *weight, bool *prefix)\n{\n\t*weight = 0;\n\t*prefix = false;\n\n\twhile (true)\n\t{\n\t\tswitch (state->state)\n\t\t{\n\t\t\tcase WAITFIRSTOPERAND:\n\t\t\tcase WAITOPERAND:\n\t\t\t\tif (t_iseq(state->buf, '!'))\n\t\t\t\t{\n\t\t\t\t\tstate->buf++;\n\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\t*operator = OP_NOT;\n\t\t\t\t\treturn PT_OPR;\n\t\t\t\t}\n\t\t\t\telse if (t_iseq(state->buf, '('))\n\t\t\t\t{\n\t\t\t\t\tstate->buf++;\n\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\tstate->count++;\n\t\t\t\t\treturn PT_OPEN;\n\t\t\t\t}\n\t\t\t\telse if (t_iseq(state->buf, ':'))\n\t\t\t\t{\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t errmsg(\"syntax error in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstate->buffer)));\n\t\t\t\t}\n\t\t\t\telse if (!t_isspace(state->buf))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We rely on the tsvector parser to parse the value for\n\t\t\t\t\t * us\n\t\t\t\t\t */\n\t\t\t\t\treset_tsvector_parser(state->valstate, state->buf);\n\t\t\t\t\tif (gettoken_tsvector(state->valstate, strval, lenval,\n\t\t\t\t\t\t\t\t\t\t  NULL, NULL, &state->buf))\n\t\t\t\t\t{\n\t\t\t\t\t\tstate->buf = get_modifiers(state->buf, weight, prefix);\n\t\t\t\t\t\tstate->state = WAITOPERATOR;\n\t\t\t\t\t\treturn PT_VAL;\n\t\t\t\t\t}\n\t\t\t\t\telse if (state->state == WAITFIRSTOPERAND)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn PT_END;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t\t errmsg(\"no operand in tsquery: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tstate->buffer)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase WAITOPERATOR:\n\t\t\t\tif (t_iseq(state->buf, '&'))\n\t\t\t\t{\n\t\t\t\t\tstate->buf++;\n\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\t*operator = OP_AND;\n\t\t\t\t\treturn PT_OPR;\n\t\t\t\t}\n\t\t\t\telse if (t_iseq(state->buf, '|'))\n\t\t\t\t{\n\t\t\t\t\tstate->buf++;\n\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\t*operator = OP_OR;\n\t\t\t\t\treturn PT_OPR;\n\t\t\t\t}\n\t\t\t\telse if (parse_phrase_operator(state, weight))\n\t\t\t\t{\n\t\t\t\t\t/* weight var is used as storage for distance */\n\t\t\t\t\tstate->state = WAITOPERAND;\n\t\t\t\t\t*operator = OP_PHRASE;\n\t\t\t\t\treturn PT_OPR;\n\t\t\t\t}\n\t\t\t\telse if (t_iseq(state->buf, ')'))\n\t\t\t\t{\n\t\t\t\t\tstate->buf++;\n\t\t\t\t\tstate->count--;\n\t\t\t\t\treturn (state->count < 0) ? PT_ERR : PT_CLOSE;\n\t\t\t\t}\n\t\t\t\telse if (*state->buf == '\\0')\n\t\t\t\t{\n\t\t\t\t\treturn (state->count) ? PT_ERR : PT_END;\n\t\t\t\t}\n\t\t\t\telse if (!t_isspace(state->buf))\n\t\t\t\t{\n\t\t\t\t\treturn PT_ERR;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tstate->buf += pg_mblen(state->buf);\n\t}\n}"
  },
  {
    "function_name": "parse_or_operator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "233-276",
    "snippet": "static bool\nparse_or_operator(TSQueryParserState pstate)\n{\n\tchar\t   *ptr = pstate->buf;\n\n\tif (pstate->in_quotes)\n\t\treturn false;\n\n\t/* it should begin with \"OR\" literal */\n\tif (pg_strncasecmp(ptr, \"or\", 2) != 0)\n\t\treturn false;\n\n\tptr += 2;\n\n\t/*\n\t * it shouldn't be a part of any word but somewhere later it should be\n\t * some operand\n\t */\n\tif (*ptr == '\\0')\t\t\t/* no operand */\n\t\treturn false;\n\n\t/* it shouldn't be a part of any word */\n\tif (t_iseq(ptr, '-') || t_iseq(ptr, '_') || t_isalpha(ptr) || t_isdigit(ptr))\n\t\treturn false;\n\n\tfor (;;)\n\t{\n\t\tptr += pg_mblen(ptr);\n\n\t\tif (*ptr == '\\0')\t\t/* got end of string without operand */\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Suppose, we found an operand, but could be a not correct operand.\n\t\t * So we still treat OR literal as operation with possibly incorrect\n\t\t * operand and  will not search it as lexeme\n\t\t */\n\t\tif (!t_isspace(ptr))\n\t\t\tbreak;\n\t}\n\n\tpstate->buf += 2;\n\treturn true;\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t_isspace",
          "args": [
            "ptr"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "ptr"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_isdigit",
          "args": [
            "ptr"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_isalpha",
          "args": [
            "ptr"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_iseq",
          "args": [
            "ptr",
            "'_'"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "text_isequal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4281-4287",
          "snippet": "static bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "ptr",
            "\"or\"",
            "2"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic bool\nparse_or_operator(TSQueryParserState pstate)\n{\n\tchar\t   *ptr = pstate->buf;\n\n\tif (pstate->in_quotes)\n\t\treturn false;\n\n\t/* it should begin with \"OR\" literal */\n\tif (pg_strncasecmp(ptr, \"or\", 2) != 0)\n\t\treturn false;\n\n\tptr += 2;\n\n\t/*\n\t * it shouldn't be a part of any word but somewhere later it should be\n\t * some operand\n\t */\n\tif (*ptr == '\\0')\t\t\t/* no operand */\n\t\treturn false;\n\n\t/* it shouldn't be a part of any word */\n\tif (t_iseq(ptr, '-') || t_iseq(ptr, '_') || t_isalpha(ptr) || t_isdigit(ptr))\n\t\treturn false;\n\n\tfor (;;)\n\t{\n\t\tptr += pg_mblen(ptr);\n\n\t\tif (*ptr == '\\0')\t\t/* got end of string without operand */\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Suppose, we found an operand, but could be a not correct operand.\n\t\t * So we still treat OR literal as operation with possibly incorrect\n\t\t * operand and  will not search it as lexeme\n\t\t */\n\t\tif (!t_isspace(ptr))\n\t\t\tbreak;\n\t}\n\n\tpstate->buf += 2;\n\treturn true;\n}"
  },
  {
    "function_name": "parse_phrase_operator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "154-227",
    "snippet": "static bool\nparse_phrase_operator(TSQueryParserState pstate, int16 *distance)\n{\n\tenum\n\t{\n\t\tPHRASE_OPEN = 0,\n\t\tPHRASE_DIST,\n\t\tPHRASE_CLOSE,\n\t\tPHRASE_FINISH\n\t}\t\t\tstate = PHRASE_OPEN;\n\tchar\t   *ptr = pstate->buf;\n\tchar\t   *endptr;\n\tlong\t\tl = 1;\t\t\t/* default distance */\n\n\twhile (*ptr)\n\t{\n\t\tswitch (state)\n\t\t{\n\t\t\tcase PHRASE_OPEN:\n\t\t\t\tif (t_iseq(ptr, '<'))\n\t\t\t\t{\n\t\t\t\t\tstate = PHRASE_DIST;\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tcase PHRASE_DIST:\n\t\t\t\tif (t_iseq(ptr, '-'))\n\t\t\t\t{\n\t\t\t\t\tstate = PHRASE_CLOSE;\n\t\t\t\t\tptr++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!t_isdigit(ptr))\n\t\t\t\t\treturn false;\n\n\t\t\t\terrno = 0;\n\t\t\t\tl = strtol(ptr, &endptr, 10);\n\t\t\t\tif (ptr == endptr)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (errno == ERANGE || l < 0 || l > MAXENTRYPOS)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"distance in phrase operator should not be greater than %d\",\n\t\t\t\t\t\t\t\t\tMAXENTRYPOS)));\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate = PHRASE_CLOSE;\n\t\t\t\t\tptr = endptr;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PHRASE_CLOSE:\n\t\t\t\tif (t_iseq(ptr, '>'))\n\t\t\t\t{\n\t\t\t\t\tstate = PHRASE_FINISH;\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tcase PHRASE_FINISH:\n\t\t\t\t*distance = (int16) l;\n\t\t\t\tpstate->buf = ptr;\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t_iseq",
          "args": [
            "ptr",
            "'>'"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "text_isequal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4281-4287",
          "snippet": "static bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"distance in phrase operator should not be greater than %d\",\n\t\t\t\t\t\t\t\t\tMAXENTRYPOS))"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"distance in phrase operator should not be greater than %d\"",
            "MAXENTRYPOS"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "ptr",
            "&endptr",
            "10"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_isdigit",
          "args": [
            "ptr"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic bool\nparse_phrase_operator(TSQueryParserState pstate, int16 *distance)\n{\n\tenum\n\t{\n\t\tPHRASE_OPEN = 0,\n\t\tPHRASE_DIST,\n\t\tPHRASE_CLOSE,\n\t\tPHRASE_FINISH\n\t}\t\t\tstate = PHRASE_OPEN;\n\tchar\t   *ptr = pstate->buf;\n\tchar\t   *endptr;\n\tlong\t\tl = 1;\t\t\t/* default distance */\n\n\twhile (*ptr)\n\t{\n\t\tswitch (state)\n\t\t{\n\t\t\tcase PHRASE_OPEN:\n\t\t\t\tif (t_iseq(ptr, '<'))\n\t\t\t\t{\n\t\t\t\t\tstate = PHRASE_DIST;\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tcase PHRASE_DIST:\n\t\t\t\tif (t_iseq(ptr, '-'))\n\t\t\t\t{\n\t\t\t\t\tstate = PHRASE_CLOSE;\n\t\t\t\t\tptr++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!t_isdigit(ptr))\n\t\t\t\t\treturn false;\n\n\t\t\t\terrno = 0;\n\t\t\t\tl = strtol(ptr, &endptr, 10);\n\t\t\t\tif (ptr == endptr)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (errno == ERANGE || l < 0 || l > MAXENTRYPOS)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"distance in phrase operator should not be greater than %d\",\n\t\t\t\t\t\t\t\t\tMAXENTRYPOS)));\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate = PHRASE_CLOSE;\n\t\t\t\t\tptr = endptr;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PHRASE_CLOSE:\n\t\t\t\tif (t_iseq(ptr, '>'))\n\t\t\t\t{\n\t\t\t\t\tstate = PHRASE_FINISH;\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\n\t\t\tcase PHRASE_FINISH:\n\t\t\t\t*distance = (int16) l;\n\t\t\t\tpstate->buf = ptr;\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "get_modifiers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery.c",
    "lines": "103-143",
    "snippet": "static char *\nget_modifiers(char *buf, int16 *weight, bool *prefix)\n{\n\t*weight = 0;\n\t*prefix = false;\n\n\tif (!t_iseq(buf, ':'))\n\t\treturn buf;\n\n\tbuf++;\n\twhile (*buf && pg_mblen(buf) == 1)\n\t{\n\t\tswitch (*buf)\n\t\t{\n\t\t\tcase 'a':\n\t\t\tcase 'A':\n\t\t\t\t*weight |= 1 << 3;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\tcase 'B':\n\t\t\t\t*weight |= 1 << 2;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\tcase 'C':\n\t\t\t\t*weight |= 1 << 1;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\tcase 'D':\n\t\t\t\t*weight |= 1;\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\t*prefix = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn buf;\n\t\t}\n\t\tbuf++;\n\t}\n\n\treturn buf;\n}",
    "includes": [
      "#include \"utils/pg_crc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "buf"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_iseq",
          "args": [
            "buf",
            "':'"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "text_isequal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4281-4287",
          "snippet": "static bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_crc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic char *\nget_modifiers(char *buf, int16 *weight, bool *prefix)\n{\n\t*weight = 0;\n\t*prefix = false;\n\n\tif (!t_iseq(buf, ':'))\n\t\treturn buf;\n\n\tbuf++;\n\twhile (*buf && pg_mblen(buf) == 1)\n\t{\n\t\tswitch (*buf)\n\t\t{\n\t\t\tcase 'a':\n\t\t\tcase 'A':\n\t\t\t\t*weight |= 1 << 3;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\tcase 'B':\n\t\t\t\t*weight |= 1 << 2;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\tcase 'C':\n\t\t\t\t*weight |= 1 << 1;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\tcase 'D':\n\t\t\t\t*weight |= 1;\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\t*prefix = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn buf;\n\t\t}\n\t\tbuf++;\n\t}\n\n\treturn buf;\n}"
  }
]