[
  {
    "function_name": "PrintCatCacheListLeakWarning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "2114-2120",
    "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"cache reference leak: cache %s (%d), list %p has count %d\"",
            "list->my_cache->cc_relname",
            "list->my_cache->id",
            "list",
            "list->refcount"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
  },
  {
    "function_name": "PrintCatCacheLeakWarning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "2098-2112",
    "snippet": "void\nPrintCatCacheLeakWarning(HeapTuple tuple)\n{\n\tCatCTup    *ct = (CatCTup *) (((char *) tuple) -\n\t\t\t\t\t\t\t\t  offsetof(CatCTup, tuple));\n\n\t/* Safety check to ensure we were handed a cache entry */\n\tAssert(ct->ct_magic == CT_MAGIC);\n\n\telog(WARNING, \"cache reference leak: cache %s (%d), tuple %u/%u has count %d\",\n\t\t ct->my_cache->cc_relname, ct->my_cache->id,\n\t\t ItemPointerGetBlockNumber(&(tuple->t_self)),\n\t\t ItemPointerGetOffsetNumber(&(tuple->t_self)),\n\t\t ct->refcount);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
      "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"cache reference leak: cache %s (%d), tuple %u/%u has count %d\"",
            "ct->my_cache->cc_relname",
            "ct->my_cache->id",
            "ItemPointerGetBlockNumber(&(tuple->t_self))",
            "ItemPointerGetOffsetNumber(&(tuple->t_self))",
            "ct->refcount"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ItemPointerGetOffsetNumber",
          "args": [
            "&(tuple->t_self)"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerGetBlockNumber",
          "args": [
            "&(tuple->t_self)"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ct->ct_magic == CT_MAGIC"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheLeakWarning(HeapTuple tuple)\n{\n\tCatCTup    *ct = (CatCTup *) (((char *) tuple) -\n\t\t\t\t\t\t\t\t  offsetof(CatCTup, tuple));\n\n\t/* Safety check to ensure we were handed a cache entry */\n\tAssert(ct->ct_magic == CT_MAGIC);\n\n\telog(WARNING, \"cache reference leak: cache %s (%d), tuple %u/%u has count %d\",\n\t\t ct->my_cache->cc_relname, ct->my_cache->id,\n\t\t ItemPointerGetBlockNumber(&(tuple->t_self)),\n\t\t ItemPointerGetOffsetNumber(&(tuple->t_self)),\n\t\t ct->refcount);\n}"
  },
  {
    "function_name": "PrepareToInvalidateCacheTuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "2034-2091",
    "snippet": "void\nPrepareToInvalidateCacheTuple(Relation relation,\n\t\t\t\t\t\t\t  HeapTuple tuple,\n\t\t\t\t\t\t\t  HeapTuple newtuple,\n\t\t\t\t\t\t\t  void (*function) (int, uint32, Oid))\n{\n\tslist_iter\titer;\n\tOid\t\t\treloid;\n\n\tCACHE1_elog(DEBUG2, \"PrepareToInvalidateCacheTuple: called\");\n\n\t/*\n\t * sanity checks\n\t */\n\tAssert(RelationIsValid(relation));\n\tAssert(HeapTupleIsValid(tuple));\n\tAssert(PointerIsValid(function));\n\tAssert(CacheHdr != NULL);\n\n\treloid = RelationGetRelid(relation);\n\n\t/* ----------------\n\t *\tfor each cache\n\t *\t   if the cache contains tuples from the specified relation\n\t *\t\t   compute the tuple's hash value(s) in this cache,\n\t *\t\t   and call the passed function to register the information.\n\t * ----------------\n\t */\n\n\tslist_foreach(iter, &CacheHdr->ch_caches)\n\t{\n\t\tCatCache   *ccp = slist_container(CatCache, cc_next, iter.cur);\n\t\tuint32\t\thashvalue;\n\t\tOid\t\t\tdbid;\n\n\t\tif (ccp->cc_reloid != reloid)\n\t\t\tcontinue;\n\n\t\t/* Just in case cache hasn't finished initialization yet... */\n\t\tif (ccp->cc_tupdesc == NULL)\n\t\t\tCatalogCacheInitializeCache(ccp);\n\n\t\thashvalue = CatalogCacheComputeTupleHashValue(ccp, ccp->cc_nkeys, tuple);\n\t\tdbid = ccp->cc_relisshared ? (Oid) 0 : MyDatabaseId;\n\n\t\t(*function) (ccp->id, hashvalue, dbid);\n\n\t\tif (newtuple)\n\t\t{\n\t\t\tuint32\t\tnewhashvalue;\n\n\t\t\tnewhashvalue = CatalogCacheComputeTupleHashValue(ccp, ccp->cc_nkeys, newtuple);\n\n\t\t\tif (newhashvalue != hashvalue)\n\t\t\t\t(*function) (ccp->id, newhashvalue, dbid);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CatCacheHeader *CacheHdr = NULL;",
      "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "ccp->id",
            "newhashvalue",
            "dbid"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatalogCacheComputeTupleHashValue",
          "args": [
            "ccp",
            "ccp->cc_nkeys",
            "newtuple"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "CatalogCacheComputeTupleHashValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "326-382",
          "snippet": "static uint32\nCatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys, HeapTuple tuple)\n{\n\tDatum\t\tv1 = 0,\n\t\t\t\tv2 = 0,\n\t\t\t\tv3 = 0,\n\t\t\t\tv4 = 0;\n\tbool\t\tisNull = false;\n\tint\t\t   *cc_keyno = cache->cc_keyno;\n\tTupleDesc\tcc_tupdesc = cache->cc_tupdesc;\n\n\t/* Now extract key fields from tuple, insert into scankey */\n\tswitch (nkeys)\n\t{\n\t\tcase 4:\n\t\t\tv4 = (cc_keyno[3] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[3],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 3:\n\t\t\tv3 = (cc_keyno[2] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[2],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\tv2 = (cc_keyno[1] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[1],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\tv1 = (cc_keyno[0] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[0],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"wrong number of hash keys: %d\", nkeys);\n\t\t\tbreak;\n\t}\n\n\treturn CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
            "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic uint32\nCatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys, HeapTuple tuple)\n{\n\tDatum\t\tv1 = 0,\n\t\t\t\tv2 = 0,\n\t\t\t\tv3 = 0,\n\t\t\t\tv4 = 0;\n\tbool\t\tisNull = false;\n\tint\t\t   *cc_keyno = cache->cc_keyno;\n\tTupleDesc\tcc_tupdesc = cache->cc_tupdesc;\n\n\t/* Now extract key fields from tuple, insert into scankey */\n\tswitch (nkeys)\n\t{\n\t\tcase 4:\n\t\t\tv4 = (cc_keyno[3] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[3],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 3:\n\t\t\tv3 = (cc_keyno[2] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[2],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\tv2 = (cc_keyno[1] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[1],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\tv1 = (cc_keyno[0] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[0],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"wrong number of hash keys: %d\", nkeys);\n\t\t\tbreak;\n\t}\n\n\treturn CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "ccp->id",
            "hashvalue",
            "dbid"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatalogCacheInitializeCache",
          "args": [
            "ccp"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "CatalogCacheInitializeCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "938-1038",
          "snippet": "static void\nCatalogCacheInitializeCache(CatCache *cache)\n{\n\tRelation\trelation;\n\tMemoryContext oldcxt;\n\tTupleDesc\ttupdesc;\n\tint\t\t\ti;\n\n\tCatalogCacheInitializeCache_DEBUG1;\n\n\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\t/*\n\t * switch to the cache context so our allocations do not vanish at the end\n\t * of a transaction\n\t */\n\tAssert(CacheMemoryContext != NULL);\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * copy the relcache's tuple descriptor to permanent cache storage\n\t */\n\ttupdesc = CreateTupleDescCopyConstr(RelationGetDescr(relation));\n\n\t/*\n\t * save the relation's name and relisshared flag, too (cc_relname is used\n\t * only for debugging purposes)\n\t */\n\tcache->cc_relname = pstrdup(RelationGetRelationName(relation));\n\tcache->cc_relisshared = RelationGetForm(relation)->relisshared;\n\n\t/*\n\t * return to the caller's memory context and close the rel\n\t */\n\tMemoryContextSwitchTo(oldcxt);\n\n\theap_close(relation, AccessShareLock);\n\n\tCACHE3_elog(DEBUG2, \"CatalogCacheInitializeCache: %s, %d keys\",\n\t\t\t\tcache->cc_relname, cache->cc_nkeys);\n\n\t/*\n\t * initialize cache's key information\n\t */\n\tfor (i = 0; i < cache->cc_nkeys; ++i)\n\t{\n\t\tOid\t\t\tkeytype;\n\t\tRegProcedure eqfunc;\n\n\t\tCatalogCacheInitializeCache_DEBUG2;\n\n\t\tif (cache->cc_keyno[i] > 0)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   cache->cc_keyno[i] - 1);\n\n\t\t\tkeytype = attr->atttypid;\n\t\t\t/* cache key columns should always be NOT NULL */\n\t\t\tAssert(attr->attnotnull);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (cache->cc_keyno[i] != ObjectIdAttributeNumber)\n\t\t\t\telog(FATAL, \"only sys attr supported in caches is OID\");\n\t\t\tkeytype = OIDOID;\n\t\t}\n\n\t\tGetCCHashEqFuncs(keytype,\n\t\t\t\t\t\t &cache->cc_hashfunc[i],\n\t\t\t\t\t\t &eqfunc,\n\t\t\t\t\t\t &cache->cc_fastequal[i]);\n\n\t\t/*\n\t\t * Do equality-function lookup (we assume this won't need a catalog\n\t\t * lookup for any supported type)\n\t\t */\n\t\tfmgr_info_cxt(eqfunc,\n\t\t\t\t\t  &cache->cc_skey[i].sk_func,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t\t/* Initialize sk_attno suitably for HeapKeyTest() and heap scans */\n\t\tcache->cc_skey[i].sk_attno = cache->cc_keyno[i];\n\n\t\t/* Fill in sk_strategy as well --- always standard equality */\n\t\tcache->cc_skey[i].sk_strategy = BTEqualStrategyNumber;\n\t\tcache->cc_skey[i].sk_subtype = InvalidOid;\n\t\t/* Currently, there are no catcaches on collation-aware data types */\n\t\tcache->cc_skey[i].sk_collation = InvalidOid;\n\n\t\tCACHE4_elog(DEBUG2, \"CatalogCacheInitializeCache %s %d %p\",\n\t\t\t\t\tcache->cc_relname,\n\t\t\t\t\ti,\n\t\t\t\t\tcache);\n\t}\n\n\t/*\n\t * mark this cache fully initialized\n\t */\n\tcache->cc_tupdesc = tupdesc;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define CatalogCacheInitializeCache_DEBUG2",
            "#define CatalogCacheInitializeCache_DEBUG1",
            "#define CatalogCacheInitializeCache_DEBUG2 \\\ndo { \\\n\t\tif (cache->cc_keyno[i] > 0) { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d, %u\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i], \\\n\t\t\t\t TupleDescAttr(tupdesc, cache->cc_keyno[i] - 1)->atttypid); \\\n\t\t} else { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i]); \\\n\t\t} \\\n} while(0)",
            "#define CatalogCacheInitializeCache_DEBUG1 \\\n\telog(DEBUG2, \"CatalogCacheInitializeCache: cache @%p rel=%u\", cache, \\\n\t\t cache->cc_reloid)"
          ],
          "globals_used": [
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\n#define CatalogCacheInitializeCache_DEBUG2\n#define CatalogCacheInitializeCache_DEBUG1\n#define CatalogCacheInitializeCache_DEBUG2 \\\ndo { \\\n\t\tif (cache->cc_keyno[i] > 0) { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d, %u\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i], \\\n\t\t\t\t TupleDescAttr(tupdesc, cache->cc_keyno[i] - 1)->atttypid); \\\n\t\t} else { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i]); \\\n\t\t} \\\n} while(0)\n#define CatalogCacheInitializeCache_DEBUG1 \\\n\telog(DEBUG2, \"CatalogCacheInitializeCache: cache @%p rel=%u\", cache, \\\n\t\t cache->cc_reloid)\n\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatalogCacheInitializeCache(CatCache *cache)\n{\n\tRelation\trelation;\n\tMemoryContext oldcxt;\n\tTupleDesc\ttupdesc;\n\tint\t\t\ti;\n\n\tCatalogCacheInitializeCache_DEBUG1;\n\n\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\t/*\n\t * switch to the cache context so our allocations do not vanish at the end\n\t * of a transaction\n\t */\n\tAssert(CacheMemoryContext != NULL);\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * copy the relcache's tuple descriptor to permanent cache storage\n\t */\n\ttupdesc = CreateTupleDescCopyConstr(RelationGetDescr(relation));\n\n\t/*\n\t * save the relation's name and relisshared flag, too (cc_relname is used\n\t * only for debugging purposes)\n\t */\n\tcache->cc_relname = pstrdup(RelationGetRelationName(relation));\n\tcache->cc_relisshared = RelationGetForm(relation)->relisshared;\n\n\t/*\n\t * return to the caller's memory context and close the rel\n\t */\n\tMemoryContextSwitchTo(oldcxt);\n\n\theap_close(relation, AccessShareLock);\n\n\tCACHE3_elog(DEBUG2, \"CatalogCacheInitializeCache: %s, %d keys\",\n\t\t\t\tcache->cc_relname, cache->cc_nkeys);\n\n\t/*\n\t * initialize cache's key information\n\t */\n\tfor (i = 0; i < cache->cc_nkeys; ++i)\n\t{\n\t\tOid\t\t\tkeytype;\n\t\tRegProcedure eqfunc;\n\n\t\tCatalogCacheInitializeCache_DEBUG2;\n\n\t\tif (cache->cc_keyno[i] > 0)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   cache->cc_keyno[i] - 1);\n\n\t\t\tkeytype = attr->atttypid;\n\t\t\t/* cache key columns should always be NOT NULL */\n\t\t\tAssert(attr->attnotnull);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (cache->cc_keyno[i] != ObjectIdAttributeNumber)\n\t\t\t\telog(FATAL, \"only sys attr supported in caches is OID\");\n\t\t\tkeytype = OIDOID;\n\t\t}\n\n\t\tGetCCHashEqFuncs(keytype,\n\t\t\t\t\t\t &cache->cc_hashfunc[i],\n\t\t\t\t\t\t &eqfunc,\n\t\t\t\t\t\t &cache->cc_fastequal[i]);\n\n\t\t/*\n\t\t * Do equality-function lookup (we assume this won't need a catalog\n\t\t * lookup for any supported type)\n\t\t */\n\t\tfmgr_info_cxt(eqfunc,\n\t\t\t\t\t  &cache->cc_skey[i].sk_func,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t\t/* Initialize sk_attno suitably for HeapKeyTest() and heap scans */\n\t\tcache->cc_skey[i].sk_attno = cache->cc_keyno[i];\n\n\t\t/* Fill in sk_strategy as well --- always standard equality */\n\t\tcache->cc_skey[i].sk_strategy = BTEqualStrategyNumber;\n\t\tcache->cc_skey[i].sk_subtype = InvalidOid;\n\t\t/* Currently, there are no catcaches on collation-aware data types */\n\t\tcache->cc_skey[i].sk_collation = InvalidOid;\n\n\t\tCACHE4_elog(DEBUG2, \"CatalogCacheInitializeCache %s %d %p\",\n\t\t\t\t\tcache->cc_relname,\n\t\t\t\t\ti,\n\t\t\t\t\tcache);\n\t}\n\n\t/*\n\t * mark this cache fully initialized\n\t */\n\tcache->cc_tupdesc = tupdesc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slist_container",
          "args": [
            "CatCache",
            "cc_next",
            "iter.cur"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slist_foreach",
          "args": [
            "iter",
            "&CacheHdr->ch_caches"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "CacheHdr != NULL"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "PointerIsValid(function)"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "function"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "HeapTupleIsValid(tuple)"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "RelationIsValid(relation)"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationIsValid",
          "args": [
            "relation"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CACHE1_elog",
          "args": [
            "DEBUG2",
            "\"PrepareToInvalidateCacheTuple: called\""
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrepareToInvalidateCacheTuple(Relation relation,\n\t\t\t\t\t\t\t  HeapTuple tuple,\n\t\t\t\t\t\t\t  HeapTuple newtuple,\n\t\t\t\t\t\t\t  void (*function) (int, uint32, Oid))\n{\n\tslist_iter\titer;\n\tOid\t\t\treloid;\n\n\tCACHE1_elog(DEBUG2, \"PrepareToInvalidateCacheTuple: called\");\n\n\t/*\n\t * sanity checks\n\t */\n\tAssert(RelationIsValid(relation));\n\tAssert(HeapTupleIsValid(tuple));\n\tAssert(PointerIsValid(function));\n\tAssert(CacheHdr != NULL);\n\n\treloid = RelationGetRelid(relation);\n\n\t/* ----------------\n\t *\tfor each cache\n\t *\t   if the cache contains tuples from the specified relation\n\t *\t\t   compute the tuple's hash value(s) in this cache,\n\t *\t\t   and call the passed function to register the information.\n\t * ----------------\n\t */\n\n\tslist_foreach(iter, &CacheHdr->ch_caches)\n\t{\n\t\tCatCache   *ccp = slist_container(CatCache, cc_next, iter.cur);\n\t\tuint32\t\thashvalue;\n\t\tOid\t\t\tdbid;\n\n\t\tif (ccp->cc_reloid != reloid)\n\t\t\tcontinue;\n\n\t\t/* Just in case cache hasn't finished initialization yet... */\n\t\tif (ccp->cc_tupdesc == NULL)\n\t\t\tCatalogCacheInitializeCache(ccp);\n\n\t\thashvalue = CatalogCacheComputeTupleHashValue(ccp, ccp->cc_nkeys, tuple);\n\t\tdbid = ccp->cc_relisshared ? (Oid) 0 : MyDatabaseId;\n\n\t\t(*function) (ccp->id, hashvalue, dbid);\n\n\t\tif (newtuple)\n\t\t{\n\t\t\tuint32\t\tnewhashvalue;\n\n\t\t\tnewhashvalue = CatalogCacheComputeTupleHashValue(ccp, ccp->cc_nkeys, newtuple);\n\n\t\t\tif (newhashvalue != hashvalue)\n\t\t\t\t(*function) (ccp->id, newhashvalue, dbid);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "CatCacheCopyKeys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "1955-1998",
    "snippet": "static void\nCatCacheCopyKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *srckeys, Datum *dstkeys)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * XXX: memory and lookup performance could possibly be improved by\n\t * storing all keys in one allocation.\n\t */\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tint\t\t\tattnum = attnos[i];\n\n\t\tif (attnum == ObjectIdAttributeNumber)\n\t\t{\n\t\t\tdstkeys[i] = srckeys[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, attnum - 1);\n\t\t\tDatum\t\tsrc = srckeys[i];\n\t\t\tNameData\tsrcname;\n\n\t\t\t/*\n\t\t\t * Must be careful in case the caller passed a C string where a\n\t\t\t * NAME is wanted: convert the given argument to a correctly\n\t\t\t * padded NAME.  Otherwise the memcpy() done by datumCopy() could\n\t\t\t * fall off the end of memory.\n\t\t\t */\n\t\t\tif (att->atttypid == NAMEOID)\n\t\t\t{\n\t\t\t\tnamestrcpy(&srcname, DatumGetCString(src));\n\t\t\t\tsrc = NameGetDatum(&srcname);\n\t\t\t}\n\n\t\t\tdstkeys[i] = datumCopy(src,\n\t\t\t\t\t\t\t\t   att->attbyval,\n\t\t\t\t\t\t\t\t   att->attlen);\n\t\t}\n\t}\n\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);",
      "static void CatCacheCopyKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *srckeys, Datum *dstkeys);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "datumCopy",
          "args": [
            "src",
            "att->attbyval",
            "att->attlen"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "datumCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "127-176",
          "snippet": "Datum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameGetDatum",
          "args": [
            "&srcname"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namestrcpy",
          "args": [
            "&srcname",
            "DatumGetCString(src)"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "src"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "attnum - 1"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\nstatic void CatCacheCopyKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *srckeys, Datum *dstkeys);\n\nstatic void\nCatCacheCopyKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *srckeys, Datum *dstkeys)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * XXX: memory and lookup performance could possibly be improved by\n\t * storing all keys in one allocation.\n\t */\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tint\t\t\tattnum = attnos[i];\n\n\t\tif (attnum == ObjectIdAttributeNumber)\n\t\t{\n\t\t\tdstkeys[i] = srckeys[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, attnum - 1);\n\t\t\tDatum\t\tsrc = srckeys[i];\n\t\t\tNameData\tsrcname;\n\n\t\t\t/*\n\t\t\t * Must be careful in case the caller passed a C string where a\n\t\t\t * NAME is wanted: convert the given argument to a correctly\n\t\t\t * padded NAME.  Otherwise the memcpy() done by datumCopy() could\n\t\t\t * fall off the end of memory.\n\t\t\t */\n\t\t\tif (att->atttypid == NAMEOID)\n\t\t\t{\n\t\t\t\tnamestrcpy(&srcname, DatumGetCString(src));\n\t\t\t\tsrc = NameGetDatum(&srcname);\n\t\t\t}\n\n\t\t\tdstkeys[i] = datumCopy(src,\n\t\t\t\t\t\t\t\t   att->attbyval,\n\t\t\t\t\t\t\t\t   att->attlen);\n\t\t}\n\t}\n\n}"
  },
  {
    "function_name": "CatCacheFreeKeys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "1928-1948",
    "snippet": "static void\nCatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos, Datum *keys)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tint\t\t\tattnum = attnos[i];\n\t\tForm_pg_attribute att;\n\n\t\t/* only valid system attribute is the oid, which is by value */\n\t\tif (attnum == ObjectIdAttributeNumber)\n\t\t\tcontinue;\n\t\tAssert(attnum > 0);\n\n\t\tatt = TupleDescAttr(tupdesc, attnum - 1);\n\n\t\tif (!att->attbyval)\n\t\t\tpfree(DatumGetPointer(keys[i]));\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "DatumGetPointer(keys[i])"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "keys[i]"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "attnum - 1"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "attnum > 0"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos, Datum *keys)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tint\t\t\tattnum = attnos[i];\n\t\tForm_pg_attribute att;\n\n\t\t/* only valid system attribute is the oid, which is by value */\n\t\tif (attnum == ObjectIdAttributeNumber)\n\t\t\tcontinue;\n\t\tAssert(attnum > 0);\n\n\t\tatt = TupleDescAttr(tupdesc, attnum - 1);\n\n\t\tif (!att->attbyval)\n\t\t\tpfree(DatumGetPointer(keys[i]));\n\t}\n}"
  },
  {
    "function_name": "CatalogCacheCreateEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "1822-1923",
    "snippet": "static CatCTup *\nCatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp, Datum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative)\n{\n\tCatCTup    *ct;\n\tHeapTuple\tdtp;\n\tMemoryContext oldcxt;\n\n\t/* negative entries have no tuple associated */\n\tif (ntp)\n\t{\n\t\tint\t\t\ti;\n\n\t\tAssert(!negative);\n\n\t\t/*\n\t\t * If there are any out-of-line toasted fields in the tuple, expand\n\t\t * them in-line.  This saves cycles during later use of the catcache\n\t\t * entry, and also protects us against the possibility of the toast\n\t\t * tuples being freed before we attempt to fetch them, in case of\n\t\t * something using a slightly stale catcache entry.\n\t\t */\n\t\tif (HeapTupleHasExternal(ntp))\n\t\t\tdtp = toast_flatten_tuple(ntp, cache->cc_tupdesc);\n\t\telse\n\t\t\tdtp = ntp;\n\n\t\t/* Allocate memory for CatCTup and the cached tuple in one go */\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tct = (CatCTup *) palloc(sizeof(CatCTup) +\n\t\t\t\t\t\t\t\tMAXIMUM_ALIGNOF + dtp->t_len);\n\t\tct->tuple.t_len = dtp->t_len;\n\t\tct->tuple.t_self = dtp->t_self;\n\t\tct->tuple.t_tableOid = dtp->t_tableOid;\n\t\tct->tuple.t_data = (HeapTupleHeader)\n\t\t\tMAXALIGN(((char *) ct) + sizeof(CatCTup));\n\t\t/* copy tuple contents */\n\t\tmemcpy((char *) ct->tuple.t_data,\n\t\t\t   (const char *) dtp->t_data,\n\t\t\t   dtp->t_len);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\tif (dtp != ntp)\n\t\t\theap_freetuple(dtp);\n\n\t\t/* extract keys - they'll point into the tuple if not by-value */\n\t\tfor (i = 0; i < cache->cc_nkeys; i++)\n\t\t{\n\t\t\tDatum\t\tatp;\n\t\t\tbool\t\tisnull;\n\n\t\t\tatp = heap_getattr(&ct->tuple,\n\t\t\t\t\t\t\t   cache->cc_keyno[i],\n\t\t\t\t\t\t\t   cache->cc_tupdesc,\n\t\t\t\t\t\t\t   &isnull);\n\t\t\tAssert(!isnull);\n\t\t\tct->keys[i] = atp;\n\t\t}\n\t}\n\telse\n\t{\n\t\tAssert(negative);\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\t\tct = (CatCTup *) palloc(sizeof(CatCTup));\n\n\t\t/*\n\t\t * Store keys - they'll point into separately allocated memory if not\n\t\t * by-value.\n\t\t */\n\t\tCatCacheCopyKeys(cache->cc_tupdesc, cache->cc_nkeys, cache->cc_keyno,\n\t\t\t\t\t\t arguments, ct->keys);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * Finish initializing the CatCTup header, and add it to the cache's\n\t * linked list and counts.\n\t */\n\tct->ct_magic = CT_MAGIC;\n\tct->my_cache = cache;\n\tct->c_list = NULL;\n\tct->refcount = 0;\t\t\t/* for the moment */\n\tct->dead = false;\n\tct->negative = negative;\n\tct->hash_value = hashValue;\n\n\tdlist_push_head(&cache->cc_bucket[hashIndex], &ct->cache_elem);\n\n\tcache->cc_ntup++;\n\tCacheHdr->ch_ntup++;\n\n\t/*\n\t * If the hash table has become too full, enlarge the buckets array. Quite\n\t * arbitrarily, we enlarge when fill factor > 2.\n\t */\n\tif (cache->cc_ntup > cache->cc_nbuckets * 2)\n\t\tRehashCatCache(cache);\n\n\treturn ct;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CatCacheHeader *CacheHdr = NULL;",
      "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
      "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
      "static void CatalogCacheInitializeCache(CatCache *cache);",
      "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);",
      "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RehashCatCache",
          "args": [
            "cache"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "RehashCatCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "875-908",
          "snippet": "static void\nRehashCatCache(CatCache *cp)\n{\n\tdlist_head *newbucket;\n\tint\t\t\tnewnbuckets;\n\tint\t\t\ti;\n\n\telog(DEBUG1, \"rehashing catalog cache id %d for %s; %d tups, %d buckets\",\n\t\t cp->id, cp->cc_relname, cp->cc_ntup, cp->cc_nbuckets);\n\n\t/* Allocate a new, larger, hash table. */\n\tnewnbuckets = cp->cc_nbuckets * 2;\n\tnewbucket = (dlist_head *) MemoryContextAllocZero(CacheMemoryContext, newnbuckets * sizeof(dlist_head));\n\n\t/* Move all entries from old hash table to new. */\n\tfor (i = 0; i < cp->cc_nbuckets; i++)\n\t{\n\t\tdlist_mutable_iter iter;\n\n\t\tdlist_foreach_modify(iter, &cp->cc_bucket[i])\n\t\t{\n\t\t\tCatCTup    *ct = dlist_container(CatCTup, cache_elem, iter.cur);\n\t\t\tint\t\t\thashIndex = HASH_INDEX(ct->hash_value, newnbuckets);\n\n\t\t\tdlist_delete(iter.cur);\n\t\t\tdlist_push_head(&newbucket[hashIndex], &ct->cache_elem);\n\t\t}\n\t}\n\n\t/* Switch to the new array. */\n\tpfree(cp->cc_bucket);\n\tcp->cc_nbuckets = newnbuckets;\n\tcp->cc_bucket = newbucket;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nstatic void\nRehashCatCache(CatCache *cp)\n{\n\tdlist_head *newbucket;\n\tint\t\t\tnewnbuckets;\n\tint\t\t\ti;\n\n\telog(DEBUG1, \"rehashing catalog cache id %d for %s; %d tups, %d buckets\",\n\t\t cp->id, cp->cc_relname, cp->cc_ntup, cp->cc_nbuckets);\n\n\t/* Allocate a new, larger, hash table. */\n\tnewnbuckets = cp->cc_nbuckets * 2;\n\tnewbucket = (dlist_head *) MemoryContextAllocZero(CacheMemoryContext, newnbuckets * sizeof(dlist_head));\n\n\t/* Move all entries from old hash table to new. */\n\tfor (i = 0; i < cp->cc_nbuckets; i++)\n\t{\n\t\tdlist_mutable_iter iter;\n\n\t\tdlist_foreach_modify(iter, &cp->cc_bucket[i])\n\t\t{\n\t\t\tCatCTup    *ct = dlist_container(CatCTup, cache_elem, iter.cur);\n\t\t\tint\t\t\thashIndex = HASH_INDEX(ct->hash_value, newnbuckets);\n\n\t\t\tdlist_delete(iter.cur);\n\t\t\tdlist_push_head(&newbucket[hashIndex], &ct->cache_elem);\n\t\t}\n\t}\n\n\t/* Switch to the new array. */\n\tpfree(cp->cc_bucket);\n\tcp->cc_nbuckets = newnbuckets;\n\tcp->cc_bucket = newbucket;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlist_push_head",
          "args": [
            "&cache->cc_bucket[hashIndex]",
            "&ct->cache_elem"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatCacheCopyKeys",
          "args": [
            "cache->cc_tupdesc",
            "cache->cc_nkeys",
            "cache->cc_keyno",
            "arguments",
            "ct->keys"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "CatCacheCopyKeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "1955-1998",
          "snippet": "static void\nCatCacheCopyKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *srckeys, Datum *dstkeys)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * XXX: memory and lookup performance could possibly be improved by\n\t * storing all keys in one allocation.\n\t */\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tint\t\t\tattnum = attnos[i];\n\n\t\tif (attnum == ObjectIdAttributeNumber)\n\t\t{\n\t\t\tdstkeys[i] = srckeys[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, attnum - 1);\n\t\t\tDatum\t\tsrc = srckeys[i];\n\t\t\tNameData\tsrcname;\n\n\t\t\t/*\n\t\t\t * Must be careful in case the caller passed a C string where a\n\t\t\t * NAME is wanted: convert the given argument to a correctly\n\t\t\t * padded NAME.  Otherwise the memcpy() done by datumCopy() could\n\t\t\t * fall off the end of memory.\n\t\t\t */\n\t\t\tif (att->atttypid == NAMEOID)\n\t\t\t{\n\t\t\t\tnamestrcpy(&srcname, DatumGetCString(src));\n\t\t\t\tsrc = NameGetDatum(&srcname);\n\t\t\t}\n\n\t\t\tdstkeys[i] = datumCopy(src,\n\t\t\t\t\t\t\t\t   att->attbyval,\n\t\t\t\t\t\t\t\t   att->attlen);\n\t\t}\n\t}\n\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);",
            "static void CatCacheCopyKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *srckeys, Datum *dstkeys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\nstatic void CatCacheCopyKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *srckeys, Datum *dstkeys);\n\nstatic void\nCatCacheCopyKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *srckeys, Datum *dstkeys)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * XXX: memory and lookup performance could possibly be improved by\n\t * storing all keys in one allocation.\n\t */\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tint\t\t\tattnum = attnos[i];\n\n\t\tif (attnum == ObjectIdAttributeNumber)\n\t\t{\n\t\t\tdstkeys[i] = srckeys[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, attnum - 1);\n\t\t\tDatum\t\tsrc = srckeys[i];\n\t\t\tNameData\tsrcname;\n\n\t\t\t/*\n\t\t\t * Must be careful in case the caller passed a C string where a\n\t\t\t * NAME is wanted: convert the given argument to a correctly\n\t\t\t * padded NAME.  Otherwise the memcpy() done by datumCopy() could\n\t\t\t * fall off the end of memory.\n\t\t\t */\n\t\t\tif (att->atttypid == NAMEOID)\n\t\t\t{\n\t\t\t\tnamestrcpy(&srcname, DatumGetCString(src));\n\t\t\t\tsrc = NameGetDatum(&srcname);\n\t\t\t}\n\n\t\t\tdstkeys[i] = datumCopy(src,\n\t\t\t\t\t\t\t\t   att->attbyval,\n\t\t\t\t\t\t\t\t   att->attlen);\n\t\t}\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(CatCTup)"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "negative"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "&ct->tuple",
            "cache->cc_keyno[i]",
            "cache->cc_tupdesc",
            "&isnull"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_freetuple",
          "args": [
            "dtp"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) ct->tuple.t_data",
            "(const char *) dtp->t_data",
            "dtp->t_len"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "((char *) ct) + sizeof(CatCTup)"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_flatten_tuple",
          "args": [
            "ntp",
            "cache->cc_tupdesc"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHasExternal",
          "args": [
            "ntp"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!negative"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic CatCTup *\nCatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp, Datum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative)\n{\n\tCatCTup    *ct;\n\tHeapTuple\tdtp;\n\tMemoryContext oldcxt;\n\n\t/* negative entries have no tuple associated */\n\tif (ntp)\n\t{\n\t\tint\t\t\ti;\n\n\t\tAssert(!negative);\n\n\t\t/*\n\t\t * If there are any out-of-line toasted fields in the tuple, expand\n\t\t * them in-line.  This saves cycles during later use of the catcache\n\t\t * entry, and also protects us against the possibility of the toast\n\t\t * tuples being freed before we attempt to fetch them, in case of\n\t\t * something using a slightly stale catcache entry.\n\t\t */\n\t\tif (HeapTupleHasExternal(ntp))\n\t\t\tdtp = toast_flatten_tuple(ntp, cache->cc_tupdesc);\n\t\telse\n\t\t\tdtp = ntp;\n\n\t\t/* Allocate memory for CatCTup and the cached tuple in one go */\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tct = (CatCTup *) palloc(sizeof(CatCTup) +\n\t\t\t\t\t\t\t\tMAXIMUM_ALIGNOF + dtp->t_len);\n\t\tct->tuple.t_len = dtp->t_len;\n\t\tct->tuple.t_self = dtp->t_self;\n\t\tct->tuple.t_tableOid = dtp->t_tableOid;\n\t\tct->tuple.t_data = (HeapTupleHeader)\n\t\t\tMAXALIGN(((char *) ct) + sizeof(CatCTup));\n\t\t/* copy tuple contents */\n\t\tmemcpy((char *) ct->tuple.t_data,\n\t\t\t   (const char *) dtp->t_data,\n\t\t\t   dtp->t_len);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\tif (dtp != ntp)\n\t\t\theap_freetuple(dtp);\n\n\t\t/* extract keys - they'll point into the tuple if not by-value */\n\t\tfor (i = 0; i < cache->cc_nkeys; i++)\n\t\t{\n\t\t\tDatum\t\tatp;\n\t\t\tbool\t\tisnull;\n\n\t\t\tatp = heap_getattr(&ct->tuple,\n\t\t\t\t\t\t\t   cache->cc_keyno[i],\n\t\t\t\t\t\t\t   cache->cc_tupdesc,\n\t\t\t\t\t\t\t   &isnull);\n\t\t\tAssert(!isnull);\n\t\t\tct->keys[i] = atp;\n\t\t}\n\t}\n\telse\n\t{\n\t\tAssert(negative);\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\t\tct = (CatCTup *) palloc(sizeof(CatCTup));\n\n\t\t/*\n\t\t * Store keys - they'll point into separately allocated memory if not\n\t\t * by-value.\n\t\t */\n\t\tCatCacheCopyKeys(cache->cc_tupdesc, cache->cc_nkeys, cache->cc_keyno,\n\t\t\t\t\t\t arguments, ct->keys);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * Finish initializing the CatCTup header, and add it to the cache's\n\t * linked list and counts.\n\t */\n\tct->ct_magic = CT_MAGIC;\n\tct->my_cache = cache;\n\tct->c_list = NULL;\n\tct->refcount = 0;\t\t\t/* for the moment */\n\tct->dead = false;\n\tct->negative = negative;\n\tct->hash_value = hashValue;\n\n\tdlist_push_head(&cache->cc_bucket[hashIndex], &ct->cache_elem);\n\n\tcache->cc_ntup++;\n\tCacheHdr->ch_ntup++;\n\n\t/*\n\t * If the hash table has become too full, enlarge the buckets array. Quite\n\t * arbitrarily, we enlarge when fill factor > 2.\n\t */\n\tif (cache->cc_ntup > cache->cc_nbuckets * 2)\n\t\tRehashCatCache(cache);\n\n\treturn ct;\n}"
  },
  {
    "function_name": "ReleaseCatCacheList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "1799-1814",
    "snippet": "void\nReleaseCatCacheList(CatCList *list)\n{\n\t/* Safety checks to ensure we were handed a cache entry */\n\tAssert(list->cl_magic == CL_MAGIC);\n\tAssert(list->refcount > 0);\n\tlist->refcount--;\n\tResourceOwnerForgetCatCacheListRef(CurrentResourceOwner, list);\n\n\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\tlist->dead &&\n#endif\n\t\tlist->refcount == 0)\n\t\tCatCacheRemoveCList(list->my_cache, list);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CatCacheRemoveCList",
          "args": [
            "list->my_cache",
            "list"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "CatCacheRemoveCList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "514-546",
          "snippet": "static void\nCatCacheRemoveCList(CatCache *cache, CatCList *cl)\n{\n\tint\t\t\ti;\n\n\tAssert(cl->refcount == 0);\n\tAssert(cl->my_cache == cache);\n\n\t/* delink from member tuples */\n\tfor (i = cl->n_members; --i >= 0;)\n\t{\n\t\tCatCTup    *ct = cl->members[i];\n\n\t\tAssert(ct->c_list == cl);\n\t\tct->c_list = NULL;\n\t\t/* if the member is dead and now has no references, remove it */\n\t\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\t\tct->dead &&\n#endif\n\t\t\tct->refcount == 0)\n\t\t\tCatCacheRemoveCTup(cache, ct);\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&cl->cache_elem);\n\n\t/* free associated column data */\n\tCatCacheFreeKeys(cache->cc_tupdesc, cl->nkeys,\n\t\t\t\t\t cache->cc_keyno, cl->keys);\n\n\tpfree(cl);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatCacheRemoveCList(CatCache *cache, CatCList *cl);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatCacheRemoveCList(CatCache *cache, CatCList *cl);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatCacheRemoveCList(CatCache *cache, CatCList *cl)\n{\n\tint\t\t\ti;\n\n\tAssert(cl->refcount == 0);\n\tAssert(cl->my_cache == cache);\n\n\t/* delink from member tuples */\n\tfor (i = cl->n_members; --i >= 0;)\n\t{\n\t\tCatCTup    *ct = cl->members[i];\n\n\t\tAssert(ct->c_list == cl);\n\t\tct->c_list = NULL;\n\t\t/* if the member is dead and now has no references, remove it */\n\t\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\t\tct->dead &&\n#endif\n\t\t\tct->refcount == 0)\n\t\t\tCatCacheRemoveCTup(cache, ct);\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&cl->cache_elem);\n\n\t/* free associated column data */\n\tCatCacheFreeKeys(cache->cc_tupdesc, cl->nkeys,\n\t\t\t\t\t cache->cc_keyno, cl->keys);\n\n\tpfree(cl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceOwnerForgetCatCacheListRef",
          "args": [
            "CurrentResourceOwner",
            "list"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerForgetCatCacheListRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "991-997",
          "snippet": "void\nResourceOwnerForgetCatCacheListRef(ResourceOwner owner, CatCList *list)\n{\n\tif (!ResourceArrayRemove(&(owner->catlistrefarr), PointerGetDatum(list)))\n\t\telog(ERROR, \"catcache list reference %p is not owned by resource owner %s\",\n\t\t\t list, owner->name);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerForgetCatCacheListRef(ResourceOwner owner, CatCList *list)\n{\n\tif (!ResourceArrayRemove(&(owner->catlistrefarr), PointerGetDatum(list)))\n\t\telog(ERROR, \"catcache list reference %p is not owned by resource owner %s\",\n\t\t\t list, owner->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "list->refcount > 0"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "list->cl_magic == CL_MAGIC"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nReleaseCatCacheList(CatCList *list)\n{\n\t/* Safety checks to ensure we were handed a cache entry */\n\tAssert(list->cl_magic == CL_MAGIC);\n\tAssert(list->refcount > 0);\n\tlist->refcount--;\n\tResourceOwnerForgetCatCacheListRef(CurrentResourceOwner, list);\n\n\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\tlist->dead &&\n#endif\n\t\tlist->refcount == 0)\n\t\tCatCacheRemoveCList(list->my_cache, list);\n}"
  },
  {
    "function_name": "SearchCatCacheList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "1523-1792",
    "snippet": "CatCList *\nSearchCatCacheList(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   Datum v1,\n\t\t\t\t   Datum v2,\n\t\t\t\t   Datum v3)\n{\n\tDatum\t\tv4 = 0;\t\t\t/* dummy last-column value */\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\tuint32\t\tlHashValue;\n\tdlist_iter\titer;\n\tCatCList   *cl;\n\tCatCTup    *ct;\n\tList\t   *volatile ctlist;\n\tListCell   *ctlist_item;\n\tint\t\t\tnmembers;\n\tbool\t\tordered;\n\tHeapTuple\tntp;\n\tMemoryContext oldcxt;\n\tint\t\t\ti;\n\n\t/*\n\t * one-time startup overhead for each cache\n\t */\n\tif (cache->cc_tupdesc == NULL)\n\t\tCatalogCacheInitializeCache(cache);\n\n\tAssert(nkeys > 0 && nkeys < cache->cc_nkeys);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_lsearches++;\n#endif\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * compute a hash value of the given keys for faster search.  We don't\n\t * presently divide the CatCList items into buckets, but this still lets\n\t * us skip non-matching items quickly most of the time.\n\t */\n\tlHashValue = CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n\n\t/*\n\t * scan the items until we find a match or exhaust our list\n\t *\n\t * Note: it's okay to use dlist_foreach here, even though we modify the\n\t * dlist within the loop, because we don't continue the loop afterwards.\n\t */\n\tdlist_foreach(iter, &cache->cc_lists)\n\t{\n\t\tcl = dlist_container(CatCList, cache_elem, iter.cur);\n\n\t\tif (cl->dead)\n\t\t\tcontinue;\t\t\t/* ignore dead entries */\n\n\t\tif (cl->hash_value != lHashValue)\n\t\t\tcontinue;\t\t\t/* quickly skip entry if wrong hash val */\n\n\t\t/*\n\t\t * see if the cached list matches our key.\n\t\t */\n\t\tif (cl->nkeys != nkeys)\n\t\t\tcontinue;\n\n\t\tif (!CatalogCacheCompareTuple(cache, nkeys, cl->keys, arguments))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We found a matching list.  Move the list to the front of the\n\t\t * cache's list-of-lists, to speed subsequent searches.  (We do not\n\t\t * move the members to the fronts of their hashbucket lists, however,\n\t\t * since there's no point in that unless they are searched for\n\t\t * individually.)\n\t\t */\n\t\tdlist_move_head(&cache->cc_lists, &cl->cache_elem);\n\n\t\t/* Bump the list's refcount and return it */\n\t\tResourceOwnerEnlargeCatCacheListRefs(CurrentResourceOwner);\n\t\tcl->refcount++;\n\t\tResourceOwnerRememberCatCacheListRef(CurrentResourceOwner, cl);\n\n\t\tCACHE2_elog(DEBUG2, \"SearchCatCacheList(%s): found list\",\n\t\t\t\t\tcache->cc_relname);\n\n#ifdef CATCACHE_STATS\n\t\tcache->cc_lhits++;\n#endif\n\n\t\treturn cl;\n\t}\n\n\t/*\n\t * List was not found in cache, so we have to build it by reading the\n\t * relation.  For each matching tuple found in the relation, use an\n\t * existing cache entry if possible, else build a new one.\n\t *\n\t * We have to bump the member refcounts temporarily to ensure they won't\n\t * get dropped from the cache while loading other members. We use a PG_TRY\n\t * block to ensure we can undo those refcounts if we get an error before\n\t * we finish constructing the CatCList.\n\t */\n\tResourceOwnerEnlargeCatCacheListRefs(CurrentResourceOwner);\n\n\tctlist = NIL;\n\n\tPG_TRY();\n\t{\n\t\tScanKeyData cur_skey[CATCACHE_MAXKEYS];\n\t\tRelation\trelation;\n\t\tSysScanDesc scandesc;\n\n\t\t/*\n\t\t * Ok, need to make a lookup in the relation, copy the scankey and\n\t\t * fill out any per-call fields.\n\t\t */\n\t\tmemcpy(cur_skey, cache->cc_skey, sizeof(ScanKeyData) * cache->cc_nkeys);\n\t\tcur_skey[0].sk_argument = v1;\n\t\tcur_skey[1].sk_argument = v2;\n\t\tcur_skey[2].sk_argument = v3;\n\t\tcur_skey[3].sk_argument = v4;\n\n\t\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\t\tscandesc = systable_beginscan(relation,\n\t\t\t\t\t\t\t\t\t  cache->cc_indexoid,\n\t\t\t\t\t\t\t\t\t  IndexScanOK(cache, cur_skey),\n\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t  nkeys,\n\t\t\t\t\t\t\t\t\t  cur_skey);\n\n\t\t/* The list will be ordered iff we are doing an index scan */\n\t\tordered = (scandesc->irel != NULL);\n\n\t\twhile (HeapTupleIsValid(ntp = systable_getnext(scandesc)))\n\t\t{\n\t\t\tuint32\t\thashValue;\n\t\t\tIndex\t\thashIndex;\n\t\t\tbool\t\tfound = false;\n\t\t\tdlist_head *bucket;\n\n\t\t\t/*\n\t\t\t * See if there's an entry for this tuple already.\n\t\t\t */\n\t\t\tct = NULL;\n\t\t\thashValue = CatalogCacheComputeTupleHashValue(cache, cache->cc_nkeys, ntp);\n\t\t\thashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);\n\n\t\t\tbucket = &cache->cc_bucket[hashIndex];\n\t\t\tdlist_foreach(iter, bucket)\n\t\t\t{\n\t\t\t\tct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\t\t\tif (ct->dead || ct->negative)\n\t\t\t\t\tcontinue;\t/* ignore dead and negative entries */\n\n\t\t\t\tif (ct->hash_value != hashValue)\n\t\t\t\t\tcontinue;\t/* quickly skip entry if wrong hash val */\n\n\t\t\t\tif (!ItemPointerEquals(&(ct->tuple.t_self), &(ntp->t_self)))\n\t\t\t\t\tcontinue;\t/* not same tuple */\n\n\t\t\t\t/*\n\t\t\t\t * Found a match, but can't use it if it belongs to another\n\t\t\t\t * list already\n\t\t\t\t */\n\t\t\t\tif (ct->c_list)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\t\t\t/* A-OK */\n\t\t\t}\n\n\t\t\tif (!found)\n\t\t\t{\n\t\t\t\t/* We didn't find a usable entry, so make a new one */\n\t\t\t\tct = CatalogCacheCreateEntry(cache, ntp, arguments,\n\t\t\t\t\t\t\t\t\t\t\t hashValue, hashIndex,\n\t\t\t\t\t\t\t\t\t\t\t false);\n\t\t\t}\n\n\t\t\t/* Careful here: add entry to ctlist, then bump its refcount */\n\t\t\t/* This way leaves state correct if lappend runs out of memory */\n\t\t\tctlist = lappend(ctlist, ct);\n\t\t\tct->refcount++;\n\t\t}\n\n\t\tsystable_endscan(scandesc);\n\n\t\theap_close(relation, AccessShareLock);\n\n\t\t/* Now we can build the CatCList entry. */\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\t\tnmembers = list_length(ctlist);\n\t\tcl = (CatCList *)\n\t\t\tpalloc(offsetof(CatCList, members) + nmembers * sizeof(CatCTup *));\n\n\t\t/* Extract key values */\n\t\tCatCacheCopyKeys(cache->cc_tupdesc, nkeys, cache->cc_keyno,\n\t\t\t\t\t\t arguments, cl->keys);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t/*\n\t\t * We are now past the last thing that could trigger an elog before we\n\t\t * have finished building the CatCList and remembering it in the\n\t\t * resource owner.  So it's OK to fall out of the PG_TRY, and indeed\n\t\t * we'd better do so before we start marking the members as belonging\n\t\t * to the list.\n\t\t */\n\n\t}\n\tPG_CATCH();\n\t{\n\t\tforeach(ctlist_item, ctlist)\n\t\t{\n\t\t\tct = (CatCTup *) lfirst(ctlist_item);\n\t\t\tAssert(ct->c_list == NULL);\n\t\t\tAssert(ct->refcount > 0);\n\t\t\tct->refcount--;\n\t\t\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\t\t\tct->dead &&\n#endif\n\t\t\t\tct->refcount == 0 &&\n\t\t\t\t(ct->c_list == NULL || ct->c_list->refcount == 0))\n\t\t\t\tCatCacheRemoveCTup(cache, ct);\n\t\t}\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\tcl->cl_magic = CL_MAGIC;\n\tcl->my_cache = cache;\n\tcl->refcount = 0;\t\t\t/* for the moment */\n\tcl->dead = false;\n\tcl->ordered = ordered;\n\tcl->nkeys = nkeys;\n\tcl->hash_value = lHashValue;\n\tcl->n_members = nmembers;\n\n\ti = 0;\n\tforeach(ctlist_item, ctlist)\n\t{\n\t\tcl->members[i++] = ct = (CatCTup *) lfirst(ctlist_item);\n\t\tAssert(ct->c_list == NULL);\n\t\tct->c_list = cl;\n\t\t/* release the temporary refcount on the member */\n\t\tAssert(ct->refcount > 0);\n\t\tct->refcount--;\n\t\t/* mark list dead if any members already dead */\n\t\tif (ct->dead)\n\t\t\tcl->dead = true;\n\t}\n\tAssert(i == nmembers);\n\n\tdlist_push_head(&cache->cc_lists, &cl->cache_elem);\n\n\t/* Finally, bump the list's refcount and return it */\n\tcl->refcount++;\n\tResourceOwnerRememberCatCacheListRef(CurrentResourceOwner, cl);\n\n\tCACHE3_elog(DEBUG2, \"SearchCatCacheList(%s): made list of %d members\",\n\t\t\t\tcache->cc_relname, nmembers);\n\n\treturn cl;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
      "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
      "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
      "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
      "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
      "static void CatCacheRemoveCList(CatCache *cache, CatCList *cl);",
      "static void CatalogCacheInitializeCache(CatCache *cache);",
      "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);",
      "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CACHE3_elog",
          "args": [
            "DEBUG2",
            "\"SearchCatCacheList(%s): made list of %d members\"",
            "cache->cc_relname",
            "nmembers"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResourceOwnerRememberCatCacheListRef",
          "args": [
            "CurrentResourceOwner",
            "cl"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerRememberCatCacheListRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "982-986",
          "snippet": "void\nResourceOwnerRememberCatCacheListRef(ResourceOwner owner, CatCList *list)\n{\n\tResourceArrayAdd(&(owner->catlistrefarr), PointerGetDatum(list));\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerRememberCatCacheListRef(ResourceOwner owner, CatCList *list)\n{\n\tResourceArrayAdd(&(owner->catlistrefarr), PointerGetDatum(list));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlist_push_head",
          "args": [
            "&cache->cc_lists",
            "&cl->cache_elem"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "i == nmembers"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ct->refcount > 0"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ct->c_list == NULL"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "ctlist_item"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "ctlist_item",
            "ctlist"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_END_TRY",
          "args": [],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatCacheRemoveCTup",
          "args": [
            "cache",
            "ct"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "CatCacheRemoveCTup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "472-505",
          "snippet": "static void\nCatCacheRemoveCTup(CatCache *cache, CatCTup *ct)\n{\n\tAssert(ct->refcount == 0);\n\tAssert(ct->my_cache == cache);\n\n\tif (ct->c_list)\n\t{\n\t\t/*\n\t\t * The cleanest way to handle this is to call CatCacheRemoveCList,\n\t\t * which will recurse back to me, and the recursive call will do the\n\t\t * work.  Set the \"dead\" flag to make sure it does recurse.\n\t\t */\n\t\tct->dead = true;\n\t\tCatCacheRemoveCList(cache, ct->c_list);\n\t\treturn;\t\t\t\t\t/* nothing left to do */\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&ct->cache_elem);\n\n\t/*\n\t * Free keys when we're dealing with a negative entry, normal entries just\n\t * point into tuple, allocated together with the CatCTup.\n\t */\n\tif (ct->negative)\n\t\tCatCacheFreeKeys(cache->cc_tupdesc, cache->cc_nkeys,\n\t\t\t\t\t\t cache->cc_keyno, ct->keys);\n\n\tpfree(ct);\n\n\t--cache->cc_ntup;\n\t--CacheHdr->ch_ntup;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCacheHeader *CacheHdr = NULL;",
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatCacheRemoveCTup(CatCache *cache, CatCTup *ct)\n{\n\tAssert(ct->refcount == 0);\n\tAssert(ct->my_cache == cache);\n\n\tif (ct->c_list)\n\t{\n\t\t/*\n\t\t * The cleanest way to handle this is to call CatCacheRemoveCList,\n\t\t * which will recurse back to me, and the recursive call will do the\n\t\t * work.  Set the \"dead\" flag to make sure it does recurse.\n\t\t */\n\t\tct->dead = true;\n\t\tCatCacheRemoveCList(cache, ct->c_list);\n\t\treturn;\t\t\t\t\t/* nothing left to do */\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&ct->cache_elem);\n\n\t/*\n\t * Free keys when we're dealing with a negative entry, normal entries just\n\t * point into tuple, allocated together with the CatCTup.\n\t */\n\tif (ct->negative)\n\t\tCatCacheFreeKeys(cache->cc_tupdesc, cache->cc_nkeys,\n\t\t\t\t\t\t cache->cc_keyno, ct->keys);\n\n\tpfree(ct);\n\n\t--cache->cc_ntup;\n\t--CacheHdr->ch_ntup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ct->refcount > 0"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ct->c_list == NULL"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "ctlist_item"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "ctlist_item",
            "ctlist"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_CATCH",
          "args": [],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatCacheCopyKeys",
          "args": [
            "cache->cc_tupdesc",
            "nkeys",
            "cache->cc_keyno",
            "arguments",
            "cl->keys"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "CatCacheCopyKeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "1955-1998",
          "snippet": "static void\nCatCacheCopyKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *srckeys, Datum *dstkeys)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * XXX: memory and lookup performance could possibly be improved by\n\t * storing all keys in one allocation.\n\t */\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tint\t\t\tattnum = attnos[i];\n\n\t\tif (attnum == ObjectIdAttributeNumber)\n\t\t{\n\t\t\tdstkeys[i] = srckeys[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, attnum - 1);\n\t\t\tDatum\t\tsrc = srckeys[i];\n\t\t\tNameData\tsrcname;\n\n\t\t\t/*\n\t\t\t * Must be careful in case the caller passed a C string where a\n\t\t\t * NAME is wanted: convert the given argument to a correctly\n\t\t\t * padded NAME.  Otherwise the memcpy() done by datumCopy() could\n\t\t\t * fall off the end of memory.\n\t\t\t */\n\t\t\tif (att->atttypid == NAMEOID)\n\t\t\t{\n\t\t\t\tnamestrcpy(&srcname, DatumGetCString(src));\n\t\t\t\tsrc = NameGetDatum(&srcname);\n\t\t\t}\n\n\t\t\tdstkeys[i] = datumCopy(src,\n\t\t\t\t\t\t\t\t   att->attbyval,\n\t\t\t\t\t\t\t\t   att->attlen);\n\t\t}\n\t}\n\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);",
            "static void CatCacheCopyKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *srckeys, Datum *dstkeys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\nstatic void CatCacheCopyKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *srckeys, Datum *dstkeys);\n\nstatic void\nCatCacheCopyKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *srckeys, Datum *dstkeys)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * XXX: memory and lookup performance could possibly be improved by\n\t * storing all keys in one allocation.\n\t */\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tint\t\t\tattnum = attnos[i];\n\n\t\tif (attnum == ObjectIdAttributeNumber)\n\t\t{\n\t\t\tdstkeys[i] = srckeys[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, attnum - 1);\n\t\t\tDatum\t\tsrc = srckeys[i];\n\t\t\tNameData\tsrcname;\n\n\t\t\t/*\n\t\t\t * Must be careful in case the caller passed a C string where a\n\t\t\t * NAME is wanted: convert the given argument to a correctly\n\t\t\t * padded NAME.  Otherwise the memcpy() done by datumCopy() could\n\t\t\t * fall off the end of memory.\n\t\t\t */\n\t\t\tif (att->atttypid == NAMEOID)\n\t\t\t{\n\t\t\t\tnamestrcpy(&srcname, DatumGetCString(src));\n\t\t\t\tsrc = NameGetDatum(&srcname);\n\t\t\t}\n\n\t\t\tdstkeys[i] = datumCopy(src,\n\t\t\t\t\t\t\t\t   att->attbyval,\n\t\t\t\t\t\t\t\t   att->attlen);\n\t\t}\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "offsetof(CatCList, members) + nmembers * sizeof(CatCTup *)"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "ctlist"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "relation",
            "AccessShareLock"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "scandesc"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "ctlist",
            "ct"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatalogCacheCreateEntry",
          "args": [
            "cache",
            "ntp",
            "arguments",
            "hashValue",
            "hashIndex",
            "false"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "CatalogCacheCreateEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "1822-1923",
          "snippet": "static CatCTup *\nCatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp, Datum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative)\n{\n\tCatCTup    *ct;\n\tHeapTuple\tdtp;\n\tMemoryContext oldcxt;\n\n\t/* negative entries have no tuple associated */\n\tif (ntp)\n\t{\n\t\tint\t\t\ti;\n\n\t\tAssert(!negative);\n\n\t\t/*\n\t\t * If there are any out-of-line toasted fields in the tuple, expand\n\t\t * them in-line.  This saves cycles during later use of the catcache\n\t\t * entry, and also protects us against the possibility of the toast\n\t\t * tuples being freed before we attempt to fetch them, in case of\n\t\t * something using a slightly stale catcache entry.\n\t\t */\n\t\tif (HeapTupleHasExternal(ntp))\n\t\t\tdtp = toast_flatten_tuple(ntp, cache->cc_tupdesc);\n\t\telse\n\t\t\tdtp = ntp;\n\n\t\t/* Allocate memory for CatCTup and the cached tuple in one go */\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tct = (CatCTup *) palloc(sizeof(CatCTup) +\n\t\t\t\t\t\t\t\tMAXIMUM_ALIGNOF + dtp->t_len);\n\t\tct->tuple.t_len = dtp->t_len;\n\t\tct->tuple.t_self = dtp->t_self;\n\t\tct->tuple.t_tableOid = dtp->t_tableOid;\n\t\tct->tuple.t_data = (HeapTupleHeader)\n\t\t\tMAXALIGN(((char *) ct) + sizeof(CatCTup));\n\t\t/* copy tuple contents */\n\t\tmemcpy((char *) ct->tuple.t_data,\n\t\t\t   (const char *) dtp->t_data,\n\t\t\t   dtp->t_len);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\tif (dtp != ntp)\n\t\t\theap_freetuple(dtp);\n\n\t\t/* extract keys - they'll point into the tuple if not by-value */\n\t\tfor (i = 0; i < cache->cc_nkeys; i++)\n\t\t{\n\t\t\tDatum\t\tatp;\n\t\t\tbool\t\tisnull;\n\n\t\t\tatp = heap_getattr(&ct->tuple,\n\t\t\t\t\t\t\t   cache->cc_keyno[i],\n\t\t\t\t\t\t\t   cache->cc_tupdesc,\n\t\t\t\t\t\t\t   &isnull);\n\t\t\tAssert(!isnull);\n\t\t\tct->keys[i] = atp;\n\t\t}\n\t}\n\telse\n\t{\n\t\tAssert(negative);\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\t\tct = (CatCTup *) palloc(sizeof(CatCTup));\n\n\t\t/*\n\t\t * Store keys - they'll point into separately allocated memory if not\n\t\t * by-value.\n\t\t */\n\t\tCatCacheCopyKeys(cache->cc_tupdesc, cache->cc_nkeys, cache->cc_keyno,\n\t\t\t\t\t\t arguments, ct->keys);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * Finish initializing the CatCTup header, and add it to the cache's\n\t * linked list and counts.\n\t */\n\tct->ct_magic = CT_MAGIC;\n\tct->my_cache = cache;\n\tct->c_list = NULL;\n\tct->refcount = 0;\t\t\t/* for the moment */\n\tct->dead = false;\n\tct->negative = negative;\n\tct->hash_value = hashValue;\n\n\tdlist_push_head(&cache->cc_bucket[hashIndex], &ct->cache_elem);\n\n\tcache->cc_ntup++;\n\tCacheHdr->ch_ntup++;\n\n\t/*\n\t * If the hash table has become too full, enlarge the buckets array. Quite\n\t * arbitrarily, we enlarge when fill factor > 2.\n\t */\n\tif (cache->cc_ntup > cache->cc_nbuckets * 2)\n\t\tRehashCatCache(cache);\n\n\treturn ct;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCacheHeader *CacheHdr = NULL;",
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic CatCTup *\nCatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp, Datum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative)\n{\n\tCatCTup    *ct;\n\tHeapTuple\tdtp;\n\tMemoryContext oldcxt;\n\n\t/* negative entries have no tuple associated */\n\tif (ntp)\n\t{\n\t\tint\t\t\ti;\n\n\t\tAssert(!negative);\n\n\t\t/*\n\t\t * If there are any out-of-line toasted fields in the tuple, expand\n\t\t * them in-line.  This saves cycles during later use of the catcache\n\t\t * entry, and also protects us against the possibility of the toast\n\t\t * tuples being freed before we attempt to fetch them, in case of\n\t\t * something using a slightly stale catcache entry.\n\t\t */\n\t\tif (HeapTupleHasExternal(ntp))\n\t\t\tdtp = toast_flatten_tuple(ntp, cache->cc_tupdesc);\n\t\telse\n\t\t\tdtp = ntp;\n\n\t\t/* Allocate memory for CatCTup and the cached tuple in one go */\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tct = (CatCTup *) palloc(sizeof(CatCTup) +\n\t\t\t\t\t\t\t\tMAXIMUM_ALIGNOF + dtp->t_len);\n\t\tct->tuple.t_len = dtp->t_len;\n\t\tct->tuple.t_self = dtp->t_self;\n\t\tct->tuple.t_tableOid = dtp->t_tableOid;\n\t\tct->tuple.t_data = (HeapTupleHeader)\n\t\t\tMAXALIGN(((char *) ct) + sizeof(CatCTup));\n\t\t/* copy tuple contents */\n\t\tmemcpy((char *) ct->tuple.t_data,\n\t\t\t   (const char *) dtp->t_data,\n\t\t\t   dtp->t_len);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\tif (dtp != ntp)\n\t\t\theap_freetuple(dtp);\n\n\t\t/* extract keys - they'll point into the tuple if not by-value */\n\t\tfor (i = 0; i < cache->cc_nkeys; i++)\n\t\t{\n\t\t\tDatum\t\tatp;\n\t\t\tbool\t\tisnull;\n\n\t\t\tatp = heap_getattr(&ct->tuple,\n\t\t\t\t\t\t\t   cache->cc_keyno[i],\n\t\t\t\t\t\t\t   cache->cc_tupdesc,\n\t\t\t\t\t\t\t   &isnull);\n\t\t\tAssert(!isnull);\n\t\t\tct->keys[i] = atp;\n\t\t}\n\t}\n\telse\n\t{\n\t\tAssert(negative);\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\t\tct = (CatCTup *) palloc(sizeof(CatCTup));\n\n\t\t/*\n\t\t * Store keys - they'll point into separately allocated memory if not\n\t\t * by-value.\n\t\t */\n\t\tCatCacheCopyKeys(cache->cc_tupdesc, cache->cc_nkeys, cache->cc_keyno,\n\t\t\t\t\t\t arguments, ct->keys);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * Finish initializing the CatCTup header, and add it to the cache's\n\t * linked list and counts.\n\t */\n\tct->ct_magic = CT_MAGIC;\n\tct->my_cache = cache;\n\tct->c_list = NULL;\n\tct->refcount = 0;\t\t\t/* for the moment */\n\tct->dead = false;\n\tct->negative = negative;\n\tct->hash_value = hashValue;\n\n\tdlist_push_head(&cache->cc_bucket[hashIndex], &ct->cache_elem);\n\n\tcache->cc_ntup++;\n\tCacheHdr->ch_ntup++;\n\n\t/*\n\t * If the hash table has become too full, enlarge the buckets array. Quite\n\t * arbitrarily, we enlarge when fill factor > 2.\n\t */\n\tif (cache->cc_ntup > cache->cc_nbuckets * 2)\n\t\tRehashCatCache(cache);\n\n\treturn ct;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ItemPointerEquals",
          "args": [
            "&(ct->tuple.t_self)",
            "&(ntp->t_self)"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_container",
          "args": [
            "CatCTup",
            "cache_elem",
            "iter.cur"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_foreach",
          "args": [
            "iter",
            "bucket"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HASH_INDEX",
          "args": [
            "hashValue",
            "cache->cc_nbuckets"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatalogCacheComputeTupleHashValue",
          "args": [
            "cache",
            "cache->cc_nkeys",
            "ntp"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "CatalogCacheComputeTupleHashValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "326-382",
          "snippet": "static uint32\nCatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys, HeapTuple tuple)\n{\n\tDatum\t\tv1 = 0,\n\t\t\t\tv2 = 0,\n\t\t\t\tv3 = 0,\n\t\t\t\tv4 = 0;\n\tbool\t\tisNull = false;\n\tint\t\t   *cc_keyno = cache->cc_keyno;\n\tTupleDesc\tcc_tupdesc = cache->cc_tupdesc;\n\n\t/* Now extract key fields from tuple, insert into scankey */\n\tswitch (nkeys)\n\t{\n\t\tcase 4:\n\t\t\tv4 = (cc_keyno[3] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[3],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 3:\n\t\t\tv3 = (cc_keyno[2] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[2],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\tv2 = (cc_keyno[1] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[1],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\tv1 = (cc_keyno[0] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[0],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"wrong number of hash keys: %d\", nkeys);\n\t\t\tbreak;\n\t}\n\n\treturn CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
            "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic uint32\nCatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys, HeapTuple tuple)\n{\n\tDatum\t\tv1 = 0,\n\t\t\t\tv2 = 0,\n\t\t\t\tv3 = 0,\n\t\t\t\tv4 = 0;\n\tbool\t\tisNull = false;\n\tint\t\t   *cc_keyno = cache->cc_keyno;\n\tTupleDesc\tcc_tupdesc = cache->cc_tupdesc;\n\n\t/* Now extract key fields from tuple, insert into scankey */\n\tswitch (nkeys)\n\t{\n\t\tcase 4:\n\t\t\tv4 = (cc_keyno[3] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[3],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 3:\n\t\t\tv3 = (cc_keyno[2] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[2],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\tv2 = (cc_keyno[1] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[1],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\tv1 = (cc_keyno[0] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[0],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"wrong number of hash keys: %d\", nkeys);\n\t\t\tbreak;\n\t}\n\n\treturn CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "ntp = systable_getnext(scandesc)"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "scandesc"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "relation",
            "cache->cc_indexoid",
            "IndexScanOK(cache, cur_skey)",
            "NULL",
            "nkeys",
            "cur_skey"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IndexScanOK",
          "args": [
            "cache",
            "cur_skey"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "IndexScanOK",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "1100-1146",
          "snippet": "static bool\nIndexScanOK(CatCache *cache, ScanKey cur_skey)\n{\n\tswitch (cache->id)\n\t{\n\t\tcase INDEXRELID:\n\n\t\t\t/*\n\t\t\t * Rather than tracking exactly which indexes have to be loaded\n\t\t\t * before we can use indexscans (which changes from time to time),\n\t\t\t * just force all pg_index searches to be heap scans until we've\n\t\t\t * built the critical relcaches.\n\t\t\t */\n\t\t\tif (!criticalRelcachesBuilt)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\n\t\tcase AMOID:\n\t\tcase AMNAME:\n\n\t\t\t/*\n\t\t\t * Always do heap scans in pg_am, because it's so small there's\n\t\t\t * not much point in an indexscan anyway.  We *must* do this when\n\t\t\t * initially building critical relcache entries, but we might as\n\t\t\t * well just always do it.\n\t\t\t */\n\t\t\treturn false;\n\n\t\tcase AUTHNAME:\n\t\tcase AUTHOID:\n\t\tcase AUTHMEMMEMROLE:\n\n\t\t\t/*\n\t\t\t * Protect authentication lookups occurring before relcache has\n\t\t\t * collected entries for shared indexes.\n\t\t\t */\n\t\t\tif (!criticalSharedRelcachesBuilt)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\t/* Normal case, allow index scan */\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nstatic bool\nIndexScanOK(CatCache *cache, ScanKey cur_skey)\n{\n\tswitch (cache->id)\n\t{\n\t\tcase INDEXRELID:\n\n\t\t\t/*\n\t\t\t * Rather than tracking exactly which indexes have to be loaded\n\t\t\t * before we can use indexscans (which changes from time to time),\n\t\t\t * just force all pg_index searches to be heap scans until we've\n\t\t\t * built the critical relcaches.\n\t\t\t */\n\t\t\tif (!criticalRelcachesBuilt)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\n\t\tcase AMOID:\n\t\tcase AMNAME:\n\n\t\t\t/*\n\t\t\t * Always do heap scans in pg_am, because it's so small there's\n\t\t\t * not much point in an indexscan anyway.  We *must* do this when\n\t\t\t * initially building critical relcache entries, but we might as\n\t\t\t * well just always do it.\n\t\t\t */\n\t\t\treturn false;\n\n\t\tcase AUTHNAME:\n\t\tcase AUTHOID:\n\t\tcase AUTHMEMMEMROLE:\n\n\t\t\t/*\n\t\t\t * Protect authentication lookups occurring before relcache has\n\t\t\t * collected entries for shared indexes.\n\t\t\t */\n\t\t\tif (!criticalSharedRelcachesBuilt)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\t/* Normal case, allow index scan */\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "cache->cc_reloid",
            "AccessShareLock"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cur_skey",
            "cache->cc_skey",
            "sizeof(ScanKeyData) * cache->cc_nkeys"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_TRY",
          "args": [],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResourceOwnerEnlargeCatCacheListRefs",
          "args": [
            "CurrentResourceOwner"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerEnlargeCatCacheListRefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "971-975",
          "snippet": "void\nResourceOwnerEnlargeCatCacheListRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->catlistrefarr));\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerEnlargeCatCacheListRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->catlistrefarr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CACHE2_elog",
          "args": [
            "DEBUG2",
            "\"SearchCatCacheList(%s): found list\"",
            "cache->cc_relname"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_move_head",
          "args": [
            "&cache->cc_lists",
            "&cl->cache_elem"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatalogCacheCompareTuple",
          "args": [
            "cache",
            "nkeys",
            "cl->keys",
            "arguments"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "CatalogCacheCompareTuple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "389-403",
          "snippet": "static inline bool\nCatalogCacheCompareTuple(const CatCache *cache, int nkeys,\n\t\t\t\t\t\t const Datum *cachekeys,\n\t\t\t\t\t\t const Datum *searchkeys)\n{\n\tconst CCFastEqualFN *cc_fastequal = cache->cc_fastequal;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tif (!(cc_fastequal[i]) (cachekeys[i], searchkeys[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool CatalogCacheCompareTuple(const CatCache *cache, int nkeys,\n\t\t\t\t\t\t const Datum *cachekeys,\n\t\t\t\t\t\t const Datum *searchkeys);",
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline bool CatalogCacheCompareTuple(const CatCache *cache, int nkeys,\n\t\t\t\t\t\t const Datum *cachekeys,\n\t\t\t\t\t\t const Datum *searchkeys);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nstatic inline bool\nCatalogCacheCompareTuple(const CatCache *cache, int nkeys,\n\t\t\t\t\t\t const Datum *cachekeys,\n\t\t\t\t\t\t const Datum *searchkeys)\n{\n\tconst CCFastEqualFN *cc_fastequal = cache->cc_fastequal;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tif (!(cc_fastequal[i]) (cachekeys[i], searchkeys[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlist_container",
          "args": [
            "CatCList",
            "cache_elem",
            "iter.cur"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_foreach",
          "args": [
            "iter",
            "&cache->cc_lists"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatalogCacheComputeHashValue",
          "args": [
            "cache",
            "nkeys",
            "v1",
            "v2",
            "v3",
            "v4"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "CatalogCacheComputeHashValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "275-319",
          "snippet": "static uint32\nCatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4)\n{\n\tuint32\t\thashValue = 0;\n\tuint32\t\toneHash;\n\tCCHashFN   *cc_hashfunc = cache->cc_hashfunc;\n\n\tCACHE4_elog(DEBUG2, \"CatalogCacheComputeHashValue %s %d %p\",\n\t\t\t\tcache->cc_relname,\n\t\t\t\tnkeys,\n\t\t\t\tcache);\n\n\tswitch (nkeys)\n\t{\n\t\tcase 4:\n\t\t\toneHash = (cc_hashfunc[3]) (v4);\n\n\t\t\thashValue ^= oneHash << 24;\n\t\t\thashValue ^= oneHash >> 8;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 3:\n\t\t\toneHash = (cc_hashfunc[2]) (v3);\n\n\t\t\thashValue ^= oneHash << 16;\n\t\t\thashValue ^= oneHash >> 16;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\toneHash = (cc_hashfunc[1]) (v2);\n\n\t\t\thashValue ^= oneHash << 8;\n\t\t\thashValue ^= oneHash >> 24;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\toneHash = (cc_hashfunc[0]) (v1);\n\n\t\t\thashValue ^= oneHash;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"wrong number of hash keys: %d\", nkeys);\n\t\t\tbreak;\n\t}\n\n\treturn hashValue;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
            "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic uint32\nCatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4)\n{\n\tuint32\t\thashValue = 0;\n\tuint32\t\toneHash;\n\tCCHashFN   *cc_hashfunc = cache->cc_hashfunc;\n\n\tCACHE4_elog(DEBUG2, \"CatalogCacheComputeHashValue %s %d %p\",\n\t\t\t\tcache->cc_relname,\n\t\t\t\tnkeys,\n\t\t\t\tcache);\n\n\tswitch (nkeys)\n\t{\n\t\tcase 4:\n\t\t\toneHash = (cc_hashfunc[3]) (v4);\n\n\t\t\thashValue ^= oneHash << 24;\n\t\t\thashValue ^= oneHash >> 8;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 3:\n\t\t\toneHash = (cc_hashfunc[2]) (v3);\n\n\t\t\thashValue ^= oneHash << 16;\n\t\t\thashValue ^= oneHash >> 16;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\toneHash = (cc_hashfunc[1]) (v2);\n\n\t\t\thashValue ^= oneHash << 8;\n\t\t\thashValue ^= oneHash >> 24;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\toneHash = (cc_hashfunc[0]) (v1);\n\n\t\t\thashValue ^= oneHash;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"wrong number of hash keys: %d\", nkeys);\n\t\t\tbreak;\n\t}\n\n\treturn hashValue;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nkeys > 0 && nkeys < cache->cc_nkeys"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatalogCacheInitializeCache",
          "args": [
            "cache"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "CatalogCacheInitializeCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "938-1038",
          "snippet": "static void\nCatalogCacheInitializeCache(CatCache *cache)\n{\n\tRelation\trelation;\n\tMemoryContext oldcxt;\n\tTupleDesc\ttupdesc;\n\tint\t\t\ti;\n\n\tCatalogCacheInitializeCache_DEBUG1;\n\n\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\t/*\n\t * switch to the cache context so our allocations do not vanish at the end\n\t * of a transaction\n\t */\n\tAssert(CacheMemoryContext != NULL);\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * copy the relcache's tuple descriptor to permanent cache storage\n\t */\n\ttupdesc = CreateTupleDescCopyConstr(RelationGetDescr(relation));\n\n\t/*\n\t * save the relation's name and relisshared flag, too (cc_relname is used\n\t * only for debugging purposes)\n\t */\n\tcache->cc_relname = pstrdup(RelationGetRelationName(relation));\n\tcache->cc_relisshared = RelationGetForm(relation)->relisshared;\n\n\t/*\n\t * return to the caller's memory context and close the rel\n\t */\n\tMemoryContextSwitchTo(oldcxt);\n\n\theap_close(relation, AccessShareLock);\n\n\tCACHE3_elog(DEBUG2, \"CatalogCacheInitializeCache: %s, %d keys\",\n\t\t\t\tcache->cc_relname, cache->cc_nkeys);\n\n\t/*\n\t * initialize cache's key information\n\t */\n\tfor (i = 0; i < cache->cc_nkeys; ++i)\n\t{\n\t\tOid\t\t\tkeytype;\n\t\tRegProcedure eqfunc;\n\n\t\tCatalogCacheInitializeCache_DEBUG2;\n\n\t\tif (cache->cc_keyno[i] > 0)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   cache->cc_keyno[i] - 1);\n\n\t\t\tkeytype = attr->atttypid;\n\t\t\t/* cache key columns should always be NOT NULL */\n\t\t\tAssert(attr->attnotnull);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (cache->cc_keyno[i] != ObjectIdAttributeNumber)\n\t\t\t\telog(FATAL, \"only sys attr supported in caches is OID\");\n\t\t\tkeytype = OIDOID;\n\t\t}\n\n\t\tGetCCHashEqFuncs(keytype,\n\t\t\t\t\t\t &cache->cc_hashfunc[i],\n\t\t\t\t\t\t &eqfunc,\n\t\t\t\t\t\t &cache->cc_fastequal[i]);\n\n\t\t/*\n\t\t * Do equality-function lookup (we assume this won't need a catalog\n\t\t * lookup for any supported type)\n\t\t */\n\t\tfmgr_info_cxt(eqfunc,\n\t\t\t\t\t  &cache->cc_skey[i].sk_func,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t\t/* Initialize sk_attno suitably for HeapKeyTest() and heap scans */\n\t\tcache->cc_skey[i].sk_attno = cache->cc_keyno[i];\n\n\t\t/* Fill in sk_strategy as well --- always standard equality */\n\t\tcache->cc_skey[i].sk_strategy = BTEqualStrategyNumber;\n\t\tcache->cc_skey[i].sk_subtype = InvalidOid;\n\t\t/* Currently, there are no catcaches on collation-aware data types */\n\t\tcache->cc_skey[i].sk_collation = InvalidOid;\n\n\t\tCACHE4_elog(DEBUG2, \"CatalogCacheInitializeCache %s %d %p\",\n\t\t\t\t\tcache->cc_relname,\n\t\t\t\t\ti,\n\t\t\t\t\tcache);\n\t}\n\n\t/*\n\t * mark this cache fully initialized\n\t */\n\tcache->cc_tupdesc = tupdesc;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define CatalogCacheInitializeCache_DEBUG2",
            "#define CatalogCacheInitializeCache_DEBUG1",
            "#define CatalogCacheInitializeCache_DEBUG2 \\\ndo { \\\n\t\tif (cache->cc_keyno[i] > 0) { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d, %u\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i], \\\n\t\t\t\t TupleDescAttr(tupdesc, cache->cc_keyno[i] - 1)->atttypid); \\\n\t\t} else { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i]); \\\n\t\t} \\\n} while(0)",
            "#define CatalogCacheInitializeCache_DEBUG1 \\\n\telog(DEBUG2, \"CatalogCacheInitializeCache: cache @%p rel=%u\", cache, \\\n\t\t cache->cc_reloid)"
          ],
          "globals_used": [
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\n#define CatalogCacheInitializeCache_DEBUG2\n#define CatalogCacheInitializeCache_DEBUG1\n#define CatalogCacheInitializeCache_DEBUG2 \\\ndo { \\\n\t\tif (cache->cc_keyno[i] > 0) { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d, %u\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i], \\\n\t\t\t\t TupleDescAttr(tupdesc, cache->cc_keyno[i] - 1)->atttypid); \\\n\t\t} else { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i]); \\\n\t\t} \\\n} while(0)\n#define CatalogCacheInitializeCache_DEBUG1 \\\n\telog(DEBUG2, \"CatalogCacheInitializeCache: cache @%p rel=%u\", cache, \\\n\t\t cache->cc_reloid)\n\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatalogCacheInitializeCache(CatCache *cache)\n{\n\tRelation\trelation;\n\tMemoryContext oldcxt;\n\tTupleDesc\ttupdesc;\n\tint\t\t\ti;\n\n\tCatalogCacheInitializeCache_DEBUG1;\n\n\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\t/*\n\t * switch to the cache context so our allocations do not vanish at the end\n\t * of a transaction\n\t */\n\tAssert(CacheMemoryContext != NULL);\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * copy the relcache's tuple descriptor to permanent cache storage\n\t */\n\ttupdesc = CreateTupleDescCopyConstr(RelationGetDescr(relation));\n\n\t/*\n\t * save the relation's name and relisshared flag, too (cc_relname is used\n\t * only for debugging purposes)\n\t */\n\tcache->cc_relname = pstrdup(RelationGetRelationName(relation));\n\tcache->cc_relisshared = RelationGetForm(relation)->relisshared;\n\n\t/*\n\t * return to the caller's memory context and close the rel\n\t */\n\tMemoryContextSwitchTo(oldcxt);\n\n\theap_close(relation, AccessShareLock);\n\n\tCACHE3_elog(DEBUG2, \"CatalogCacheInitializeCache: %s, %d keys\",\n\t\t\t\tcache->cc_relname, cache->cc_nkeys);\n\n\t/*\n\t * initialize cache's key information\n\t */\n\tfor (i = 0; i < cache->cc_nkeys; ++i)\n\t{\n\t\tOid\t\t\tkeytype;\n\t\tRegProcedure eqfunc;\n\n\t\tCatalogCacheInitializeCache_DEBUG2;\n\n\t\tif (cache->cc_keyno[i] > 0)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   cache->cc_keyno[i] - 1);\n\n\t\t\tkeytype = attr->atttypid;\n\t\t\t/* cache key columns should always be NOT NULL */\n\t\t\tAssert(attr->attnotnull);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (cache->cc_keyno[i] != ObjectIdAttributeNumber)\n\t\t\t\telog(FATAL, \"only sys attr supported in caches is OID\");\n\t\t\tkeytype = OIDOID;\n\t\t}\n\n\t\tGetCCHashEqFuncs(keytype,\n\t\t\t\t\t\t &cache->cc_hashfunc[i],\n\t\t\t\t\t\t &eqfunc,\n\t\t\t\t\t\t &cache->cc_fastequal[i]);\n\n\t\t/*\n\t\t * Do equality-function lookup (we assume this won't need a catalog\n\t\t * lookup for any supported type)\n\t\t */\n\t\tfmgr_info_cxt(eqfunc,\n\t\t\t\t\t  &cache->cc_skey[i].sk_func,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t\t/* Initialize sk_attno suitably for HeapKeyTest() and heap scans */\n\t\tcache->cc_skey[i].sk_attno = cache->cc_keyno[i];\n\n\t\t/* Fill in sk_strategy as well --- always standard equality */\n\t\tcache->cc_skey[i].sk_strategy = BTEqualStrategyNumber;\n\t\tcache->cc_skey[i].sk_subtype = InvalidOid;\n\t\t/* Currently, there are no catcaches on collation-aware data types */\n\t\tcache->cc_skey[i].sk_collation = InvalidOid;\n\n\t\tCACHE4_elog(DEBUG2, \"CatalogCacheInitializeCache %s %d %p\",\n\t\t\t\t\tcache->cc_relname,\n\t\t\t\t\ti,\n\t\t\t\t\tcache);\n\t}\n\n\t/*\n\t * mark this cache fully initialized\n\t */\n\tcache->cc_tupdesc = tupdesc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatCacheRemoveCList(CatCache *cache, CatCList *cl);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nCatCList *\nSearchCatCacheList(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   Datum v1,\n\t\t\t\t   Datum v2,\n\t\t\t\t   Datum v3)\n{\n\tDatum\t\tv4 = 0;\t\t\t/* dummy last-column value */\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\tuint32\t\tlHashValue;\n\tdlist_iter\titer;\n\tCatCList   *cl;\n\tCatCTup    *ct;\n\tList\t   *volatile ctlist;\n\tListCell   *ctlist_item;\n\tint\t\t\tnmembers;\n\tbool\t\tordered;\n\tHeapTuple\tntp;\n\tMemoryContext oldcxt;\n\tint\t\t\ti;\n\n\t/*\n\t * one-time startup overhead for each cache\n\t */\n\tif (cache->cc_tupdesc == NULL)\n\t\tCatalogCacheInitializeCache(cache);\n\n\tAssert(nkeys > 0 && nkeys < cache->cc_nkeys);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_lsearches++;\n#endif\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * compute a hash value of the given keys for faster search.  We don't\n\t * presently divide the CatCList items into buckets, but this still lets\n\t * us skip non-matching items quickly most of the time.\n\t */\n\tlHashValue = CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n\n\t/*\n\t * scan the items until we find a match or exhaust our list\n\t *\n\t * Note: it's okay to use dlist_foreach here, even though we modify the\n\t * dlist within the loop, because we don't continue the loop afterwards.\n\t */\n\tdlist_foreach(iter, &cache->cc_lists)\n\t{\n\t\tcl = dlist_container(CatCList, cache_elem, iter.cur);\n\n\t\tif (cl->dead)\n\t\t\tcontinue;\t\t\t/* ignore dead entries */\n\n\t\tif (cl->hash_value != lHashValue)\n\t\t\tcontinue;\t\t\t/* quickly skip entry if wrong hash val */\n\n\t\t/*\n\t\t * see if the cached list matches our key.\n\t\t */\n\t\tif (cl->nkeys != nkeys)\n\t\t\tcontinue;\n\n\t\tif (!CatalogCacheCompareTuple(cache, nkeys, cl->keys, arguments))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We found a matching list.  Move the list to the front of the\n\t\t * cache's list-of-lists, to speed subsequent searches.  (We do not\n\t\t * move the members to the fronts of their hashbucket lists, however,\n\t\t * since there's no point in that unless they are searched for\n\t\t * individually.)\n\t\t */\n\t\tdlist_move_head(&cache->cc_lists, &cl->cache_elem);\n\n\t\t/* Bump the list's refcount and return it */\n\t\tResourceOwnerEnlargeCatCacheListRefs(CurrentResourceOwner);\n\t\tcl->refcount++;\n\t\tResourceOwnerRememberCatCacheListRef(CurrentResourceOwner, cl);\n\n\t\tCACHE2_elog(DEBUG2, \"SearchCatCacheList(%s): found list\",\n\t\t\t\t\tcache->cc_relname);\n\n#ifdef CATCACHE_STATS\n\t\tcache->cc_lhits++;\n#endif\n\n\t\treturn cl;\n\t}\n\n\t/*\n\t * List was not found in cache, so we have to build it by reading the\n\t * relation.  For each matching tuple found in the relation, use an\n\t * existing cache entry if possible, else build a new one.\n\t *\n\t * We have to bump the member refcounts temporarily to ensure they won't\n\t * get dropped from the cache while loading other members. We use a PG_TRY\n\t * block to ensure we can undo those refcounts if we get an error before\n\t * we finish constructing the CatCList.\n\t */\n\tResourceOwnerEnlargeCatCacheListRefs(CurrentResourceOwner);\n\n\tctlist = NIL;\n\n\tPG_TRY();\n\t{\n\t\tScanKeyData cur_skey[CATCACHE_MAXKEYS];\n\t\tRelation\trelation;\n\t\tSysScanDesc scandesc;\n\n\t\t/*\n\t\t * Ok, need to make a lookup in the relation, copy the scankey and\n\t\t * fill out any per-call fields.\n\t\t */\n\t\tmemcpy(cur_skey, cache->cc_skey, sizeof(ScanKeyData) * cache->cc_nkeys);\n\t\tcur_skey[0].sk_argument = v1;\n\t\tcur_skey[1].sk_argument = v2;\n\t\tcur_skey[2].sk_argument = v3;\n\t\tcur_skey[3].sk_argument = v4;\n\n\t\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\t\tscandesc = systable_beginscan(relation,\n\t\t\t\t\t\t\t\t\t  cache->cc_indexoid,\n\t\t\t\t\t\t\t\t\t  IndexScanOK(cache, cur_skey),\n\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t  nkeys,\n\t\t\t\t\t\t\t\t\t  cur_skey);\n\n\t\t/* The list will be ordered iff we are doing an index scan */\n\t\tordered = (scandesc->irel != NULL);\n\n\t\twhile (HeapTupleIsValid(ntp = systable_getnext(scandesc)))\n\t\t{\n\t\t\tuint32\t\thashValue;\n\t\t\tIndex\t\thashIndex;\n\t\t\tbool\t\tfound = false;\n\t\t\tdlist_head *bucket;\n\n\t\t\t/*\n\t\t\t * See if there's an entry for this tuple already.\n\t\t\t */\n\t\t\tct = NULL;\n\t\t\thashValue = CatalogCacheComputeTupleHashValue(cache, cache->cc_nkeys, ntp);\n\t\t\thashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);\n\n\t\t\tbucket = &cache->cc_bucket[hashIndex];\n\t\t\tdlist_foreach(iter, bucket)\n\t\t\t{\n\t\t\t\tct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\t\t\tif (ct->dead || ct->negative)\n\t\t\t\t\tcontinue;\t/* ignore dead and negative entries */\n\n\t\t\t\tif (ct->hash_value != hashValue)\n\t\t\t\t\tcontinue;\t/* quickly skip entry if wrong hash val */\n\n\t\t\t\tif (!ItemPointerEquals(&(ct->tuple.t_self), &(ntp->t_self)))\n\t\t\t\t\tcontinue;\t/* not same tuple */\n\n\t\t\t\t/*\n\t\t\t\t * Found a match, but can't use it if it belongs to another\n\t\t\t\t * list already\n\t\t\t\t */\n\t\t\t\tif (ct->c_list)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\t\t\t/* A-OK */\n\t\t\t}\n\n\t\t\tif (!found)\n\t\t\t{\n\t\t\t\t/* We didn't find a usable entry, so make a new one */\n\t\t\t\tct = CatalogCacheCreateEntry(cache, ntp, arguments,\n\t\t\t\t\t\t\t\t\t\t\t hashValue, hashIndex,\n\t\t\t\t\t\t\t\t\t\t\t false);\n\t\t\t}\n\n\t\t\t/* Careful here: add entry to ctlist, then bump its refcount */\n\t\t\t/* This way leaves state correct if lappend runs out of memory */\n\t\t\tctlist = lappend(ctlist, ct);\n\t\t\tct->refcount++;\n\t\t}\n\n\t\tsystable_endscan(scandesc);\n\n\t\theap_close(relation, AccessShareLock);\n\n\t\t/* Now we can build the CatCList entry. */\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\t\tnmembers = list_length(ctlist);\n\t\tcl = (CatCList *)\n\t\t\tpalloc(offsetof(CatCList, members) + nmembers * sizeof(CatCTup *));\n\n\t\t/* Extract key values */\n\t\tCatCacheCopyKeys(cache->cc_tupdesc, nkeys, cache->cc_keyno,\n\t\t\t\t\t\t arguments, cl->keys);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t/*\n\t\t * We are now past the last thing that could trigger an elog before we\n\t\t * have finished building the CatCList and remembering it in the\n\t\t * resource owner.  So it's OK to fall out of the PG_TRY, and indeed\n\t\t * we'd better do so before we start marking the members as belonging\n\t\t * to the list.\n\t\t */\n\n\t}\n\tPG_CATCH();\n\t{\n\t\tforeach(ctlist_item, ctlist)\n\t\t{\n\t\t\tct = (CatCTup *) lfirst(ctlist_item);\n\t\t\tAssert(ct->c_list == NULL);\n\t\t\tAssert(ct->refcount > 0);\n\t\t\tct->refcount--;\n\t\t\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\t\t\tct->dead &&\n#endif\n\t\t\t\tct->refcount == 0 &&\n\t\t\t\t(ct->c_list == NULL || ct->c_list->refcount == 0))\n\t\t\t\tCatCacheRemoveCTup(cache, ct);\n\t\t}\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\tcl->cl_magic = CL_MAGIC;\n\tcl->my_cache = cache;\n\tcl->refcount = 0;\t\t\t/* for the moment */\n\tcl->dead = false;\n\tcl->ordered = ordered;\n\tcl->nkeys = nkeys;\n\tcl->hash_value = lHashValue;\n\tcl->n_members = nmembers;\n\n\ti = 0;\n\tforeach(ctlist_item, ctlist)\n\t{\n\t\tcl->members[i++] = ct = (CatCTup *) lfirst(ctlist_item);\n\t\tAssert(ct->c_list == NULL);\n\t\tct->c_list = cl;\n\t\t/* release the temporary refcount on the member */\n\t\tAssert(ct->refcount > 0);\n\t\tct->refcount--;\n\t\t/* mark list dead if any members already dead */\n\t\tif (ct->dead)\n\t\t\tcl->dead = true;\n\t}\n\tAssert(i == nmembers);\n\n\tdlist_push_head(&cache->cc_lists, &cl->cache_elem);\n\n\t/* Finally, bump the list's refcount and return it */\n\tcl->refcount++;\n\tResourceOwnerRememberCatCacheListRef(CurrentResourceOwner, cl);\n\n\tCACHE3_elog(DEBUG2, \"SearchCatCacheList(%s): made list of %d members\",\n\t\t\t\tcache->cc_relname, nmembers);\n\n\treturn cl;\n}"
  },
  {
    "function_name": "GetCatCacheHashValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "1489-1506",
    "snippet": "uint32\nGetCatCacheHashValue(CatCache *cache,\n\t\t\t\t\t Datum v1,\n\t\t\t\t\t Datum v2,\n\t\t\t\t\t Datum v3,\n\t\t\t\t\t Datum v4)\n{\n\t/*\n\t * one-time startup overhead for each cache\n\t */\n\tif (cache->cc_tupdesc == NULL)\n\t\tCatalogCacheInitializeCache(cache);\n\n\t/*\n\t * calculate the hash value\n\t */\n\treturn CatalogCacheComputeHashValue(cache, cache->cc_nkeys, v1, v2, v3, v4);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
      "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
      "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CatalogCacheComputeHashValue",
          "args": [
            "cache",
            "cache->cc_nkeys",
            "v1",
            "v2",
            "v3",
            "v4"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "CatalogCacheComputeHashValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "275-319",
          "snippet": "static uint32\nCatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4)\n{\n\tuint32\t\thashValue = 0;\n\tuint32\t\toneHash;\n\tCCHashFN   *cc_hashfunc = cache->cc_hashfunc;\n\n\tCACHE4_elog(DEBUG2, \"CatalogCacheComputeHashValue %s %d %p\",\n\t\t\t\tcache->cc_relname,\n\t\t\t\tnkeys,\n\t\t\t\tcache);\n\n\tswitch (nkeys)\n\t{\n\t\tcase 4:\n\t\t\toneHash = (cc_hashfunc[3]) (v4);\n\n\t\t\thashValue ^= oneHash << 24;\n\t\t\thashValue ^= oneHash >> 8;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 3:\n\t\t\toneHash = (cc_hashfunc[2]) (v3);\n\n\t\t\thashValue ^= oneHash << 16;\n\t\t\thashValue ^= oneHash >> 16;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\toneHash = (cc_hashfunc[1]) (v2);\n\n\t\t\thashValue ^= oneHash << 8;\n\t\t\thashValue ^= oneHash >> 24;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\toneHash = (cc_hashfunc[0]) (v1);\n\n\t\t\thashValue ^= oneHash;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"wrong number of hash keys: %d\", nkeys);\n\t\t\tbreak;\n\t}\n\n\treturn hashValue;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
            "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic uint32\nCatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4)\n{\n\tuint32\t\thashValue = 0;\n\tuint32\t\toneHash;\n\tCCHashFN   *cc_hashfunc = cache->cc_hashfunc;\n\n\tCACHE4_elog(DEBUG2, \"CatalogCacheComputeHashValue %s %d %p\",\n\t\t\t\tcache->cc_relname,\n\t\t\t\tnkeys,\n\t\t\t\tcache);\n\n\tswitch (nkeys)\n\t{\n\t\tcase 4:\n\t\t\toneHash = (cc_hashfunc[3]) (v4);\n\n\t\t\thashValue ^= oneHash << 24;\n\t\t\thashValue ^= oneHash >> 8;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 3:\n\t\t\toneHash = (cc_hashfunc[2]) (v3);\n\n\t\t\thashValue ^= oneHash << 16;\n\t\t\thashValue ^= oneHash >> 16;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\toneHash = (cc_hashfunc[1]) (v2);\n\n\t\t\thashValue ^= oneHash << 8;\n\t\t\thashValue ^= oneHash >> 24;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\toneHash = (cc_hashfunc[0]) (v1);\n\n\t\t\thashValue ^= oneHash;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"wrong number of hash keys: %d\", nkeys);\n\t\t\tbreak;\n\t}\n\n\treturn hashValue;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CatalogCacheInitializeCache",
          "args": [
            "cache"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "CatalogCacheInitializeCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "938-1038",
          "snippet": "static void\nCatalogCacheInitializeCache(CatCache *cache)\n{\n\tRelation\trelation;\n\tMemoryContext oldcxt;\n\tTupleDesc\ttupdesc;\n\tint\t\t\ti;\n\n\tCatalogCacheInitializeCache_DEBUG1;\n\n\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\t/*\n\t * switch to the cache context so our allocations do not vanish at the end\n\t * of a transaction\n\t */\n\tAssert(CacheMemoryContext != NULL);\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * copy the relcache's tuple descriptor to permanent cache storage\n\t */\n\ttupdesc = CreateTupleDescCopyConstr(RelationGetDescr(relation));\n\n\t/*\n\t * save the relation's name and relisshared flag, too (cc_relname is used\n\t * only for debugging purposes)\n\t */\n\tcache->cc_relname = pstrdup(RelationGetRelationName(relation));\n\tcache->cc_relisshared = RelationGetForm(relation)->relisshared;\n\n\t/*\n\t * return to the caller's memory context and close the rel\n\t */\n\tMemoryContextSwitchTo(oldcxt);\n\n\theap_close(relation, AccessShareLock);\n\n\tCACHE3_elog(DEBUG2, \"CatalogCacheInitializeCache: %s, %d keys\",\n\t\t\t\tcache->cc_relname, cache->cc_nkeys);\n\n\t/*\n\t * initialize cache's key information\n\t */\n\tfor (i = 0; i < cache->cc_nkeys; ++i)\n\t{\n\t\tOid\t\t\tkeytype;\n\t\tRegProcedure eqfunc;\n\n\t\tCatalogCacheInitializeCache_DEBUG2;\n\n\t\tif (cache->cc_keyno[i] > 0)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   cache->cc_keyno[i] - 1);\n\n\t\t\tkeytype = attr->atttypid;\n\t\t\t/* cache key columns should always be NOT NULL */\n\t\t\tAssert(attr->attnotnull);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (cache->cc_keyno[i] != ObjectIdAttributeNumber)\n\t\t\t\telog(FATAL, \"only sys attr supported in caches is OID\");\n\t\t\tkeytype = OIDOID;\n\t\t}\n\n\t\tGetCCHashEqFuncs(keytype,\n\t\t\t\t\t\t &cache->cc_hashfunc[i],\n\t\t\t\t\t\t &eqfunc,\n\t\t\t\t\t\t &cache->cc_fastequal[i]);\n\n\t\t/*\n\t\t * Do equality-function lookup (we assume this won't need a catalog\n\t\t * lookup for any supported type)\n\t\t */\n\t\tfmgr_info_cxt(eqfunc,\n\t\t\t\t\t  &cache->cc_skey[i].sk_func,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t\t/* Initialize sk_attno suitably for HeapKeyTest() and heap scans */\n\t\tcache->cc_skey[i].sk_attno = cache->cc_keyno[i];\n\n\t\t/* Fill in sk_strategy as well --- always standard equality */\n\t\tcache->cc_skey[i].sk_strategy = BTEqualStrategyNumber;\n\t\tcache->cc_skey[i].sk_subtype = InvalidOid;\n\t\t/* Currently, there are no catcaches on collation-aware data types */\n\t\tcache->cc_skey[i].sk_collation = InvalidOid;\n\n\t\tCACHE4_elog(DEBUG2, \"CatalogCacheInitializeCache %s %d %p\",\n\t\t\t\t\tcache->cc_relname,\n\t\t\t\t\ti,\n\t\t\t\t\tcache);\n\t}\n\n\t/*\n\t * mark this cache fully initialized\n\t */\n\tcache->cc_tupdesc = tupdesc;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define CatalogCacheInitializeCache_DEBUG2",
            "#define CatalogCacheInitializeCache_DEBUG1",
            "#define CatalogCacheInitializeCache_DEBUG2 \\\ndo { \\\n\t\tif (cache->cc_keyno[i] > 0) { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d, %u\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i], \\\n\t\t\t\t TupleDescAttr(tupdesc, cache->cc_keyno[i] - 1)->atttypid); \\\n\t\t} else { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i]); \\\n\t\t} \\\n} while(0)",
            "#define CatalogCacheInitializeCache_DEBUG1 \\\n\telog(DEBUG2, \"CatalogCacheInitializeCache: cache @%p rel=%u\", cache, \\\n\t\t cache->cc_reloid)"
          ],
          "globals_used": [
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\n#define CatalogCacheInitializeCache_DEBUG2\n#define CatalogCacheInitializeCache_DEBUG1\n#define CatalogCacheInitializeCache_DEBUG2 \\\ndo { \\\n\t\tif (cache->cc_keyno[i] > 0) { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d, %u\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i], \\\n\t\t\t\t TupleDescAttr(tupdesc, cache->cc_keyno[i] - 1)->atttypid); \\\n\t\t} else { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i]); \\\n\t\t} \\\n} while(0)\n#define CatalogCacheInitializeCache_DEBUG1 \\\n\telog(DEBUG2, \"CatalogCacheInitializeCache: cache @%p rel=%u\", cache, \\\n\t\t cache->cc_reloid)\n\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatalogCacheInitializeCache(CatCache *cache)\n{\n\tRelation\trelation;\n\tMemoryContext oldcxt;\n\tTupleDesc\ttupdesc;\n\tint\t\t\ti;\n\n\tCatalogCacheInitializeCache_DEBUG1;\n\n\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\t/*\n\t * switch to the cache context so our allocations do not vanish at the end\n\t * of a transaction\n\t */\n\tAssert(CacheMemoryContext != NULL);\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * copy the relcache's tuple descriptor to permanent cache storage\n\t */\n\ttupdesc = CreateTupleDescCopyConstr(RelationGetDescr(relation));\n\n\t/*\n\t * save the relation's name and relisshared flag, too (cc_relname is used\n\t * only for debugging purposes)\n\t */\n\tcache->cc_relname = pstrdup(RelationGetRelationName(relation));\n\tcache->cc_relisshared = RelationGetForm(relation)->relisshared;\n\n\t/*\n\t * return to the caller's memory context and close the rel\n\t */\n\tMemoryContextSwitchTo(oldcxt);\n\n\theap_close(relation, AccessShareLock);\n\n\tCACHE3_elog(DEBUG2, \"CatalogCacheInitializeCache: %s, %d keys\",\n\t\t\t\tcache->cc_relname, cache->cc_nkeys);\n\n\t/*\n\t * initialize cache's key information\n\t */\n\tfor (i = 0; i < cache->cc_nkeys; ++i)\n\t{\n\t\tOid\t\t\tkeytype;\n\t\tRegProcedure eqfunc;\n\n\t\tCatalogCacheInitializeCache_DEBUG2;\n\n\t\tif (cache->cc_keyno[i] > 0)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   cache->cc_keyno[i] - 1);\n\n\t\t\tkeytype = attr->atttypid;\n\t\t\t/* cache key columns should always be NOT NULL */\n\t\t\tAssert(attr->attnotnull);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (cache->cc_keyno[i] != ObjectIdAttributeNumber)\n\t\t\t\telog(FATAL, \"only sys attr supported in caches is OID\");\n\t\t\tkeytype = OIDOID;\n\t\t}\n\n\t\tGetCCHashEqFuncs(keytype,\n\t\t\t\t\t\t &cache->cc_hashfunc[i],\n\t\t\t\t\t\t &eqfunc,\n\t\t\t\t\t\t &cache->cc_fastequal[i]);\n\n\t\t/*\n\t\t * Do equality-function lookup (we assume this won't need a catalog\n\t\t * lookup for any supported type)\n\t\t */\n\t\tfmgr_info_cxt(eqfunc,\n\t\t\t\t\t  &cache->cc_skey[i].sk_func,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t\t/* Initialize sk_attno suitably for HeapKeyTest() and heap scans */\n\t\tcache->cc_skey[i].sk_attno = cache->cc_keyno[i];\n\n\t\t/* Fill in sk_strategy as well --- always standard equality */\n\t\tcache->cc_skey[i].sk_strategy = BTEqualStrategyNumber;\n\t\tcache->cc_skey[i].sk_subtype = InvalidOid;\n\t\t/* Currently, there are no catcaches on collation-aware data types */\n\t\tcache->cc_skey[i].sk_collation = InvalidOid;\n\n\t\tCACHE4_elog(DEBUG2, \"CatalogCacheInitializeCache %s %d %p\",\n\t\t\t\t\tcache->cc_relname,\n\t\t\t\t\ti,\n\t\t\t\t\tcache);\n\t}\n\n\t/*\n\t * mark this cache fully initialized\n\t */\n\tcache->cc_tupdesc = tupdesc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nuint32\nGetCatCacheHashValue(CatCache *cache,\n\t\t\t\t\t Datum v1,\n\t\t\t\t\t Datum v2,\n\t\t\t\t\t Datum v3,\n\t\t\t\t\t Datum v4)\n{\n\t/*\n\t * one-time startup overhead for each cache\n\t */\n\tif (cache->cc_tupdesc == NULL)\n\t\tCatalogCacheInitializeCache(cache);\n\n\t/*\n\t * calculate the hash value\n\t */\n\treturn CatalogCacheComputeHashValue(cache, cache->cc_nkeys, v1, v2, v3, v4);\n}"
  },
  {
    "function_name": "ReleaseCatCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "1457-1477",
    "snippet": "void\nReleaseCatCache(HeapTuple tuple)\n{\n\tCatCTup    *ct = (CatCTup *) (((char *) tuple) -\n\t\t\t\t\t\t\t\t  offsetof(CatCTup, tuple));\n\n\t/* Safety checks to ensure we were handed a cache entry */\n\tAssert(ct->ct_magic == CT_MAGIC);\n\tAssert(ct->refcount > 0);\n\n\tct->refcount--;\n\tResourceOwnerForgetCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\n\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\tct->dead &&\n#endif\n\t\tct->refcount == 0 &&\n\t\t(ct->c_list == NULL || ct->c_list->refcount == 0))\n\t\tCatCacheRemoveCTup(ct->my_cache, ct);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
      "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CatCacheRemoveCTup",
          "args": [
            "ct->my_cache",
            "ct"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "CatCacheRemoveCTup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "472-505",
          "snippet": "static void\nCatCacheRemoveCTup(CatCache *cache, CatCTup *ct)\n{\n\tAssert(ct->refcount == 0);\n\tAssert(ct->my_cache == cache);\n\n\tif (ct->c_list)\n\t{\n\t\t/*\n\t\t * The cleanest way to handle this is to call CatCacheRemoveCList,\n\t\t * which will recurse back to me, and the recursive call will do the\n\t\t * work.  Set the \"dead\" flag to make sure it does recurse.\n\t\t */\n\t\tct->dead = true;\n\t\tCatCacheRemoveCList(cache, ct->c_list);\n\t\treturn;\t\t\t\t\t/* nothing left to do */\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&ct->cache_elem);\n\n\t/*\n\t * Free keys when we're dealing with a negative entry, normal entries just\n\t * point into tuple, allocated together with the CatCTup.\n\t */\n\tif (ct->negative)\n\t\tCatCacheFreeKeys(cache->cc_tupdesc, cache->cc_nkeys,\n\t\t\t\t\t\t cache->cc_keyno, ct->keys);\n\n\tpfree(ct);\n\n\t--cache->cc_ntup;\n\t--CacheHdr->ch_ntup;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCacheHeader *CacheHdr = NULL;",
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatCacheRemoveCTup(CatCache *cache, CatCTup *ct)\n{\n\tAssert(ct->refcount == 0);\n\tAssert(ct->my_cache == cache);\n\n\tif (ct->c_list)\n\t{\n\t\t/*\n\t\t * The cleanest way to handle this is to call CatCacheRemoveCList,\n\t\t * which will recurse back to me, and the recursive call will do the\n\t\t * work.  Set the \"dead\" flag to make sure it does recurse.\n\t\t */\n\t\tct->dead = true;\n\t\tCatCacheRemoveCList(cache, ct->c_list);\n\t\treturn;\t\t\t\t\t/* nothing left to do */\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&ct->cache_elem);\n\n\t/*\n\t * Free keys when we're dealing with a negative entry, normal entries just\n\t * point into tuple, allocated together with the CatCTup.\n\t */\n\tif (ct->negative)\n\t\tCatCacheFreeKeys(cache->cc_tupdesc, cache->cc_nkeys,\n\t\t\t\t\t\t cache->cc_keyno, ct->keys);\n\n\tpfree(ct);\n\n\t--cache->cc_ntup;\n\t--CacheHdr->ch_ntup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceOwnerForgetCatCacheRef",
          "args": [
            "CurrentResourceOwner",
            "&ct->tuple"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerForgetCatCacheRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "956-962",
          "snippet": "void\nResourceOwnerForgetCatCacheRef(ResourceOwner owner, HeapTuple tuple)\n{\n\tif (!ResourceArrayRemove(&(owner->catrefarr), PointerGetDatum(tuple)))\n\t\telog(ERROR, \"catcache reference %p is not owned by resource owner %s\",\n\t\t\t tuple, owner->name);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerForgetCatCacheRef(ResourceOwner owner, HeapTuple tuple)\n{\n\tif (!ResourceArrayRemove(&(owner->catrefarr), PointerGetDatum(tuple)))\n\t\telog(ERROR, \"catcache reference %p is not owned by resource owner %s\",\n\t\t\t tuple, owner->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ct->refcount > 0"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ct->ct_magic == CT_MAGIC"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nReleaseCatCache(HeapTuple tuple)\n{\n\tCatCTup    *ct = (CatCTup *) (((char *) tuple) -\n\t\t\t\t\t\t\t\t  offsetof(CatCTup, tuple));\n\n\t/* Safety checks to ensure we were handed a cache entry */\n\tAssert(ct->ct_magic == CT_MAGIC);\n\tAssert(ct->refcount > 0);\n\n\tct->refcount--;\n\tResourceOwnerForgetCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\n\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\tct->dead &&\n#endif\n\t\tct->refcount == 0 &&\n\t\t(ct->c_list == NULL || ct->c_list->refcount == 0))\n\t\tCatCacheRemoveCTup(ct->my_cache, ct);\n}"
  },
  {
    "function_name": "SearchCatCacheMiss",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "1327-1444",
    "snippet": "static pg_noinline HeapTuple\nSearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1,\n\t\t\t\t   Datum v2,\n\t\t\t\t   Datum v3,\n\t\t\t\t   Datum v4)\n{\n\tScanKeyData cur_skey[CATCACHE_MAXKEYS];\n\tRelation\trelation;\n\tSysScanDesc scandesc;\n\tHeapTuple\tntp;\n\tCatCTup    *ct;\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * Ok, need to make a lookup in the relation, copy the scankey and fill\n\t * out any per-call fields.\n\t */\n\tmemcpy(cur_skey, cache->cc_skey, sizeof(ScanKeyData) * nkeys);\n\tcur_skey[0].sk_argument = v1;\n\tcur_skey[1].sk_argument = v2;\n\tcur_skey[2].sk_argument = v3;\n\tcur_skey[3].sk_argument = v4;\n\n\t/*\n\t * Tuple was not found in cache, so we have to try to retrieve it directly\n\t * from the relation.  If found, we will add it to the cache; if not\n\t * found, we will add a negative cache entry instead.\n\t *\n\t * NOTE: it is possible for recursive cache lookups to occur while reading\n\t * the relation --- for example, due to shared-cache-inval messages being\n\t * processed during heap_open().  This is OK.  It's even possible for one\n\t * of those lookups to find and enter the very same tuple we are trying to\n\t * fetch here.  If that happens, we will enter a second copy of the tuple\n\t * into the cache.  The first copy will never be referenced again, and\n\t * will eventually age out of the cache, so there's no functional problem.\n\t * This case is rare enough that it's not worth expending extra cycles to\n\t * detect.\n\t */\n\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\tscandesc = systable_beginscan(relation,\n\t\t\t\t\t\t\t\t  cache->cc_indexoid,\n\t\t\t\t\t\t\t\t  IndexScanOK(cache, cur_skey),\n\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t  nkeys,\n\t\t\t\t\t\t\t\t  cur_skey);\n\n\tct = NULL;\n\n\twhile (HeapTupleIsValid(ntp = systable_getnext(scandesc)))\n\t{\n\t\tct = CatalogCacheCreateEntry(cache, ntp, arguments,\n\t\t\t\t\t\t\t\t\t hashValue, hashIndex,\n\t\t\t\t\t\t\t\t\t false);\n\t\t/* immediately set the refcount to 1 */\n\t\tResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);\n\t\tct->refcount++;\n\t\tResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\t\tbreak;\t\t\t\t\t/* assume only one match */\n\t}\n\n\tsystable_endscan(scandesc);\n\n\theap_close(relation, AccessShareLock);\n\n\t/*\n\t * If tuple was not found, we need to build a negative cache entry\n\t * containing a fake tuple.  The fake tuple has the correct key columns,\n\t * but nulls everywhere else.\n\t *\n\t * In bootstrap mode, we don't build negative entries, because the cache\n\t * invalidation mechanism isn't alive and can't clear them if the tuple\n\t * gets created later.  (Bootstrap doesn't do UPDATEs, so it doesn't need\n\t * cache inval for that.)\n\t */\n\tif (ct == NULL)\n\t{\n\t\tif (IsBootstrapProcessingMode())\n\t\t\treturn NULL;\n\n\t\tct = CatalogCacheCreateEntry(cache, NULL, arguments,\n\t\t\t\t\t\t\t\t\t hashValue, hashIndex,\n\t\t\t\t\t\t\t\t\t true);\n\n\t\tCACHE4_elog(DEBUG2, \"SearchCatCache(%s): Contains %d/%d tuples\",\n\t\t\t\t\tcache->cc_relname, cache->cc_ntup, CacheHdr->ch_ntup);\n\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): put neg entry in bucket %d\",\n\t\t\t\t\tcache->cc_relname, hashIndex);\n\n\t\t/*\n\t\t * We are not returning the negative entry to the caller, so leave its\n\t\t * refcount zero.\n\t\t */\n\n\t\treturn NULL;\n\t}\n\n\tCACHE4_elog(DEBUG2, \"SearchCatCache(%s): Contains %d/%d tuples\",\n\t\t\t\tcache->cc_relname, cache->cc_ntup, CacheHdr->ch_ntup);\n\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): put in bucket %d\",\n\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_newloads++;\n#endif\n\n\treturn &ct->tuple;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CatCacheHeader *CacheHdr = NULL;",
      "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
      "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
      "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
      "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
      "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
      "static void CatalogCacheInitializeCache(CatCache *cache);",
      "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CACHE3_elog",
          "args": [
            "DEBUG2",
            "\"SearchCatCache(%s): put in bucket %d\"",
            "cache->cc_relname",
            "hashIndex"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CACHE4_elog",
          "args": [
            "DEBUG2",
            "\"SearchCatCache(%s): Contains %d/%d tuples\"",
            "cache->cc_relname",
            "cache->cc_ntup",
            "CacheHdr->ch_ntup"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CACHE3_elog",
          "args": [
            "DEBUG2",
            "\"SearchCatCache(%s): put neg entry in bucket %d\"",
            "cache->cc_relname",
            "hashIndex"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CACHE4_elog",
          "args": [
            "DEBUG2",
            "\"SearchCatCache(%s): Contains %d/%d tuples\"",
            "cache->cc_relname",
            "cache->cc_ntup",
            "CacheHdr->ch_ntup"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatalogCacheCreateEntry",
          "args": [
            "cache",
            "NULL",
            "arguments",
            "hashValue",
            "hashIndex",
            "true"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "CatalogCacheCreateEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "1822-1923",
          "snippet": "static CatCTup *\nCatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp, Datum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative)\n{\n\tCatCTup    *ct;\n\tHeapTuple\tdtp;\n\tMemoryContext oldcxt;\n\n\t/* negative entries have no tuple associated */\n\tif (ntp)\n\t{\n\t\tint\t\t\ti;\n\n\t\tAssert(!negative);\n\n\t\t/*\n\t\t * If there are any out-of-line toasted fields in the tuple, expand\n\t\t * them in-line.  This saves cycles during later use of the catcache\n\t\t * entry, and also protects us against the possibility of the toast\n\t\t * tuples being freed before we attempt to fetch them, in case of\n\t\t * something using a slightly stale catcache entry.\n\t\t */\n\t\tif (HeapTupleHasExternal(ntp))\n\t\t\tdtp = toast_flatten_tuple(ntp, cache->cc_tupdesc);\n\t\telse\n\t\t\tdtp = ntp;\n\n\t\t/* Allocate memory for CatCTup and the cached tuple in one go */\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tct = (CatCTup *) palloc(sizeof(CatCTup) +\n\t\t\t\t\t\t\t\tMAXIMUM_ALIGNOF + dtp->t_len);\n\t\tct->tuple.t_len = dtp->t_len;\n\t\tct->tuple.t_self = dtp->t_self;\n\t\tct->tuple.t_tableOid = dtp->t_tableOid;\n\t\tct->tuple.t_data = (HeapTupleHeader)\n\t\t\tMAXALIGN(((char *) ct) + sizeof(CatCTup));\n\t\t/* copy tuple contents */\n\t\tmemcpy((char *) ct->tuple.t_data,\n\t\t\t   (const char *) dtp->t_data,\n\t\t\t   dtp->t_len);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\tif (dtp != ntp)\n\t\t\theap_freetuple(dtp);\n\n\t\t/* extract keys - they'll point into the tuple if not by-value */\n\t\tfor (i = 0; i < cache->cc_nkeys; i++)\n\t\t{\n\t\t\tDatum\t\tatp;\n\t\t\tbool\t\tisnull;\n\n\t\t\tatp = heap_getattr(&ct->tuple,\n\t\t\t\t\t\t\t   cache->cc_keyno[i],\n\t\t\t\t\t\t\t   cache->cc_tupdesc,\n\t\t\t\t\t\t\t   &isnull);\n\t\t\tAssert(!isnull);\n\t\t\tct->keys[i] = atp;\n\t\t}\n\t}\n\telse\n\t{\n\t\tAssert(negative);\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\t\tct = (CatCTup *) palloc(sizeof(CatCTup));\n\n\t\t/*\n\t\t * Store keys - they'll point into separately allocated memory if not\n\t\t * by-value.\n\t\t */\n\t\tCatCacheCopyKeys(cache->cc_tupdesc, cache->cc_nkeys, cache->cc_keyno,\n\t\t\t\t\t\t arguments, ct->keys);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * Finish initializing the CatCTup header, and add it to the cache's\n\t * linked list and counts.\n\t */\n\tct->ct_magic = CT_MAGIC;\n\tct->my_cache = cache;\n\tct->c_list = NULL;\n\tct->refcount = 0;\t\t\t/* for the moment */\n\tct->dead = false;\n\tct->negative = negative;\n\tct->hash_value = hashValue;\n\n\tdlist_push_head(&cache->cc_bucket[hashIndex], &ct->cache_elem);\n\n\tcache->cc_ntup++;\n\tCacheHdr->ch_ntup++;\n\n\t/*\n\t * If the hash table has become too full, enlarge the buckets array. Quite\n\t * arbitrarily, we enlarge when fill factor > 2.\n\t */\n\tif (cache->cc_ntup > cache->cc_nbuckets * 2)\n\t\tRehashCatCache(cache);\n\n\treturn ct;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCacheHeader *CacheHdr = NULL;",
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic CatCTup *\nCatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp, Datum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative)\n{\n\tCatCTup    *ct;\n\tHeapTuple\tdtp;\n\tMemoryContext oldcxt;\n\n\t/* negative entries have no tuple associated */\n\tif (ntp)\n\t{\n\t\tint\t\t\ti;\n\n\t\tAssert(!negative);\n\n\t\t/*\n\t\t * If there are any out-of-line toasted fields in the tuple, expand\n\t\t * them in-line.  This saves cycles during later use of the catcache\n\t\t * entry, and also protects us against the possibility of the toast\n\t\t * tuples being freed before we attempt to fetch them, in case of\n\t\t * something using a slightly stale catcache entry.\n\t\t */\n\t\tif (HeapTupleHasExternal(ntp))\n\t\t\tdtp = toast_flatten_tuple(ntp, cache->cc_tupdesc);\n\t\telse\n\t\t\tdtp = ntp;\n\n\t\t/* Allocate memory for CatCTup and the cached tuple in one go */\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tct = (CatCTup *) palloc(sizeof(CatCTup) +\n\t\t\t\t\t\t\t\tMAXIMUM_ALIGNOF + dtp->t_len);\n\t\tct->tuple.t_len = dtp->t_len;\n\t\tct->tuple.t_self = dtp->t_self;\n\t\tct->tuple.t_tableOid = dtp->t_tableOid;\n\t\tct->tuple.t_data = (HeapTupleHeader)\n\t\t\tMAXALIGN(((char *) ct) + sizeof(CatCTup));\n\t\t/* copy tuple contents */\n\t\tmemcpy((char *) ct->tuple.t_data,\n\t\t\t   (const char *) dtp->t_data,\n\t\t\t   dtp->t_len);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\tif (dtp != ntp)\n\t\t\theap_freetuple(dtp);\n\n\t\t/* extract keys - they'll point into the tuple if not by-value */\n\t\tfor (i = 0; i < cache->cc_nkeys; i++)\n\t\t{\n\t\t\tDatum\t\tatp;\n\t\t\tbool\t\tisnull;\n\n\t\t\tatp = heap_getattr(&ct->tuple,\n\t\t\t\t\t\t\t   cache->cc_keyno[i],\n\t\t\t\t\t\t\t   cache->cc_tupdesc,\n\t\t\t\t\t\t\t   &isnull);\n\t\t\tAssert(!isnull);\n\t\t\tct->keys[i] = atp;\n\t\t}\n\t}\n\telse\n\t{\n\t\tAssert(negative);\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\t\tct = (CatCTup *) palloc(sizeof(CatCTup));\n\n\t\t/*\n\t\t * Store keys - they'll point into separately allocated memory if not\n\t\t * by-value.\n\t\t */\n\t\tCatCacheCopyKeys(cache->cc_tupdesc, cache->cc_nkeys, cache->cc_keyno,\n\t\t\t\t\t\t arguments, ct->keys);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * Finish initializing the CatCTup header, and add it to the cache's\n\t * linked list and counts.\n\t */\n\tct->ct_magic = CT_MAGIC;\n\tct->my_cache = cache;\n\tct->c_list = NULL;\n\tct->refcount = 0;\t\t\t/* for the moment */\n\tct->dead = false;\n\tct->negative = negative;\n\tct->hash_value = hashValue;\n\n\tdlist_push_head(&cache->cc_bucket[hashIndex], &ct->cache_elem);\n\n\tcache->cc_ntup++;\n\tCacheHdr->ch_ntup++;\n\n\t/*\n\t * If the hash table has become too full, enlarge the buckets array. Quite\n\t * arbitrarily, we enlarge when fill factor > 2.\n\t */\n\tif (cache->cc_ntup > cache->cc_nbuckets * 2)\n\t\tRehashCatCache(cache);\n\n\treturn ct;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "relation",
            "AccessShareLock"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "scandesc"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResourceOwnerRememberCatCacheRef",
          "args": [
            "CurrentResourceOwner",
            "&ct->tuple"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerRememberCatCacheRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "947-951",
          "snippet": "void\nResourceOwnerRememberCatCacheRef(ResourceOwner owner, HeapTuple tuple)\n{\n\tResourceArrayAdd(&(owner->catrefarr), PointerGetDatum(tuple));\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerRememberCatCacheRef(ResourceOwner owner, HeapTuple tuple)\n{\n\tResourceArrayAdd(&(owner->catrefarr), PointerGetDatum(tuple));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceOwnerEnlargeCatCacheRefs",
          "args": [
            "CurrentResourceOwner"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerEnlargeCatCacheRefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "936-940",
          "snippet": "void\nResourceOwnerEnlargeCatCacheRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->catrefarr));\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerEnlargeCatCacheRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->catrefarr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "ntp = systable_getnext(scandesc)"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "scandesc"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "relation",
            "cache->cc_indexoid",
            "IndexScanOK(cache, cur_skey)",
            "NULL",
            "nkeys",
            "cur_skey"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IndexScanOK",
          "args": [
            "cache",
            "cur_skey"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "IndexScanOK",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "1100-1146",
          "snippet": "static bool\nIndexScanOK(CatCache *cache, ScanKey cur_skey)\n{\n\tswitch (cache->id)\n\t{\n\t\tcase INDEXRELID:\n\n\t\t\t/*\n\t\t\t * Rather than tracking exactly which indexes have to be loaded\n\t\t\t * before we can use indexscans (which changes from time to time),\n\t\t\t * just force all pg_index searches to be heap scans until we've\n\t\t\t * built the critical relcaches.\n\t\t\t */\n\t\t\tif (!criticalRelcachesBuilt)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\n\t\tcase AMOID:\n\t\tcase AMNAME:\n\n\t\t\t/*\n\t\t\t * Always do heap scans in pg_am, because it's so small there's\n\t\t\t * not much point in an indexscan anyway.  We *must* do this when\n\t\t\t * initially building critical relcache entries, but we might as\n\t\t\t * well just always do it.\n\t\t\t */\n\t\t\treturn false;\n\n\t\tcase AUTHNAME:\n\t\tcase AUTHOID:\n\t\tcase AUTHMEMMEMROLE:\n\n\t\t\t/*\n\t\t\t * Protect authentication lookups occurring before relcache has\n\t\t\t * collected entries for shared indexes.\n\t\t\t */\n\t\t\tif (!criticalSharedRelcachesBuilt)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\t/* Normal case, allow index scan */\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nstatic bool\nIndexScanOK(CatCache *cache, ScanKey cur_skey)\n{\n\tswitch (cache->id)\n\t{\n\t\tcase INDEXRELID:\n\n\t\t\t/*\n\t\t\t * Rather than tracking exactly which indexes have to be loaded\n\t\t\t * before we can use indexscans (which changes from time to time),\n\t\t\t * just force all pg_index searches to be heap scans until we've\n\t\t\t * built the critical relcaches.\n\t\t\t */\n\t\t\tif (!criticalRelcachesBuilt)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\n\t\tcase AMOID:\n\t\tcase AMNAME:\n\n\t\t\t/*\n\t\t\t * Always do heap scans in pg_am, because it's so small there's\n\t\t\t * not much point in an indexscan anyway.  We *must* do this when\n\t\t\t * initially building critical relcache entries, but we might as\n\t\t\t * well just always do it.\n\t\t\t */\n\t\t\treturn false;\n\n\t\tcase AUTHNAME:\n\t\tcase AUTHOID:\n\t\tcase AUTHMEMMEMROLE:\n\n\t\t\t/*\n\t\t\t * Protect authentication lookups occurring before relcache has\n\t\t\t * collected entries for shared indexes.\n\t\t\t */\n\t\t\tif (!criticalSharedRelcachesBuilt)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\t/* Normal case, allow index scan */\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "cache->cc_reloid",
            "AccessShareLock"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cur_skey",
            "cache->cc_skey",
            "sizeof(ScanKeyData) * nkeys"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\n\nstatic pg_noinline HeapTuple\nSearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1,\n\t\t\t\t   Datum v2,\n\t\t\t\t   Datum v3,\n\t\t\t\t   Datum v4)\n{\n\tScanKeyData cur_skey[CATCACHE_MAXKEYS];\n\tRelation\trelation;\n\tSysScanDesc scandesc;\n\tHeapTuple\tntp;\n\tCatCTup    *ct;\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * Ok, need to make a lookup in the relation, copy the scankey and fill\n\t * out any per-call fields.\n\t */\n\tmemcpy(cur_skey, cache->cc_skey, sizeof(ScanKeyData) * nkeys);\n\tcur_skey[0].sk_argument = v1;\n\tcur_skey[1].sk_argument = v2;\n\tcur_skey[2].sk_argument = v3;\n\tcur_skey[3].sk_argument = v4;\n\n\t/*\n\t * Tuple was not found in cache, so we have to try to retrieve it directly\n\t * from the relation.  If found, we will add it to the cache; if not\n\t * found, we will add a negative cache entry instead.\n\t *\n\t * NOTE: it is possible for recursive cache lookups to occur while reading\n\t * the relation --- for example, due to shared-cache-inval messages being\n\t * processed during heap_open().  This is OK.  It's even possible for one\n\t * of those lookups to find and enter the very same tuple we are trying to\n\t * fetch here.  If that happens, we will enter a second copy of the tuple\n\t * into the cache.  The first copy will never be referenced again, and\n\t * will eventually age out of the cache, so there's no functional problem.\n\t * This case is rare enough that it's not worth expending extra cycles to\n\t * detect.\n\t */\n\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\tscandesc = systable_beginscan(relation,\n\t\t\t\t\t\t\t\t  cache->cc_indexoid,\n\t\t\t\t\t\t\t\t  IndexScanOK(cache, cur_skey),\n\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t  nkeys,\n\t\t\t\t\t\t\t\t  cur_skey);\n\n\tct = NULL;\n\n\twhile (HeapTupleIsValid(ntp = systable_getnext(scandesc)))\n\t{\n\t\tct = CatalogCacheCreateEntry(cache, ntp, arguments,\n\t\t\t\t\t\t\t\t\t hashValue, hashIndex,\n\t\t\t\t\t\t\t\t\t false);\n\t\t/* immediately set the refcount to 1 */\n\t\tResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);\n\t\tct->refcount++;\n\t\tResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\t\tbreak;\t\t\t\t\t/* assume only one match */\n\t}\n\n\tsystable_endscan(scandesc);\n\n\theap_close(relation, AccessShareLock);\n\n\t/*\n\t * If tuple was not found, we need to build a negative cache entry\n\t * containing a fake tuple.  The fake tuple has the correct key columns,\n\t * but nulls everywhere else.\n\t *\n\t * In bootstrap mode, we don't build negative entries, because the cache\n\t * invalidation mechanism isn't alive and can't clear them if the tuple\n\t * gets created later.  (Bootstrap doesn't do UPDATEs, so it doesn't need\n\t * cache inval for that.)\n\t */\n\tif (ct == NULL)\n\t{\n\t\tif (IsBootstrapProcessingMode())\n\t\t\treturn NULL;\n\n\t\tct = CatalogCacheCreateEntry(cache, NULL, arguments,\n\t\t\t\t\t\t\t\t\t hashValue, hashIndex,\n\t\t\t\t\t\t\t\t\t true);\n\n\t\tCACHE4_elog(DEBUG2, \"SearchCatCache(%s): Contains %d/%d tuples\",\n\t\t\t\t\tcache->cc_relname, cache->cc_ntup, CacheHdr->ch_ntup);\n\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): put neg entry in bucket %d\",\n\t\t\t\t\tcache->cc_relname, hashIndex);\n\n\t\t/*\n\t\t * We are not returning the negative entry to the caller, so leave its\n\t\t * refcount zero.\n\t\t */\n\n\t\treturn NULL;\n\t}\n\n\tCACHE4_elog(DEBUG2, \"SearchCatCache(%s): Contains %d/%d tuples\",\n\t\t\t\tcache->cc_relname, cache->cc_ntup, CacheHdr->ch_ntup);\n\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): put in bucket %d\",\n\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_newloads++;\n#endif\n\n\treturn &ct->tuple;\n}"
  },
  {
    "function_name": "SearchCatCacheInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "1215-1318",
    "snippet": "static inline HeapTuple\nSearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1,\n\t\t\t\t\t   Datum v2,\n\t\t\t\t\t   Datum v3,\n\t\t\t\t\t   Datum v4)\n{\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\tuint32\t\thashValue;\n\tIndex\t\thashIndex;\n\tdlist_iter\titer;\n\tdlist_head *bucket;\n\tCatCTup    *ct;\n\n\t/* Make sure we're in an xact, even if this ends up being a cache hit */\n\tAssert(IsTransactionState());\n\n\tAssert(cache->cc_nkeys == nkeys);\n\n\t/*\n\t * one-time startup overhead for each cache\n\t */\n\tif (unlikely(cache->cc_tupdesc == NULL))\n\t\tCatalogCacheInitializeCache(cache);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_searches++;\n#endif\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * find the hash bucket in which to look for the tuple\n\t */\n\thashValue = CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n\thashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);\n\n\t/*\n\t * scan the hash bucket until we find a match or exhaust our tuples\n\t *\n\t * Note: it's okay to use dlist_foreach here, even though we modify the\n\t * dlist within the loop, because we don't continue the loop afterwards.\n\t */\n\tbucket = &cache->cc_bucket[hashIndex];\n\tdlist_foreach(iter, bucket)\n\t{\n\t\tct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\tif (ct->dead)\n\t\t\tcontinue;\t\t\t/* ignore dead entries */\n\n\t\tif (ct->hash_value != hashValue)\n\t\t\tcontinue;\t\t\t/* quickly skip entry if wrong hash val */\n\n\t\tif (!CatalogCacheCompareTuple(cache, nkeys, ct->keys, arguments))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We found a match in the cache.  Move it to the front of the list\n\t\t * for its hashbucket, in order to speed subsequent searches.  (The\n\t\t * most frequently accessed elements in any hashbucket will tend to be\n\t\t * near the front of the hashbucket's list.)\n\t\t */\n\t\tdlist_move_head(bucket, &ct->cache_elem);\n\n\t\t/*\n\t\t * If it's a positive entry, bump its refcount and return it. If it's\n\t\t * negative, we can report failure to the caller.\n\t\t */\n\t\tif (!ct->negative)\n\t\t{\n\t\t\tResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);\n\t\t\tct->refcount++;\n\t\t\tResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_hits++;\n#endif\n\n\t\t\treturn &ct->tuple;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found neg entry in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_neg_hits++;\n#endif\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn SearchCatCacheMiss(cache, nkeys, hashValue, hashIndex, v1, v2, v3, v4);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
      "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
      "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
      "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
      "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
      "static void CatalogCacheInitializeCache(CatCache *cache);",
      "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);",
      "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SearchCatCacheMiss",
          "args": [
            "cache",
            "nkeys",
            "hashValue",
            "hashIndex",
            "v1",
            "v2",
            "v3",
            "v4"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "SearchCatCacheMiss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "1327-1444",
          "snippet": "static pg_noinline HeapTuple\nSearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1,\n\t\t\t\t   Datum v2,\n\t\t\t\t   Datum v3,\n\t\t\t\t   Datum v4)\n{\n\tScanKeyData cur_skey[CATCACHE_MAXKEYS];\n\tRelation\trelation;\n\tSysScanDesc scandesc;\n\tHeapTuple\tntp;\n\tCatCTup    *ct;\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * Ok, need to make a lookup in the relation, copy the scankey and fill\n\t * out any per-call fields.\n\t */\n\tmemcpy(cur_skey, cache->cc_skey, sizeof(ScanKeyData) * nkeys);\n\tcur_skey[0].sk_argument = v1;\n\tcur_skey[1].sk_argument = v2;\n\tcur_skey[2].sk_argument = v3;\n\tcur_skey[3].sk_argument = v4;\n\n\t/*\n\t * Tuple was not found in cache, so we have to try to retrieve it directly\n\t * from the relation.  If found, we will add it to the cache; if not\n\t * found, we will add a negative cache entry instead.\n\t *\n\t * NOTE: it is possible for recursive cache lookups to occur while reading\n\t * the relation --- for example, due to shared-cache-inval messages being\n\t * processed during heap_open().  This is OK.  It's even possible for one\n\t * of those lookups to find and enter the very same tuple we are trying to\n\t * fetch here.  If that happens, we will enter a second copy of the tuple\n\t * into the cache.  The first copy will never be referenced again, and\n\t * will eventually age out of the cache, so there's no functional problem.\n\t * This case is rare enough that it's not worth expending extra cycles to\n\t * detect.\n\t */\n\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\tscandesc = systable_beginscan(relation,\n\t\t\t\t\t\t\t\t  cache->cc_indexoid,\n\t\t\t\t\t\t\t\t  IndexScanOK(cache, cur_skey),\n\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t  nkeys,\n\t\t\t\t\t\t\t\t  cur_skey);\n\n\tct = NULL;\n\n\twhile (HeapTupleIsValid(ntp = systable_getnext(scandesc)))\n\t{\n\t\tct = CatalogCacheCreateEntry(cache, ntp, arguments,\n\t\t\t\t\t\t\t\t\t hashValue, hashIndex,\n\t\t\t\t\t\t\t\t\t false);\n\t\t/* immediately set the refcount to 1 */\n\t\tResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);\n\t\tct->refcount++;\n\t\tResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\t\tbreak;\t\t\t\t\t/* assume only one match */\n\t}\n\n\tsystable_endscan(scandesc);\n\n\theap_close(relation, AccessShareLock);\n\n\t/*\n\t * If tuple was not found, we need to build a negative cache entry\n\t * containing a fake tuple.  The fake tuple has the correct key columns,\n\t * but nulls everywhere else.\n\t *\n\t * In bootstrap mode, we don't build negative entries, because the cache\n\t * invalidation mechanism isn't alive and can't clear them if the tuple\n\t * gets created later.  (Bootstrap doesn't do UPDATEs, so it doesn't need\n\t * cache inval for that.)\n\t */\n\tif (ct == NULL)\n\t{\n\t\tif (IsBootstrapProcessingMode())\n\t\t\treturn NULL;\n\n\t\tct = CatalogCacheCreateEntry(cache, NULL, arguments,\n\t\t\t\t\t\t\t\t\t hashValue, hashIndex,\n\t\t\t\t\t\t\t\t\t true);\n\n\t\tCACHE4_elog(DEBUG2, \"SearchCatCache(%s): Contains %d/%d tuples\",\n\t\t\t\t\tcache->cc_relname, cache->cc_ntup, CacheHdr->ch_ntup);\n\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): put neg entry in bucket %d\",\n\t\t\t\t\tcache->cc_relname, hashIndex);\n\n\t\t/*\n\t\t * We are not returning the negative entry to the caller, so leave its\n\t\t * refcount zero.\n\t\t */\n\n\t\treturn NULL;\n\t}\n\n\tCACHE4_elog(DEBUG2, \"SearchCatCache(%s): Contains %d/%d tuples\",\n\t\t\t\tcache->cc_relname, cache->cc_ntup, CacheHdr->ch_ntup);\n\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): put in bucket %d\",\n\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_newloads++;\n#endif\n\n\treturn &ct->tuple;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCacheHeader *CacheHdr = NULL;",
            "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
            "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\n\nstatic pg_noinline HeapTuple\nSearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1,\n\t\t\t\t   Datum v2,\n\t\t\t\t   Datum v3,\n\t\t\t\t   Datum v4)\n{\n\tScanKeyData cur_skey[CATCACHE_MAXKEYS];\n\tRelation\trelation;\n\tSysScanDesc scandesc;\n\tHeapTuple\tntp;\n\tCatCTup    *ct;\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * Ok, need to make a lookup in the relation, copy the scankey and fill\n\t * out any per-call fields.\n\t */\n\tmemcpy(cur_skey, cache->cc_skey, sizeof(ScanKeyData) * nkeys);\n\tcur_skey[0].sk_argument = v1;\n\tcur_skey[1].sk_argument = v2;\n\tcur_skey[2].sk_argument = v3;\n\tcur_skey[3].sk_argument = v4;\n\n\t/*\n\t * Tuple was not found in cache, so we have to try to retrieve it directly\n\t * from the relation.  If found, we will add it to the cache; if not\n\t * found, we will add a negative cache entry instead.\n\t *\n\t * NOTE: it is possible for recursive cache lookups to occur while reading\n\t * the relation --- for example, due to shared-cache-inval messages being\n\t * processed during heap_open().  This is OK.  It's even possible for one\n\t * of those lookups to find and enter the very same tuple we are trying to\n\t * fetch here.  If that happens, we will enter a second copy of the tuple\n\t * into the cache.  The first copy will never be referenced again, and\n\t * will eventually age out of the cache, so there's no functional problem.\n\t * This case is rare enough that it's not worth expending extra cycles to\n\t * detect.\n\t */\n\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\tscandesc = systable_beginscan(relation,\n\t\t\t\t\t\t\t\t  cache->cc_indexoid,\n\t\t\t\t\t\t\t\t  IndexScanOK(cache, cur_skey),\n\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t  nkeys,\n\t\t\t\t\t\t\t\t  cur_skey);\n\n\tct = NULL;\n\n\twhile (HeapTupleIsValid(ntp = systable_getnext(scandesc)))\n\t{\n\t\tct = CatalogCacheCreateEntry(cache, ntp, arguments,\n\t\t\t\t\t\t\t\t\t hashValue, hashIndex,\n\t\t\t\t\t\t\t\t\t false);\n\t\t/* immediately set the refcount to 1 */\n\t\tResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);\n\t\tct->refcount++;\n\t\tResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\t\tbreak;\t\t\t\t\t/* assume only one match */\n\t}\n\n\tsystable_endscan(scandesc);\n\n\theap_close(relation, AccessShareLock);\n\n\t/*\n\t * If tuple was not found, we need to build a negative cache entry\n\t * containing a fake tuple.  The fake tuple has the correct key columns,\n\t * but nulls everywhere else.\n\t *\n\t * In bootstrap mode, we don't build negative entries, because the cache\n\t * invalidation mechanism isn't alive and can't clear them if the tuple\n\t * gets created later.  (Bootstrap doesn't do UPDATEs, so it doesn't need\n\t * cache inval for that.)\n\t */\n\tif (ct == NULL)\n\t{\n\t\tif (IsBootstrapProcessingMode())\n\t\t\treturn NULL;\n\n\t\tct = CatalogCacheCreateEntry(cache, NULL, arguments,\n\t\t\t\t\t\t\t\t\t hashValue, hashIndex,\n\t\t\t\t\t\t\t\t\t true);\n\n\t\tCACHE4_elog(DEBUG2, \"SearchCatCache(%s): Contains %d/%d tuples\",\n\t\t\t\t\tcache->cc_relname, cache->cc_ntup, CacheHdr->ch_ntup);\n\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): put neg entry in bucket %d\",\n\t\t\t\t\tcache->cc_relname, hashIndex);\n\n\t\t/*\n\t\t * We are not returning the negative entry to the caller, so leave its\n\t\t * refcount zero.\n\t\t */\n\n\t\treturn NULL;\n\t}\n\n\tCACHE4_elog(DEBUG2, \"SearchCatCache(%s): Contains %d/%d tuples\",\n\t\t\t\tcache->cc_relname, cache->cc_ntup, CacheHdr->ch_ntup);\n\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): put in bucket %d\",\n\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_newloads++;\n#endif\n\n\treturn &ct->tuple;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CACHE3_elog",
          "args": [
            "DEBUG2",
            "\"SearchCatCache(%s): found neg entry in bucket %d\"",
            "cache->cc_relname",
            "hashIndex"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CACHE3_elog",
          "args": [
            "DEBUG2",
            "\"SearchCatCache(%s): found in bucket %d\"",
            "cache->cc_relname",
            "hashIndex"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResourceOwnerRememberCatCacheRef",
          "args": [
            "CurrentResourceOwner",
            "&ct->tuple"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerRememberCatCacheRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "947-951",
          "snippet": "void\nResourceOwnerRememberCatCacheRef(ResourceOwner owner, HeapTuple tuple)\n{\n\tResourceArrayAdd(&(owner->catrefarr), PointerGetDatum(tuple));\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerRememberCatCacheRef(ResourceOwner owner, HeapTuple tuple)\n{\n\tResourceArrayAdd(&(owner->catrefarr), PointerGetDatum(tuple));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceOwnerEnlargeCatCacheRefs",
          "args": [
            "CurrentResourceOwner"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerEnlargeCatCacheRefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "936-940",
          "snippet": "void\nResourceOwnerEnlargeCatCacheRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->catrefarr));\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerEnlargeCatCacheRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->catrefarr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlist_move_head",
          "args": [
            "bucket",
            "&ct->cache_elem"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatalogCacheCompareTuple",
          "args": [
            "cache",
            "nkeys",
            "ct->keys",
            "arguments"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "CatalogCacheCompareTuple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "389-403",
          "snippet": "static inline bool\nCatalogCacheCompareTuple(const CatCache *cache, int nkeys,\n\t\t\t\t\t\t const Datum *cachekeys,\n\t\t\t\t\t\t const Datum *searchkeys)\n{\n\tconst CCFastEqualFN *cc_fastequal = cache->cc_fastequal;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tif (!(cc_fastequal[i]) (cachekeys[i], searchkeys[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool CatalogCacheCompareTuple(const CatCache *cache, int nkeys,\n\t\t\t\t\t\t const Datum *cachekeys,\n\t\t\t\t\t\t const Datum *searchkeys);",
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline bool CatalogCacheCompareTuple(const CatCache *cache, int nkeys,\n\t\t\t\t\t\t const Datum *cachekeys,\n\t\t\t\t\t\t const Datum *searchkeys);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nstatic inline bool\nCatalogCacheCompareTuple(const CatCache *cache, int nkeys,\n\t\t\t\t\t\t const Datum *cachekeys,\n\t\t\t\t\t\t const Datum *searchkeys)\n{\n\tconst CCFastEqualFN *cc_fastequal = cache->cc_fastequal;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tif (!(cc_fastequal[i]) (cachekeys[i], searchkeys[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlist_container",
          "args": [
            "CatCTup",
            "cache_elem",
            "iter.cur"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_foreach",
          "args": [
            "iter",
            "bucket"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HASH_INDEX",
          "args": [
            "hashValue",
            "cache->cc_nbuckets"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatalogCacheComputeHashValue",
          "args": [
            "cache",
            "nkeys",
            "v1",
            "v2",
            "v3",
            "v4"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "CatalogCacheComputeHashValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "275-319",
          "snippet": "static uint32\nCatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4)\n{\n\tuint32\t\thashValue = 0;\n\tuint32\t\toneHash;\n\tCCHashFN   *cc_hashfunc = cache->cc_hashfunc;\n\n\tCACHE4_elog(DEBUG2, \"CatalogCacheComputeHashValue %s %d %p\",\n\t\t\t\tcache->cc_relname,\n\t\t\t\tnkeys,\n\t\t\t\tcache);\n\n\tswitch (nkeys)\n\t{\n\t\tcase 4:\n\t\t\toneHash = (cc_hashfunc[3]) (v4);\n\n\t\t\thashValue ^= oneHash << 24;\n\t\t\thashValue ^= oneHash >> 8;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 3:\n\t\t\toneHash = (cc_hashfunc[2]) (v3);\n\n\t\t\thashValue ^= oneHash << 16;\n\t\t\thashValue ^= oneHash >> 16;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\toneHash = (cc_hashfunc[1]) (v2);\n\n\t\t\thashValue ^= oneHash << 8;\n\t\t\thashValue ^= oneHash >> 24;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\toneHash = (cc_hashfunc[0]) (v1);\n\n\t\t\thashValue ^= oneHash;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"wrong number of hash keys: %d\", nkeys);\n\t\t\tbreak;\n\t}\n\n\treturn hashValue;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
            "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic uint32\nCatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4)\n{\n\tuint32\t\thashValue = 0;\n\tuint32\t\toneHash;\n\tCCHashFN   *cc_hashfunc = cache->cc_hashfunc;\n\n\tCACHE4_elog(DEBUG2, \"CatalogCacheComputeHashValue %s %d %p\",\n\t\t\t\tcache->cc_relname,\n\t\t\t\tnkeys,\n\t\t\t\tcache);\n\n\tswitch (nkeys)\n\t{\n\t\tcase 4:\n\t\t\toneHash = (cc_hashfunc[3]) (v4);\n\n\t\t\thashValue ^= oneHash << 24;\n\t\t\thashValue ^= oneHash >> 8;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 3:\n\t\t\toneHash = (cc_hashfunc[2]) (v3);\n\n\t\t\thashValue ^= oneHash << 16;\n\t\t\thashValue ^= oneHash >> 16;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\toneHash = (cc_hashfunc[1]) (v2);\n\n\t\t\thashValue ^= oneHash << 8;\n\t\t\thashValue ^= oneHash >> 24;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\toneHash = (cc_hashfunc[0]) (v1);\n\n\t\t\thashValue ^= oneHash;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"wrong number of hash keys: %d\", nkeys);\n\t\t\tbreak;\n\t}\n\n\treturn hashValue;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CatalogCacheInitializeCache",
          "args": [
            "cache"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "CatalogCacheInitializeCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "938-1038",
          "snippet": "static void\nCatalogCacheInitializeCache(CatCache *cache)\n{\n\tRelation\trelation;\n\tMemoryContext oldcxt;\n\tTupleDesc\ttupdesc;\n\tint\t\t\ti;\n\n\tCatalogCacheInitializeCache_DEBUG1;\n\n\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\t/*\n\t * switch to the cache context so our allocations do not vanish at the end\n\t * of a transaction\n\t */\n\tAssert(CacheMemoryContext != NULL);\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * copy the relcache's tuple descriptor to permanent cache storage\n\t */\n\ttupdesc = CreateTupleDescCopyConstr(RelationGetDescr(relation));\n\n\t/*\n\t * save the relation's name and relisshared flag, too (cc_relname is used\n\t * only for debugging purposes)\n\t */\n\tcache->cc_relname = pstrdup(RelationGetRelationName(relation));\n\tcache->cc_relisshared = RelationGetForm(relation)->relisshared;\n\n\t/*\n\t * return to the caller's memory context and close the rel\n\t */\n\tMemoryContextSwitchTo(oldcxt);\n\n\theap_close(relation, AccessShareLock);\n\n\tCACHE3_elog(DEBUG2, \"CatalogCacheInitializeCache: %s, %d keys\",\n\t\t\t\tcache->cc_relname, cache->cc_nkeys);\n\n\t/*\n\t * initialize cache's key information\n\t */\n\tfor (i = 0; i < cache->cc_nkeys; ++i)\n\t{\n\t\tOid\t\t\tkeytype;\n\t\tRegProcedure eqfunc;\n\n\t\tCatalogCacheInitializeCache_DEBUG2;\n\n\t\tif (cache->cc_keyno[i] > 0)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   cache->cc_keyno[i] - 1);\n\n\t\t\tkeytype = attr->atttypid;\n\t\t\t/* cache key columns should always be NOT NULL */\n\t\t\tAssert(attr->attnotnull);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (cache->cc_keyno[i] != ObjectIdAttributeNumber)\n\t\t\t\telog(FATAL, \"only sys attr supported in caches is OID\");\n\t\t\tkeytype = OIDOID;\n\t\t}\n\n\t\tGetCCHashEqFuncs(keytype,\n\t\t\t\t\t\t &cache->cc_hashfunc[i],\n\t\t\t\t\t\t &eqfunc,\n\t\t\t\t\t\t &cache->cc_fastequal[i]);\n\n\t\t/*\n\t\t * Do equality-function lookup (we assume this won't need a catalog\n\t\t * lookup for any supported type)\n\t\t */\n\t\tfmgr_info_cxt(eqfunc,\n\t\t\t\t\t  &cache->cc_skey[i].sk_func,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t\t/* Initialize sk_attno suitably for HeapKeyTest() and heap scans */\n\t\tcache->cc_skey[i].sk_attno = cache->cc_keyno[i];\n\n\t\t/* Fill in sk_strategy as well --- always standard equality */\n\t\tcache->cc_skey[i].sk_strategy = BTEqualStrategyNumber;\n\t\tcache->cc_skey[i].sk_subtype = InvalidOid;\n\t\t/* Currently, there are no catcaches on collation-aware data types */\n\t\tcache->cc_skey[i].sk_collation = InvalidOid;\n\n\t\tCACHE4_elog(DEBUG2, \"CatalogCacheInitializeCache %s %d %p\",\n\t\t\t\t\tcache->cc_relname,\n\t\t\t\t\ti,\n\t\t\t\t\tcache);\n\t}\n\n\t/*\n\t * mark this cache fully initialized\n\t */\n\tcache->cc_tupdesc = tupdesc;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define CatalogCacheInitializeCache_DEBUG2",
            "#define CatalogCacheInitializeCache_DEBUG1",
            "#define CatalogCacheInitializeCache_DEBUG2 \\\ndo { \\\n\t\tif (cache->cc_keyno[i] > 0) { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d, %u\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i], \\\n\t\t\t\t TupleDescAttr(tupdesc, cache->cc_keyno[i] - 1)->atttypid); \\\n\t\t} else { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i]); \\\n\t\t} \\\n} while(0)",
            "#define CatalogCacheInitializeCache_DEBUG1 \\\n\telog(DEBUG2, \"CatalogCacheInitializeCache: cache @%p rel=%u\", cache, \\\n\t\t cache->cc_reloid)"
          ],
          "globals_used": [
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\n#define CatalogCacheInitializeCache_DEBUG2\n#define CatalogCacheInitializeCache_DEBUG1\n#define CatalogCacheInitializeCache_DEBUG2 \\\ndo { \\\n\t\tif (cache->cc_keyno[i] > 0) { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d, %u\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i], \\\n\t\t\t\t TupleDescAttr(tupdesc, cache->cc_keyno[i] - 1)->atttypid); \\\n\t\t} else { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i]); \\\n\t\t} \\\n} while(0)\n#define CatalogCacheInitializeCache_DEBUG1 \\\n\telog(DEBUG2, \"CatalogCacheInitializeCache: cache @%p rel=%u\", cache, \\\n\t\t cache->cc_reloid)\n\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatalogCacheInitializeCache(CatCache *cache)\n{\n\tRelation\trelation;\n\tMemoryContext oldcxt;\n\tTupleDesc\ttupdesc;\n\tint\t\t\ti;\n\n\tCatalogCacheInitializeCache_DEBUG1;\n\n\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\t/*\n\t * switch to the cache context so our allocations do not vanish at the end\n\t * of a transaction\n\t */\n\tAssert(CacheMemoryContext != NULL);\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * copy the relcache's tuple descriptor to permanent cache storage\n\t */\n\ttupdesc = CreateTupleDescCopyConstr(RelationGetDescr(relation));\n\n\t/*\n\t * save the relation's name and relisshared flag, too (cc_relname is used\n\t * only for debugging purposes)\n\t */\n\tcache->cc_relname = pstrdup(RelationGetRelationName(relation));\n\tcache->cc_relisshared = RelationGetForm(relation)->relisshared;\n\n\t/*\n\t * return to the caller's memory context and close the rel\n\t */\n\tMemoryContextSwitchTo(oldcxt);\n\n\theap_close(relation, AccessShareLock);\n\n\tCACHE3_elog(DEBUG2, \"CatalogCacheInitializeCache: %s, %d keys\",\n\t\t\t\tcache->cc_relname, cache->cc_nkeys);\n\n\t/*\n\t * initialize cache's key information\n\t */\n\tfor (i = 0; i < cache->cc_nkeys; ++i)\n\t{\n\t\tOid\t\t\tkeytype;\n\t\tRegProcedure eqfunc;\n\n\t\tCatalogCacheInitializeCache_DEBUG2;\n\n\t\tif (cache->cc_keyno[i] > 0)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   cache->cc_keyno[i] - 1);\n\n\t\t\tkeytype = attr->atttypid;\n\t\t\t/* cache key columns should always be NOT NULL */\n\t\t\tAssert(attr->attnotnull);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (cache->cc_keyno[i] != ObjectIdAttributeNumber)\n\t\t\t\telog(FATAL, \"only sys attr supported in caches is OID\");\n\t\t\tkeytype = OIDOID;\n\t\t}\n\n\t\tGetCCHashEqFuncs(keytype,\n\t\t\t\t\t\t &cache->cc_hashfunc[i],\n\t\t\t\t\t\t &eqfunc,\n\t\t\t\t\t\t &cache->cc_fastequal[i]);\n\n\t\t/*\n\t\t * Do equality-function lookup (we assume this won't need a catalog\n\t\t * lookup for any supported type)\n\t\t */\n\t\tfmgr_info_cxt(eqfunc,\n\t\t\t\t\t  &cache->cc_skey[i].sk_func,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t\t/* Initialize sk_attno suitably for HeapKeyTest() and heap scans */\n\t\tcache->cc_skey[i].sk_attno = cache->cc_keyno[i];\n\n\t\t/* Fill in sk_strategy as well --- always standard equality */\n\t\tcache->cc_skey[i].sk_strategy = BTEqualStrategyNumber;\n\t\tcache->cc_skey[i].sk_subtype = InvalidOid;\n\t\t/* Currently, there are no catcaches on collation-aware data types */\n\t\tcache->cc_skey[i].sk_collation = InvalidOid;\n\n\t\tCACHE4_elog(DEBUG2, \"CatalogCacheInitializeCache %s %d %p\",\n\t\t\t\t\tcache->cc_relname,\n\t\t\t\t\ti,\n\t\t\t\t\tcache);\n\t}\n\n\t/*\n\t * mark this cache fully initialized\n\t */\n\tcache->cc_tupdesc = tupdesc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cache->cc_tupdesc == NULL"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "cache->cc_nkeys == nkeys"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "IsTransactionState()"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsTransactionState",
          "args": [],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic inline HeapTuple\nSearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1,\n\t\t\t\t\t   Datum v2,\n\t\t\t\t\t   Datum v3,\n\t\t\t\t\t   Datum v4)\n{\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\tuint32\t\thashValue;\n\tIndex\t\thashIndex;\n\tdlist_iter\titer;\n\tdlist_head *bucket;\n\tCatCTup    *ct;\n\n\t/* Make sure we're in an xact, even if this ends up being a cache hit */\n\tAssert(IsTransactionState());\n\n\tAssert(cache->cc_nkeys == nkeys);\n\n\t/*\n\t * one-time startup overhead for each cache\n\t */\n\tif (unlikely(cache->cc_tupdesc == NULL))\n\t\tCatalogCacheInitializeCache(cache);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_searches++;\n#endif\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * find the hash bucket in which to look for the tuple\n\t */\n\thashValue = CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n\thashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);\n\n\t/*\n\t * scan the hash bucket until we find a match or exhaust our tuples\n\t *\n\t * Note: it's okay to use dlist_foreach here, even though we modify the\n\t * dlist within the loop, because we don't continue the loop afterwards.\n\t */\n\tbucket = &cache->cc_bucket[hashIndex];\n\tdlist_foreach(iter, bucket)\n\t{\n\t\tct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\tif (ct->dead)\n\t\t\tcontinue;\t\t\t/* ignore dead entries */\n\n\t\tif (ct->hash_value != hashValue)\n\t\t\tcontinue;\t\t\t/* quickly skip entry if wrong hash val */\n\n\t\tif (!CatalogCacheCompareTuple(cache, nkeys, ct->keys, arguments))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We found a match in the cache.  Move it to the front of the list\n\t\t * for its hashbucket, in order to speed subsequent searches.  (The\n\t\t * most frequently accessed elements in any hashbucket will tend to be\n\t\t * near the front of the hashbucket's list.)\n\t\t */\n\t\tdlist_move_head(bucket, &ct->cache_elem);\n\n\t\t/*\n\t\t * If it's a positive entry, bump its refcount and return it. If it's\n\t\t * negative, we can report failure to the caller.\n\t\t */\n\t\tif (!ct->negative)\n\t\t{\n\t\t\tResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);\n\t\t\tct->refcount++;\n\t\t\tResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_hits++;\n#endif\n\n\t\t\treturn &ct->tuple;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found neg entry in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_neg_hits++;\n#endif\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn SearchCatCacheMiss(cache, nkeys, hashValue, hashIndex, v1, v2, v3, v4);\n}"
  },
  {
    "function_name": "SearchCatCache4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "1205-1210",
    "snippet": "HeapTuple\nSearchCatCache4(CatCache *cache,\n\t\t\t\tDatum v1, Datum v2, Datum v3, Datum v4)\n{\n\treturn SearchCatCacheInternal(cache, 4, v1, v2, v3, v4);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
      "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
      "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SearchCatCacheInternal",
          "args": [
            "cache",
            "4",
            "v1",
            "v2",
            "v3",
            "v4"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "SearchCatCacheInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "1215-1318",
          "snippet": "static inline HeapTuple\nSearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1,\n\t\t\t\t\t   Datum v2,\n\t\t\t\t\t   Datum v3,\n\t\t\t\t\t   Datum v4)\n{\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\tuint32\t\thashValue;\n\tIndex\t\thashIndex;\n\tdlist_iter\titer;\n\tdlist_head *bucket;\n\tCatCTup    *ct;\n\n\t/* Make sure we're in an xact, even if this ends up being a cache hit */\n\tAssert(IsTransactionState());\n\n\tAssert(cache->cc_nkeys == nkeys);\n\n\t/*\n\t * one-time startup overhead for each cache\n\t */\n\tif (unlikely(cache->cc_tupdesc == NULL))\n\t\tCatalogCacheInitializeCache(cache);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_searches++;\n#endif\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * find the hash bucket in which to look for the tuple\n\t */\n\thashValue = CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n\thashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);\n\n\t/*\n\t * scan the hash bucket until we find a match or exhaust our tuples\n\t *\n\t * Note: it's okay to use dlist_foreach here, even though we modify the\n\t * dlist within the loop, because we don't continue the loop afterwards.\n\t */\n\tbucket = &cache->cc_bucket[hashIndex];\n\tdlist_foreach(iter, bucket)\n\t{\n\t\tct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\tif (ct->dead)\n\t\t\tcontinue;\t\t\t/* ignore dead entries */\n\n\t\tif (ct->hash_value != hashValue)\n\t\t\tcontinue;\t\t\t/* quickly skip entry if wrong hash val */\n\n\t\tif (!CatalogCacheCompareTuple(cache, nkeys, ct->keys, arguments))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We found a match in the cache.  Move it to the front of the list\n\t\t * for its hashbucket, in order to speed subsequent searches.  (The\n\t\t * most frequently accessed elements in any hashbucket will tend to be\n\t\t * near the front of the hashbucket's list.)\n\t\t */\n\t\tdlist_move_head(bucket, &ct->cache_elem);\n\n\t\t/*\n\t\t * If it's a positive entry, bump its refcount and return it. If it's\n\t\t * negative, we can report failure to the caller.\n\t\t */\n\t\tif (!ct->negative)\n\t\t{\n\t\t\tResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);\n\t\t\tct->refcount++;\n\t\t\tResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_hits++;\n#endif\n\n\t\t\treturn &ct->tuple;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found neg entry in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_neg_hits++;\n#endif\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn SearchCatCacheMiss(cache, nkeys, hashValue, hashIndex, v1, v2, v3, v4);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
            "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic inline HeapTuple\nSearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1,\n\t\t\t\t\t   Datum v2,\n\t\t\t\t\t   Datum v3,\n\t\t\t\t\t   Datum v4)\n{\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\tuint32\t\thashValue;\n\tIndex\t\thashIndex;\n\tdlist_iter\titer;\n\tdlist_head *bucket;\n\tCatCTup    *ct;\n\n\t/* Make sure we're in an xact, even if this ends up being a cache hit */\n\tAssert(IsTransactionState());\n\n\tAssert(cache->cc_nkeys == nkeys);\n\n\t/*\n\t * one-time startup overhead for each cache\n\t */\n\tif (unlikely(cache->cc_tupdesc == NULL))\n\t\tCatalogCacheInitializeCache(cache);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_searches++;\n#endif\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * find the hash bucket in which to look for the tuple\n\t */\n\thashValue = CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n\thashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);\n\n\t/*\n\t * scan the hash bucket until we find a match or exhaust our tuples\n\t *\n\t * Note: it's okay to use dlist_foreach here, even though we modify the\n\t * dlist within the loop, because we don't continue the loop afterwards.\n\t */\n\tbucket = &cache->cc_bucket[hashIndex];\n\tdlist_foreach(iter, bucket)\n\t{\n\t\tct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\tif (ct->dead)\n\t\t\tcontinue;\t\t\t/* ignore dead entries */\n\n\t\tif (ct->hash_value != hashValue)\n\t\t\tcontinue;\t\t\t/* quickly skip entry if wrong hash val */\n\n\t\tif (!CatalogCacheCompareTuple(cache, nkeys, ct->keys, arguments))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We found a match in the cache.  Move it to the front of the list\n\t\t * for its hashbucket, in order to speed subsequent searches.  (The\n\t\t * most frequently accessed elements in any hashbucket will tend to be\n\t\t * near the front of the hashbucket's list.)\n\t\t */\n\t\tdlist_move_head(bucket, &ct->cache_elem);\n\n\t\t/*\n\t\t * If it's a positive entry, bump its refcount and return it. If it's\n\t\t * negative, we can report failure to the caller.\n\t\t */\n\t\tif (!ct->negative)\n\t\t{\n\t\t\tResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);\n\t\t\tct->refcount++;\n\t\t\tResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_hits++;\n#endif\n\n\t\t\treturn &ct->tuple;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found neg entry in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_neg_hits++;\n#endif\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn SearchCatCacheMiss(cache, nkeys, hashValue, hashIndex, v1, v2, v3, v4);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nHeapTuple\nSearchCatCache4(CatCache *cache,\n\t\t\t\tDatum v1, Datum v2, Datum v3, Datum v4)\n{\n\treturn SearchCatCacheInternal(cache, 4, v1, v2, v3, v4);\n}"
  },
  {
    "function_name": "SearchCatCache3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "1197-1202",
    "snippet": "HeapTuple\nSearchCatCache3(CatCache *cache,\n\t\t\t\tDatum v1, Datum v2, Datum v3)\n{\n\treturn SearchCatCacheInternal(cache, 3, v1, v2, v3, 0);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SearchCatCacheInternal",
          "args": [
            "cache",
            "3",
            "v1",
            "v2",
            "v3",
            "0"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "SearchCatCacheInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "1215-1318",
          "snippet": "static inline HeapTuple\nSearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1,\n\t\t\t\t\t   Datum v2,\n\t\t\t\t\t   Datum v3,\n\t\t\t\t\t   Datum v4)\n{\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\tuint32\t\thashValue;\n\tIndex\t\thashIndex;\n\tdlist_iter\titer;\n\tdlist_head *bucket;\n\tCatCTup    *ct;\n\n\t/* Make sure we're in an xact, even if this ends up being a cache hit */\n\tAssert(IsTransactionState());\n\n\tAssert(cache->cc_nkeys == nkeys);\n\n\t/*\n\t * one-time startup overhead for each cache\n\t */\n\tif (unlikely(cache->cc_tupdesc == NULL))\n\t\tCatalogCacheInitializeCache(cache);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_searches++;\n#endif\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * find the hash bucket in which to look for the tuple\n\t */\n\thashValue = CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n\thashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);\n\n\t/*\n\t * scan the hash bucket until we find a match or exhaust our tuples\n\t *\n\t * Note: it's okay to use dlist_foreach here, even though we modify the\n\t * dlist within the loop, because we don't continue the loop afterwards.\n\t */\n\tbucket = &cache->cc_bucket[hashIndex];\n\tdlist_foreach(iter, bucket)\n\t{\n\t\tct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\tif (ct->dead)\n\t\t\tcontinue;\t\t\t/* ignore dead entries */\n\n\t\tif (ct->hash_value != hashValue)\n\t\t\tcontinue;\t\t\t/* quickly skip entry if wrong hash val */\n\n\t\tif (!CatalogCacheCompareTuple(cache, nkeys, ct->keys, arguments))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We found a match in the cache.  Move it to the front of the list\n\t\t * for its hashbucket, in order to speed subsequent searches.  (The\n\t\t * most frequently accessed elements in any hashbucket will tend to be\n\t\t * near the front of the hashbucket's list.)\n\t\t */\n\t\tdlist_move_head(bucket, &ct->cache_elem);\n\n\t\t/*\n\t\t * If it's a positive entry, bump its refcount and return it. If it's\n\t\t * negative, we can report failure to the caller.\n\t\t */\n\t\tif (!ct->negative)\n\t\t{\n\t\t\tResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);\n\t\t\tct->refcount++;\n\t\t\tResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_hits++;\n#endif\n\n\t\t\treturn &ct->tuple;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found neg entry in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_neg_hits++;\n#endif\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn SearchCatCacheMiss(cache, nkeys, hashValue, hashIndex, v1, v2, v3, v4);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
            "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic inline HeapTuple\nSearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1,\n\t\t\t\t\t   Datum v2,\n\t\t\t\t\t   Datum v3,\n\t\t\t\t\t   Datum v4)\n{\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\tuint32\t\thashValue;\n\tIndex\t\thashIndex;\n\tdlist_iter\titer;\n\tdlist_head *bucket;\n\tCatCTup    *ct;\n\n\t/* Make sure we're in an xact, even if this ends up being a cache hit */\n\tAssert(IsTransactionState());\n\n\tAssert(cache->cc_nkeys == nkeys);\n\n\t/*\n\t * one-time startup overhead for each cache\n\t */\n\tif (unlikely(cache->cc_tupdesc == NULL))\n\t\tCatalogCacheInitializeCache(cache);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_searches++;\n#endif\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * find the hash bucket in which to look for the tuple\n\t */\n\thashValue = CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n\thashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);\n\n\t/*\n\t * scan the hash bucket until we find a match or exhaust our tuples\n\t *\n\t * Note: it's okay to use dlist_foreach here, even though we modify the\n\t * dlist within the loop, because we don't continue the loop afterwards.\n\t */\n\tbucket = &cache->cc_bucket[hashIndex];\n\tdlist_foreach(iter, bucket)\n\t{\n\t\tct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\tif (ct->dead)\n\t\t\tcontinue;\t\t\t/* ignore dead entries */\n\n\t\tif (ct->hash_value != hashValue)\n\t\t\tcontinue;\t\t\t/* quickly skip entry if wrong hash val */\n\n\t\tif (!CatalogCacheCompareTuple(cache, nkeys, ct->keys, arguments))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We found a match in the cache.  Move it to the front of the list\n\t\t * for its hashbucket, in order to speed subsequent searches.  (The\n\t\t * most frequently accessed elements in any hashbucket will tend to be\n\t\t * near the front of the hashbucket's list.)\n\t\t */\n\t\tdlist_move_head(bucket, &ct->cache_elem);\n\n\t\t/*\n\t\t * If it's a positive entry, bump its refcount and return it. If it's\n\t\t * negative, we can report failure to the caller.\n\t\t */\n\t\tif (!ct->negative)\n\t\t{\n\t\t\tResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);\n\t\t\tct->refcount++;\n\t\t\tResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_hits++;\n#endif\n\n\t\t\treturn &ct->tuple;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found neg entry in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_neg_hits++;\n#endif\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn SearchCatCacheMiss(cache, nkeys, hashValue, hashIndex, v1, v2, v3, v4);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nHeapTuple\nSearchCatCache3(CatCache *cache,\n\t\t\t\tDatum v1, Datum v2, Datum v3)\n{\n\treturn SearchCatCacheInternal(cache, 3, v1, v2, v3, 0);\n}"
  },
  {
    "function_name": "SearchCatCache2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "1189-1194",
    "snippet": "HeapTuple\nSearchCatCache2(CatCache *cache,\n\t\t\t\tDatum v1, Datum v2)\n{\n\treturn SearchCatCacheInternal(cache, 2, v1, v2, 0, 0);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SearchCatCacheInternal",
          "args": [
            "cache",
            "2",
            "v1",
            "v2",
            "0",
            "0"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "SearchCatCacheInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "1215-1318",
          "snippet": "static inline HeapTuple\nSearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1,\n\t\t\t\t\t   Datum v2,\n\t\t\t\t\t   Datum v3,\n\t\t\t\t\t   Datum v4)\n{\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\tuint32\t\thashValue;\n\tIndex\t\thashIndex;\n\tdlist_iter\titer;\n\tdlist_head *bucket;\n\tCatCTup    *ct;\n\n\t/* Make sure we're in an xact, even if this ends up being a cache hit */\n\tAssert(IsTransactionState());\n\n\tAssert(cache->cc_nkeys == nkeys);\n\n\t/*\n\t * one-time startup overhead for each cache\n\t */\n\tif (unlikely(cache->cc_tupdesc == NULL))\n\t\tCatalogCacheInitializeCache(cache);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_searches++;\n#endif\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * find the hash bucket in which to look for the tuple\n\t */\n\thashValue = CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n\thashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);\n\n\t/*\n\t * scan the hash bucket until we find a match or exhaust our tuples\n\t *\n\t * Note: it's okay to use dlist_foreach here, even though we modify the\n\t * dlist within the loop, because we don't continue the loop afterwards.\n\t */\n\tbucket = &cache->cc_bucket[hashIndex];\n\tdlist_foreach(iter, bucket)\n\t{\n\t\tct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\tif (ct->dead)\n\t\t\tcontinue;\t\t\t/* ignore dead entries */\n\n\t\tif (ct->hash_value != hashValue)\n\t\t\tcontinue;\t\t\t/* quickly skip entry if wrong hash val */\n\n\t\tif (!CatalogCacheCompareTuple(cache, nkeys, ct->keys, arguments))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We found a match in the cache.  Move it to the front of the list\n\t\t * for its hashbucket, in order to speed subsequent searches.  (The\n\t\t * most frequently accessed elements in any hashbucket will tend to be\n\t\t * near the front of the hashbucket's list.)\n\t\t */\n\t\tdlist_move_head(bucket, &ct->cache_elem);\n\n\t\t/*\n\t\t * If it's a positive entry, bump its refcount and return it. If it's\n\t\t * negative, we can report failure to the caller.\n\t\t */\n\t\tif (!ct->negative)\n\t\t{\n\t\t\tResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);\n\t\t\tct->refcount++;\n\t\t\tResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_hits++;\n#endif\n\n\t\t\treturn &ct->tuple;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found neg entry in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_neg_hits++;\n#endif\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn SearchCatCacheMiss(cache, nkeys, hashValue, hashIndex, v1, v2, v3, v4);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
            "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic inline HeapTuple\nSearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1,\n\t\t\t\t\t   Datum v2,\n\t\t\t\t\t   Datum v3,\n\t\t\t\t\t   Datum v4)\n{\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\tuint32\t\thashValue;\n\tIndex\t\thashIndex;\n\tdlist_iter\titer;\n\tdlist_head *bucket;\n\tCatCTup    *ct;\n\n\t/* Make sure we're in an xact, even if this ends up being a cache hit */\n\tAssert(IsTransactionState());\n\n\tAssert(cache->cc_nkeys == nkeys);\n\n\t/*\n\t * one-time startup overhead for each cache\n\t */\n\tif (unlikely(cache->cc_tupdesc == NULL))\n\t\tCatalogCacheInitializeCache(cache);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_searches++;\n#endif\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * find the hash bucket in which to look for the tuple\n\t */\n\thashValue = CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n\thashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);\n\n\t/*\n\t * scan the hash bucket until we find a match or exhaust our tuples\n\t *\n\t * Note: it's okay to use dlist_foreach here, even though we modify the\n\t * dlist within the loop, because we don't continue the loop afterwards.\n\t */\n\tbucket = &cache->cc_bucket[hashIndex];\n\tdlist_foreach(iter, bucket)\n\t{\n\t\tct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\tif (ct->dead)\n\t\t\tcontinue;\t\t\t/* ignore dead entries */\n\n\t\tif (ct->hash_value != hashValue)\n\t\t\tcontinue;\t\t\t/* quickly skip entry if wrong hash val */\n\n\t\tif (!CatalogCacheCompareTuple(cache, nkeys, ct->keys, arguments))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We found a match in the cache.  Move it to the front of the list\n\t\t * for its hashbucket, in order to speed subsequent searches.  (The\n\t\t * most frequently accessed elements in any hashbucket will tend to be\n\t\t * near the front of the hashbucket's list.)\n\t\t */\n\t\tdlist_move_head(bucket, &ct->cache_elem);\n\n\t\t/*\n\t\t * If it's a positive entry, bump its refcount and return it. If it's\n\t\t * negative, we can report failure to the caller.\n\t\t */\n\t\tif (!ct->negative)\n\t\t{\n\t\t\tResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);\n\t\t\tct->refcount++;\n\t\t\tResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_hits++;\n#endif\n\n\t\t\treturn &ct->tuple;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found neg entry in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_neg_hits++;\n#endif\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn SearchCatCacheMiss(cache, nkeys, hashValue, hashIndex, v1, v2, v3, v4);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nHeapTuple\nSearchCatCache2(CatCache *cache,\n\t\t\t\tDatum v1, Datum v2)\n{\n\treturn SearchCatCacheInternal(cache, 2, v1, v2, 0, 0);\n}"
  },
  {
    "function_name": "SearchCatCache1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "1181-1186",
    "snippet": "HeapTuple\nSearchCatCache1(CatCache *cache,\n\t\t\t\tDatum v1)\n{\n\treturn SearchCatCacheInternal(cache, 1, v1, 0, 0, 0);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SearchCatCacheInternal",
          "args": [
            "cache",
            "1",
            "v1",
            "0",
            "0",
            "0"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "SearchCatCacheInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "1215-1318",
          "snippet": "static inline HeapTuple\nSearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1,\n\t\t\t\t\t   Datum v2,\n\t\t\t\t\t   Datum v3,\n\t\t\t\t\t   Datum v4)\n{\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\tuint32\t\thashValue;\n\tIndex\t\thashIndex;\n\tdlist_iter\titer;\n\tdlist_head *bucket;\n\tCatCTup    *ct;\n\n\t/* Make sure we're in an xact, even if this ends up being a cache hit */\n\tAssert(IsTransactionState());\n\n\tAssert(cache->cc_nkeys == nkeys);\n\n\t/*\n\t * one-time startup overhead for each cache\n\t */\n\tif (unlikely(cache->cc_tupdesc == NULL))\n\t\tCatalogCacheInitializeCache(cache);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_searches++;\n#endif\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * find the hash bucket in which to look for the tuple\n\t */\n\thashValue = CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n\thashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);\n\n\t/*\n\t * scan the hash bucket until we find a match or exhaust our tuples\n\t *\n\t * Note: it's okay to use dlist_foreach here, even though we modify the\n\t * dlist within the loop, because we don't continue the loop afterwards.\n\t */\n\tbucket = &cache->cc_bucket[hashIndex];\n\tdlist_foreach(iter, bucket)\n\t{\n\t\tct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\tif (ct->dead)\n\t\t\tcontinue;\t\t\t/* ignore dead entries */\n\n\t\tif (ct->hash_value != hashValue)\n\t\t\tcontinue;\t\t\t/* quickly skip entry if wrong hash val */\n\n\t\tif (!CatalogCacheCompareTuple(cache, nkeys, ct->keys, arguments))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We found a match in the cache.  Move it to the front of the list\n\t\t * for its hashbucket, in order to speed subsequent searches.  (The\n\t\t * most frequently accessed elements in any hashbucket will tend to be\n\t\t * near the front of the hashbucket's list.)\n\t\t */\n\t\tdlist_move_head(bucket, &ct->cache_elem);\n\n\t\t/*\n\t\t * If it's a positive entry, bump its refcount and return it. If it's\n\t\t * negative, we can report failure to the caller.\n\t\t */\n\t\tif (!ct->negative)\n\t\t{\n\t\t\tResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);\n\t\t\tct->refcount++;\n\t\t\tResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_hits++;\n#endif\n\n\t\t\treturn &ct->tuple;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found neg entry in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_neg_hits++;\n#endif\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn SearchCatCacheMiss(cache, nkeys, hashValue, hashIndex, v1, v2, v3, v4);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
            "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic inline HeapTuple\nSearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1,\n\t\t\t\t\t   Datum v2,\n\t\t\t\t\t   Datum v3,\n\t\t\t\t\t   Datum v4)\n{\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\tuint32\t\thashValue;\n\tIndex\t\thashIndex;\n\tdlist_iter\titer;\n\tdlist_head *bucket;\n\tCatCTup    *ct;\n\n\t/* Make sure we're in an xact, even if this ends up being a cache hit */\n\tAssert(IsTransactionState());\n\n\tAssert(cache->cc_nkeys == nkeys);\n\n\t/*\n\t * one-time startup overhead for each cache\n\t */\n\tif (unlikely(cache->cc_tupdesc == NULL))\n\t\tCatalogCacheInitializeCache(cache);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_searches++;\n#endif\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * find the hash bucket in which to look for the tuple\n\t */\n\thashValue = CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n\thashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);\n\n\t/*\n\t * scan the hash bucket until we find a match or exhaust our tuples\n\t *\n\t * Note: it's okay to use dlist_foreach here, even though we modify the\n\t * dlist within the loop, because we don't continue the loop afterwards.\n\t */\n\tbucket = &cache->cc_bucket[hashIndex];\n\tdlist_foreach(iter, bucket)\n\t{\n\t\tct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\tif (ct->dead)\n\t\t\tcontinue;\t\t\t/* ignore dead entries */\n\n\t\tif (ct->hash_value != hashValue)\n\t\t\tcontinue;\t\t\t/* quickly skip entry if wrong hash val */\n\n\t\tif (!CatalogCacheCompareTuple(cache, nkeys, ct->keys, arguments))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We found a match in the cache.  Move it to the front of the list\n\t\t * for its hashbucket, in order to speed subsequent searches.  (The\n\t\t * most frequently accessed elements in any hashbucket will tend to be\n\t\t * near the front of the hashbucket's list.)\n\t\t */\n\t\tdlist_move_head(bucket, &ct->cache_elem);\n\n\t\t/*\n\t\t * If it's a positive entry, bump its refcount and return it. If it's\n\t\t * negative, we can report failure to the caller.\n\t\t */\n\t\tif (!ct->negative)\n\t\t{\n\t\t\tResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);\n\t\t\tct->refcount++;\n\t\t\tResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_hits++;\n#endif\n\n\t\t\treturn &ct->tuple;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found neg entry in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_neg_hits++;\n#endif\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn SearchCatCacheMiss(cache, nkeys, hashValue, hashIndex, v1, v2, v3, v4);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nHeapTuple\nSearchCatCache1(CatCache *cache,\n\t\t\t\tDatum v1)\n{\n\treturn SearchCatCacheInternal(cache, 1, v1, 0, 0, 0);\n}"
  },
  {
    "function_name": "SearchCatCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "1164-1172",
    "snippet": "HeapTuple\nSearchCatCache(CatCache *cache,\n\t\t\t   Datum v1,\n\t\t\t   Datum v2,\n\t\t\t   Datum v3,\n\t\t\t   Datum v4)\n{\n\treturn SearchCatCacheInternal(cache, cache->cc_nkeys, v1, v2, v3, v4);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
      "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
      "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SearchCatCacheInternal",
          "args": [
            "cache",
            "cache->cc_nkeys",
            "v1",
            "v2",
            "v3",
            "v4"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "SearchCatCacheInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "1215-1318",
          "snippet": "static inline HeapTuple\nSearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1,\n\t\t\t\t\t   Datum v2,\n\t\t\t\t\t   Datum v3,\n\t\t\t\t\t   Datum v4)\n{\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\tuint32\t\thashValue;\n\tIndex\t\thashIndex;\n\tdlist_iter\titer;\n\tdlist_head *bucket;\n\tCatCTup    *ct;\n\n\t/* Make sure we're in an xact, even if this ends up being a cache hit */\n\tAssert(IsTransactionState());\n\n\tAssert(cache->cc_nkeys == nkeys);\n\n\t/*\n\t * one-time startup overhead for each cache\n\t */\n\tif (unlikely(cache->cc_tupdesc == NULL))\n\t\tCatalogCacheInitializeCache(cache);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_searches++;\n#endif\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * find the hash bucket in which to look for the tuple\n\t */\n\thashValue = CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n\thashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);\n\n\t/*\n\t * scan the hash bucket until we find a match or exhaust our tuples\n\t *\n\t * Note: it's okay to use dlist_foreach here, even though we modify the\n\t * dlist within the loop, because we don't continue the loop afterwards.\n\t */\n\tbucket = &cache->cc_bucket[hashIndex];\n\tdlist_foreach(iter, bucket)\n\t{\n\t\tct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\tif (ct->dead)\n\t\t\tcontinue;\t\t\t/* ignore dead entries */\n\n\t\tif (ct->hash_value != hashValue)\n\t\t\tcontinue;\t\t\t/* quickly skip entry if wrong hash val */\n\n\t\tif (!CatalogCacheCompareTuple(cache, nkeys, ct->keys, arguments))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We found a match in the cache.  Move it to the front of the list\n\t\t * for its hashbucket, in order to speed subsequent searches.  (The\n\t\t * most frequently accessed elements in any hashbucket will tend to be\n\t\t * near the front of the hashbucket's list.)\n\t\t */\n\t\tdlist_move_head(bucket, &ct->cache_elem);\n\n\t\t/*\n\t\t * If it's a positive entry, bump its refcount and return it. If it's\n\t\t * negative, we can report failure to the caller.\n\t\t */\n\t\tif (!ct->negative)\n\t\t{\n\t\t\tResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);\n\t\t\tct->refcount++;\n\t\t\tResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_hits++;\n#endif\n\n\t\t\treturn &ct->tuple;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found neg entry in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_neg_hits++;\n#endif\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn SearchCatCacheMiss(cache, nkeys, hashValue, hashIndex, v1, v2, v3, v4);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
            "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic inline HeapTuple\nSearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1,\n\t\t\t\t\t   Datum v2,\n\t\t\t\t\t   Datum v3,\n\t\t\t\t\t   Datum v4)\n{\n\tDatum\t\targuments[CATCACHE_MAXKEYS];\n\tuint32\t\thashValue;\n\tIndex\t\thashIndex;\n\tdlist_iter\titer;\n\tdlist_head *bucket;\n\tCatCTup    *ct;\n\n\t/* Make sure we're in an xact, even if this ends up being a cache hit */\n\tAssert(IsTransactionState());\n\n\tAssert(cache->cc_nkeys == nkeys);\n\n\t/*\n\t * one-time startup overhead for each cache\n\t */\n\tif (unlikely(cache->cc_tupdesc == NULL))\n\t\tCatalogCacheInitializeCache(cache);\n\n#ifdef CATCACHE_STATS\n\tcache->cc_searches++;\n#endif\n\n\t/* Initialize local parameter array */\n\targuments[0] = v1;\n\targuments[1] = v2;\n\targuments[2] = v3;\n\targuments[3] = v4;\n\n\t/*\n\t * find the hash bucket in which to look for the tuple\n\t */\n\thashValue = CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n\thashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);\n\n\t/*\n\t * scan the hash bucket until we find a match or exhaust our tuples\n\t *\n\t * Note: it's okay to use dlist_foreach here, even though we modify the\n\t * dlist within the loop, because we don't continue the loop afterwards.\n\t */\n\tbucket = &cache->cc_bucket[hashIndex];\n\tdlist_foreach(iter, bucket)\n\t{\n\t\tct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\tif (ct->dead)\n\t\t\tcontinue;\t\t\t/* ignore dead entries */\n\n\t\tif (ct->hash_value != hashValue)\n\t\t\tcontinue;\t\t\t/* quickly skip entry if wrong hash val */\n\n\t\tif (!CatalogCacheCompareTuple(cache, nkeys, ct->keys, arguments))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We found a match in the cache.  Move it to the front of the list\n\t\t * for its hashbucket, in order to speed subsequent searches.  (The\n\t\t * most frequently accessed elements in any hashbucket will tend to be\n\t\t * near the front of the hashbucket's list.)\n\t\t */\n\t\tdlist_move_head(bucket, &ct->cache_elem);\n\n\t\t/*\n\t\t * If it's a positive entry, bump its refcount and return it. If it's\n\t\t * negative, we can report failure to the caller.\n\t\t */\n\t\tif (!ct->negative)\n\t\t{\n\t\t\tResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);\n\t\t\tct->refcount++;\n\t\t\tResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);\n\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_hits++;\n#endif\n\n\t\t\treturn &ct->tuple;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCACHE3_elog(DEBUG2, \"SearchCatCache(%s): found neg entry in bucket %d\",\n\t\t\t\t\t\tcache->cc_relname, hashIndex);\n\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_neg_hits++;\n#endif\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn SearchCatCacheMiss(cache, nkeys, hashValue, hashIndex, v1, v2, v3, v4);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nHeapTuple\nSearchCatCache(CatCache *cache,\n\t\t\t   Datum v1,\n\t\t\t   Datum v2,\n\t\t\t   Datum v3,\n\t\t\t   Datum v4)\n{\n\treturn SearchCatCacheInternal(cache, cache->cc_nkeys, v1, v2, v3, v4);\n}"
  },
  {
    "function_name": "IndexScanOK",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "1100-1146",
    "snippet": "static bool\nIndexScanOK(CatCache *cache, ScanKey cur_skey)\n{\n\tswitch (cache->id)\n\t{\n\t\tcase INDEXRELID:\n\n\t\t\t/*\n\t\t\t * Rather than tracking exactly which indexes have to be loaded\n\t\t\t * before we can use indexscans (which changes from time to time),\n\t\t\t * just force all pg_index searches to be heap scans until we've\n\t\t\t * built the critical relcaches.\n\t\t\t */\n\t\t\tif (!criticalRelcachesBuilt)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\n\t\tcase AMOID:\n\t\tcase AMNAME:\n\n\t\t\t/*\n\t\t\t * Always do heap scans in pg_am, because it's so small there's\n\t\t\t * not much point in an indexscan anyway.  We *must* do this when\n\t\t\t * initially building critical relcache entries, but we might as\n\t\t\t * well just always do it.\n\t\t\t */\n\t\t\treturn false;\n\n\t\tcase AUTHNAME:\n\t\tcase AUTHOID:\n\t\tcase AUTHMEMMEMROLE:\n\n\t\t\t/*\n\t\t\t * Protect authentication lookups occurring before relcache has\n\t\t\t * collected entries for shared indexes.\n\t\t\t */\n\t\t\tif (!criticalSharedRelcachesBuilt)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\t/* Normal case, allow index scan */\n\treturn true;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nstatic bool\nIndexScanOK(CatCache *cache, ScanKey cur_skey)\n{\n\tswitch (cache->id)\n\t{\n\t\tcase INDEXRELID:\n\n\t\t\t/*\n\t\t\t * Rather than tracking exactly which indexes have to be loaded\n\t\t\t * before we can use indexscans (which changes from time to time),\n\t\t\t * just force all pg_index searches to be heap scans until we've\n\t\t\t * built the critical relcaches.\n\t\t\t */\n\t\t\tif (!criticalRelcachesBuilt)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\n\t\tcase AMOID:\n\t\tcase AMNAME:\n\n\t\t\t/*\n\t\t\t * Always do heap scans in pg_am, because it's so small there's\n\t\t\t * not much point in an indexscan anyway.  We *must* do this when\n\t\t\t * initially building critical relcache entries, but we might as\n\t\t\t * well just always do it.\n\t\t\t */\n\t\t\treturn false;\n\n\t\tcase AUTHNAME:\n\t\tcase AUTHOID:\n\t\tcase AUTHMEMMEMROLE:\n\n\t\t\t/*\n\t\t\t * Protect authentication lookups occurring before relcache has\n\t\t\t * collected entries for shared indexes.\n\t\t\t */\n\t\t\tif (!criticalSharedRelcachesBuilt)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\t/* Normal case, allow index scan */\n\treturn true;\n}"
  },
  {
    "function_name": "InitCatCachePhase2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "1049-1082",
    "snippet": "void\nInitCatCachePhase2(CatCache *cache, bool touch_index)\n{\n\tif (cache->cc_tupdesc == NULL)\n\t\tCatalogCacheInitializeCache(cache);\n\n\tif (touch_index &&\n\t\tcache->id != AMOID &&\n\t\tcache->id != AMNAME)\n\t{\n\t\tRelation\tidesc;\n\n\t\t/*\n\t\t * We must lock the underlying catalog before opening the index to\n\t\t * avoid deadlock, since index_open could possibly result in reading\n\t\t * this same catalog, and if anyone else is exclusive-locking this\n\t\t * catalog and index they'll be doing it in that order.\n\t\t */\n\t\tLockRelationOid(cache->cc_reloid, AccessShareLock);\n\t\tidesc = index_open(cache->cc_indexoid, AccessShareLock);\n\n\t\t/*\n\t\t * While we've got the index open, let's check that it's unique (and\n\t\t * not just deferrable-unique, thank you very much).  This is just to\n\t\t * catch thinkos in definitions of new catcaches, so we don't worry\n\t\t * about the pg_am indexes not getting tested.\n\t\t */\n\t\tAssert(idesc->rd_index->indisunique &&\n\t\t\t   idesc->rd_index->indimmediate);\n\n\t\tindex_close(idesc, AccessShareLock);\n\t\tUnlockRelationOid(cache->cc_reloid, AccessShareLock);\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UnlockRelationOid",
          "args": [
            "cache->cc_reloid",
            "AccessShareLock"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_close",
          "args": [
            "idesc",
            "AccessShareLock"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "idesc->rd_index->indisunique &&\n\t\t\t   idesc->rd_index->indimmediate"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_open",
          "args": [
            "cache->cc_indexoid",
            "AccessShareLock"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockRelationOid",
          "args": [
            "cache->cc_reloid",
            "AccessShareLock"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatalogCacheInitializeCache",
          "args": [
            "cache"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "CatalogCacheInitializeCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "938-1038",
          "snippet": "static void\nCatalogCacheInitializeCache(CatCache *cache)\n{\n\tRelation\trelation;\n\tMemoryContext oldcxt;\n\tTupleDesc\ttupdesc;\n\tint\t\t\ti;\n\n\tCatalogCacheInitializeCache_DEBUG1;\n\n\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\t/*\n\t * switch to the cache context so our allocations do not vanish at the end\n\t * of a transaction\n\t */\n\tAssert(CacheMemoryContext != NULL);\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * copy the relcache's tuple descriptor to permanent cache storage\n\t */\n\ttupdesc = CreateTupleDescCopyConstr(RelationGetDescr(relation));\n\n\t/*\n\t * save the relation's name and relisshared flag, too (cc_relname is used\n\t * only for debugging purposes)\n\t */\n\tcache->cc_relname = pstrdup(RelationGetRelationName(relation));\n\tcache->cc_relisshared = RelationGetForm(relation)->relisshared;\n\n\t/*\n\t * return to the caller's memory context and close the rel\n\t */\n\tMemoryContextSwitchTo(oldcxt);\n\n\theap_close(relation, AccessShareLock);\n\n\tCACHE3_elog(DEBUG2, \"CatalogCacheInitializeCache: %s, %d keys\",\n\t\t\t\tcache->cc_relname, cache->cc_nkeys);\n\n\t/*\n\t * initialize cache's key information\n\t */\n\tfor (i = 0; i < cache->cc_nkeys; ++i)\n\t{\n\t\tOid\t\t\tkeytype;\n\t\tRegProcedure eqfunc;\n\n\t\tCatalogCacheInitializeCache_DEBUG2;\n\n\t\tif (cache->cc_keyno[i] > 0)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   cache->cc_keyno[i] - 1);\n\n\t\t\tkeytype = attr->atttypid;\n\t\t\t/* cache key columns should always be NOT NULL */\n\t\t\tAssert(attr->attnotnull);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (cache->cc_keyno[i] != ObjectIdAttributeNumber)\n\t\t\t\telog(FATAL, \"only sys attr supported in caches is OID\");\n\t\t\tkeytype = OIDOID;\n\t\t}\n\n\t\tGetCCHashEqFuncs(keytype,\n\t\t\t\t\t\t &cache->cc_hashfunc[i],\n\t\t\t\t\t\t &eqfunc,\n\t\t\t\t\t\t &cache->cc_fastequal[i]);\n\n\t\t/*\n\t\t * Do equality-function lookup (we assume this won't need a catalog\n\t\t * lookup for any supported type)\n\t\t */\n\t\tfmgr_info_cxt(eqfunc,\n\t\t\t\t\t  &cache->cc_skey[i].sk_func,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t\t/* Initialize sk_attno suitably for HeapKeyTest() and heap scans */\n\t\tcache->cc_skey[i].sk_attno = cache->cc_keyno[i];\n\n\t\t/* Fill in sk_strategy as well --- always standard equality */\n\t\tcache->cc_skey[i].sk_strategy = BTEqualStrategyNumber;\n\t\tcache->cc_skey[i].sk_subtype = InvalidOid;\n\t\t/* Currently, there are no catcaches on collation-aware data types */\n\t\tcache->cc_skey[i].sk_collation = InvalidOid;\n\n\t\tCACHE4_elog(DEBUG2, \"CatalogCacheInitializeCache %s %d %p\",\n\t\t\t\t\tcache->cc_relname,\n\t\t\t\t\ti,\n\t\t\t\t\tcache);\n\t}\n\n\t/*\n\t * mark this cache fully initialized\n\t */\n\tcache->cc_tupdesc = tupdesc;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define CatalogCacheInitializeCache_DEBUG2",
            "#define CatalogCacheInitializeCache_DEBUG1",
            "#define CatalogCacheInitializeCache_DEBUG2 \\\ndo { \\\n\t\tif (cache->cc_keyno[i] > 0) { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d, %u\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i], \\\n\t\t\t\t TupleDescAttr(tupdesc, cache->cc_keyno[i] - 1)->atttypid); \\\n\t\t} else { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i]); \\\n\t\t} \\\n} while(0)",
            "#define CatalogCacheInitializeCache_DEBUG1 \\\n\telog(DEBUG2, \"CatalogCacheInitializeCache: cache @%p rel=%u\", cache, \\\n\t\t cache->cc_reloid)"
          ],
          "globals_used": [
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\n#define CatalogCacheInitializeCache_DEBUG2\n#define CatalogCacheInitializeCache_DEBUG1\n#define CatalogCacheInitializeCache_DEBUG2 \\\ndo { \\\n\t\tif (cache->cc_keyno[i] > 0) { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d, %u\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i], \\\n\t\t\t\t TupleDescAttr(tupdesc, cache->cc_keyno[i] - 1)->atttypid); \\\n\t\t} else { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i]); \\\n\t\t} \\\n} while(0)\n#define CatalogCacheInitializeCache_DEBUG1 \\\n\telog(DEBUG2, \"CatalogCacheInitializeCache: cache @%p rel=%u\", cache, \\\n\t\t cache->cc_reloid)\n\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatalogCacheInitializeCache(CatCache *cache)\n{\n\tRelation\trelation;\n\tMemoryContext oldcxt;\n\tTupleDesc\ttupdesc;\n\tint\t\t\ti;\n\n\tCatalogCacheInitializeCache_DEBUG1;\n\n\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\t/*\n\t * switch to the cache context so our allocations do not vanish at the end\n\t * of a transaction\n\t */\n\tAssert(CacheMemoryContext != NULL);\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * copy the relcache's tuple descriptor to permanent cache storage\n\t */\n\ttupdesc = CreateTupleDescCopyConstr(RelationGetDescr(relation));\n\n\t/*\n\t * save the relation's name and relisshared flag, too (cc_relname is used\n\t * only for debugging purposes)\n\t */\n\tcache->cc_relname = pstrdup(RelationGetRelationName(relation));\n\tcache->cc_relisshared = RelationGetForm(relation)->relisshared;\n\n\t/*\n\t * return to the caller's memory context and close the rel\n\t */\n\tMemoryContextSwitchTo(oldcxt);\n\n\theap_close(relation, AccessShareLock);\n\n\tCACHE3_elog(DEBUG2, \"CatalogCacheInitializeCache: %s, %d keys\",\n\t\t\t\tcache->cc_relname, cache->cc_nkeys);\n\n\t/*\n\t * initialize cache's key information\n\t */\n\tfor (i = 0; i < cache->cc_nkeys; ++i)\n\t{\n\t\tOid\t\t\tkeytype;\n\t\tRegProcedure eqfunc;\n\n\t\tCatalogCacheInitializeCache_DEBUG2;\n\n\t\tif (cache->cc_keyno[i] > 0)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   cache->cc_keyno[i] - 1);\n\n\t\t\tkeytype = attr->atttypid;\n\t\t\t/* cache key columns should always be NOT NULL */\n\t\t\tAssert(attr->attnotnull);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (cache->cc_keyno[i] != ObjectIdAttributeNumber)\n\t\t\t\telog(FATAL, \"only sys attr supported in caches is OID\");\n\t\t\tkeytype = OIDOID;\n\t\t}\n\n\t\tGetCCHashEqFuncs(keytype,\n\t\t\t\t\t\t &cache->cc_hashfunc[i],\n\t\t\t\t\t\t &eqfunc,\n\t\t\t\t\t\t &cache->cc_fastequal[i]);\n\n\t\t/*\n\t\t * Do equality-function lookup (we assume this won't need a catalog\n\t\t * lookup for any supported type)\n\t\t */\n\t\tfmgr_info_cxt(eqfunc,\n\t\t\t\t\t  &cache->cc_skey[i].sk_func,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t\t/* Initialize sk_attno suitably for HeapKeyTest() and heap scans */\n\t\tcache->cc_skey[i].sk_attno = cache->cc_keyno[i];\n\n\t\t/* Fill in sk_strategy as well --- always standard equality */\n\t\tcache->cc_skey[i].sk_strategy = BTEqualStrategyNumber;\n\t\tcache->cc_skey[i].sk_subtype = InvalidOid;\n\t\t/* Currently, there are no catcaches on collation-aware data types */\n\t\tcache->cc_skey[i].sk_collation = InvalidOid;\n\n\t\tCACHE4_elog(DEBUG2, \"CatalogCacheInitializeCache %s %d %p\",\n\t\t\t\t\tcache->cc_relname,\n\t\t\t\t\ti,\n\t\t\t\t\tcache);\n\t}\n\n\t/*\n\t * mark this cache fully initialized\n\t */\n\tcache->cc_tupdesc = tupdesc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nInitCatCachePhase2(CatCache *cache, bool touch_index)\n{\n\tif (cache->cc_tupdesc == NULL)\n\t\tCatalogCacheInitializeCache(cache);\n\n\tif (touch_index &&\n\t\tcache->id != AMOID &&\n\t\tcache->id != AMNAME)\n\t{\n\t\tRelation\tidesc;\n\n\t\t/*\n\t\t * We must lock the underlying catalog before opening the index to\n\t\t * avoid deadlock, since index_open could possibly result in reading\n\t\t * this same catalog, and if anyone else is exclusive-locking this\n\t\t * catalog and index they'll be doing it in that order.\n\t\t */\n\t\tLockRelationOid(cache->cc_reloid, AccessShareLock);\n\t\tidesc = index_open(cache->cc_indexoid, AccessShareLock);\n\n\t\t/*\n\t\t * While we've got the index open, let's check that it's unique (and\n\t\t * not just deferrable-unique, thank you very much).  This is just to\n\t\t * catch thinkos in definitions of new catcaches, so we don't worry\n\t\t * about the pg_am indexes not getting tested.\n\t\t */\n\t\tAssert(idesc->rd_index->indisunique &&\n\t\t\t   idesc->rd_index->indimmediate);\n\n\t\tindex_close(idesc, AccessShareLock);\n\t\tUnlockRelationOid(cache->cc_reloid, AccessShareLock);\n\t}\n}"
  },
  {
    "function_name": "CatalogCacheInitializeCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "938-1038",
    "snippet": "static void\nCatalogCacheInitializeCache(CatCache *cache)\n{\n\tRelation\trelation;\n\tMemoryContext oldcxt;\n\tTupleDesc\ttupdesc;\n\tint\t\t\ti;\n\n\tCatalogCacheInitializeCache_DEBUG1;\n\n\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\t/*\n\t * switch to the cache context so our allocations do not vanish at the end\n\t * of a transaction\n\t */\n\tAssert(CacheMemoryContext != NULL);\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * copy the relcache's tuple descriptor to permanent cache storage\n\t */\n\ttupdesc = CreateTupleDescCopyConstr(RelationGetDescr(relation));\n\n\t/*\n\t * save the relation's name and relisshared flag, too (cc_relname is used\n\t * only for debugging purposes)\n\t */\n\tcache->cc_relname = pstrdup(RelationGetRelationName(relation));\n\tcache->cc_relisshared = RelationGetForm(relation)->relisshared;\n\n\t/*\n\t * return to the caller's memory context and close the rel\n\t */\n\tMemoryContextSwitchTo(oldcxt);\n\n\theap_close(relation, AccessShareLock);\n\n\tCACHE3_elog(DEBUG2, \"CatalogCacheInitializeCache: %s, %d keys\",\n\t\t\t\tcache->cc_relname, cache->cc_nkeys);\n\n\t/*\n\t * initialize cache's key information\n\t */\n\tfor (i = 0; i < cache->cc_nkeys; ++i)\n\t{\n\t\tOid\t\t\tkeytype;\n\t\tRegProcedure eqfunc;\n\n\t\tCatalogCacheInitializeCache_DEBUG2;\n\n\t\tif (cache->cc_keyno[i] > 0)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   cache->cc_keyno[i] - 1);\n\n\t\t\tkeytype = attr->atttypid;\n\t\t\t/* cache key columns should always be NOT NULL */\n\t\t\tAssert(attr->attnotnull);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (cache->cc_keyno[i] != ObjectIdAttributeNumber)\n\t\t\t\telog(FATAL, \"only sys attr supported in caches is OID\");\n\t\t\tkeytype = OIDOID;\n\t\t}\n\n\t\tGetCCHashEqFuncs(keytype,\n\t\t\t\t\t\t &cache->cc_hashfunc[i],\n\t\t\t\t\t\t &eqfunc,\n\t\t\t\t\t\t &cache->cc_fastequal[i]);\n\n\t\t/*\n\t\t * Do equality-function lookup (we assume this won't need a catalog\n\t\t * lookup for any supported type)\n\t\t */\n\t\tfmgr_info_cxt(eqfunc,\n\t\t\t\t\t  &cache->cc_skey[i].sk_func,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t\t/* Initialize sk_attno suitably for HeapKeyTest() and heap scans */\n\t\tcache->cc_skey[i].sk_attno = cache->cc_keyno[i];\n\n\t\t/* Fill in sk_strategy as well --- always standard equality */\n\t\tcache->cc_skey[i].sk_strategy = BTEqualStrategyNumber;\n\t\tcache->cc_skey[i].sk_subtype = InvalidOid;\n\t\t/* Currently, there are no catcaches on collation-aware data types */\n\t\tcache->cc_skey[i].sk_collation = InvalidOid;\n\n\t\tCACHE4_elog(DEBUG2, \"CatalogCacheInitializeCache %s %d %p\",\n\t\t\t\t\tcache->cc_relname,\n\t\t\t\t\ti,\n\t\t\t\t\tcache);\n\t}\n\n\t/*\n\t * mark this cache fully initialized\n\t */\n\tcache->cc_tupdesc = tupdesc;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define CatalogCacheInitializeCache_DEBUG2",
      "#define CatalogCacheInitializeCache_DEBUG1",
      "#define CatalogCacheInitializeCache_DEBUG2 \\\ndo { \\\n\t\tif (cache->cc_keyno[i] > 0) { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d, %u\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i], \\\n\t\t\t\t TupleDescAttr(tupdesc, cache->cc_keyno[i] - 1)->atttypid); \\\n\t\t} else { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i]); \\\n\t\t} \\\n} while(0)",
      "#define CatalogCacheInitializeCache_DEBUG1 \\\n\telog(DEBUG2, \"CatalogCacheInitializeCache: cache @%p rel=%u\", cache, \\\n\t\t cache->cc_reloid)"
    ],
    "globals_used": [
      "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
      "static void CatalogCacheInitializeCache(CatCache *cache);",
      "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CACHE4_elog",
          "args": [
            "DEBUG2",
            "\"CatalogCacheInitializeCache %s %d %p\"",
            "cache->cc_relname",
            "i",
            "cache"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "eqfunc",
            "&cache->cc_skey[i].sk_func",
            "CacheMemoryContext"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCCHashEqFuncs",
          "args": [
            "keytype",
            "&cache->cc_hashfunc[i]",
            "&eqfunc",
            "&cache->cc_fastequal[i]"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "GetCCHashEqFuncs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "206-268",
          "snippet": "static void\nGetCCHashEqFuncs(Oid keytype, CCHashFN *hashfunc, RegProcedure *eqfunc, CCFastEqualFN *fasteqfunc)\n{\n\tswitch (keytype)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*hashfunc = charhashfast;\n\t\t\t*fasteqfunc = chareqfast;\n\t\t\t*eqfunc = F_BOOLEQ;\n\t\t\tbreak;\n\t\tcase CHAROID:\n\t\t\t*hashfunc = charhashfast;\n\t\t\t*fasteqfunc = chareqfast;\n\t\t\t*eqfunc = F_CHAREQ;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\t*hashfunc = namehashfast;\n\t\t\t*fasteqfunc = nameeqfast;\n\t\t\t*eqfunc = F_NAMEEQ;\n\t\t\tbreak;\n\t\tcase INT2OID:\n\t\t\t*hashfunc = int2hashfast;\n\t\t\t*fasteqfunc = int2eqfast;\n\t\t\t*eqfunc = F_INT2EQ;\n\t\t\tbreak;\n\t\tcase INT4OID:\n\t\t\t*hashfunc = int4hashfast;\n\t\t\t*fasteqfunc = int4eqfast;\n\t\t\t*eqfunc = F_INT4EQ;\n\t\t\tbreak;\n\t\tcase TEXTOID:\n\t\t\t*hashfunc = texthashfast;\n\t\t\t*fasteqfunc = texteqfast;\n\t\t\t*eqfunc = F_TEXTEQ;\n\t\t\tbreak;\n\t\tcase OIDOID:\n\t\tcase REGPROCOID:\n\t\tcase REGPROCEDUREOID:\n\t\tcase REGOPEROID:\n\t\tcase REGOPERATOROID:\n\t\tcase REGCLASSOID:\n\t\tcase REGTYPEOID:\n\t\tcase REGCONFIGOID:\n\t\tcase REGDICTIONARYOID:\n\t\tcase REGROLEOID:\n\t\tcase REGNAMESPACEOID:\n\t\t\t*hashfunc = int4hashfast;\n\t\t\t*fasteqfunc = int4eqfast;\n\t\t\t*eqfunc = F_OIDEQ;\n\t\t\tbreak;\n\t\tcase OIDVECTOROID:\n\t\t\t*hashfunc = oidvectorhashfast;\n\t\t\t*fasteqfunc = oidvectoreqfast;\n\t\t\t*eqfunc = F_OIDVECTOREQ;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"type %u not supported as catcache key\", keytype);\n\t\t\t*hashfunc = NULL;\t/* keep compiler quiet */\n\n\t\t\t*eqfunc = InvalidOid;\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void\nGetCCHashEqFuncs(Oid keytype, CCHashFN *hashfunc, RegProcedure *eqfunc, CCFastEqualFN *fasteqfunc)\n{\n\tswitch (keytype)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*hashfunc = charhashfast;\n\t\t\t*fasteqfunc = chareqfast;\n\t\t\t*eqfunc = F_BOOLEQ;\n\t\t\tbreak;\n\t\tcase CHAROID:\n\t\t\t*hashfunc = charhashfast;\n\t\t\t*fasteqfunc = chareqfast;\n\t\t\t*eqfunc = F_CHAREQ;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\t*hashfunc = namehashfast;\n\t\t\t*fasteqfunc = nameeqfast;\n\t\t\t*eqfunc = F_NAMEEQ;\n\t\t\tbreak;\n\t\tcase INT2OID:\n\t\t\t*hashfunc = int2hashfast;\n\t\t\t*fasteqfunc = int2eqfast;\n\t\t\t*eqfunc = F_INT2EQ;\n\t\t\tbreak;\n\t\tcase INT4OID:\n\t\t\t*hashfunc = int4hashfast;\n\t\t\t*fasteqfunc = int4eqfast;\n\t\t\t*eqfunc = F_INT4EQ;\n\t\t\tbreak;\n\t\tcase TEXTOID:\n\t\t\t*hashfunc = texthashfast;\n\t\t\t*fasteqfunc = texteqfast;\n\t\t\t*eqfunc = F_TEXTEQ;\n\t\t\tbreak;\n\t\tcase OIDOID:\n\t\tcase REGPROCOID:\n\t\tcase REGPROCEDUREOID:\n\t\tcase REGOPEROID:\n\t\tcase REGOPERATOROID:\n\t\tcase REGCLASSOID:\n\t\tcase REGTYPEOID:\n\t\tcase REGCONFIGOID:\n\t\tcase REGDICTIONARYOID:\n\t\tcase REGROLEOID:\n\t\tcase REGNAMESPACEOID:\n\t\t\t*hashfunc = int4hashfast;\n\t\t\t*fasteqfunc = int4eqfast;\n\t\t\t*eqfunc = F_OIDEQ;\n\t\t\tbreak;\n\t\tcase OIDVECTOROID:\n\t\t\t*hashfunc = oidvectorhashfast;\n\t\t\t*fasteqfunc = oidvectoreqfast;\n\t\t\t*eqfunc = F_OIDVECTOREQ;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"type %u not supported as catcache key\", keytype);\n\t\t\t*hashfunc = NULL;\t/* keep compiler quiet */\n\n\t\t\t*eqfunc = InvalidOid;\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"only sys attr supported in caches is OID\""
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "attr->attnotnull"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "cache->cc_keyno[i] - 1"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CACHE3_elog",
          "args": [
            "DEBUG2",
            "\"CatalogCacheInitializeCache: %s, %d keys\"",
            "cache->cc_relname",
            "cache->cc_nkeys"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "relation",
            "AccessShareLock"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetForm",
          "args": [
            "relation"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "RelationGetRelationName(relation)"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "relation"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopyConstr",
          "args": [
            "RelationGetDescr(relation)"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "relation"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "CacheMemoryContext != NULL"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "cache->cc_reloid",
            "AccessShareLock"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\n#define CatalogCacheInitializeCache_DEBUG2\n#define CatalogCacheInitializeCache_DEBUG1\n#define CatalogCacheInitializeCache_DEBUG2 \\\ndo { \\\n\t\tif (cache->cc_keyno[i] > 0) { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d, %u\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i], \\\n\t\t\t\t TupleDescAttr(tupdesc, cache->cc_keyno[i] - 1)->atttypid); \\\n\t\t} else { \\\n\t\t\telog(DEBUG2, \"CatalogCacheInitializeCache: load %d/%d w/%d\", \\\n\t\t\t\ti+1, cache->cc_nkeys, cache->cc_keyno[i]); \\\n\t\t} \\\n} while(0)\n#define CatalogCacheInitializeCache_DEBUG1 \\\n\telog(DEBUG2, \"CatalogCacheInitializeCache: cache @%p rel=%u\", cache, \\\n\t\t cache->cc_reloid)\n\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatalogCacheInitializeCache(CatCache *cache)\n{\n\tRelation\trelation;\n\tMemoryContext oldcxt;\n\tTupleDesc\ttupdesc;\n\tint\t\t\ti;\n\n\tCatalogCacheInitializeCache_DEBUG1;\n\n\trelation = heap_open(cache->cc_reloid, AccessShareLock);\n\n\t/*\n\t * switch to the cache context so our allocations do not vanish at the end\n\t * of a transaction\n\t */\n\tAssert(CacheMemoryContext != NULL);\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * copy the relcache's tuple descriptor to permanent cache storage\n\t */\n\ttupdesc = CreateTupleDescCopyConstr(RelationGetDescr(relation));\n\n\t/*\n\t * save the relation's name and relisshared flag, too (cc_relname is used\n\t * only for debugging purposes)\n\t */\n\tcache->cc_relname = pstrdup(RelationGetRelationName(relation));\n\tcache->cc_relisshared = RelationGetForm(relation)->relisshared;\n\n\t/*\n\t * return to the caller's memory context and close the rel\n\t */\n\tMemoryContextSwitchTo(oldcxt);\n\n\theap_close(relation, AccessShareLock);\n\n\tCACHE3_elog(DEBUG2, \"CatalogCacheInitializeCache: %s, %d keys\",\n\t\t\t\tcache->cc_relname, cache->cc_nkeys);\n\n\t/*\n\t * initialize cache's key information\n\t */\n\tfor (i = 0; i < cache->cc_nkeys; ++i)\n\t{\n\t\tOid\t\t\tkeytype;\n\t\tRegProcedure eqfunc;\n\n\t\tCatalogCacheInitializeCache_DEBUG2;\n\n\t\tif (cache->cc_keyno[i] > 0)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   cache->cc_keyno[i] - 1);\n\n\t\t\tkeytype = attr->atttypid;\n\t\t\t/* cache key columns should always be NOT NULL */\n\t\t\tAssert(attr->attnotnull);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (cache->cc_keyno[i] != ObjectIdAttributeNumber)\n\t\t\t\telog(FATAL, \"only sys attr supported in caches is OID\");\n\t\t\tkeytype = OIDOID;\n\t\t}\n\n\t\tGetCCHashEqFuncs(keytype,\n\t\t\t\t\t\t &cache->cc_hashfunc[i],\n\t\t\t\t\t\t &eqfunc,\n\t\t\t\t\t\t &cache->cc_fastequal[i]);\n\n\t\t/*\n\t\t * Do equality-function lookup (we assume this won't need a catalog\n\t\t * lookup for any supported type)\n\t\t */\n\t\tfmgr_info_cxt(eqfunc,\n\t\t\t\t\t  &cache->cc_skey[i].sk_func,\n\t\t\t\t\t  CacheMemoryContext);\n\n\t\t/* Initialize sk_attno suitably for HeapKeyTest() and heap scans */\n\t\tcache->cc_skey[i].sk_attno = cache->cc_keyno[i];\n\n\t\t/* Fill in sk_strategy as well --- always standard equality */\n\t\tcache->cc_skey[i].sk_strategy = BTEqualStrategyNumber;\n\t\tcache->cc_skey[i].sk_subtype = InvalidOid;\n\t\t/* Currently, there are no catcaches on collation-aware data types */\n\t\tcache->cc_skey[i].sk_collation = InvalidOid;\n\n\t\tCACHE4_elog(DEBUG2, \"CatalogCacheInitializeCache %s %d %p\",\n\t\t\t\t\tcache->cc_relname,\n\t\t\t\t\ti,\n\t\t\t\t\tcache);\n\t}\n\n\t/*\n\t * mark this cache fully initialized\n\t */\n\tcache->cc_tupdesc = tupdesc;\n}"
  },
  {
    "function_name": "RehashCatCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "875-908",
    "snippet": "static void\nRehashCatCache(CatCache *cp)\n{\n\tdlist_head *newbucket;\n\tint\t\t\tnewnbuckets;\n\tint\t\t\ti;\n\n\telog(DEBUG1, \"rehashing catalog cache id %d for %s; %d tups, %d buckets\",\n\t\t cp->id, cp->cc_relname, cp->cc_ntup, cp->cc_nbuckets);\n\n\t/* Allocate a new, larger, hash table. */\n\tnewnbuckets = cp->cc_nbuckets * 2;\n\tnewbucket = (dlist_head *) MemoryContextAllocZero(CacheMemoryContext, newnbuckets * sizeof(dlist_head));\n\n\t/* Move all entries from old hash table to new. */\n\tfor (i = 0; i < cp->cc_nbuckets; i++)\n\t{\n\t\tdlist_mutable_iter iter;\n\n\t\tdlist_foreach_modify(iter, &cp->cc_bucket[i])\n\t\t{\n\t\t\tCatCTup    *ct = dlist_container(CatCTup, cache_elem, iter.cur);\n\t\t\tint\t\t\thashIndex = HASH_INDEX(ct->hash_value, newnbuckets);\n\n\t\t\tdlist_delete(iter.cur);\n\t\t\tdlist_push_head(&newbucket[hashIndex], &ct->cache_elem);\n\t\t}\n\t}\n\n\t/* Switch to the new array. */\n\tpfree(cp->cc_bucket);\n\tcp->cc_nbuckets = newnbuckets;\n\tcp->cc_bucket = newbucket;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "cp->cc_bucket"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlist_push_head",
          "args": [
            "&newbucket[hashIndex]",
            "&ct->cache_elem"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_delete",
          "args": [
            "iter.cur"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HASH_INDEX",
          "args": [
            "ct->hash_value",
            "newnbuckets"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_container",
          "args": [
            "CatCTup",
            "cache_elem",
            "iter.cur"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_foreach_modify",
          "args": [
            "iter",
            "&cp->cc_bucket[i]"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "CacheMemoryContext",
            "newnbuckets * sizeof(dlist_head)"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "DEBUG1",
            "\"rehashing catalog cache id %d for %s; %d tups, %d buckets\"",
            "cp->id",
            "cp->cc_relname",
            "cp->cc_ntup",
            "cp->cc_nbuckets"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nstatic void\nRehashCatCache(CatCache *cp)\n{\n\tdlist_head *newbucket;\n\tint\t\t\tnewnbuckets;\n\tint\t\t\ti;\n\n\telog(DEBUG1, \"rehashing catalog cache id %d for %s; %d tups, %d buckets\",\n\t\t cp->id, cp->cc_relname, cp->cc_ntup, cp->cc_nbuckets);\n\n\t/* Allocate a new, larger, hash table. */\n\tnewnbuckets = cp->cc_nbuckets * 2;\n\tnewbucket = (dlist_head *) MemoryContextAllocZero(CacheMemoryContext, newnbuckets * sizeof(dlist_head));\n\n\t/* Move all entries from old hash table to new. */\n\tfor (i = 0; i < cp->cc_nbuckets; i++)\n\t{\n\t\tdlist_mutable_iter iter;\n\n\t\tdlist_foreach_modify(iter, &cp->cc_bucket[i])\n\t\t{\n\t\t\tCatCTup    *ct = dlist_container(CatCTup, cache_elem, iter.cur);\n\t\t\tint\t\t\thashIndex = HASH_INDEX(ct->hash_value, newnbuckets);\n\n\t\t\tdlist_delete(iter.cur);\n\t\t\tdlist_push_head(&newbucket[hashIndex], &ct->cache_elem);\n\t\t}\n\t}\n\n\t/* Switch to the new array. */\n\tpfree(cp->cc_bucket);\n\tcp->cc_nbuckets = newnbuckets;\n\tcp->cc_bucket = newbucket;\n}"
  },
  {
    "function_name": "InitCatCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "778-870",
    "snippet": "CatCache *\nInitCatCache(int id,\n\t\t\t Oid reloid,\n\t\t\t Oid indexoid,\n\t\t\t int nkeys,\n\t\t\t const int *key,\n\t\t\t int nbuckets)\n{\n\tCatCache   *cp;\n\tMemoryContext oldcxt;\n\tsize_t\t\tsz;\n\tint\t\t\ti;\n\n\t/*\n\t * nbuckets is the initial number of hash buckets to use in this catcache.\n\t * It will be enlarged later if it becomes too full.\n\t *\n\t * nbuckets must be a power of two.  We check this via Assert rather than\n\t * a full runtime check because the values will be coming from constant\n\t * tables.\n\t *\n\t * If you're confused by the power-of-two check, see comments in\n\t * bitmapset.c for an explanation.\n\t */\n\tAssert(nbuckets > 0 && (nbuckets & -nbuckets) == nbuckets);\n\n\t/*\n\t * first switch to the cache context so our allocations do not vanish at\n\t * the end of a transaction\n\t */\n\tif (!CacheMemoryContext)\n\t\tCreateCacheMemoryContext();\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * if first time through, initialize the cache group header\n\t */\n\tif (CacheHdr == NULL)\n\t{\n\t\tCacheHdr = (CatCacheHeader *) palloc(sizeof(CatCacheHeader));\n\t\tslist_init(&CacheHdr->ch_caches);\n\t\tCacheHdr->ch_ntup = 0;\n#ifdef CATCACHE_STATS\n\t\t/* set up to dump stats at backend exit */\n\t\ton_proc_exit(CatCachePrintStats, 0);\n#endif\n\t}\n\n\t/*\n\t * Allocate a new cache structure, aligning to a cacheline boundary\n\t *\n\t * Note: we rely on zeroing to initialize all the dlist headers correctly\n\t */\n\tsz = sizeof(CatCache) + PG_CACHE_LINE_SIZE;\n\tcp = (CatCache *) CACHELINEALIGN(palloc0(sz));\n\tcp->cc_bucket = palloc0(nbuckets * sizeof(dlist_head));\n\n\t/*\n\t * initialize the cache's relation information for the relation\n\t * corresponding to this cache, and initialize some of the new cache's\n\t * other internal fields.  But don't open the relation yet.\n\t */\n\tcp->id = id;\n\tcp->cc_relname = \"(not known yet)\";\n\tcp->cc_reloid = reloid;\n\tcp->cc_indexoid = indexoid;\n\tcp->cc_relisshared = false; /* temporary */\n\tcp->cc_tupdesc = (TupleDesc) NULL;\n\tcp->cc_ntup = 0;\n\tcp->cc_nbuckets = nbuckets;\n\tcp->cc_nkeys = nkeys;\n\tfor (i = 0; i < nkeys; ++i)\n\t\tcp->cc_keyno[i] = key[i];\n\n\t/*\n\t * new cache is initialized as far as we can go for now. print some\n\t * debugging information, if appropriate.\n\t */\n\tInitCatCache_DEBUG2;\n\n\t/*\n\t * add completed cache to top of group header's list\n\t */\n\tslist_push_head(&CacheHdr->ch_caches, &cp->cc_next);\n\n\t/*\n\t * back to the old context before we return...\n\t */\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn cp;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define InitCatCache_DEBUG2",
      "#define InitCatCache_DEBUG2 \\\ndo { \\\n\telog(DEBUG2, \"InitCatCache: rel=%u ind=%u id=%d nkeys=%d size=%d\", \\\n\t\t cp->cc_reloid, cp->cc_indexoid, cp->id, \\\n\t\t cp->cc_nkeys, cp->cc_nbuckets); \\\n} while(0)"
    ],
    "globals_used": [
      "static CatCacheHeader *CacheHdr = NULL;",
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slist_push_head",
          "args": [
            "&CacheHdr->ch_caches",
            "&cp->cc_next"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "nbuckets * sizeof(dlist_head)"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CACHELINEALIGN",
          "args": [
            "palloc0(sz)"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_proc_exit",
          "args": [
            "CatCachePrintStats",
            "0"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slist_init",
          "args": [
            "&CacheHdr->ch_caches"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateCacheMemoryContext",
          "args": [],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "CreateCacheMemoryContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "635-646",
          "snippet": "void\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nvoid\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nbuckets > 0 && (nbuckets & -nbuckets) == nbuckets"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\n#define InitCatCache_DEBUG2\n#define InitCatCache_DEBUG2 \\\ndo { \\\n\telog(DEBUG2, \"InitCatCache: rel=%u ind=%u id=%d nkeys=%d size=%d\", \\\n\t\t cp->cc_reloid, cp->cc_indexoid, cp->id, \\\n\t\t cp->cc_nkeys, cp->cc_nbuckets); \\\n} while(0)\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nCatCache *\nInitCatCache(int id,\n\t\t\t Oid reloid,\n\t\t\t Oid indexoid,\n\t\t\t int nkeys,\n\t\t\t const int *key,\n\t\t\t int nbuckets)\n{\n\tCatCache   *cp;\n\tMemoryContext oldcxt;\n\tsize_t\t\tsz;\n\tint\t\t\ti;\n\n\t/*\n\t * nbuckets is the initial number of hash buckets to use in this catcache.\n\t * It will be enlarged later if it becomes too full.\n\t *\n\t * nbuckets must be a power of two.  We check this via Assert rather than\n\t * a full runtime check because the values will be coming from constant\n\t * tables.\n\t *\n\t * If you're confused by the power-of-two check, see comments in\n\t * bitmapset.c for an explanation.\n\t */\n\tAssert(nbuckets > 0 && (nbuckets & -nbuckets) == nbuckets);\n\n\t/*\n\t * first switch to the cache context so our allocations do not vanish at\n\t * the end of a transaction\n\t */\n\tif (!CacheMemoryContext)\n\t\tCreateCacheMemoryContext();\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * if first time through, initialize the cache group header\n\t */\n\tif (CacheHdr == NULL)\n\t{\n\t\tCacheHdr = (CatCacheHeader *) palloc(sizeof(CatCacheHeader));\n\t\tslist_init(&CacheHdr->ch_caches);\n\t\tCacheHdr->ch_ntup = 0;\n#ifdef CATCACHE_STATS\n\t\t/* set up to dump stats at backend exit */\n\t\ton_proc_exit(CatCachePrintStats, 0);\n#endif\n\t}\n\n\t/*\n\t * Allocate a new cache structure, aligning to a cacheline boundary\n\t *\n\t * Note: we rely on zeroing to initialize all the dlist headers correctly\n\t */\n\tsz = sizeof(CatCache) + PG_CACHE_LINE_SIZE;\n\tcp = (CatCache *) CACHELINEALIGN(palloc0(sz));\n\tcp->cc_bucket = palloc0(nbuckets * sizeof(dlist_head));\n\n\t/*\n\t * initialize the cache's relation information for the relation\n\t * corresponding to this cache, and initialize some of the new cache's\n\t * other internal fields.  But don't open the relation yet.\n\t */\n\tcp->id = id;\n\tcp->cc_relname = \"(not known yet)\";\n\tcp->cc_reloid = reloid;\n\tcp->cc_indexoid = indexoid;\n\tcp->cc_relisshared = false; /* temporary */\n\tcp->cc_tupdesc = (TupleDesc) NULL;\n\tcp->cc_ntup = 0;\n\tcp->cc_nbuckets = nbuckets;\n\tcp->cc_nkeys = nkeys;\n\tfor (i = 0; i < nkeys; ++i)\n\t\tcp->cc_keyno[i] = key[i];\n\n\t/*\n\t * new cache is initialized as far as we can go for now. print some\n\t * debugging information, if appropriate.\n\t */\n\tInitCatCache_DEBUG2;\n\n\t/*\n\t * add completed cache to top of group header's list\n\t */\n\tslist_push_head(&CacheHdr->ch_caches, &cp->cc_next);\n\n\t/*\n\t * back to the old context before we return...\n\t */\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn cp;\n}"
  },
  {
    "function_name": "CatalogCacheFlushCatalog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "734-757",
    "snippet": "void\nCatalogCacheFlushCatalog(Oid catId)\n{\n\tslist_iter\titer;\n\n\tCACHE2_elog(DEBUG2, \"CatalogCacheFlushCatalog called for %u\", catId);\n\n\tslist_foreach(iter, &CacheHdr->ch_caches)\n\t{\n\t\tCatCache   *cache = slist_container(CatCache, cc_next, iter.cur);\n\n\t\t/* Does this cache store tuples of the target catalog? */\n\t\tif (cache->cc_reloid == catId)\n\t\t{\n\t\t\t/* Yes, so flush all its contents */\n\t\t\tResetCatalogCache(cache);\n\n\t\t\t/* Tell inval.c to call syscache callbacks for this cache */\n\t\t\tCallSyscacheCallbacks(cache->id, 0);\n\t\t}\n\t}\n\n\tCACHE1_elog(DEBUG2, \"end of CatalogCacheFlushCatalog call\");\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CatCacheHeader *CacheHdr = NULL;",
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CACHE1_elog",
          "args": [
            "DEBUG2",
            "\"end of CatalogCacheFlushCatalog call\""
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CallSyscacheCallbacks",
          "args": [
            "cache->id",
            "0"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "CallSyscacheCallbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1486-1503",
          "snippet": "void\nCallSyscacheCallbacks(int cacheid, uint32 hashvalue)\n{\n\tint\t\t\ti;\n\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheid);\n\n\ti = syscache_callback_links[cacheid] - 1;\n\twhile (i >= 0)\n\t{\n\t\tstruct SYSCACHECALLBACK *ccitem = syscache_callback_list + i;\n\n\t\tAssert(ccitem->id == cacheid);\n\t\tccitem->function(ccitem->arg, cacheid, hashvalue);\n\t\ti = ccitem->link - 1;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];",
            "static int16 syscache_callback_links[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];\nstatic int16 syscache_callback_links[SysCacheSize];\n\nvoid\nCallSyscacheCallbacks(int cacheid, uint32 hashvalue)\n{\n\tint\t\t\ti;\n\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheid);\n\n\ti = syscache_callback_links[cacheid] - 1;\n\twhile (i >= 0)\n\t{\n\t\tstruct SYSCACHECALLBACK *ccitem = syscache_callback_list + i;\n\n\t\tAssert(ccitem->id == cacheid);\n\t\tccitem->function(ccitem->arg, cacheid, hashvalue);\n\t\ti = ccitem->link - 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResetCatalogCache",
          "args": [
            "cache"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "ResetCatalogCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "657-697",
          "snippet": "static void\nResetCatalogCache(CatCache *cache)\n{\n\tdlist_mutable_iter iter;\n\tint\t\t\ti;\n\n\t/* Remove each list in this cache, or at least mark it dead */\n\tdlist_foreach_modify(iter, &cache->cc_lists)\n\t{\n\t\tCatCList   *cl = dlist_container(CatCList, cache_elem, iter.cur);\n\n\t\tif (cl->refcount > 0)\n\t\t\tcl->dead = true;\n\t\telse\n\t\t\tCatCacheRemoveCList(cache, cl);\n\t}\n\n\t/* Remove each tuple in this cache, or at least mark it dead */\n\tfor (i = 0; i < cache->cc_nbuckets; i++)\n\t{\n\t\tdlist_head *bucket = &cache->cc_bucket[i];\n\n\t\tdlist_foreach_modify(iter, bucket)\n\t\t{\n\t\t\tCatCTup    *ct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\t\tif (ct->refcount > 0 ||\n\t\t\t\t(ct->c_list && ct->c_list->refcount > 0))\n\t\t\t{\n\t\t\t\tct->dead = true;\n\t\t\t\t/* list, if any, was marked dead above */\n\t\t\t\tAssert(ct->c_list == NULL || ct->c_list->dead);\n\t\t\t}\n\t\t\telse\n\t\t\t\tCatCacheRemoveCTup(cache, ct);\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_invals++;\n#endif\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatCacheRemoveCList(CatCache *cache, CatCList *cl);",
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatCacheRemoveCList(CatCache *cache, CatCList *cl);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nstatic void\nResetCatalogCache(CatCache *cache)\n{\n\tdlist_mutable_iter iter;\n\tint\t\t\ti;\n\n\t/* Remove each list in this cache, or at least mark it dead */\n\tdlist_foreach_modify(iter, &cache->cc_lists)\n\t{\n\t\tCatCList   *cl = dlist_container(CatCList, cache_elem, iter.cur);\n\n\t\tif (cl->refcount > 0)\n\t\t\tcl->dead = true;\n\t\telse\n\t\t\tCatCacheRemoveCList(cache, cl);\n\t}\n\n\t/* Remove each tuple in this cache, or at least mark it dead */\n\tfor (i = 0; i < cache->cc_nbuckets; i++)\n\t{\n\t\tdlist_head *bucket = &cache->cc_bucket[i];\n\n\t\tdlist_foreach_modify(iter, bucket)\n\t\t{\n\t\t\tCatCTup    *ct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\t\tif (ct->refcount > 0 ||\n\t\t\t\t(ct->c_list && ct->c_list->refcount > 0))\n\t\t\t{\n\t\t\t\tct->dead = true;\n\t\t\t\t/* list, if any, was marked dead above */\n\t\t\t\tAssert(ct->c_list == NULL || ct->c_list->dead);\n\t\t\t}\n\t\t\telse\n\t\t\t\tCatCacheRemoveCTup(cache, ct);\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_invals++;\n#endif\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "slist_container",
          "args": [
            "CatCache",
            "cc_next",
            "iter.cur"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slist_foreach",
          "args": [
            "iter",
            "&CacheHdr->ch_caches"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CACHE2_elog",
          "args": [
            "DEBUG2",
            "\"CatalogCacheFlushCatalog called for %u\"",
            "catId"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nCatalogCacheFlushCatalog(Oid catId)\n{\n\tslist_iter\titer;\n\n\tCACHE2_elog(DEBUG2, \"CatalogCacheFlushCatalog called for %u\", catId);\n\n\tslist_foreach(iter, &CacheHdr->ch_caches)\n\t{\n\t\tCatCache   *cache = slist_container(CatCache, cc_next, iter.cur);\n\n\t\t/* Does this cache store tuples of the target catalog? */\n\t\tif (cache->cc_reloid == catId)\n\t\t{\n\t\t\t/* Yes, so flush all its contents */\n\t\t\tResetCatalogCache(cache);\n\n\t\t\t/* Tell inval.c to call syscache callbacks for this cache */\n\t\t\tCallSyscacheCallbacks(cache->id, 0);\n\t\t}\n\t}\n\n\tCACHE1_elog(DEBUG2, \"end of CatalogCacheFlushCatalog call\");\n}"
  },
  {
    "function_name": "ResetCatalogCaches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "704-719",
    "snippet": "void\nResetCatalogCaches(void)\n{\n\tslist_iter\titer;\n\n\tCACHE1_elog(DEBUG2, \"ResetCatalogCaches called\");\n\n\tslist_foreach(iter, &CacheHdr->ch_caches)\n\t{\n\t\tCatCache   *cache = slist_container(CatCache, cc_next, iter.cur);\n\n\t\tResetCatalogCache(cache);\n\t}\n\n\tCACHE1_elog(DEBUG2, \"end of ResetCatalogCaches call\");\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CatCacheHeader *CacheHdr = NULL;",
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CACHE1_elog",
          "args": [
            "DEBUG2",
            "\"end of ResetCatalogCaches call\""
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResetCatalogCache",
          "args": [
            "cache"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "ResetCatalogCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "657-697",
          "snippet": "static void\nResetCatalogCache(CatCache *cache)\n{\n\tdlist_mutable_iter iter;\n\tint\t\t\ti;\n\n\t/* Remove each list in this cache, or at least mark it dead */\n\tdlist_foreach_modify(iter, &cache->cc_lists)\n\t{\n\t\tCatCList   *cl = dlist_container(CatCList, cache_elem, iter.cur);\n\n\t\tif (cl->refcount > 0)\n\t\t\tcl->dead = true;\n\t\telse\n\t\t\tCatCacheRemoveCList(cache, cl);\n\t}\n\n\t/* Remove each tuple in this cache, or at least mark it dead */\n\tfor (i = 0; i < cache->cc_nbuckets; i++)\n\t{\n\t\tdlist_head *bucket = &cache->cc_bucket[i];\n\n\t\tdlist_foreach_modify(iter, bucket)\n\t\t{\n\t\t\tCatCTup    *ct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\t\tif (ct->refcount > 0 ||\n\t\t\t\t(ct->c_list && ct->c_list->refcount > 0))\n\t\t\t{\n\t\t\t\tct->dead = true;\n\t\t\t\t/* list, if any, was marked dead above */\n\t\t\t\tAssert(ct->c_list == NULL || ct->c_list->dead);\n\t\t\t}\n\t\t\telse\n\t\t\t\tCatCacheRemoveCTup(cache, ct);\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_invals++;\n#endif\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatCacheRemoveCList(CatCache *cache, CatCList *cl);",
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatCacheRemoveCList(CatCache *cache, CatCList *cl);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nstatic void\nResetCatalogCache(CatCache *cache)\n{\n\tdlist_mutable_iter iter;\n\tint\t\t\ti;\n\n\t/* Remove each list in this cache, or at least mark it dead */\n\tdlist_foreach_modify(iter, &cache->cc_lists)\n\t{\n\t\tCatCList   *cl = dlist_container(CatCList, cache_elem, iter.cur);\n\n\t\tif (cl->refcount > 0)\n\t\t\tcl->dead = true;\n\t\telse\n\t\t\tCatCacheRemoveCList(cache, cl);\n\t}\n\n\t/* Remove each tuple in this cache, or at least mark it dead */\n\tfor (i = 0; i < cache->cc_nbuckets; i++)\n\t{\n\t\tdlist_head *bucket = &cache->cc_bucket[i];\n\n\t\tdlist_foreach_modify(iter, bucket)\n\t\t{\n\t\t\tCatCTup    *ct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\t\tif (ct->refcount > 0 ||\n\t\t\t\t(ct->c_list && ct->c_list->refcount > 0))\n\t\t\t{\n\t\t\t\tct->dead = true;\n\t\t\t\t/* list, if any, was marked dead above */\n\t\t\t\tAssert(ct->c_list == NULL || ct->c_list->dead);\n\t\t\t}\n\t\t\telse\n\t\t\t\tCatCacheRemoveCTup(cache, ct);\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_invals++;\n#endif\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "slist_container",
          "args": [
            "CatCache",
            "cc_next",
            "iter.cur"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slist_foreach",
          "args": [
            "iter",
            "&CacheHdr->ch_caches"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CACHE1_elog",
          "args": [
            "DEBUG2",
            "\"ResetCatalogCaches called\""
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nResetCatalogCaches(void)\n{\n\tslist_iter\titer;\n\n\tCACHE1_elog(DEBUG2, \"ResetCatalogCaches called\");\n\n\tslist_foreach(iter, &CacheHdr->ch_caches)\n\t{\n\t\tCatCache   *cache = slist_container(CatCache, cc_next, iter.cur);\n\n\t\tResetCatalogCache(cache);\n\t}\n\n\tCACHE1_elog(DEBUG2, \"end of ResetCatalogCaches call\");\n}"
  },
  {
    "function_name": "ResetCatalogCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "657-697",
    "snippet": "static void\nResetCatalogCache(CatCache *cache)\n{\n\tdlist_mutable_iter iter;\n\tint\t\t\ti;\n\n\t/* Remove each list in this cache, or at least mark it dead */\n\tdlist_foreach_modify(iter, &cache->cc_lists)\n\t{\n\t\tCatCList   *cl = dlist_container(CatCList, cache_elem, iter.cur);\n\n\t\tif (cl->refcount > 0)\n\t\t\tcl->dead = true;\n\t\telse\n\t\t\tCatCacheRemoveCList(cache, cl);\n\t}\n\n\t/* Remove each tuple in this cache, or at least mark it dead */\n\tfor (i = 0; i < cache->cc_nbuckets; i++)\n\t{\n\t\tdlist_head *bucket = &cache->cc_bucket[i];\n\n\t\tdlist_foreach_modify(iter, bucket)\n\t\t{\n\t\t\tCatCTup    *ct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\t\tif (ct->refcount > 0 ||\n\t\t\t\t(ct->c_list && ct->c_list->refcount > 0))\n\t\t\t{\n\t\t\t\tct->dead = true;\n\t\t\t\t/* list, if any, was marked dead above */\n\t\t\t\tAssert(ct->c_list == NULL || ct->c_list->dead);\n\t\t\t}\n\t\t\telse\n\t\t\t\tCatCacheRemoveCTup(cache, ct);\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_invals++;\n#endif\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
      "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
      "static void CatCacheRemoveCList(CatCache *cache, CatCList *cl);",
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CatCacheRemoveCTup",
          "args": [
            "cache",
            "ct"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "CatCacheRemoveCTup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "472-505",
          "snippet": "static void\nCatCacheRemoveCTup(CatCache *cache, CatCTup *ct)\n{\n\tAssert(ct->refcount == 0);\n\tAssert(ct->my_cache == cache);\n\n\tif (ct->c_list)\n\t{\n\t\t/*\n\t\t * The cleanest way to handle this is to call CatCacheRemoveCList,\n\t\t * which will recurse back to me, and the recursive call will do the\n\t\t * work.  Set the \"dead\" flag to make sure it does recurse.\n\t\t */\n\t\tct->dead = true;\n\t\tCatCacheRemoveCList(cache, ct->c_list);\n\t\treturn;\t\t\t\t\t/* nothing left to do */\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&ct->cache_elem);\n\n\t/*\n\t * Free keys when we're dealing with a negative entry, normal entries just\n\t * point into tuple, allocated together with the CatCTup.\n\t */\n\tif (ct->negative)\n\t\tCatCacheFreeKeys(cache->cc_tupdesc, cache->cc_nkeys,\n\t\t\t\t\t\t cache->cc_keyno, ct->keys);\n\n\tpfree(ct);\n\n\t--cache->cc_ntup;\n\t--CacheHdr->ch_ntup;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCacheHeader *CacheHdr = NULL;",
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatCacheRemoveCTup(CatCache *cache, CatCTup *ct)\n{\n\tAssert(ct->refcount == 0);\n\tAssert(ct->my_cache == cache);\n\n\tif (ct->c_list)\n\t{\n\t\t/*\n\t\t * The cleanest way to handle this is to call CatCacheRemoveCList,\n\t\t * which will recurse back to me, and the recursive call will do the\n\t\t * work.  Set the \"dead\" flag to make sure it does recurse.\n\t\t */\n\t\tct->dead = true;\n\t\tCatCacheRemoveCList(cache, ct->c_list);\n\t\treturn;\t\t\t\t\t/* nothing left to do */\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&ct->cache_elem);\n\n\t/*\n\t * Free keys when we're dealing with a negative entry, normal entries just\n\t * point into tuple, allocated together with the CatCTup.\n\t */\n\tif (ct->negative)\n\t\tCatCacheFreeKeys(cache->cc_tupdesc, cache->cc_nkeys,\n\t\t\t\t\t\t cache->cc_keyno, ct->keys);\n\n\tpfree(ct);\n\n\t--cache->cc_ntup;\n\t--CacheHdr->ch_ntup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ct->c_list == NULL || ct->c_list->dead"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_container",
          "args": [
            "CatCTup",
            "cache_elem",
            "iter.cur"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_foreach_modify",
          "args": [
            "iter",
            "bucket"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatCacheRemoveCList",
          "args": [
            "cache",
            "cl"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "CatCacheRemoveCList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "514-546",
          "snippet": "static void\nCatCacheRemoveCList(CatCache *cache, CatCList *cl)\n{\n\tint\t\t\ti;\n\n\tAssert(cl->refcount == 0);\n\tAssert(cl->my_cache == cache);\n\n\t/* delink from member tuples */\n\tfor (i = cl->n_members; --i >= 0;)\n\t{\n\t\tCatCTup    *ct = cl->members[i];\n\n\t\tAssert(ct->c_list == cl);\n\t\tct->c_list = NULL;\n\t\t/* if the member is dead and now has no references, remove it */\n\t\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\t\tct->dead &&\n#endif\n\t\t\tct->refcount == 0)\n\t\t\tCatCacheRemoveCTup(cache, ct);\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&cl->cache_elem);\n\n\t/* free associated column data */\n\tCatCacheFreeKeys(cache->cc_tupdesc, cl->nkeys,\n\t\t\t\t\t cache->cc_keyno, cl->keys);\n\n\tpfree(cl);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatCacheRemoveCList(CatCache *cache, CatCList *cl);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatCacheRemoveCList(CatCache *cache, CatCList *cl);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatCacheRemoveCList(CatCache *cache, CatCList *cl)\n{\n\tint\t\t\ti;\n\n\tAssert(cl->refcount == 0);\n\tAssert(cl->my_cache == cache);\n\n\t/* delink from member tuples */\n\tfor (i = cl->n_members; --i >= 0;)\n\t{\n\t\tCatCTup    *ct = cl->members[i];\n\n\t\tAssert(ct->c_list == cl);\n\t\tct->c_list = NULL;\n\t\t/* if the member is dead and now has no references, remove it */\n\t\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\t\tct->dead &&\n#endif\n\t\t\tct->refcount == 0)\n\t\t\tCatCacheRemoveCTup(cache, ct);\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&cl->cache_elem);\n\n\t/* free associated column data */\n\tCatCacheFreeKeys(cache->cc_tupdesc, cl->nkeys,\n\t\t\t\t\t cache->cc_keyno, cl->keys);\n\n\tpfree(cl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlist_container",
          "args": [
            "CatCList",
            "cache_elem",
            "iter.cur"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_foreach_modify",
          "args": [
            "iter",
            "&cache->cc_lists"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatCacheRemoveCList(CatCache *cache, CatCList *cl);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nstatic void\nResetCatalogCache(CatCache *cache)\n{\n\tdlist_mutable_iter iter;\n\tint\t\t\ti;\n\n\t/* Remove each list in this cache, or at least mark it dead */\n\tdlist_foreach_modify(iter, &cache->cc_lists)\n\t{\n\t\tCatCList   *cl = dlist_container(CatCList, cache_elem, iter.cur);\n\n\t\tif (cl->refcount > 0)\n\t\t\tcl->dead = true;\n\t\telse\n\t\t\tCatCacheRemoveCList(cache, cl);\n\t}\n\n\t/* Remove each tuple in this cache, or at least mark it dead */\n\tfor (i = 0; i < cache->cc_nbuckets; i++)\n\t{\n\t\tdlist_head *bucket = &cache->cc_bucket[i];\n\n\t\tdlist_foreach_modify(iter, bucket)\n\t\t{\n\t\t\tCatCTup    *ct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\t\tif (ct->refcount > 0 ||\n\t\t\t\t(ct->c_list && ct->c_list->refcount > 0))\n\t\t\t{\n\t\t\t\tct->dead = true;\n\t\t\t\t/* list, if any, was marked dead above */\n\t\t\t\tAssert(ct->c_list == NULL || ct->c_list->dead);\n\t\t\t}\n\t\t\telse\n\t\t\t\tCatCacheRemoveCTup(cache, ct);\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_invals++;\n#endif\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "CreateCacheMemoryContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "635-646",
    "snippet": "void\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "TopMemoryContext",
            "\"CacheMemoryContext\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nvoid\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}"
  },
  {
    "function_name": "CatCacheInvalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "567-620",
    "snippet": "void\nCatCacheInvalidate(CatCache *cache, uint32 hashValue)\n{\n\tIndex\t\thashIndex;\n\tdlist_mutable_iter iter;\n\n\tCACHE1_elog(DEBUG2, \"CatCacheInvalidate: called\");\n\n\t/*\n\t * We don't bother to check whether the cache has finished initialization\n\t * yet; if not, there will be no entries in it so no problem.\n\t */\n\n\t/*\n\t * Invalidate *all* CatCLists in this cache; it's too hard to tell which\n\t * searches might still be correct, so just zap 'em all.\n\t */\n\tdlist_foreach_modify(iter, &cache->cc_lists)\n\t{\n\t\tCatCList   *cl = dlist_container(CatCList, cache_elem, iter.cur);\n\n\t\tif (cl->refcount > 0)\n\t\t\tcl->dead = true;\n\t\telse\n\t\t\tCatCacheRemoveCList(cache, cl);\n\t}\n\n\t/*\n\t * inspect the proper hash bucket for tuple matches\n\t */\n\thashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);\n\tdlist_foreach_modify(iter, &cache->cc_bucket[hashIndex])\n\t{\n\t\tCatCTup    *ct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\tif (hashValue == ct->hash_value)\n\t\t{\n\t\t\tif (ct->refcount > 0 ||\n\t\t\t\t(ct->c_list && ct->c_list->refcount > 0))\n\t\t\t{\n\t\t\t\tct->dead = true;\n\t\t\t\t/* list, if any, was marked dead above */\n\t\t\t\tAssert(ct->c_list == NULL || ct->c_list->dead);\n\t\t\t}\n\t\t\telse\n\t\t\t\tCatCacheRemoveCTup(cache, ct);\n\t\t\tCACHE1_elog(DEBUG2, \"CatCacheInvalidate: invalidated\");\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_invals++;\n#endif\n\t\t\t/* could be multiple matches, so keep looking! */\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
      "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
      "static void CatCacheRemoveCList(CatCache *cache, CatCList *cl);",
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CACHE1_elog",
          "args": [
            "DEBUG2",
            "\"CatCacheInvalidate: invalidated\""
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatCacheRemoveCTup",
          "args": [
            "cache",
            "ct"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "CatCacheRemoveCTup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "472-505",
          "snippet": "static void\nCatCacheRemoveCTup(CatCache *cache, CatCTup *ct)\n{\n\tAssert(ct->refcount == 0);\n\tAssert(ct->my_cache == cache);\n\n\tif (ct->c_list)\n\t{\n\t\t/*\n\t\t * The cleanest way to handle this is to call CatCacheRemoveCList,\n\t\t * which will recurse back to me, and the recursive call will do the\n\t\t * work.  Set the \"dead\" flag to make sure it does recurse.\n\t\t */\n\t\tct->dead = true;\n\t\tCatCacheRemoveCList(cache, ct->c_list);\n\t\treturn;\t\t\t\t\t/* nothing left to do */\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&ct->cache_elem);\n\n\t/*\n\t * Free keys when we're dealing with a negative entry, normal entries just\n\t * point into tuple, allocated together with the CatCTup.\n\t */\n\tif (ct->negative)\n\t\tCatCacheFreeKeys(cache->cc_tupdesc, cache->cc_nkeys,\n\t\t\t\t\t\t cache->cc_keyno, ct->keys);\n\n\tpfree(ct);\n\n\t--cache->cc_ntup;\n\t--CacheHdr->ch_ntup;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCacheHeader *CacheHdr = NULL;",
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatCacheRemoveCTup(CatCache *cache, CatCTup *ct)\n{\n\tAssert(ct->refcount == 0);\n\tAssert(ct->my_cache == cache);\n\n\tif (ct->c_list)\n\t{\n\t\t/*\n\t\t * The cleanest way to handle this is to call CatCacheRemoveCList,\n\t\t * which will recurse back to me, and the recursive call will do the\n\t\t * work.  Set the \"dead\" flag to make sure it does recurse.\n\t\t */\n\t\tct->dead = true;\n\t\tCatCacheRemoveCList(cache, ct->c_list);\n\t\treturn;\t\t\t\t\t/* nothing left to do */\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&ct->cache_elem);\n\n\t/*\n\t * Free keys when we're dealing with a negative entry, normal entries just\n\t * point into tuple, allocated together with the CatCTup.\n\t */\n\tif (ct->negative)\n\t\tCatCacheFreeKeys(cache->cc_tupdesc, cache->cc_nkeys,\n\t\t\t\t\t\t cache->cc_keyno, ct->keys);\n\n\tpfree(ct);\n\n\t--cache->cc_ntup;\n\t--CacheHdr->ch_ntup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ct->c_list == NULL || ct->c_list->dead"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_container",
          "args": [
            "CatCTup",
            "cache_elem",
            "iter.cur"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_foreach_modify",
          "args": [
            "iter",
            "&cache->cc_bucket[hashIndex]"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HASH_INDEX",
          "args": [
            "hashValue",
            "cache->cc_nbuckets"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatCacheRemoveCList",
          "args": [
            "cache",
            "cl"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "CatCacheRemoveCList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "514-546",
          "snippet": "static void\nCatCacheRemoveCList(CatCache *cache, CatCList *cl)\n{\n\tint\t\t\ti;\n\n\tAssert(cl->refcount == 0);\n\tAssert(cl->my_cache == cache);\n\n\t/* delink from member tuples */\n\tfor (i = cl->n_members; --i >= 0;)\n\t{\n\t\tCatCTup    *ct = cl->members[i];\n\n\t\tAssert(ct->c_list == cl);\n\t\tct->c_list = NULL;\n\t\t/* if the member is dead and now has no references, remove it */\n\t\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\t\tct->dead &&\n#endif\n\t\t\tct->refcount == 0)\n\t\t\tCatCacheRemoveCTup(cache, ct);\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&cl->cache_elem);\n\n\t/* free associated column data */\n\tCatCacheFreeKeys(cache->cc_tupdesc, cl->nkeys,\n\t\t\t\t\t cache->cc_keyno, cl->keys);\n\n\tpfree(cl);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatCacheRemoveCList(CatCache *cache, CatCList *cl);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatCacheRemoveCList(CatCache *cache, CatCList *cl);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatCacheRemoveCList(CatCache *cache, CatCList *cl)\n{\n\tint\t\t\ti;\n\n\tAssert(cl->refcount == 0);\n\tAssert(cl->my_cache == cache);\n\n\t/* delink from member tuples */\n\tfor (i = cl->n_members; --i >= 0;)\n\t{\n\t\tCatCTup    *ct = cl->members[i];\n\n\t\tAssert(ct->c_list == cl);\n\t\tct->c_list = NULL;\n\t\t/* if the member is dead and now has no references, remove it */\n\t\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\t\tct->dead &&\n#endif\n\t\t\tct->refcount == 0)\n\t\t\tCatCacheRemoveCTup(cache, ct);\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&cl->cache_elem);\n\n\t/* free associated column data */\n\tCatCacheFreeKeys(cache->cc_tupdesc, cl->nkeys,\n\t\t\t\t\t cache->cc_keyno, cl->keys);\n\n\tpfree(cl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlist_container",
          "args": [
            "CatCList",
            "cache_elem",
            "iter.cur"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_foreach_modify",
          "args": [
            "iter",
            "&cache->cc_lists"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CACHE1_elog",
          "args": [
            "DEBUG2",
            "\"CatCacheInvalidate: called\""
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatCacheRemoveCList(CatCache *cache, CatCList *cl);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nCatCacheInvalidate(CatCache *cache, uint32 hashValue)\n{\n\tIndex\t\thashIndex;\n\tdlist_mutable_iter iter;\n\n\tCACHE1_elog(DEBUG2, \"CatCacheInvalidate: called\");\n\n\t/*\n\t * We don't bother to check whether the cache has finished initialization\n\t * yet; if not, there will be no entries in it so no problem.\n\t */\n\n\t/*\n\t * Invalidate *all* CatCLists in this cache; it's too hard to tell which\n\t * searches might still be correct, so just zap 'em all.\n\t */\n\tdlist_foreach_modify(iter, &cache->cc_lists)\n\t{\n\t\tCatCList   *cl = dlist_container(CatCList, cache_elem, iter.cur);\n\n\t\tif (cl->refcount > 0)\n\t\t\tcl->dead = true;\n\t\telse\n\t\t\tCatCacheRemoveCList(cache, cl);\n\t}\n\n\t/*\n\t * inspect the proper hash bucket for tuple matches\n\t */\n\thashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);\n\tdlist_foreach_modify(iter, &cache->cc_bucket[hashIndex])\n\t{\n\t\tCatCTup    *ct = dlist_container(CatCTup, cache_elem, iter.cur);\n\n\t\tif (hashValue == ct->hash_value)\n\t\t{\n\t\t\tif (ct->refcount > 0 ||\n\t\t\t\t(ct->c_list && ct->c_list->refcount > 0))\n\t\t\t{\n\t\t\t\tct->dead = true;\n\t\t\t\t/* list, if any, was marked dead above */\n\t\t\t\tAssert(ct->c_list == NULL || ct->c_list->dead);\n\t\t\t}\n\t\t\telse\n\t\t\t\tCatCacheRemoveCTup(cache, ct);\n\t\t\tCACHE1_elog(DEBUG2, \"CatCacheInvalidate: invalidated\");\n#ifdef CATCACHE_STATS\n\t\t\tcache->cc_invals++;\n#endif\n\t\t\t/* could be multiple matches, so keep looking! */\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "CatCacheRemoveCList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "514-546",
    "snippet": "static void\nCatCacheRemoveCList(CatCache *cache, CatCList *cl)\n{\n\tint\t\t\ti;\n\n\tAssert(cl->refcount == 0);\n\tAssert(cl->my_cache == cache);\n\n\t/* delink from member tuples */\n\tfor (i = cl->n_members; --i >= 0;)\n\t{\n\t\tCatCTup    *ct = cl->members[i];\n\n\t\tAssert(ct->c_list == cl);\n\t\tct->c_list = NULL;\n\t\t/* if the member is dead and now has no references, remove it */\n\t\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\t\tct->dead &&\n#endif\n\t\t\tct->refcount == 0)\n\t\t\tCatCacheRemoveCTup(cache, ct);\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&cl->cache_elem);\n\n\t/* free associated column data */\n\tCatCacheFreeKeys(cache->cc_tupdesc, cl->nkeys,\n\t\t\t\t\t cache->cc_keyno, cl->keys);\n\n\tpfree(cl);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
      "static void CatCacheRemoveCList(CatCache *cache, CatCList *cl);",
      "static void CatalogCacheInitializeCache(CatCache *cache);",
      "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "cl"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CatCacheFreeKeys",
          "args": [
            "cache->cc_tupdesc",
            "cl->nkeys",
            "cache->cc_keyno",
            "cl->keys"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "CatCacheFreeKeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "1928-1948",
          "snippet": "static void\nCatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos, Datum *keys)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tint\t\t\tattnum = attnos[i];\n\t\tForm_pg_attribute att;\n\n\t\t/* only valid system attribute is the oid, which is by value */\n\t\tif (attnum == ObjectIdAttributeNumber)\n\t\t\tcontinue;\n\t\tAssert(attnum > 0);\n\n\t\tatt = TupleDescAttr(tupdesc, attnum - 1);\n\n\t\tif (!att->attbyval)\n\t\t\tpfree(DatumGetPointer(keys[i]));\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos, Datum *keys)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tint\t\t\tattnum = attnos[i];\n\t\tForm_pg_attribute att;\n\n\t\t/* only valid system attribute is the oid, which is by value */\n\t\tif (attnum == ObjectIdAttributeNumber)\n\t\t\tcontinue;\n\t\tAssert(attnum > 0);\n\n\t\tatt = TupleDescAttr(tupdesc, attnum - 1);\n\n\t\tif (!att->attbyval)\n\t\t\tpfree(DatumGetPointer(keys[i]));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlist_delete",
          "args": [
            "&cl->cache_elem"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatCacheRemoveCTup",
          "args": [
            "cache",
            "ct"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "CatCacheRemoveCTup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "472-505",
          "snippet": "static void\nCatCacheRemoveCTup(CatCache *cache, CatCTup *ct)\n{\n\tAssert(ct->refcount == 0);\n\tAssert(ct->my_cache == cache);\n\n\tif (ct->c_list)\n\t{\n\t\t/*\n\t\t * The cleanest way to handle this is to call CatCacheRemoveCList,\n\t\t * which will recurse back to me, and the recursive call will do the\n\t\t * work.  Set the \"dead\" flag to make sure it does recurse.\n\t\t */\n\t\tct->dead = true;\n\t\tCatCacheRemoveCList(cache, ct->c_list);\n\t\treturn;\t\t\t\t\t/* nothing left to do */\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&ct->cache_elem);\n\n\t/*\n\t * Free keys when we're dealing with a negative entry, normal entries just\n\t * point into tuple, allocated together with the CatCTup.\n\t */\n\tif (ct->negative)\n\t\tCatCacheFreeKeys(cache->cc_tupdesc, cache->cc_nkeys,\n\t\t\t\t\t\t cache->cc_keyno, ct->keys);\n\n\tpfree(ct);\n\n\t--cache->cc_ntup;\n\t--CacheHdr->ch_ntup;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCacheHeader *CacheHdr = NULL;",
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatCacheRemoveCTup(CatCache *cache, CatCTup *ct)\n{\n\tAssert(ct->refcount == 0);\n\tAssert(ct->my_cache == cache);\n\n\tif (ct->c_list)\n\t{\n\t\t/*\n\t\t * The cleanest way to handle this is to call CatCacheRemoveCList,\n\t\t * which will recurse back to me, and the recursive call will do the\n\t\t * work.  Set the \"dead\" flag to make sure it does recurse.\n\t\t */\n\t\tct->dead = true;\n\t\tCatCacheRemoveCList(cache, ct->c_list);\n\t\treturn;\t\t\t\t\t/* nothing left to do */\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&ct->cache_elem);\n\n\t/*\n\t * Free keys when we're dealing with a negative entry, normal entries just\n\t * point into tuple, allocated together with the CatCTup.\n\t */\n\tif (ct->negative)\n\t\tCatCacheFreeKeys(cache->cc_tupdesc, cache->cc_nkeys,\n\t\t\t\t\t\t cache->cc_keyno, ct->keys);\n\n\tpfree(ct);\n\n\t--cache->cc_ntup;\n\t--CacheHdr->ch_ntup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ct->c_list == cl"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "cl->my_cache == cache"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "cl->refcount == 0"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatCacheRemoveCList(CatCache *cache, CatCList *cl);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatCacheRemoveCList(CatCache *cache, CatCList *cl)\n{\n\tint\t\t\ti;\n\n\tAssert(cl->refcount == 0);\n\tAssert(cl->my_cache == cache);\n\n\t/* delink from member tuples */\n\tfor (i = cl->n_members; --i >= 0;)\n\t{\n\t\tCatCTup    *ct = cl->members[i];\n\n\t\tAssert(ct->c_list == cl);\n\t\tct->c_list = NULL;\n\t\t/* if the member is dead and now has no references, remove it */\n\t\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\t\tct->dead &&\n#endif\n\t\t\tct->refcount == 0)\n\t\t\tCatCacheRemoveCTup(cache, ct);\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&cl->cache_elem);\n\n\t/* free associated column data */\n\tCatCacheFreeKeys(cache->cc_tupdesc, cl->nkeys,\n\t\t\t\t\t cache->cc_keyno, cl->keys);\n\n\tpfree(cl);\n}"
  },
  {
    "function_name": "CatCacheRemoveCTup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "472-505",
    "snippet": "static void\nCatCacheRemoveCTup(CatCache *cache, CatCTup *ct)\n{\n\tAssert(ct->refcount == 0);\n\tAssert(ct->my_cache == cache);\n\n\tif (ct->c_list)\n\t{\n\t\t/*\n\t\t * The cleanest way to handle this is to call CatCacheRemoveCList,\n\t\t * which will recurse back to me, and the recursive call will do the\n\t\t * work.  Set the \"dead\" flag to make sure it does recurse.\n\t\t */\n\t\tct->dead = true;\n\t\tCatCacheRemoveCList(cache, ct->c_list);\n\t\treturn;\t\t\t\t\t/* nothing left to do */\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&ct->cache_elem);\n\n\t/*\n\t * Free keys when we're dealing with a negative entry, normal entries just\n\t * point into tuple, allocated together with the CatCTup.\n\t */\n\tif (ct->negative)\n\t\tCatCacheFreeKeys(cache->cc_tupdesc, cache->cc_nkeys,\n\t\t\t\t\t\t cache->cc_keyno, ct->keys);\n\n\tpfree(ct);\n\n\t--cache->cc_ntup;\n\t--CacheHdr->ch_ntup;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CatCacheHeader *CacheHdr = NULL;",
      "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
      "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
      "static void CatalogCacheInitializeCache(CatCache *cache);",
      "static CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);",
      "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "ct"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CatCacheFreeKeys",
          "args": [
            "cache->cc_tupdesc",
            "cache->cc_nkeys",
            "cache->cc_keyno",
            "ct->keys"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "CatCacheFreeKeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "1928-1948",
          "snippet": "static void\nCatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos, Datum *keys)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tint\t\t\tattnum = attnos[i];\n\t\tForm_pg_attribute att;\n\n\t\t/* only valid system attribute is the oid, which is by value */\n\t\tif (attnum == ObjectIdAttributeNumber)\n\t\t\tcontinue;\n\t\tAssert(attnum > 0);\n\n\t\tatt = TupleDescAttr(tupdesc, attnum - 1);\n\n\t\tif (!att->attbyval)\n\t\t\tpfree(DatumGetPointer(keys[i]));\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos, Datum *keys)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tint\t\t\tattnum = attnos[i];\n\t\tForm_pg_attribute att;\n\n\t\t/* only valid system attribute is the oid, which is by value */\n\t\tif (attnum == ObjectIdAttributeNumber)\n\t\t\tcontinue;\n\t\tAssert(attnum > 0);\n\n\t\tatt = TupleDescAttr(tupdesc, attnum - 1);\n\n\t\tif (!att->attbyval)\n\t\t\tpfree(DatumGetPointer(keys[i]));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlist_delete",
          "args": [
            "&ct->cache_elem"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatCacheRemoveCList",
          "args": [
            "cache",
            "ct->c_list"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "CatCacheRemoveCList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "514-546",
          "snippet": "static void\nCatCacheRemoveCList(CatCache *cache, CatCList *cl)\n{\n\tint\t\t\ti;\n\n\tAssert(cl->refcount == 0);\n\tAssert(cl->my_cache == cache);\n\n\t/* delink from member tuples */\n\tfor (i = cl->n_members; --i >= 0;)\n\t{\n\t\tCatCTup    *ct = cl->members[i];\n\n\t\tAssert(ct->c_list == cl);\n\t\tct->c_list = NULL;\n\t\t/* if the member is dead and now has no references, remove it */\n\t\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\t\tct->dead &&\n#endif\n\t\t\tct->refcount == 0)\n\t\t\tCatCacheRemoveCTup(cache, ct);\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&cl->cache_elem);\n\n\t/* free associated column data */\n\tCatCacheFreeKeys(cache->cc_tupdesc, cl->nkeys,\n\t\t\t\t\t cache->cc_keyno, cl->keys);\n\n\tpfree(cl);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatCacheRemoveCList(CatCache *cache, CatCList *cl);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatCacheRemoveCList(CatCache *cache, CatCList *cl);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatCacheRemoveCList(CatCache *cache, CatCList *cl)\n{\n\tint\t\t\ti;\n\n\tAssert(cl->refcount == 0);\n\tAssert(cl->my_cache == cache);\n\n\t/* delink from member tuples */\n\tfor (i = cl->n_members; --i >= 0;)\n\t{\n\t\tCatCTup    *ct = cl->members[i];\n\n\t\tAssert(ct->c_list == cl);\n\t\tct->c_list = NULL;\n\t\t/* if the member is dead and now has no references, remove it */\n\t\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\t\tct->dead &&\n#endif\n\t\t\tct->refcount == 0)\n\t\t\tCatCacheRemoveCTup(cache, ct);\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&cl->cache_elem);\n\n\t/* free associated column data */\n\tCatCacheFreeKeys(cache->cc_tupdesc, cl->nkeys,\n\t\t\t\t\t cache->cc_keyno, cl->keys);\n\n\tpfree(cl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ct->my_cache == cache"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ct->refcount == 0"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic CatCTup *CatalogCacheCreateEntry(CatCache *cache, HeapTuple ntp,\n\t\t\t\t\t\tDatum *arguments,\n\t\t\t\t\t\tuint32 hashValue, Index hashIndex,\n\t\t\t\t\t\tbool negative);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic void\nCatCacheRemoveCTup(CatCache *cache, CatCTup *ct)\n{\n\tAssert(ct->refcount == 0);\n\tAssert(ct->my_cache == cache);\n\n\tif (ct->c_list)\n\t{\n\t\t/*\n\t\t * The cleanest way to handle this is to call CatCacheRemoveCList,\n\t\t * which will recurse back to me, and the recursive call will do the\n\t\t * work.  Set the \"dead\" flag to make sure it does recurse.\n\t\t */\n\t\tct->dead = true;\n\t\tCatCacheRemoveCList(cache, ct->c_list);\n\t\treturn;\t\t\t\t\t/* nothing left to do */\n\t}\n\n\t/* delink from linked list */\n\tdlist_delete(&ct->cache_elem);\n\n\t/*\n\t * Free keys when we're dealing with a negative entry, normal entries just\n\t * point into tuple, allocated together with the CatCTup.\n\t */\n\tif (ct->negative)\n\t\tCatCacheFreeKeys(cache->cc_tupdesc, cache->cc_nkeys,\n\t\t\t\t\t\t cache->cc_keyno, ct->keys);\n\n\tpfree(ct);\n\n\t--cache->cc_ntup;\n\t--CacheHdr->ch_ntup;\n}"
  },
  {
    "function_name": "CatCachePrintStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "408-460",
    "snippet": "static void\nCatCachePrintStats(int code, Datum arg)\n{\n\tslist_iter\titer;\n\tlong\t\tcc_searches = 0;\n\tlong\t\tcc_hits = 0;\n\tlong\t\tcc_neg_hits = 0;\n\tlong\t\tcc_newloads = 0;\n\tlong\t\tcc_invals = 0;\n\tlong\t\tcc_lsearches = 0;\n\tlong\t\tcc_lhits = 0;\n\n\tslist_foreach(iter, &CacheHdr->ch_caches)\n\t{\n\t\tCatCache   *cache = slist_container(CatCache, cc_next, iter.cur);\n\n\t\tif (cache->cc_ntup == 0 && cache->cc_searches == 0)\n\t\t\tcontinue;\t\t\t/* don't print unused caches */\n\t\telog(DEBUG2, \"catcache %s/%u: %d tup, %ld srch, %ld+%ld=%ld hits, %ld+%ld=%ld loads, %ld invals, %ld lsrch, %ld lhits\",\n\t\t\t cache->cc_relname,\n\t\t\t cache->cc_indexoid,\n\t\t\t cache->cc_ntup,\n\t\t\t cache->cc_searches,\n\t\t\t cache->cc_hits,\n\t\t\t cache->cc_neg_hits,\n\t\t\t cache->cc_hits + cache->cc_neg_hits,\n\t\t\t cache->cc_newloads,\n\t\t\t cache->cc_searches - cache->cc_hits - cache->cc_neg_hits - cache->cc_newloads,\n\t\t\t cache->cc_searches - cache->cc_hits - cache->cc_neg_hits,\n\t\t\t cache->cc_invals,\n\t\t\t cache->cc_lsearches,\n\t\t\t cache->cc_lhits);\n\t\tcc_searches += cache->cc_searches;\n\t\tcc_hits += cache->cc_hits;\n\t\tcc_neg_hits += cache->cc_neg_hits;\n\t\tcc_newloads += cache->cc_newloads;\n\t\tcc_invals += cache->cc_invals;\n\t\tcc_lsearches += cache->cc_lsearches;\n\t\tcc_lhits += cache->cc_lhits;\n\t}\n\telog(DEBUG2, \"catcache totals: %d tup, %ld srch, %ld+%ld=%ld hits, %ld+%ld=%ld loads, %ld invals, %ld lsrch, %ld lhits\",\n\t\t CacheHdr->ch_ntup,\n\t\t cc_searches,\n\t\t cc_hits,\n\t\t cc_neg_hits,\n\t\t cc_hits + cc_neg_hits,\n\t\t cc_newloads,\n\t\t cc_searches - cc_hits - cc_neg_hits - cc_newloads,\n\t\t cc_searches - cc_hits - cc_neg_hits,\n\t\t cc_invals,\n\t\t cc_lsearches,\n\t\t cc_lhits);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CatCacheHeader *CacheHdr = NULL;",
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "DEBUG2",
            "\"catcache totals: %d tup, %ld srch, %ld+%ld=%ld hits, %ld+%ld=%ld loads, %ld invals, %ld lsrch, %ld lhits\"",
            "CacheHdr->ch_ntup",
            "cc_searches",
            "cc_hits",
            "cc_neg_hits",
            "cc_hits + cc_neg_hits",
            "cc_newloads",
            "cc_searches - cc_hits - cc_neg_hits - cc_newloads",
            "cc_searches - cc_hits - cc_neg_hits",
            "cc_invals",
            "cc_lsearches",
            "cc_lhits"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slist_container",
          "args": [
            "CatCache",
            "cc_next",
            "iter.cur"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slist_foreach",
          "args": [
            "iter",
            "&CacheHdr->ch_caches"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nstatic void\nCatCachePrintStats(int code, Datum arg)\n{\n\tslist_iter\titer;\n\tlong\t\tcc_searches = 0;\n\tlong\t\tcc_hits = 0;\n\tlong\t\tcc_neg_hits = 0;\n\tlong\t\tcc_newloads = 0;\n\tlong\t\tcc_invals = 0;\n\tlong\t\tcc_lsearches = 0;\n\tlong\t\tcc_lhits = 0;\n\n\tslist_foreach(iter, &CacheHdr->ch_caches)\n\t{\n\t\tCatCache   *cache = slist_container(CatCache, cc_next, iter.cur);\n\n\t\tif (cache->cc_ntup == 0 && cache->cc_searches == 0)\n\t\t\tcontinue;\t\t\t/* don't print unused caches */\n\t\telog(DEBUG2, \"catcache %s/%u: %d tup, %ld srch, %ld+%ld=%ld hits, %ld+%ld=%ld loads, %ld invals, %ld lsrch, %ld lhits\",\n\t\t\t cache->cc_relname,\n\t\t\t cache->cc_indexoid,\n\t\t\t cache->cc_ntup,\n\t\t\t cache->cc_searches,\n\t\t\t cache->cc_hits,\n\t\t\t cache->cc_neg_hits,\n\t\t\t cache->cc_hits + cache->cc_neg_hits,\n\t\t\t cache->cc_newloads,\n\t\t\t cache->cc_searches - cache->cc_hits - cache->cc_neg_hits - cache->cc_newloads,\n\t\t\t cache->cc_searches - cache->cc_hits - cache->cc_neg_hits,\n\t\t\t cache->cc_invals,\n\t\t\t cache->cc_lsearches,\n\t\t\t cache->cc_lhits);\n\t\tcc_searches += cache->cc_searches;\n\t\tcc_hits += cache->cc_hits;\n\t\tcc_neg_hits += cache->cc_neg_hits;\n\t\tcc_newloads += cache->cc_newloads;\n\t\tcc_invals += cache->cc_invals;\n\t\tcc_lsearches += cache->cc_lsearches;\n\t\tcc_lhits += cache->cc_lhits;\n\t}\n\telog(DEBUG2, \"catcache totals: %d tup, %ld srch, %ld+%ld=%ld hits, %ld+%ld=%ld loads, %ld invals, %ld lsrch, %ld lhits\",\n\t\t CacheHdr->ch_ntup,\n\t\t cc_searches,\n\t\t cc_hits,\n\t\t cc_neg_hits,\n\t\t cc_hits + cc_neg_hits,\n\t\t cc_newloads,\n\t\t cc_searches - cc_hits - cc_neg_hits - cc_newloads,\n\t\t cc_searches - cc_hits - cc_neg_hits,\n\t\t cc_invals,\n\t\t cc_lsearches,\n\t\t cc_lhits);\n}"
  },
  {
    "function_name": "CatalogCacheCompareTuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "389-403",
    "snippet": "static inline bool\nCatalogCacheCompareTuple(const CatCache *cache, int nkeys,\n\t\t\t\t\t\t const Datum *cachekeys,\n\t\t\t\t\t\t const Datum *searchkeys)\n{\n\tconst CCFastEqualFN *cc_fastequal = cache->cc_fastequal;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tif (!(cc_fastequal[i]) (cachekeys[i], searchkeys[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline bool CatalogCacheCompareTuple(const CatCache *cache, int nkeys,\n\t\t\t\t\t\t const Datum *cachekeys,\n\t\t\t\t\t\t const Datum *searchkeys);",
      "static void CatalogCacheInitializeCache(CatCache *cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "cachekeys[i]",
            "searchkeys[i]"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline bool CatalogCacheCompareTuple(const CatCache *cache, int nkeys,\n\t\t\t\t\t\t const Datum *cachekeys,\n\t\t\t\t\t\t const Datum *searchkeys);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nstatic inline bool\nCatalogCacheCompareTuple(const CatCache *cache, int nkeys,\n\t\t\t\t\t\t const Datum *cachekeys,\n\t\t\t\t\t\t const Datum *searchkeys)\n{\n\tconst CCFastEqualFN *cc_fastequal = cache->cc_fastequal;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tif (!(cc_fastequal[i]) (cachekeys[i], searchkeys[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "CatalogCacheComputeTupleHashValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "326-382",
    "snippet": "static uint32\nCatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys, HeapTuple tuple)\n{\n\tDatum\t\tv1 = 0,\n\t\t\t\tv2 = 0,\n\t\t\t\tv3 = 0,\n\t\t\t\tv4 = 0;\n\tbool\t\tisNull = false;\n\tint\t\t   *cc_keyno = cache->cc_keyno;\n\tTupleDesc\tcc_tupdesc = cache->cc_tupdesc;\n\n\t/* Now extract key fields from tuple, insert into scankey */\n\tswitch (nkeys)\n\t{\n\t\tcase 4:\n\t\t\tv4 = (cc_keyno[3] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[3],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 3:\n\t\t\tv3 = (cc_keyno[2] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[2],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\tv2 = (cc_keyno[1] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[1],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\tv1 = (cc_keyno[0] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[0],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"wrong number of hash keys: %d\", nkeys);\n\t\t\tbreak;\n\t}\n\n\treturn CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
      "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
      "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
      "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
      "static void CatalogCacheInitializeCache(CatCache *cache);",
      "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CatalogCacheComputeHashValue",
          "args": [
            "cache",
            "nkeys",
            "v1",
            "v2",
            "v3",
            "v4"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "CatalogCacheComputeHashValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "275-319",
          "snippet": "static uint32\nCatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4)\n{\n\tuint32\t\thashValue = 0;\n\tuint32\t\toneHash;\n\tCCHashFN   *cc_hashfunc = cache->cc_hashfunc;\n\n\tCACHE4_elog(DEBUG2, \"CatalogCacheComputeHashValue %s %d %p\",\n\t\t\t\tcache->cc_relname,\n\t\t\t\tnkeys,\n\t\t\t\tcache);\n\n\tswitch (nkeys)\n\t{\n\t\tcase 4:\n\t\t\toneHash = (cc_hashfunc[3]) (v4);\n\n\t\t\thashValue ^= oneHash << 24;\n\t\t\thashValue ^= oneHash >> 8;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 3:\n\t\t\toneHash = (cc_hashfunc[2]) (v3);\n\n\t\t\thashValue ^= oneHash << 16;\n\t\t\thashValue ^= oneHash >> 16;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\toneHash = (cc_hashfunc[1]) (v2);\n\n\t\t\thashValue ^= oneHash << 8;\n\t\t\thashValue ^= oneHash >> 24;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\toneHash = (cc_hashfunc[0]) (v1);\n\n\t\t\thashValue ^= oneHash;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"wrong number of hash keys: %d\", nkeys);\n\t\t\tbreak;\n\t}\n\n\treturn hashValue;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
            "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
            "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
            "static void CatalogCacheInitializeCache(CatCache *cache);",
            "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic uint32\nCatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4)\n{\n\tuint32\t\thashValue = 0;\n\tuint32\t\toneHash;\n\tCCHashFN   *cc_hashfunc = cache->cc_hashfunc;\n\n\tCACHE4_elog(DEBUG2, \"CatalogCacheComputeHashValue %s %d %p\",\n\t\t\t\tcache->cc_relname,\n\t\t\t\tnkeys,\n\t\t\t\tcache);\n\n\tswitch (nkeys)\n\t{\n\t\tcase 4:\n\t\t\toneHash = (cc_hashfunc[3]) (v4);\n\n\t\t\thashValue ^= oneHash << 24;\n\t\t\thashValue ^= oneHash >> 8;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 3:\n\t\t\toneHash = (cc_hashfunc[2]) (v3);\n\n\t\t\thashValue ^= oneHash << 16;\n\t\t\thashValue ^= oneHash >> 16;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\toneHash = (cc_hashfunc[1]) (v2);\n\n\t\t\thashValue ^= oneHash << 8;\n\t\t\thashValue ^= oneHash >> 24;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\toneHash = (cc_hashfunc[0]) (v1);\n\n\t\t\thashValue ^= oneHash;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"wrong number of hash keys: %d\", nkeys);\n\t\t\tbreak;\n\t}\n\n\treturn hashValue;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"wrong number of hash keys: %d\"",
            "nkeys"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isNull"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastgetattr",
          "args": [
            "tuple",
            "cc_keyno[0]",
            "cc_tupdesc",
            "&isNull"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "HeapTupleGetOid(tuple)"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "tuple"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isNull"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastgetattr",
          "args": [
            "tuple",
            "cc_keyno[1]",
            "cc_tupdesc",
            "&isNull"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "HeapTupleGetOid(tuple)"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "tuple"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isNull"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastgetattr",
          "args": [
            "tuple",
            "cc_keyno[2]",
            "cc_tupdesc",
            "&isNull"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "HeapTupleGetOid(tuple)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "tuple"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isNull"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastgetattr",
          "args": [
            "tuple",
            "cc_keyno[3]",
            "cc_tupdesc",
            "&isNull"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "HeapTupleGetOid(tuple)"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "tuple"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic uint32\nCatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys, HeapTuple tuple)\n{\n\tDatum\t\tv1 = 0,\n\t\t\t\tv2 = 0,\n\t\t\t\tv3 = 0,\n\t\t\t\tv4 = 0;\n\tbool\t\tisNull = false;\n\tint\t\t   *cc_keyno = cache->cc_keyno;\n\tTupleDesc\tcc_tupdesc = cache->cc_tupdesc;\n\n\t/* Now extract key fields from tuple, insert into scankey */\n\tswitch (nkeys)\n\t{\n\t\tcase 4:\n\t\t\tv4 = (cc_keyno[3] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[3],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 3:\n\t\t\tv3 = (cc_keyno[2] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[2],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\tv2 = (cc_keyno[1] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[1],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\tv1 = (cc_keyno[0] == ObjectIdAttributeNumber)\n\t\t\t\t? ObjectIdGetDatum(HeapTupleGetOid(tuple))\n\t\t\t\t: fastgetattr(tuple,\n\t\t\t\t\t\t\t  cc_keyno[0],\n\t\t\t\t\t\t\t  cc_tupdesc,\n\t\t\t\t\t\t\t  &isNull);\n\t\t\tAssert(!isNull);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"wrong number of hash keys: %d\", nkeys);\n\t\t\tbreak;\n\t}\n\n\treturn CatalogCacheComputeHashValue(cache, nkeys, v1, v2, v3, v4);\n}"
  },
  {
    "function_name": "CatalogCacheComputeHashValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "275-319",
    "snippet": "static uint32\nCatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4)\n{\n\tuint32\t\thashValue = 0;\n\tuint32\t\toneHash;\n\tCCHashFN   *cc_hashfunc = cache->cc_hashfunc;\n\n\tCACHE4_elog(DEBUG2, \"CatalogCacheComputeHashValue %s %d %p\",\n\t\t\t\tcache->cc_relname,\n\t\t\t\tnkeys,\n\t\t\t\tcache);\n\n\tswitch (nkeys)\n\t{\n\t\tcase 4:\n\t\t\toneHash = (cc_hashfunc[3]) (v4);\n\n\t\t\thashValue ^= oneHash << 24;\n\t\t\thashValue ^= oneHash >> 8;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 3:\n\t\t\toneHash = (cc_hashfunc[2]) (v3);\n\n\t\t\thashValue ^= oneHash << 16;\n\t\t\thashValue ^= oneHash >> 16;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\toneHash = (cc_hashfunc[1]) (v2);\n\n\t\t\thashValue ^= oneHash << 8;\n\t\t\thashValue ^= oneHash >> 24;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\toneHash = (cc_hashfunc[0]) (v1);\n\n\t\t\thashValue ^= oneHash;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"wrong number of hash keys: %d\", nkeys);\n\t\t\tbreak;\n\t}\n\n\treturn hashValue;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);",
      "static pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);",
      "static uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);",
      "static void CatalogCacheInitializeCache(CatCache *cache);",
      "static void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"wrong number of hash keys: %d\"",
            "nkeys"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "v1"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "v2"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "v3"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "v4"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CACHE4_elog",
          "args": [
            "DEBUG2",
            "\"CatalogCacheComputeHashValue %s %d %p\"",
            "cache->cc_relname",
            "nkeys",
            "cache"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic inline HeapTuple SearchCatCacheInternal(CatCache *cache,\n\t\t\t\t\t   int nkeys,\n\t\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t\t   Datum v3, Datum v4);\nstatic pg_noinline HeapTuple SearchCatCacheMiss(CatCache *cache,\n\t\t\t\t   int nkeys,\n\t\t\t\t   uint32 hashValue,\n\t\t\t\t   Index hashIndex,\n\t\t\t\t   Datum v1, Datum v2,\n\t\t\t\t   Datum v3, Datum v4);\nstatic uint32 CatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\nstatic void CatCacheFreeKeys(TupleDesc tupdesc, int nkeys, int *attnos,\n\t\t\t\t Datum *keys);\n\nstatic uint32\nCatalogCacheComputeHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t Datum v1, Datum v2, Datum v3, Datum v4)\n{\n\tuint32\t\thashValue = 0;\n\tuint32\t\toneHash;\n\tCCHashFN   *cc_hashfunc = cache->cc_hashfunc;\n\n\tCACHE4_elog(DEBUG2, \"CatalogCacheComputeHashValue %s %d %p\",\n\t\t\t\tcache->cc_relname,\n\t\t\t\tnkeys,\n\t\t\t\tcache);\n\n\tswitch (nkeys)\n\t{\n\t\tcase 4:\n\t\t\toneHash = (cc_hashfunc[3]) (v4);\n\n\t\t\thashValue ^= oneHash << 24;\n\t\t\thashValue ^= oneHash >> 8;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 3:\n\t\t\toneHash = (cc_hashfunc[2]) (v3);\n\n\t\t\thashValue ^= oneHash << 16;\n\t\t\thashValue ^= oneHash >> 16;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\toneHash = (cc_hashfunc[1]) (v2);\n\n\t\t\thashValue ^= oneHash << 8;\n\t\t\thashValue ^= oneHash >> 24;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\toneHash = (cc_hashfunc[0]) (v1);\n\n\t\t\thashValue ^= oneHash;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"wrong number of hash keys: %d\", nkeys);\n\t\t\tbreak;\n\t}\n\n\treturn hashValue;\n}"
  },
  {
    "function_name": "GetCCHashEqFuncs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "206-268",
    "snippet": "static void\nGetCCHashEqFuncs(Oid keytype, CCHashFN *hashfunc, RegProcedure *eqfunc, CCFastEqualFN *fasteqfunc)\n{\n\tswitch (keytype)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*hashfunc = charhashfast;\n\t\t\t*fasteqfunc = chareqfast;\n\t\t\t*eqfunc = F_BOOLEQ;\n\t\t\tbreak;\n\t\tcase CHAROID:\n\t\t\t*hashfunc = charhashfast;\n\t\t\t*fasteqfunc = chareqfast;\n\t\t\t*eqfunc = F_CHAREQ;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\t*hashfunc = namehashfast;\n\t\t\t*fasteqfunc = nameeqfast;\n\t\t\t*eqfunc = F_NAMEEQ;\n\t\t\tbreak;\n\t\tcase INT2OID:\n\t\t\t*hashfunc = int2hashfast;\n\t\t\t*fasteqfunc = int2eqfast;\n\t\t\t*eqfunc = F_INT2EQ;\n\t\t\tbreak;\n\t\tcase INT4OID:\n\t\t\t*hashfunc = int4hashfast;\n\t\t\t*fasteqfunc = int4eqfast;\n\t\t\t*eqfunc = F_INT4EQ;\n\t\t\tbreak;\n\t\tcase TEXTOID:\n\t\t\t*hashfunc = texthashfast;\n\t\t\t*fasteqfunc = texteqfast;\n\t\t\t*eqfunc = F_TEXTEQ;\n\t\t\tbreak;\n\t\tcase OIDOID:\n\t\tcase REGPROCOID:\n\t\tcase REGPROCEDUREOID:\n\t\tcase REGOPEROID:\n\t\tcase REGOPERATOROID:\n\t\tcase REGCLASSOID:\n\t\tcase REGTYPEOID:\n\t\tcase REGCONFIGOID:\n\t\tcase REGDICTIONARYOID:\n\t\tcase REGROLEOID:\n\t\tcase REGNAMESPACEOID:\n\t\t\t*hashfunc = int4hashfast;\n\t\t\t*fasteqfunc = int4eqfast;\n\t\t\t*eqfunc = F_OIDEQ;\n\t\t\tbreak;\n\t\tcase OIDVECTOROID:\n\t\t\t*hashfunc = oidvectorhashfast;\n\t\t\t*fasteqfunc = oidvectoreqfast;\n\t\t\t*eqfunc = F_OIDVECTOREQ;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"type %u not supported as catcache key\", keytype);\n\t\t\t*hashfunc = NULL;\t/* keep compiler quiet */\n\n\t\t\t*eqfunc = InvalidOid;\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"type %u not supported as catcache key\"",
            "keytype"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void\nGetCCHashEqFuncs(Oid keytype, CCHashFN *hashfunc, RegProcedure *eqfunc, CCFastEqualFN *fasteqfunc)\n{\n\tswitch (keytype)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*hashfunc = charhashfast;\n\t\t\t*fasteqfunc = chareqfast;\n\t\t\t*eqfunc = F_BOOLEQ;\n\t\t\tbreak;\n\t\tcase CHAROID:\n\t\t\t*hashfunc = charhashfast;\n\t\t\t*fasteqfunc = chareqfast;\n\t\t\t*eqfunc = F_CHAREQ;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\t*hashfunc = namehashfast;\n\t\t\t*fasteqfunc = nameeqfast;\n\t\t\t*eqfunc = F_NAMEEQ;\n\t\t\tbreak;\n\t\tcase INT2OID:\n\t\t\t*hashfunc = int2hashfast;\n\t\t\t*fasteqfunc = int2eqfast;\n\t\t\t*eqfunc = F_INT2EQ;\n\t\t\tbreak;\n\t\tcase INT4OID:\n\t\t\t*hashfunc = int4hashfast;\n\t\t\t*fasteqfunc = int4eqfast;\n\t\t\t*eqfunc = F_INT4EQ;\n\t\t\tbreak;\n\t\tcase TEXTOID:\n\t\t\t*hashfunc = texthashfast;\n\t\t\t*fasteqfunc = texteqfast;\n\t\t\t*eqfunc = F_TEXTEQ;\n\t\t\tbreak;\n\t\tcase OIDOID:\n\t\tcase REGPROCOID:\n\t\tcase REGPROCEDUREOID:\n\t\tcase REGOPEROID:\n\t\tcase REGOPERATOROID:\n\t\tcase REGCLASSOID:\n\t\tcase REGTYPEOID:\n\t\tcase REGCONFIGOID:\n\t\tcase REGDICTIONARYOID:\n\t\tcase REGROLEOID:\n\t\tcase REGNAMESPACEOID:\n\t\t\t*hashfunc = int4hashfast;\n\t\t\t*fasteqfunc = int4eqfast;\n\t\t\t*eqfunc = F_OIDEQ;\n\t\t\tbreak;\n\t\tcase OIDVECTOROID:\n\t\t\t*hashfunc = oidvectorhashfast;\n\t\t\t*fasteqfunc = oidvectoreqfast;\n\t\t\t*eqfunc = F_OIDVECTOREQ;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"type %u not supported as catcache key\", keytype);\n\t\t\t*hashfunc = NULL;\t/* keep compiler quiet */\n\n\t\t\t*eqfunc = InvalidOid;\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "oidvectorhashfast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "199-203",
    "snippet": "static uint32\noidvectorhashfast(Datum datum)\n{\n\treturn DatumGetInt32(DirectFunctionCall1(hashoidvector, datum));\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "DirectFunctionCall1(hashoidvector, datum)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "hashoidvector",
            "datum"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic uint32\noidvectorhashfast(Datum datum)\n{\n\treturn DatumGetInt32(DirectFunctionCall1(hashoidvector, datum));\n}"
  },
  {
    "function_name": "oidvectoreqfast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "193-197",
    "snippet": "static bool\noidvectoreqfast(Datum a, Datum b)\n{\n\treturn DatumGetBool(DirectFunctionCall2(oidvectoreq, a, b));\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(oidvectoreq, a, b)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "oidvectoreq",
            "a",
            "b"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic bool\noidvectoreqfast(Datum a, Datum b)\n{\n\treturn DatumGetBool(DirectFunctionCall2(oidvectoreq, a, b));\n}"
  },
  {
    "function_name": "texthashfast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "187-191",
    "snippet": "static uint32\ntexthashfast(Datum datum)\n{\n\treturn DatumGetInt32(DirectFunctionCall1(hashtext, datum));\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "DirectFunctionCall1(hashtext, datum)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "hashtext",
            "datum"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic uint32\ntexthashfast(Datum datum)\n{\n\treturn DatumGetInt32(DirectFunctionCall1(hashtext, datum));\n}"
  },
  {
    "function_name": "texteqfast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "181-185",
    "snippet": "static bool\ntexteqfast(Datum a, Datum b)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq, a, b));\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(texteq, a, b)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "texteq",
            "a",
            "b"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic bool\ntexteqfast(Datum a, Datum b)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq, a, b));\n}"
  },
  {
    "function_name": "int4hashfast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "175-179",
    "snippet": "static uint32\nint4hashfast(Datum datum)\n{\n\treturn murmurhash32((int32) DatumGetInt32(datum));\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "murmurhash32",
          "args": [
            "(int32) DatumGetInt32(datum)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "datum"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic uint32\nint4hashfast(Datum datum)\n{\n\treturn murmurhash32((int32) DatumGetInt32(datum));\n}"
  },
  {
    "function_name": "int4eqfast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "169-173",
    "snippet": "static bool\nint4eqfast(Datum a, Datum b)\n{\n\treturn DatumGetInt32(a) == DatumGetInt32(b);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "b"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "a"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic bool\nint4eqfast(Datum a, Datum b)\n{\n\treturn DatumGetInt32(a) == DatumGetInt32(b);\n}"
  },
  {
    "function_name": "int2hashfast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "163-167",
    "snippet": "static uint32\nint2hashfast(Datum datum)\n{\n\treturn murmurhash32((int32) DatumGetInt16(datum));\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "murmurhash32",
          "args": [
            "(int32) DatumGetInt16(datum)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt16",
          "args": [
            "datum"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic uint32\nint2hashfast(Datum datum)\n{\n\treturn murmurhash32((int32) DatumGetInt16(datum));\n}"
  },
  {
    "function_name": "int2eqfast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "157-161",
    "snippet": "static bool\nint2eqfast(Datum a, Datum b)\n{\n\treturn DatumGetInt16(a) == DatumGetInt16(b);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetInt16",
          "args": [
            "b"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt16",
          "args": [
            "a"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic bool\nint2eqfast(Datum a, Datum b)\n{\n\treturn DatumGetInt16(a) == DatumGetInt16(b);\n}"
  },
  {
    "function_name": "namehashfast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "149-155",
    "snippet": "static uint32\nnamehashfast(Datum datum)\n{\n\tchar\t   *key = NameStr(*DatumGetName(datum));\n\n\treturn hash_any((unsigned char *) key, strlen(key));\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_any",
          "args": [
            "(unsigned char *) key",
            "strlen(key)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*DatumGetName(datum)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetName",
          "args": [
            "datum"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic uint32\nnamehashfast(Datum datum)\n{\n\tchar\t   *key = NameStr(*DatumGetName(datum));\n\n\treturn hash_any((unsigned char *) key, strlen(key));\n}"
  },
  {
    "function_name": "nameeqfast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "140-147",
    "snippet": "static bool\nnameeqfast(Datum a, Datum b)\n{\n\tchar\t   *ca = NameStr(*DatumGetName(a));\n\tchar\t   *cb = NameStr(*DatumGetName(b));\n\n\treturn strncmp(ca, cb, NAMEDATALEN) == 0;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ca",
            "cb",
            "NAMEDATALEN"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_and_wchar_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "54-67",
          "snippet": "int\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nint\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*DatumGetName(b)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetName",
          "args": [
            "b"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*DatumGetName(a)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetName",
          "args": [
            "a"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic bool\nnameeqfast(Datum a, Datum b)\n{\n\tchar\t   *ca = NameStr(*DatumGetName(a));\n\tchar\t   *cb = NameStr(*DatumGetName(b));\n\n\treturn strncmp(ca, cb, NAMEDATALEN) == 0;\n}"
  },
  {
    "function_name": "charhashfast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "134-138",
    "snippet": "static uint32\ncharhashfast(Datum datum)\n{\n\treturn murmurhash32((int32) DatumGetChar(datum));\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "murmurhash32",
          "args": [
            "(int32) DatumGetChar(datum)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetChar",
          "args": [
            "datum"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic uint32\ncharhashfast(Datum datum)\n{\n\treturn murmurhash32((int32) DatumGetChar(datum));\n}"
  },
  {
    "function_name": "chareqfast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
    "lines": "128-132",
    "snippet": "static bool\nchareqfast(Datum a, Datum b)\n{\n\treturn DatumGetChar(a) == DatumGetChar(b);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hashutils.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/valid.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/relscan.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetChar",
          "args": [
            "b"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetChar",
          "args": [
            "a"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic bool\nchareqfast(Datum a, Datum b)\n{\n\treturn DatumGetChar(a) == DatumGetChar(b);\n}"
  }
]