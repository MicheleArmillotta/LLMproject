[
  {
    "function_name": "QTNClearFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
    "lines": "432-447",
    "snippet": "void\nQTNClearFlags(QTNode *in, uint32 flags)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tin->flags &= ~flags;\n\n\tif (in->valnode->type != QI_VAL)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNClearFlags(in->child[i], flags);\n\t}\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QTNClearFlags",
          "args": [
            "in->child[i]",
            "flags"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "QTNClearFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "432-447",
          "snippet": "void\nQTNClearFlags(QTNode *in, uint32 flags)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tin->flags &= ~flags;\n\n\tif (in->valnode->type != QI_VAL)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNClearFlags(in->child[i], flags);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNClearFlags(QTNode *in, uint32 flags)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tin->flags &= ~flags;\n\n\tif (in->valnode->type != QI_VAL)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNClearFlags(in->child[i], flags);\n\t}\n}"
  },
  {
    "function_name": "QTNCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
    "lines": "394-427",
    "snippet": "QTNode *\nQTNCopy(QTNode *in)\n{\n\tQTNode\t   *out;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tout = (QTNode *) palloc(sizeof(QTNode));\n\n\t*out = *in;\n\tout->valnode = (QueryItem *) palloc(sizeof(QueryItem));\n\t*(out->valnode) = *(in->valnode);\n\tout->flags |= QTN_NEEDFREE;\n\n\tif (in->valnode->type == QI_VAL)\n\t{\n\t\tout->word = palloc(in->valnode->qoperand.length + 1);\n\t\tmemcpy(out->word, in->word, in->valnode->qoperand.length);\n\t\tout->word[in->valnode->qoperand.length] = '\\0';\n\t\tout->flags |= QTN_WORDFREE;\n\t}\n\telse\n\t{\n\t\tint\t\t\ti;\n\n\t\tout->child = (QTNode **) palloc(sizeof(QTNode *) * in->nchild);\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tout->child[i] = QTNCopy(in->child[i]);\n\t}\n\n\treturn out;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QTNCopy",
          "args": [
            "in->child[i]"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "QTNCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "394-427",
          "snippet": "QTNode *\nQTNCopy(QTNode *in)\n{\n\tQTNode\t   *out;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tout = (QTNode *) palloc(sizeof(QTNode));\n\n\t*out = *in;\n\tout->valnode = (QueryItem *) palloc(sizeof(QueryItem));\n\t*(out->valnode) = *(in->valnode);\n\tout->flags |= QTN_NEEDFREE;\n\n\tif (in->valnode->type == QI_VAL)\n\t{\n\t\tout->word = palloc(in->valnode->qoperand.length + 1);\n\t\tmemcpy(out->word, in->word, in->valnode->qoperand.length);\n\t\tout->word[in->valnode->qoperand.length] = '\\0';\n\t\tout->flags |= QTN_WORDFREE;\n\t}\n\telse\n\t{\n\t\tint\t\t\ti;\n\n\t\tout->child = (QTNode **) palloc(sizeof(QTNode *) * in->nchild);\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tout->child[i] = QTNCopy(in->child[i]);\n\t}\n\n\treturn out;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(QTNode *) * in->nchild"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out->word",
            "in->word",
            "in->valnode->qoperand.length"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nQTNode *\nQTNCopy(QTNode *in)\n{\n\tQTNode\t   *out;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tout = (QTNode *) palloc(sizeof(QTNode));\n\n\t*out = *in;\n\tout->valnode = (QueryItem *) palloc(sizeof(QueryItem));\n\t*(out->valnode) = *(in->valnode);\n\tout->flags |= QTN_NEEDFREE;\n\n\tif (in->valnode->type == QI_VAL)\n\t{\n\t\tout->word = palloc(in->valnode->qoperand.length + 1);\n\t\tmemcpy(out->word, in->word, in->valnode->qoperand.length);\n\t\tout->word[in->valnode->qoperand.length] = '\\0';\n\t\tout->flags |= QTN_WORDFREE;\n\t}\n\telse\n\t{\n\t\tint\t\t\ti;\n\n\t\tout->child = (QTNode **) palloc(sizeof(QTNode *) * in->nchild);\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tout->child[i] = QTNCopy(in->child[i]);\n\t}\n\n\treturn out;\n}"
  },
  {
    "function_name": "QTN2QT",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
    "lines": "361-387",
    "snippet": "TSQuery\nQTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\n\tcntsize(in, &sumlen, &nnode);\n\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\n\tfillQT(&state, in);\n\treturn out;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fillQT",
          "args": [
            "&state",
            "in"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "fillQT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "321-356",
          "snippet": "static void\nfillQT(QTN2QTState *state, QTNode *in)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL)\n\t{\n\t\tmemcpy(state->curitem, in->valnode, sizeof(QueryOperand));\n\n\t\tmemcpy(state->curoperand, in->word, in->valnode->qoperand.length);\n\t\tstate->curitem->qoperand.distance = state->curoperand - state->operand;\n\t\tstate->curoperand[in->valnode->qoperand.length] = '\\0';\n\t\tstate->curoperand += in->valnode->qoperand.length + 1;\n\t\tstate->curitem++;\n\t}\n\telse\n\t{\n\t\tQueryItem  *curitem = state->curitem;\n\n\t\tAssert(in->valnode->type == QI_OPR);\n\n\t\tmemcpy(state->curitem, in->valnode, sizeof(QueryOperator));\n\n\t\tAssert(in->nchild <= 2);\n\t\tstate->curitem++;\n\n\t\tfillQT(state, in->child[0]);\n\n\t\tif (in->nchild == 2)\n\t\t{\n\t\t\tcuritem->qoperator.left = state->curitem - curitem;\n\t\t\tfillQT(state, in->child[1]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic void\nfillQT(QTN2QTState *state, QTNode *in)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL)\n\t{\n\t\tmemcpy(state->curitem, in->valnode, sizeof(QueryOperand));\n\n\t\tmemcpy(state->curoperand, in->word, in->valnode->qoperand.length);\n\t\tstate->curitem->qoperand.distance = state->curoperand - state->operand;\n\t\tstate->curoperand[in->valnode->qoperand.length] = '\\0';\n\t\tstate->curoperand += in->valnode->qoperand.length + 1;\n\t\tstate->curitem++;\n\t}\n\telse\n\t{\n\t\tQueryItem  *curitem = state->curitem;\n\n\t\tAssert(in->valnode->type == QI_OPR);\n\n\t\tmemcpy(state->curitem, in->valnode, sizeof(QueryOperator));\n\n\t\tAssert(in->nchild <= 2);\n\t\tstate->curitem++;\n\n\t\tfillQT(state, in->child[0]);\n\n\t\tif (in->nchild == 2)\n\t\t{\n\t\t\tcuritem->qoperator.left = state->curitem - curitem;\n\t\t\tfillQT(state, in->child[1]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "out"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "out"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "out",
            "len"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "len"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COMPUTESIZE",
          "args": [
            "nnode",
            "sumlen"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\"))"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"tsquery is too large\""
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSQUERY_TOO_BIG",
          "args": [
            "nnode",
            "sumlen"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cntsize",
          "args": [
            "in",
            "&sumlen",
            "&nnode"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "cntsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "290-308",
          "snippet": "static void\ncntsize(QTNode *in, int *sumlen, int *nnode)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\t*nnode += 1;\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tcntsize(in->child[i], sumlen, nnode);\n\t}\n\telse\n\t{\n\t\t*sumlen += in->valnode->qoperand.length + 1;\n\t}\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic void\ncntsize(QTNode *in, int *sumlen, int *nnode)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\t*nnode += 1;\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tcntsize(in->child[i], sumlen, nnode);\n\t}\n\telse\n\t{\n\t\t*sumlen += in->valnode->qoperand.length + 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nTSQuery\nQTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\n\tcntsize(in, &sumlen, &nnode);\n\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\n\tfillQT(&state, in);\n\treturn out;\n}"
  },
  {
    "function_name": "fillQT",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
    "lines": "321-356",
    "snippet": "static void\nfillQT(QTN2QTState *state, QTNode *in)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL)\n\t{\n\t\tmemcpy(state->curitem, in->valnode, sizeof(QueryOperand));\n\n\t\tmemcpy(state->curoperand, in->word, in->valnode->qoperand.length);\n\t\tstate->curitem->qoperand.distance = state->curoperand - state->operand;\n\t\tstate->curoperand[in->valnode->qoperand.length] = '\\0';\n\t\tstate->curoperand += in->valnode->qoperand.length + 1;\n\t\tstate->curitem++;\n\t}\n\telse\n\t{\n\t\tQueryItem  *curitem = state->curitem;\n\n\t\tAssert(in->valnode->type == QI_OPR);\n\n\t\tmemcpy(state->curitem, in->valnode, sizeof(QueryOperator));\n\n\t\tAssert(in->nchild <= 2);\n\t\tstate->curitem++;\n\n\t\tfillQT(state, in->child[0]);\n\n\t\tif (in->nchild == 2)\n\t\t{\n\t\t\tcuritem->qoperator.left = state->curitem - curitem;\n\t\t\tfillQT(state, in->child[1]);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fillQT",
          "args": [
            "state",
            "in->child[1]"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "fillQT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "321-356",
          "snippet": "static void\nfillQT(QTN2QTState *state, QTNode *in)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL)\n\t{\n\t\tmemcpy(state->curitem, in->valnode, sizeof(QueryOperand));\n\n\t\tmemcpy(state->curoperand, in->word, in->valnode->qoperand.length);\n\t\tstate->curitem->qoperand.distance = state->curoperand - state->operand;\n\t\tstate->curoperand[in->valnode->qoperand.length] = '\\0';\n\t\tstate->curoperand += in->valnode->qoperand.length + 1;\n\t\tstate->curitem++;\n\t}\n\telse\n\t{\n\t\tQueryItem  *curitem = state->curitem;\n\n\t\tAssert(in->valnode->type == QI_OPR);\n\n\t\tmemcpy(state->curitem, in->valnode, sizeof(QueryOperator));\n\n\t\tAssert(in->nchild <= 2);\n\t\tstate->curitem++;\n\n\t\tfillQT(state, in->child[0]);\n\n\t\tif (in->nchild == 2)\n\t\t{\n\t\t\tcuritem->qoperator.left = state->curitem - curitem;\n\t\t\tfillQT(state, in->child[1]);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "in->nchild <= 2"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state->curitem",
            "in->valnode",
            "sizeof(QueryOperator)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "in->valnode->type == QI_OPR"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state->curoperand",
            "in->word",
            "in->valnode->qoperand.length"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state->curitem",
            "in->valnode",
            "sizeof(QueryOperand)"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic void\nfillQT(QTN2QTState *state, QTNode *in)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL)\n\t{\n\t\tmemcpy(state->curitem, in->valnode, sizeof(QueryOperand));\n\n\t\tmemcpy(state->curoperand, in->word, in->valnode->qoperand.length);\n\t\tstate->curitem->qoperand.distance = state->curoperand - state->operand;\n\t\tstate->curoperand[in->valnode->qoperand.length] = '\\0';\n\t\tstate->curoperand += in->valnode->qoperand.length + 1;\n\t\tstate->curitem++;\n\t}\n\telse\n\t{\n\t\tQueryItem  *curitem = state->curitem;\n\n\t\tAssert(in->valnode->type == QI_OPR);\n\n\t\tmemcpy(state->curitem, in->valnode, sizeof(QueryOperator));\n\n\t\tAssert(in->nchild <= 2);\n\t\tstate->curitem++;\n\n\t\tfillQT(state, in->child[0]);\n\n\t\tif (in->nchild == 2)\n\t\t{\n\t\t\tcuritem->qoperator.left = state->curitem - curitem;\n\t\t\tfillQT(state, in->child[1]);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "cntsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
    "lines": "290-308",
    "snippet": "static void\ncntsize(QTNode *in, int *sumlen, int *nnode)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\t*nnode += 1;\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tcntsize(in->child[i], sumlen, nnode);\n\t}\n\telse\n\t{\n\t\t*sumlen += in->valnode->qoperand.length + 1;\n\t}\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cntsize",
          "args": [
            "in->child[i]",
            "sumlen",
            "nnode"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "cntsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "290-308",
          "snippet": "static void\ncntsize(QTNode *in, int *sumlen, int *nnode)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\t*nnode += 1;\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tcntsize(in->child[i], sumlen, nnode);\n\t}\n\telse\n\t{\n\t\t*sumlen += in->valnode->qoperand.length + 1;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic void\ncntsize(QTNode *in, int *sumlen, int *nnode)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\t*nnode += 1;\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tcntsize(in->child[i], sumlen, nnode);\n\t}\n\telse\n\t{\n\t\t*sumlen += in->valnode->qoperand.length + 1;\n\t}\n}"
  },
  {
    "function_name": "QTNBinary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
    "lines": "248-283",
    "snippet": "void\nQTNBinary(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNBinary(in->child[i]);\n\n\twhile (in->nchild > 2)\n\t{\n\t\tQTNode\t   *nn = (QTNode *) palloc0(sizeof(QTNode));\n\n\t\tnn->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\t\tnn->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\n\t\tnn->nchild = 2;\n\t\tnn->flags = QTN_NEEDFREE;\n\n\t\tnn->child[0] = in->child[0];\n\t\tnn->child[1] = in->child[1];\n\t\tnn->sign = nn->child[0]->sign | nn->child[1]->sign;\n\n\t\tnn->valnode->type = in->valnode->type;\n\t\tnn->valnode->qoperator.oper = in->valnode->qoperator.oper;\n\n\t\tin->child[0] = nn;\n\t\tin->child[1] = in->child[in->nchild - 1];\n\t\tin->nchild--;\n\t}\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(QTNode *) * 2"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTNBinary",
          "args": [
            "in->child[i]"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "QTNBinary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "248-283",
          "snippet": "void\nQTNBinary(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNBinary(in->child[i]);\n\n\twhile (in->nchild > 2)\n\t{\n\t\tQTNode\t   *nn = (QTNode *) palloc0(sizeof(QTNode));\n\n\t\tnn->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\t\tnn->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\n\t\tnn->nchild = 2;\n\t\tnn->flags = QTN_NEEDFREE;\n\n\t\tnn->child[0] = in->child[0];\n\t\tnn->child[1] = in->child[1];\n\t\tnn->sign = nn->child[0]->sign | nn->child[1]->sign;\n\n\t\tnn->valnode->type = in->valnode->type;\n\t\tnn->valnode->qoperator.oper = in->valnode->qoperator.oper;\n\n\t\tin->child[0] = nn;\n\t\tin->child[1] = in->child[in->nchild - 1];\n\t\tin->nchild--;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNBinary(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNBinary(in->child[i]);\n\n\twhile (in->nchild > 2)\n\t{\n\t\tQTNode\t   *nn = (QTNode *) palloc0(sizeof(QTNode));\n\n\t\tnn->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\t\tnn->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\n\t\tnn->nchild = 2;\n\t\tnn->flags = QTN_NEEDFREE;\n\n\t\tnn->child[0] = in->child[0];\n\t\tnn->child[1] = in->child[1];\n\t\tnn->sign = nn->child[0]->sign | nn->child[1]->sign;\n\n\t\tnn->valnode->type = in->valnode->type;\n\t\tnn->valnode->qoperator.oper = in->valnode->qoperator.oper;\n\n\t\tin->child[0] = nn;\n\t\tin->child[1] = in->child[in->nchild - 1];\n\t\tin->nchild--;\n\t}\n}"
  },
  {
    "function_name": "QTNTernary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
    "lines": "199-242",
    "snippet": "void\nQTNTernary(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNTernary(in->child[i]);\n\n\t/* Only AND and OR are associative, so don't flatten other node types */\n\tif (in->valnode->qoperator.oper != OP_AND &&\n\t\tin->valnode->qoperator.oper != OP_OR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t{\n\t\tQTNode\t   *cc = in->child[i];\n\n\t\tif (cc->valnode->type == QI_OPR &&\n\t\t\tin->valnode->qoperator.oper == cc->valnode->qoperator.oper)\n\t\t{\n\t\t\tint\t\t\toldnchild = in->nchild;\n\n\t\t\tin->nchild += cc->nchild - 1;\n\t\t\tin->child = (QTNode **) repalloc(in->child, in->nchild * sizeof(QTNode *));\n\n\t\t\tif (i + 1 != oldnchild)\n\t\t\t\tmemmove(in->child + i + cc->nchild, in->child + i + 1,\n\t\t\t\t\t\t(oldnchild - i - 1) * sizeof(QTNode *));\n\n\t\t\tmemcpy(in->child + i, cc->child, cc->nchild * sizeof(QTNode *));\n\t\t\ti += cc->nchild - 1;\n\n\t\t\tif (cc->flags & QTN_NEEDFREE)\n\t\t\t\tpfree(cc->valnode);\n\t\t\tpfree(cc);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "cc"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "in->child + i",
            "cc->child",
            "cc->nchild * sizeof(QTNode *)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "in->child + i + cc->nchild",
            "in->child + i + 1",
            "(oldnchild - i - 1) * sizeof(QTNode *)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "in->child",
            "in->nchild * sizeof(QTNode *)"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTNTernary",
          "args": [
            "in->child[i]"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "QTNTernary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "199-242",
          "snippet": "void\nQTNTernary(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNTernary(in->child[i]);\n\n\t/* Only AND and OR are associative, so don't flatten other node types */\n\tif (in->valnode->qoperator.oper != OP_AND &&\n\t\tin->valnode->qoperator.oper != OP_OR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t{\n\t\tQTNode\t   *cc = in->child[i];\n\n\t\tif (cc->valnode->type == QI_OPR &&\n\t\t\tin->valnode->qoperator.oper == cc->valnode->qoperator.oper)\n\t\t{\n\t\t\tint\t\t\toldnchild = in->nchild;\n\n\t\t\tin->nchild += cc->nchild - 1;\n\t\t\tin->child = (QTNode **) repalloc(in->child, in->nchild * sizeof(QTNode *));\n\n\t\t\tif (i + 1 != oldnchild)\n\t\t\t\tmemmove(in->child + i + cc->nchild, in->child + i + 1,\n\t\t\t\t\t\t(oldnchild - i - 1) * sizeof(QTNode *));\n\n\t\t\tmemcpy(in->child + i, cc->child, cc->nchild * sizeof(QTNode *));\n\t\t\ti += cc->nchild - 1;\n\n\t\t\tif (cc->flags & QTN_NEEDFREE)\n\t\t\t\tpfree(cc->valnode);\n\t\t\tpfree(cc);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNTernary(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNTernary(in->child[i]);\n\n\t/* Only AND and OR are associative, so don't flatten other node types */\n\tif (in->valnode->qoperator.oper != OP_AND &&\n\t\tin->valnode->qoperator.oper != OP_OR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t{\n\t\tQTNode\t   *cc = in->child[i];\n\n\t\tif (cc->valnode->type == QI_OPR &&\n\t\t\tin->valnode->qoperator.oper == cc->valnode->qoperator.oper)\n\t\t{\n\t\t\tint\t\t\toldnchild = in->nchild;\n\n\t\t\tin->nchild += cc->nchild - 1;\n\t\t\tin->child = (QTNode **) repalloc(in->child, in->nchild * sizeof(QTNode *));\n\n\t\t\tif (i + 1 != oldnchild)\n\t\t\t\tmemmove(in->child + i + cc->nchild, in->child + i + 1,\n\t\t\t\t\t\t(oldnchild - i - 1) * sizeof(QTNode *));\n\n\t\t\tmemcpy(in->child + i, cc->child, cc->nchild * sizeof(QTNode *));\n\t\t\ti += cc->nchild - 1;\n\n\t\t\tif (cc->flags & QTN_NEEDFREE)\n\t\t\t\tpfree(cc->valnode);\n\t\t\tpfree(cc);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "QTNEq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
    "lines": "181-190",
    "snippet": "bool\nQTNEq(QTNode *a, QTNode *b)\n{\n\tuint32\t\tsign = a->sign & b->sign;\n\n\tif (!(sign == a->sign && sign == b->sign))\n\t\treturn false;\n\n\treturn (QTNodeCompare(a, b) == 0) ? true : false;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QTNodeCompare",
          "args": [
            "a",
            "b"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "QTNodeCompare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "95-146",
          "snippet": "int\nQTNodeCompare(QTNode *an, QTNode *bn)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (an->valnode->type != bn->valnode->type)\n\t\treturn (an->valnode->type > bn->valnode->type) ? -1 : 1;\n\n\tif (an->valnode->type == QI_OPR)\n\t{\n\t\tQueryOperator *ao = &an->valnode->qoperator;\n\t\tQueryOperator *bo = &bn->valnode->qoperator;\n\n\t\tif (ao->oper != bo->oper)\n\t\t\treturn (ao->oper > bo->oper) ? -1 : 1;\n\n\t\tif (an->nchild != bn->nchild)\n\t\t\treturn (an->nchild > bn->nchild) ? -1 : 1;\n\n\t\t{\n\t\t\tint\t\t\ti,\n\t\t\t\t\t\tres;\n\n\t\t\tfor (i = 0; i < an->nchild; i++)\n\t\t\t\tif ((res = QTNodeCompare(an->child[i], bn->child[i])) != 0)\n\t\t\t\t\treturn res;\n\t\t}\n\n\t\tif (ao->oper == OP_PHRASE && ao->distance != bo->distance)\n\t\t\treturn (ao->distance > bo->distance) ? -1 : 1;\n\n\t\treturn 0;\n\t}\n\telse if (an->valnode->type == QI_VAL)\n\t{\n\t\tQueryOperand *ao = &an->valnode->qoperand;\n\t\tQueryOperand *bo = &bn->valnode->qoperand;\n\n\t\tif (ao->valcrc != bo->valcrc)\n\t\t{\n\t\t\treturn (ao->valcrc > bo->valcrc) ? -1 : 1;\n\t\t}\n\n\t\treturn tsCompareString(an->word, ao->length, bn->word, bo->length, false);\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"unrecognized QueryItem type: %d\", an->valnode->type);\n\t\treturn 0;\t\t\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nint\nQTNodeCompare(QTNode *an, QTNode *bn)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (an->valnode->type != bn->valnode->type)\n\t\treturn (an->valnode->type > bn->valnode->type) ? -1 : 1;\n\n\tif (an->valnode->type == QI_OPR)\n\t{\n\t\tQueryOperator *ao = &an->valnode->qoperator;\n\t\tQueryOperator *bo = &bn->valnode->qoperator;\n\n\t\tif (ao->oper != bo->oper)\n\t\t\treturn (ao->oper > bo->oper) ? -1 : 1;\n\n\t\tif (an->nchild != bn->nchild)\n\t\t\treturn (an->nchild > bn->nchild) ? -1 : 1;\n\n\t\t{\n\t\t\tint\t\t\ti,\n\t\t\t\t\t\tres;\n\n\t\t\tfor (i = 0; i < an->nchild; i++)\n\t\t\t\tif ((res = QTNodeCompare(an->child[i], bn->child[i])) != 0)\n\t\t\t\t\treturn res;\n\t\t}\n\n\t\tif (ao->oper == OP_PHRASE && ao->distance != bo->distance)\n\t\t\treturn (ao->distance > bo->distance) ? -1 : 1;\n\n\t\treturn 0;\n\t}\n\telse if (an->valnode->type == QI_VAL)\n\t{\n\t\tQueryOperand *ao = &an->valnode->qoperand;\n\t\tQueryOperand *bo = &bn->valnode->qoperand;\n\n\t\tif (ao->valcrc != bo->valcrc)\n\t\t{\n\t\t\treturn (ao->valcrc > bo->valcrc) ? -1 : 1;\n\t\t}\n\n\t\treturn tsCompareString(an->word, ao->length, bn->word, bo->length, false);\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"unrecognized QueryItem type: %d\", an->valnode->type);\n\t\treturn 0;\t\t\t\t/* keep compiler quiet */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nbool\nQTNEq(QTNode *a, QTNode *b)\n{\n\tuint32\t\tsign = a->sign & b->sign;\n\n\tif (!(sign == a->sign && sign == b->sign))\n\t\treturn false;\n\n\treturn (QTNodeCompare(a, b) == 0) ? true : false;\n}"
  },
  {
    "function_name": "QTNSort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
    "lines": "161-176",
    "snippet": "void\nQTNSort(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNSort(in->child[i]);\n\tif (in->nchild > 1 && in->valnode->qoperator.oper != OP_PHRASE)\n\t\tqsort((void *) in->child, in->nchild, sizeof(QTNode *), cmpQTN);\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "(void *) in->child",
            "in->nchild",
            "sizeof(QTNode *)",
            "cmpQTN"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QTNSort",
          "args": [
            "in->child[i]"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "QTNSort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "161-176",
          "snippet": "void\nQTNSort(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNSort(in->child[i]);\n\tif (in->nchild > 1 && in->valnode->qoperator.oper != OP_PHRASE)\n\t\tqsort((void *) in->child, in->nchild, sizeof(QTNode *), cmpQTN);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNSort(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNSort(in->child[i]);\n\tif (in->nchild > 1 && in->valnode->qoperator.oper != OP_PHRASE)\n\t\tqsort((void *) in->child, in->nchild, sizeof(QTNode *), cmpQTN);\n}"
  },
  {
    "function_name": "cmpQTN",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
    "lines": "151-155",
    "snippet": "static int\ncmpQTN(const void *a, const void *b)\n{\n\treturn QTNodeCompare(*(QTNode *const *) a, *(QTNode *const *) b);\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QTNodeCompare",
          "args": [
            "*(QTNode *const *) a",
            "*(QTNode *const *) b"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "QTNodeCompare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "95-146",
          "snippet": "int\nQTNodeCompare(QTNode *an, QTNode *bn)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (an->valnode->type != bn->valnode->type)\n\t\treturn (an->valnode->type > bn->valnode->type) ? -1 : 1;\n\n\tif (an->valnode->type == QI_OPR)\n\t{\n\t\tQueryOperator *ao = &an->valnode->qoperator;\n\t\tQueryOperator *bo = &bn->valnode->qoperator;\n\n\t\tif (ao->oper != bo->oper)\n\t\t\treturn (ao->oper > bo->oper) ? -1 : 1;\n\n\t\tif (an->nchild != bn->nchild)\n\t\t\treturn (an->nchild > bn->nchild) ? -1 : 1;\n\n\t\t{\n\t\t\tint\t\t\ti,\n\t\t\t\t\t\tres;\n\n\t\t\tfor (i = 0; i < an->nchild; i++)\n\t\t\t\tif ((res = QTNodeCompare(an->child[i], bn->child[i])) != 0)\n\t\t\t\t\treturn res;\n\t\t}\n\n\t\tif (ao->oper == OP_PHRASE && ao->distance != bo->distance)\n\t\t\treturn (ao->distance > bo->distance) ? -1 : 1;\n\n\t\treturn 0;\n\t}\n\telse if (an->valnode->type == QI_VAL)\n\t{\n\t\tQueryOperand *ao = &an->valnode->qoperand;\n\t\tQueryOperand *bo = &bn->valnode->qoperand;\n\n\t\tif (ao->valcrc != bo->valcrc)\n\t\t{\n\t\t\treturn (ao->valcrc > bo->valcrc) ? -1 : 1;\n\t\t}\n\n\t\treturn tsCompareString(an->word, ao->length, bn->word, bo->length, false);\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"unrecognized QueryItem type: %d\", an->valnode->type);\n\t\treturn 0;\t\t\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nint\nQTNodeCompare(QTNode *an, QTNode *bn)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (an->valnode->type != bn->valnode->type)\n\t\treturn (an->valnode->type > bn->valnode->type) ? -1 : 1;\n\n\tif (an->valnode->type == QI_OPR)\n\t{\n\t\tQueryOperator *ao = &an->valnode->qoperator;\n\t\tQueryOperator *bo = &bn->valnode->qoperator;\n\n\t\tif (ao->oper != bo->oper)\n\t\t\treturn (ao->oper > bo->oper) ? -1 : 1;\n\n\t\tif (an->nchild != bn->nchild)\n\t\t\treturn (an->nchild > bn->nchild) ? -1 : 1;\n\n\t\t{\n\t\t\tint\t\t\ti,\n\t\t\t\t\t\tres;\n\n\t\t\tfor (i = 0; i < an->nchild; i++)\n\t\t\t\tif ((res = QTNodeCompare(an->child[i], bn->child[i])) != 0)\n\t\t\t\t\treturn res;\n\t\t}\n\n\t\tif (ao->oper == OP_PHRASE && ao->distance != bo->distance)\n\t\t\treturn (ao->distance > bo->distance) ? -1 : 1;\n\n\t\treturn 0;\n\t}\n\telse if (an->valnode->type == QI_VAL)\n\t{\n\t\tQueryOperand *ao = &an->valnode->qoperand;\n\t\tQueryOperand *bo = &bn->valnode->qoperand;\n\n\t\tif (ao->valcrc != bo->valcrc)\n\t\t{\n\t\t\treturn (ao->valcrc > bo->valcrc) ? -1 : 1;\n\t\t}\n\n\t\treturn tsCompareString(an->word, ao->length, bn->word, bo->length, false);\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"unrecognized QueryItem type: %d\", an->valnode->type);\n\t\treturn 0;\t\t\t\t/* keep compiler quiet */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int\ncmpQTN(const void *a, const void *b)\n{\n\treturn QTNodeCompare(*(QTNode *const *) a, *(QTNode *const *) b);\n}"
  },
  {
    "function_name": "QTNodeCompare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
    "lines": "95-146",
    "snippet": "int\nQTNodeCompare(QTNode *an, QTNode *bn)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (an->valnode->type != bn->valnode->type)\n\t\treturn (an->valnode->type > bn->valnode->type) ? -1 : 1;\n\n\tif (an->valnode->type == QI_OPR)\n\t{\n\t\tQueryOperator *ao = &an->valnode->qoperator;\n\t\tQueryOperator *bo = &bn->valnode->qoperator;\n\n\t\tif (ao->oper != bo->oper)\n\t\t\treturn (ao->oper > bo->oper) ? -1 : 1;\n\n\t\tif (an->nchild != bn->nchild)\n\t\t\treturn (an->nchild > bn->nchild) ? -1 : 1;\n\n\t\t{\n\t\t\tint\t\t\ti,\n\t\t\t\t\t\tres;\n\n\t\t\tfor (i = 0; i < an->nchild; i++)\n\t\t\t\tif ((res = QTNodeCompare(an->child[i], bn->child[i])) != 0)\n\t\t\t\t\treturn res;\n\t\t}\n\n\t\tif (ao->oper == OP_PHRASE && ao->distance != bo->distance)\n\t\t\treturn (ao->distance > bo->distance) ? -1 : 1;\n\n\t\treturn 0;\n\t}\n\telse if (an->valnode->type == QI_VAL)\n\t{\n\t\tQueryOperand *ao = &an->valnode->qoperand;\n\t\tQueryOperand *bo = &bn->valnode->qoperand;\n\n\t\tif (ao->valcrc != bo->valcrc)\n\t\t{\n\t\t\treturn (ao->valcrc > bo->valcrc) ? -1 : 1;\n\t\t}\n\n\t\treturn tsCompareString(an->word, ao->length, bn->word, bo->length, false);\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"unrecognized QueryItem type: %d\", an->valnode->type);\n\t\treturn 0;\t\t\t\t/* keep compiler quiet */\n\t}\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized QueryItem type: %d\"",
            "an->valnode->type"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsCompareString",
          "args": [
            "an->word",
            "ao->length",
            "bn->word",
            "bo->length",
            "false"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "tsCompareString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1159-1191",
          "snippet": "int32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nint32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTNodeCompare",
          "args": [
            "an->child[i]",
            "bn->child[i]"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "QTNodeCompare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "95-146",
          "snippet": "int\nQTNodeCompare(QTNode *an, QTNode *bn)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (an->valnode->type != bn->valnode->type)\n\t\treturn (an->valnode->type > bn->valnode->type) ? -1 : 1;\n\n\tif (an->valnode->type == QI_OPR)\n\t{\n\t\tQueryOperator *ao = &an->valnode->qoperator;\n\t\tQueryOperator *bo = &bn->valnode->qoperator;\n\n\t\tif (ao->oper != bo->oper)\n\t\t\treturn (ao->oper > bo->oper) ? -1 : 1;\n\n\t\tif (an->nchild != bn->nchild)\n\t\t\treturn (an->nchild > bn->nchild) ? -1 : 1;\n\n\t\t{\n\t\t\tint\t\t\ti,\n\t\t\t\t\t\tres;\n\n\t\t\tfor (i = 0; i < an->nchild; i++)\n\t\t\t\tif ((res = QTNodeCompare(an->child[i], bn->child[i])) != 0)\n\t\t\t\t\treturn res;\n\t\t}\n\n\t\tif (ao->oper == OP_PHRASE && ao->distance != bo->distance)\n\t\t\treturn (ao->distance > bo->distance) ? -1 : 1;\n\n\t\treturn 0;\n\t}\n\telse if (an->valnode->type == QI_VAL)\n\t{\n\t\tQueryOperand *ao = &an->valnode->qoperand;\n\t\tQueryOperand *bo = &bn->valnode->qoperand;\n\n\t\tif (ao->valcrc != bo->valcrc)\n\t\t{\n\t\t\treturn (ao->valcrc > bo->valcrc) ? -1 : 1;\n\t\t}\n\n\t\treturn tsCompareString(an->word, ao->length, bn->word, bo->length, false);\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"unrecognized QueryItem type: %d\", an->valnode->type);\n\t\treturn 0;\t\t\t\t/* keep compiler quiet */\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nint\nQTNodeCompare(QTNode *an, QTNode *bn)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (an->valnode->type != bn->valnode->type)\n\t\treturn (an->valnode->type > bn->valnode->type) ? -1 : 1;\n\n\tif (an->valnode->type == QI_OPR)\n\t{\n\t\tQueryOperator *ao = &an->valnode->qoperator;\n\t\tQueryOperator *bo = &bn->valnode->qoperator;\n\n\t\tif (ao->oper != bo->oper)\n\t\t\treturn (ao->oper > bo->oper) ? -1 : 1;\n\n\t\tif (an->nchild != bn->nchild)\n\t\t\treturn (an->nchild > bn->nchild) ? -1 : 1;\n\n\t\t{\n\t\t\tint\t\t\ti,\n\t\t\t\t\t\tres;\n\n\t\t\tfor (i = 0; i < an->nchild; i++)\n\t\t\t\tif ((res = QTNodeCompare(an->child[i], bn->child[i])) != 0)\n\t\t\t\t\treturn res;\n\t\t}\n\n\t\tif (ao->oper == OP_PHRASE && ao->distance != bo->distance)\n\t\t\treturn (ao->distance > bo->distance) ? -1 : 1;\n\n\t\treturn 0;\n\t}\n\telse if (an->valnode->type == QI_VAL)\n\t{\n\t\tQueryOperand *ao = &an->valnode->qoperand;\n\t\tQueryOperand *bo = &bn->valnode->qoperand;\n\n\t\tif (ao->valcrc != bo->valcrc)\n\t\t{\n\t\t\treturn (ao->valcrc > bo->valcrc) ? -1 : 1;\n\t\t}\n\n\t\treturn tsCompareString(an->word, ao->length, bn->word, bo->length, false);\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"unrecognized QueryItem type: %d\", an->valnode->type);\n\t\treturn 0;\t\t\t\t/* keep compiler quiet */\n\t}\n}"
  },
  {
    "function_name": "QTNFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
    "lines": "62-88",
    "snippet": "void\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "in"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTNFree",
          "args": [
            "in->child[i]"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "QTNFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "62-88",
          "snippet": "void\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}"
  },
  {
    "function_name": "QT2QTN",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
    "lines": "23-54",
    "snippet": "QTNode *\nQT2QTN(QueryItem *in, char *operand)\n{\n\tQTNode\t   *node = (QTNode *) palloc0(sizeof(QTNode));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\t\tnode->child[0] = QT2QTN(in + 1, operand);\n\t\tnode->sign = node->child[0]->sign;\n\t\tif (in->qoperator.oper == OP_NOT)\n\t\t\tnode->nchild = 1;\n\t\telse\n\t\t{\n\t\t\tnode->nchild = 2;\n\t\t\tnode->child[1] = QT2QTN(in + in->qoperator.left, operand);\n\t\t\tnode->sign |= node->child[1]->sign;\n\t\t}\n\t}\n\telse if (operand)\n\t{\n\t\tnode->word = operand + in->qoperand.distance;\n\t\tnode->sign = ((uint32) 1) << (((unsigned int) in->qoperand.valcrc) % 32);\n\t}\n\n\treturn node;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QT2QTN",
          "args": [
            "in + in->qoperator.left",
            "operand"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "QT2QTN",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "23-54",
          "snippet": "QTNode *\nQT2QTN(QueryItem *in, char *operand)\n{\n\tQTNode\t   *node = (QTNode *) palloc0(sizeof(QTNode));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\t\tnode->child[0] = QT2QTN(in + 1, operand);\n\t\tnode->sign = node->child[0]->sign;\n\t\tif (in->qoperator.oper == OP_NOT)\n\t\t\tnode->nchild = 1;\n\t\telse\n\t\t{\n\t\t\tnode->nchild = 2;\n\t\t\tnode->child[1] = QT2QTN(in + in->qoperator.left, operand);\n\t\t\tnode->sign |= node->child[1]->sign;\n\t\t}\n\t}\n\telse if (operand)\n\t{\n\t\tnode->word = operand + in->qoperand.distance;\n\t\tnode->sign = ((uint32) 1) << (((unsigned int) in->qoperand.valcrc) % 32);\n\t}\n\n\treturn node;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(QTNode *) * 2"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nQTNode *\nQT2QTN(QueryItem *in, char *operand)\n{\n\tQTNode\t   *node = (QTNode *) palloc0(sizeof(QTNode));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\t\tnode->child[0] = QT2QTN(in + 1, operand);\n\t\tnode->sign = node->child[0]->sign;\n\t\tif (in->qoperator.oper == OP_NOT)\n\t\t\tnode->nchild = 1;\n\t\telse\n\t\t{\n\t\t\tnode->nchild = 2;\n\t\t\tnode->child[1] = QT2QTN(in + in->qoperator.left, operand);\n\t\t\tnode->sign |= node->child[1]->sign;\n\t\t}\n\t}\n\telse if (operand)\n\t{\n\t\tnode->word = operand + in->qoperand.distance;\n\t\tnode->sign = ((uint32) 1) << (((unsigned int) in->qoperand.valcrc) % 32);\n\t}\n\n\treturn node;\n}"
  }
]