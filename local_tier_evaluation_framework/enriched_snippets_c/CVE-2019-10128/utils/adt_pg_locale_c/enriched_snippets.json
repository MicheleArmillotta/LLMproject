[
  {
    "function_name": "char2wchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "1735-1822",
    "snippet": "size_t\nchar2wchar(wchar_t *to, size_t tolen, const char *from, size_t fromlen,\n\t\t   pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\t/* See WIN32 \"Unicode\" comment above */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\t/* Win32 API does not work for zero-length input */\n\t\tif (fromlen == 0)\n\t\t\tresult = 0;\n\t\telse\n\t\t{\n\t\t\tresult = MultiByteToWideChar(CP_UTF8, 0, from, fromlen, to, tolen - 1);\n\t\t\t/* A zero return is failure */\n\t\t\tif (result == 0)\n\t\t\t\tresult = -1;\n\t\t}\n\n\t\tif (result != -1)\n\t\t{\n\t\t\tAssert(result < tolen);\n\t\t\t/* Append trailing null wchar (MultiByteToWideChar() does not) */\n\t\t\tto[result] = 0;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t{\n\t\t/* mbstowcs requires ending '\\0' */\n\t\tchar\t   *str = pnstrdup(from, fromlen);\n\n\t\tif (locale == (pg_locale_t) 0)\n\t\t{\n\t\t\t/* Use mbstowcs directly for the default locale */\n\t\t\tresult = mbstowcs(to, str, tolen);\n\t\t}\n\t\telse\n\t\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_MBSTOWCS_L\n\t\t\t/* Use mbstowcs_l for nondefault locales */\n\t\t\tresult = mbstowcs_l(to, str, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_MBSTOWCS_L */\n\t\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\t\tresult = mbstowcs(to, str, tolen);\n\n\t\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_MBSTOWCS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\t\telog(ERROR, \"mbstowcs_l is not available\");\n\t\t\tresult = 0;\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t\t}\n\n\t\tpfree(str);\n\t}\n\n\tif (result == -1)\n\t{\n\t\t/*\n\t\t * Invalid multibyte character encountered.  We try to give a useful\n\t\t * error message by letting pg_verifymbstr check the string.  But it's\n\t\t * possible that the string is OK to us, and not OK to mbstowcs ---\n\t\t * this suggests that the LC_CTYPE locale is different from the\n\t\t * database encoding.  Give a generic error message if verifymbstr\n\t\t * can't find anything wrong.\n\t\t */\n\t\tpg_verifymbstr(from, fromlen, false);\t/* might not return */\n\t\t/* but if it does ... */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t errmsg(\"invalid multibyte character for locale\"),\n\t\t\t\t errhint(\"The server's LC_CTYPE locale is probably incompatible with the database encoding.\")));\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t errmsg(\"invalid multibyte character for locale\"),\n\t\t\t\t errhint(\"The server's LC_CTYPE locale is probably incompatible with the database encoding.\"))"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"The server's LC_CTYPE locale is probably incompatible with the database encoding.\""
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid multibyte character for locale\""
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_CHARACTER_NOT_IN_REPERTOIRE"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_verifymbstr",
          "args": [
            "from",
            "fromlen",
            "false"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "pg_verifymbstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1865-1870",
          "snippet": "bool\npg_verifymbstr(const char *mbstr, int len, bool noError)\n{\n\treturn\n\t\tpg_verify_mbstr_len(GetDatabaseEncoding(), mbstr, len, noError) >= 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nbool\npg_verifymbstr(const char *mbstr, int len, bool noError)\n{\n\treturn\n\t\tpg_verify_mbstr_len(GetDatabaseEncoding(), mbstr, len, noError) >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "str"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"mbstowcs_l is not available\""
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uselocale",
          "args": [
            "save_locale"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mbstowcs",
          "args": [
            "to",
            "str",
            "tolen"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uselocale",
          "args": [
            "locale->info.lt"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mbstowcs_l",
          "args": [
            "to",
            "str",
            "tolen",
            "locale->info.lt"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mbstowcs",
          "args": [
            "to",
            "str",
            "tolen"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnstrdup",
          "args": [
            "from",
            "fromlen"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pnstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1155-1164",
          "snippet": "static xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "result < tolen"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiByteToWideChar",
          "args": [
            "CP_UTF8",
            "0",
            "from",
            "fromlen",
            "to",
            "tolen - 1"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!locale || locale->provider == COLLPROVIDER_LIBC"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nsize_t\nchar2wchar(wchar_t *to, size_t tolen, const char *from, size_t fromlen,\n\t\t   pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\t/* See WIN32 \"Unicode\" comment above */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\t/* Win32 API does not work for zero-length input */\n\t\tif (fromlen == 0)\n\t\t\tresult = 0;\n\t\telse\n\t\t{\n\t\t\tresult = MultiByteToWideChar(CP_UTF8, 0, from, fromlen, to, tolen - 1);\n\t\t\t/* A zero return is failure */\n\t\t\tif (result == 0)\n\t\t\t\tresult = -1;\n\t\t}\n\n\t\tif (result != -1)\n\t\t{\n\t\t\tAssert(result < tolen);\n\t\t\t/* Append trailing null wchar (MultiByteToWideChar() does not) */\n\t\t\tto[result] = 0;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t{\n\t\t/* mbstowcs requires ending '\\0' */\n\t\tchar\t   *str = pnstrdup(from, fromlen);\n\n\t\tif (locale == (pg_locale_t) 0)\n\t\t{\n\t\t\t/* Use mbstowcs directly for the default locale */\n\t\t\tresult = mbstowcs(to, str, tolen);\n\t\t}\n\t\telse\n\t\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_MBSTOWCS_L\n\t\t\t/* Use mbstowcs_l for nondefault locales */\n\t\t\tresult = mbstowcs_l(to, str, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_MBSTOWCS_L */\n\t\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\t\tresult = mbstowcs(to, str, tolen);\n\n\t\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_MBSTOWCS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\t\telog(ERROR, \"mbstowcs_l is not available\");\n\t\t\tresult = 0;\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t\t}\n\n\t\tpfree(str);\n\t}\n\n\tif (result == -1)\n\t{\n\t\t/*\n\t\t * Invalid multibyte character encountered.  We try to give a useful\n\t\t * error message by letting pg_verifymbstr check the string.  But it's\n\t\t * possible that the string is OK to us, and not OK to mbstowcs ---\n\t\t * this suggests that the LC_CTYPE locale is different from the\n\t\t * database encoding.  Give a generic error message if verifymbstr\n\t\t * can't find anything wrong.\n\t\t */\n\t\tpg_verifymbstr(from, fromlen, false);\t/* might not return */\n\t\t/* but if it does ... */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t errmsg(\"invalid multibyte character for locale\"),\n\t\t\t\t errhint(\"The server's LC_CTYPE locale is probably incompatible with the database encoding.\")));\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "wchar2char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "1664-1724",
    "snippet": "size_t\nwchar2char(char *to, const wchar_t *from, size_t tolen, pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\n\t/*\n\t * On Windows, the \"Unicode\" locales assume UTF16 not UTF8 encoding, and\n\t * for some reason mbstowcs and wcstombs won't do this for us, so we use\n\t * MultiByteToWideChar().\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\tresult = WideCharToMultiByte(CP_UTF8, 0, from, -1, to, tolen,\n\t\t\t\t\t\t\t\t\t NULL, NULL);\n\t\t/* A zero return is failure */\n\t\tif (result <= 0)\n\t\t\tresult = -1;\n\t\telse\n\t\t{\n\t\t\tAssert(result <= tolen);\n\t\t\t/* Microsoft counts the zero terminator in the result */\n\t\t\tresult--;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\tif (locale == (pg_locale_t) 0)\n\t{\n\t\t/* Use wcstombs directly for the default locale */\n\t\tresult = wcstombs(to, from, tolen);\n\t}\n\telse\n\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_WCSTOMBS_L\n\t\t/* Use wcstombs_l for nondefault locales */\n\t\tresult = wcstombs_l(to, from, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_WCSTOMBS_L */\n\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\tresult = wcstombs(to, from, tolen);\n\n\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_WCSTOMBS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\telog(ERROR, \"wcstombs_l is not available\");\n\t\tresult = 0;\t\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"wcstombs_l is not available\""
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uselocale",
          "args": [
            "save_locale"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcstombs",
          "args": [
            "to",
            "from",
            "tolen"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uselocale",
          "args": [
            "locale->info.lt"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcstombs_l",
          "args": [
            "to",
            "from",
            "tolen",
            "locale->info.lt"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcstombs",
          "args": [
            "to",
            "from",
            "tolen"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "result <= tolen"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WideCharToMultiByte",
          "args": [
            "CP_UTF8",
            "0",
            "from",
            "-1",
            "to",
            "tolen",
            "NULL",
            "NULL"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!locale || locale->provider == COLLPROVIDER_LIBC"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nsize_t\nwchar2char(char *to, const wchar_t *from, size_t tolen, pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\n\t/*\n\t * On Windows, the \"Unicode\" locales assume UTF16 not UTF8 encoding, and\n\t * for some reason mbstowcs and wcstombs won't do this for us, so we use\n\t * MultiByteToWideChar().\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\tresult = WideCharToMultiByte(CP_UTF8, 0, from, -1, to, tolen,\n\t\t\t\t\t\t\t\t\t NULL, NULL);\n\t\t/* A zero return is failure */\n\t\tif (result <= 0)\n\t\t\tresult = -1;\n\t\telse\n\t\t{\n\t\t\tAssert(result <= tolen);\n\t\t\t/* Microsoft counts the zero terminator in the result */\n\t\t\tresult--;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\tif (locale == (pg_locale_t) 0)\n\t{\n\t\t/* Use wcstombs directly for the default locale */\n\t\tresult = wcstombs(to, from, tolen);\n\t}\n\telse\n\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_WCSTOMBS_L\n\t\t/* Use wcstombs_l for nondefault locales */\n\t\tresult = wcstombs_l(to, from, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_WCSTOMBS_L */\n\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\tresult = wcstombs(to, from, tolen);\n\n\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_WCSTOMBS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\telog(ERROR, \"wcstombs_l is not available\");\n\t\tresult = 0;\t\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "icu_from_uchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "1623-1648",
    "snippet": "int32_t\nicu_from_uchar(char **result, const UChar *buff_uchar, int32_t len_uchar)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_result;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_result = ucnv_fromUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t\t buff_uchar, len_uchar, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status))));\n\n\t*result = palloc(len_result + 1);\n\n\tstatus = U_ZERO_ERROR;\n\tlen_result = ucnv_fromUChars(icu_converter, *result, len_result + 1,\n\t\t\t\t\t\t\t\t buff_uchar, len_uchar, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status))));\n\n\treturn len_result;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status)))"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"ucnv_fromUChars failed: %s\"",
            "u_errorName(status)"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "u_errorName",
          "args": [
            "status"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "U_FAILURE",
          "args": [
            "status"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucnv_fromUChars",
          "args": [
            "icu_converter",
            "*result",
            "len_result + 1",
            "buff_uchar",
            "len_uchar",
            "&status"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len_result + 1"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status)))"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_errorName",
          "args": [
            "status"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "U_FAILURE",
          "args": [
            "status"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucnv_fromUChars",
          "args": [
            "icu_converter",
            "NULL",
            "0",
            "buff_uchar",
            "len_uchar",
            "&status"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_icu_converter",
          "args": [],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "init_icu_converter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1551-1571",
          "snippet": "static void\ninit_icu_converter(void)\n{\n\tconst char *icu_encoding_name;\n\tUErrorCode\tstatus;\n\tUConverter *conv;\n\n\tif (icu_converter)\n\t\treturn;\n\n\ticu_encoding_name = get_encoding_name_for_icu(GetDatabaseEncoding());\n\n\tstatus = U_ZERO_ERROR;\n\tconv = ucnv_open(icu_encoding_name, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"could not open ICU converter for encoding \\\"%s\\\": %s\",\n\t\t\t\t\t\ticu_encoding_name, u_errorName(status))));\n\n\ticu_converter = conv;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic void\ninit_icu_converter(void)\n{\n\tconst char *icu_encoding_name;\n\tUErrorCode\tstatus;\n\tUConverter *conv;\n\n\tif (icu_converter)\n\t\treturn;\n\n\ticu_encoding_name = get_encoding_name_for_icu(GetDatabaseEncoding());\n\n\tstatus = U_ZERO_ERROR;\n\tconv = ucnv_open(icu_encoding_name, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"could not open ICU converter for encoding \\\"%s\\\": %s\",\n\t\t\t\t\t\ticu_encoding_name, u_errorName(status))));\n\n\ticu_converter = conv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nint32_t\nicu_from_uchar(char **result, const UChar *buff_uchar, int32_t len_uchar)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_result;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_result = ucnv_fromUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t\t buff_uchar, len_uchar, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status))));\n\n\t*result = palloc(len_result + 1);\n\n\tstatus = U_ZERO_ERROR;\n\tlen_result = ucnv_fromUChars(icu_converter, *result, len_result + 1,\n\t\t\t\t\t\t\t\t buff_uchar, len_uchar, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status))));\n\n\treturn len_result;\n}"
  },
  {
    "function_name": "icu_to_uchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "1585-1610",
    "snippet": "int32_t\nicu_to_uchar(UChar **buff_uchar, const char *buff, size_t nbytes)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_uchar;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\t*buff_uchar = palloc((len_uchar + 1) * sizeof(**buff_uchar));\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, *buff_uchar, len_uchar + 1,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\treturn len_uchar;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status)))"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"ucnv_toUChars failed: %s\"",
            "u_errorName(status)"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "u_errorName",
          "args": [
            "status"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "U_FAILURE",
          "args": [
            "status"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucnv_toUChars",
          "args": [
            "icu_converter",
            "*buff_uchar",
            "len_uchar + 1",
            "buff",
            "nbytes",
            "&status"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "(len_uchar + 1) * sizeof(**buff_uchar)"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status)))"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_errorName",
          "args": [
            "status"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "U_FAILURE",
          "args": [
            "status"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucnv_toUChars",
          "args": [
            "icu_converter",
            "NULL",
            "0",
            "buff",
            "nbytes",
            "&status"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_icu_converter",
          "args": [],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "init_icu_converter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1551-1571",
          "snippet": "static void\ninit_icu_converter(void)\n{\n\tconst char *icu_encoding_name;\n\tUErrorCode\tstatus;\n\tUConverter *conv;\n\n\tif (icu_converter)\n\t\treturn;\n\n\ticu_encoding_name = get_encoding_name_for_icu(GetDatabaseEncoding());\n\n\tstatus = U_ZERO_ERROR;\n\tconv = ucnv_open(icu_encoding_name, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"could not open ICU converter for encoding \\\"%s\\\": %s\",\n\t\t\t\t\t\ticu_encoding_name, u_errorName(status))));\n\n\ticu_converter = conv;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic void\ninit_icu_converter(void)\n{\n\tconst char *icu_encoding_name;\n\tUErrorCode\tstatus;\n\tUConverter *conv;\n\n\tif (icu_converter)\n\t\treturn;\n\n\ticu_encoding_name = get_encoding_name_for_icu(GetDatabaseEncoding());\n\n\tstatus = U_ZERO_ERROR;\n\tconv = ucnv_open(icu_encoding_name, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"could not open ICU converter for encoding \\\"%s\\\": %s\",\n\t\t\t\t\t\ticu_encoding_name, u_errorName(status))));\n\n\ticu_converter = conv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nint32_t\nicu_to_uchar(UChar **buff_uchar, const char *buff, size_t nbytes)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_uchar;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\t*buff_uchar = palloc((len_uchar + 1) * sizeof(**buff_uchar));\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, *buff_uchar, len_uchar + 1,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\treturn len_uchar;\n}"
  },
  {
    "function_name": "init_icu_converter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "1551-1571",
    "snippet": "static void\ninit_icu_converter(void)\n{\n\tconst char *icu_encoding_name;\n\tUErrorCode\tstatus;\n\tUConverter *conv;\n\n\tif (icu_converter)\n\t\treturn;\n\n\ticu_encoding_name = get_encoding_name_for_icu(GetDatabaseEncoding());\n\n\tstatus = U_ZERO_ERROR;\n\tconv = ucnv_open(icu_encoding_name, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"could not open ICU converter for encoding \\\"%s\\\": %s\",\n\t\t\t\t\t\ticu_encoding_name, u_errorName(status))));\n\n\ticu_converter = conv;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errmsg(\"could not open ICU converter for encoding \\\"%s\\\": %s\",\n\t\t\t\t\t\ticu_encoding_name, u_errorName(status)))"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not open ICU converter for encoding \\\"%s\\\": %s\"",
            "icu_encoding_name",
            "u_errorName(status)"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "u_errorName",
          "args": [
            "status"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "U_FAILURE",
          "args": [
            "status"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucnv_open",
          "args": [
            "icu_encoding_name",
            "&status"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_encoding_name_for_icu",
          "args": [
            "GetDatabaseEncoding()"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "get_encoding_name_for_icu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/encnames.c",
          "lines": "460-477",
          "snippet": "const char *\nget_encoding_name_for_icu(int encoding)\n{\n\tconst char *icu_encoding_name;\n\n\tStaticAssertStmt(lengthof(pg_enc2icu_tbl) == PG_ENCODING_BE_LAST + 1,\n\t\t\t\t\t \"pg_enc2icu_tbl incomplete\");\n\n\ticu_encoding_name = pg_enc2icu_tbl[encoding];\n\n\tif (!icu_encoding_name)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"encoding \\\"%s\\\" not supported by ICU\",\n\t\t\t\t\t\tpg_encoding_to_char(encoding))));\n\n\treturn icu_encoding_name;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"utils/builtins.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include <unistd.h>\n#include <ctype.h>\n#include \"utils/builtins.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst char *\nget_encoding_name_for_icu(int encoding)\n{\n\tconst char *icu_encoding_name;\n\n\tStaticAssertStmt(lengthof(pg_enc2icu_tbl) == PG_ENCODING_BE_LAST + 1,\n\t\t\t\t\t \"pg_enc2icu_tbl incomplete\");\n\n\ticu_encoding_name = pg_enc2icu_tbl[encoding];\n\n\tif (!icu_encoding_name)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"encoding \\\"%s\\\" not supported by ICU\",\n\t\t\t\t\t\tpg_encoding_to_char(encoding))));\n\n\treturn icu_encoding_name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic void\ninit_icu_converter(void)\n{\n\tconst char *icu_encoding_name;\n\tUErrorCode\tstatus;\n\tUConverter *conv;\n\n\tif (icu_converter)\n\t\treturn;\n\n\ticu_encoding_name = get_encoding_name_for_icu(GetDatabaseEncoding());\n\n\tstatus = U_ZERO_ERROR;\n\tconv = ucnv_open(icu_encoding_name, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"could not open ICU converter for encoding \\\"%s\\\": %s\",\n\t\t\t\t\t\ticu_encoding_name, u_errorName(status))));\n\n\ticu_converter = conv;\n}"
  },
  {
    "function_name": "get_collation_actual_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "1510-1540",
    "snippet": "char *\nget_collation_actual_version(char collprovider, const char *collcollate)\n{\n\tchar\t   *collversion;\n\n#ifdef USE_ICU\n\tif (collprovider == COLLPROVIDER_ICU)\n\t{\n\t\tUCollator  *collator;\n\t\tUErrorCode\tstatus;\n\t\tUVersionInfo versioninfo;\n\t\tchar\t\tbuf[U_MAX_VERSION_STRING_LENGTH];\n\n\t\tstatus = U_ZERO_ERROR;\n\t\tcollator = ucol_open(collcollate, &status);\n\t\tif (U_FAILURE(status))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\t\tucol_getVersion(collator, versioninfo);\n\t\tucol_close(collator);\n\n\t\tu_versionToString(versioninfo, buf);\n\t\tcollversion = pstrdup(buf);\n\t}\n\telse\n#endif\n\t\tcollversion = NULL;\n\n\treturn collversion;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "buf"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "u_versionToString",
          "args": [
            "versioninfo",
            "buf"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucol_close",
          "args": [
            "collator"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucol_getVersion",
          "args": [
            "collator",
            "versioninfo"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\tcollcollate, u_errorName(status)))"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not open collator for locale \\\"%s\\\": %s\"",
            "collcollate",
            "u_errorName(status)"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "u_errorName",
          "args": [
            "status"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "U_FAILURE",
          "args": [
            "status"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucol_open",
          "args": [
            "collcollate",
            "&status"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nchar *\nget_collation_actual_version(char collprovider, const char *collcollate)\n{\n\tchar\t   *collversion;\n\n#ifdef USE_ICU\n\tif (collprovider == COLLPROVIDER_ICU)\n\t{\n\t\tUCollator  *collator;\n\t\tUErrorCode\tstatus;\n\t\tUVersionInfo versioninfo;\n\t\tchar\t\tbuf[U_MAX_VERSION_STRING_LENGTH];\n\n\t\tstatus = U_ZERO_ERROR;\n\t\tcollator = ucol_open(collcollate, &status);\n\t\tif (U_FAILURE(status))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\t\tucol_getVersion(collator, versioninfo);\n\t\tucol_close(collator);\n\n\t\tu_versionToString(versioninfo, buf);\n\t\tcollversion = pstrdup(buf);\n\t}\n\telse\n#endif\n\t\tcollversion = NULL;\n\n\treturn collversion;\n}"
  },
  {
    "function_name": "pg_newlocale_from_collation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "1333-1500",
    "snippet": "pg_locale_t\npg_newlocale_from_collation(Oid collid)\n{\n\tcollation_cache_entry *cache_entry;\n\n\t/* Callers must pass a valid OID */\n\tAssert(OidIsValid(collid));\n\n\t/* Return 0 for \"default\" collation, just in case caller forgets */\n\tif (collid == DEFAULT_COLLATION_OID)\n\t\treturn (pg_locale_t) 0;\n\n\tcache_entry = lookup_collation_cache(collid, false);\n\n\tif (cache_entry->locale == 0)\n\t{\n\t\t/* We haven't computed this yet in this session, so do it */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype pg_attribute_unused();\n\t\tstruct pg_locale_struct result;\n\t\tpg_locale_t resultp;\n\t\tDatum\t\tcollversion;\n\t\tbool\t\tisnull;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\t/* We'll fill in the result struct locally before allocating memory */\n\t\tmemset(&result, 0, sizeof(result));\n\t\tresult.provider = collform->collprovider;\n\n\t\tif (collform->collprovider == COLLPROVIDER_LIBC)\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tlocale_t\tloc;\n\n\t\t\tif (strcmp(collcollate, collctype) == 0)\n\t\t\t{\n\t\t\t\t/* Normal case where they're the same */\n\t\t\t\terrno = 0;\n#ifndef WIN32\n\t\t\t\tloc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,\n\t\t\t\t\t\t\t\tNULL);\n#else\n\t\t\t\tloc = _create_locale(LC_ALL, collcollate);\n#endif\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifndef WIN32\n\t\t\t\t/* We need two newlocale() steps */\n\t\t\t\tlocale_t\tloc1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tloc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);\n\t\t\t\tif (!loc1)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t\terrno = 0;\n\t\t\t\tloc = newlocale(LC_CTYPE_MASK, collctype, loc1);\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collctype);\n#else\n\n\t\t\t\t/*\n\t\t\t\t * XXX The _create_locale() API doesn't appear to support\n\t\t\t\t * this. Could perhaps be worked around by changing\n\t\t\t\t * pg_locale_t to contain two separate fields.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\")));\n#endif\n\t\t\t}\n\n\t\t\tresult.info.lt = loc;\n#else\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t\t/* platform that doesn't support locale_t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\")));\n#endif\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t}\n\t\telse if (collform->collprovider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n\t\t\tUCollator  *collator;\n\t\t\tUErrorCode\tstatus;\n\n\t\t\tif (strcmp(collcollate, collctype) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\")));\n\n\t\t\tstatus = U_ZERO_ERROR;\n\t\t\tcollator = ucol_open(collcollate, &status);\n\t\t\tif (U_FAILURE(status))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\n\t\t\t/* We will leak this string if we get an error below :-( */\n\t\t\tresult.info.icu.locale = MemoryContextStrdup(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t collcollate);\n\t\t\tresult.info.icu.ucol = collator;\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* could get here if a collation was created by a build with ICU */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\")));\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\n\t\tcollversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tchar\t   *actual_versionstr;\n\t\t\tchar\t   *collversionstr;\n\n\t\t\tactual_versionstr = get_collation_actual_version(collform->collprovider, collcollate);\n\t\t\tif (!actual_versionstr)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This could happen when specifying a version in CREATE\n\t\t\t\t * COLLATION for a libc locale, or manually creating a mess in\n\t\t\t\t * the catalogs.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname))));\n\t\t\t}\n\t\t\tcollversionstr = TextDatumGetCString(collversion);\n\n\t\t\tif (strcmp(actual_versionstr, collversionstr) != 0)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname)))));\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\t/* We'll keep the pg_locale_t structures in TopMemoryContext */\n\t\tresultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));\n\t\t*resultp = result;\n\n\t\tcache_entry->locale = resultp;\n\t}\n\n\treturn cache_entry->locale;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "TopMemoryContext",
            "sizeof(*resultp)"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tp"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "WARNING",
            "(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname))))"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\"",
            "quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname))"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "quote_qualified_identifier",
          "args": [
            "get_namespace_name(collform->collnamespace)",
            "NameStr(collform->collname)"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "quote_qualified_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "10636-10647",
          "snippet": "char *\nquote_qualified_identifier(const char *qualifier,\n\t\t\t\t\t\t   const char *ident)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\tif (qualifier)\n\t\tappendStringInfo(&buf, \"%s.\", quote_identifier(qualifier));\n\tappendStringInfoString(&buf, quote_identifier(ident));\n\treturn buf.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);",
            "static void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);\nstatic void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);\n\nchar *\nquote_qualified_identifier(const char *qualifier,\n\t\t\t\t\t\t   const char *ident)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\tif (qualifier)\n\t\tappendStringInfo(&buf, \"%s.\", quote_identifier(qualifier));\n\tappendStringInfoString(&buf, quote_identifier(ident));\n\treturn buf.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "collform->collname"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "collform->collnamespace"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\"",
            "collversionstr",
            "actual_versionstr"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"collation \\\"%s\\\" has version mismatch\"",
            "NameStr(collform->collname)"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "collform->collname"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "actual_versionstr",
            "collversionstr"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "collversion"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)))"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "collform->collname"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_collation_actual_version",
          "args": [
            "collform->collprovider",
            "collcollate"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "get_collation_actual_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1510-1540",
          "snippet": "char *\nget_collation_actual_version(char collprovider, const char *collcollate)\n{\n\tchar\t   *collversion;\n\n#ifdef USE_ICU\n\tif (collprovider == COLLPROVIDER_ICU)\n\t{\n\t\tUCollator  *collator;\n\t\tUErrorCode\tstatus;\n\t\tUVersionInfo versioninfo;\n\t\tchar\t\tbuf[U_MAX_VERSION_STRING_LENGTH];\n\n\t\tstatus = U_ZERO_ERROR;\n\t\tcollator = ucol_open(collcollate, &status);\n\t\tif (U_FAILURE(status))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\t\tucol_getVersion(collator, versioninfo);\n\t\tucol_close(collator);\n\n\t\tu_versionToString(versioninfo, buf);\n\t\tcollversion = pstrdup(buf);\n\t}\n\telse\n#endif\n\t\tcollversion = NULL;\n\n\treturn collversion;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nchar *\nget_collation_actual_version(char collprovider, const char *collcollate)\n{\n\tchar\t   *collversion;\n\n#ifdef USE_ICU\n\tif (collprovider == COLLPROVIDER_ICU)\n\t{\n\t\tUCollator  *collator;\n\t\tUErrorCode\tstatus;\n\t\tUVersionInfo versioninfo;\n\t\tchar\t\tbuf[U_MAX_VERSION_STRING_LENGTH];\n\n\t\tstatus = U_ZERO_ERROR;\n\t\tcollator = ucol_open(collcollate, &status);\n\t\tif (U_FAILURE(status))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\t\tucol_getVersion(collator, versioninfo);\n\t\tucol_close(collator);\n\n\t\tu_versionToString(versioninfo, buf);\n\t\tcollversion = pstrdup(buf);\n\t}\n\telse\n#endif\n\t\tcollversion = NULL;\n\n\treturn collversion;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SysCacheGetAttr",
          "args": [
            "COLLOID",
            "tp",
            "Anum_pg_collation_collversion",
            "&isnull"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "SysCacheGetAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1367-1390",
          "snippet": "Datum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nDatum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\"))"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextStrdup",
          "args": [
            "TopMemoryContext",
            "collcollate"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextStrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1147-1158",
          "snippet": "char *\nMemoryContextStrdup(MemoryContext context, const char *string)\n{\n\tchar\t   *nstr;\n\tSize\t\tlen = strlen(string) + 1;\n\n\tnstr = (char *) MemoryContextAlloc(context, len);\n\n\tmemcpy(nstr, string, len);\n\n\treturn nstr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nchar *\nMemoryContextStrdup(MemoryContext context, const char *string)\n{\n\tchar\t   *nstr;\n\tSize\t\tlen = strlen(string) + 1;\n\n\tnstr = (char *) MemoryContextAlloc(context, len);\n\n\tmemcpy(nstr, string, len);\n\n\treturn nstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status)))"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_errorName",
          "args": [
            "status"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "U_FAILURE",
          "args": [
            "status"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucol_open",
          "args": [
            "collcollate",
            "&status"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\"))"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\"))"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\"))"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_newlocale_failure",
          "args": [
            "collctype"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "report_newlocale_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1286-1313",
          "snippet": "static void\nreport_newlocale_failure(const char *localename)\n{\n\tint\t\t\tsave_errno;\n\n\t/*\n\t * Windows doesn't provide any useful error indication from\n\t * _create_locale(), and BSD-derived platforms don't seem to feel they\n\t * need to set errno either (even though POSIX is pretty clear that\n\t * newlocale should do so).  So, if errno hasn't been set, assume ENOENT\n\t * is what to report.\n\t */\n\tif (errno == 0)\n\t\terrno = ENOENT;\n\n\t/*\n\t * ENOENT means \"no such locale\", not \"no such file\", so clarify that\n\t * errno with an errdetail message.\n\t */\n\tsave_errno = errno;\t\t\t/* auxiliary funcs might change errno */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t errmsg(\"could not create locale \\\"%s\\\": %m\",\n\t\t\t\t\tlocalename),\n\t\t\t (save_errno == ENOENT ?\n\t\t\t  errdetail(\"The operating system could not find any locale data for the locale name \\\"%s\\\".\",\n\t\t\t\t\t\tlocalename) : 0)));\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic void\nreport_newlocale_failure(const char *localename)\n{\n\tint\t\t\tsave_errno;\n\n\t/*\n\t * Windows doesn't provide any useful error indication from\n\t * _create_locale(), and BSD-derived platforms don't seem to feel they\n\t * need to set errno either (even though POSIX is pretty clear that\n\t * newlocale should do so).  So, if errno hasn't been set, assume ENOENT\n\t * is what to report.\n\t */\n\tif (errno == 0)\n\t\terrno = ENOENT;\n\n\t/*\n\t * ENOENT means \"no such locale\", not \"no such file\", so clarify that\n\t * errno with an errdetail message.\n\t */\n\tsave_errno = errno;\t\t\t/* auxiliary funcs might change errno */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t errmsg(\"could not create locale \\\"%s\\\": %m\",\n\t\t\t\t\tlocalename),\n\t\t\t (save_errno == ENOENT ?\n\t\t\t  errdetail(\"The operating system could not find any locale data for the locale name \\\"%s\\\".\",\n\t\t\t\t\t\tlocalename) : 0)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "newlocale",
          "args": [
            "LC_CTYPE_MASK",
            "collctype",
            "loc1"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newlocale",
          "args": [
            "LC_COLLATE_MASK",
            "collcollate",
            "NULL"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_create_locale",
          "args": [
            "LC_ALL",
            "collcollate"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newlocale",
          "args": [
            "LC_COLLATE_MASK | LC_CTYPE_MASK",
            "collcollate",
            "NULL"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&result",
            "0",
            "sizeof(result)"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "collform->collctype"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "collform->collcollate"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tp"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for collation %u\"",
            "collid"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tp"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "COLLOID",
            "ObjectIdGetDatum(collid)"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "collid"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_collation_cache",
          "args": [
            "collid",
            "false"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_collation_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1121-1180",
          "snippet": "static collation_cache_entry *\nlookup_collation_cache(Oid collation, bool set_flags)\n{\n\tcollation_cache_entry *cache_entry;\n\tbool\t\tfound;\n\n\tAssert(OidIsValid(collation));\n\tAssert(collation != DEFAULT_COLLATION_OID);\n\n\tif (collation_cache == NULL)\n\t{\n\t\t/* First time through, initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tmemset(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(collation_cache_entry);\n\t\tcollation_cache = hash_create(\"Collation cache\", 100, &ctl,\n\t\t\t\t\t\t\t\t\t  HASH_ELEM | HASH_BLOBS);\n\t}\n\n\tcache_entry = hash_search(collation_cache, &collation, HASH_ENTER, &found);\n\tif (!found)\n\t{\n\t\t/*\n\t\t * Make sure cache entry is marked invalid, in case we fail before\n\t\t * setting things.\n\t\t */\n\t\tcache_entry->flags_valid = false;\n\t\tcache_entry->locale = 0;\n\t}\n\n\tif (set_flags && !cache_entry->flags_valid)\n\t{\n\t\t/* Attempt to set the flags */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collation));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collation);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\tcache_entry->collate_is_c = ((strcmp(collcollate, \"C\") == 0) ||\n\t\t\t\t\t\t\t\t\t (strcmp(collcollate, \"POSIX\") == 0));\n\t\tcache_entry->ctype_is_c = ((strcmp(collctype, \"C\") == 0) ||\n\t\t\t\t\t\t\t\t   (strcmp(collctype, \"POSIX\") == 0));\n\n\t\tcache_entry->flags_valid = true;\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\treturn cache_entry;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *collation_cache = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic HTAB *collation_cache = NULL;\n\nstatic collation_cache_entry *\nlookup_collation_cache(Oid collation, bool set_flags)\n{\n\tcollation_cache_entry *cache_entry;\n\tbool\t\tfound;\n\n\tAssert(OidIsValid(collation));\n\tAssert(collation != DEFAULT_COLLATION_OID);\n\n\tif (collation_cache == NULL)\n\t{\n\t\t/* First time through, initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tmemset(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(collation_cache_entry);\n\t\tcollation_cache = hash_create(\"Collation cache\", 100, &ctl,\n\t\t\t\t\t\t\t\t\t  HASH_ELEM | HASH_BLOBS);\n\t}\n\n\tcache_entry = hash_search(collation_cache, &collation, HASH_ENTER, &found);\n\tif (!found)\n\t{\n\t\t/*\n\t\t * Make sure cache entry is marked invalid, in case we fail before\n\t\t * setting things.\n\t\t */\n\t\tcache_entry->flags_valid = false;\n\t\tcache_entry->locale = 0;\n\t}\n\n\tif (set_flags && !cache_entry->flags_valid)\n\t{\n\t\t/* Attempt to set the flags */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collation));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collation);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\tcache_entry->collate_is_c = ((strcmp(collcollate, \"C\") == 0) ||\n\t\t\t\t\t\t\t\t\t (strcmp(collcollate, \"POSIX\") == 0));\n\t\tcache_entry->ctype_is_c = ((strcmp(collctype, \"C\") == 0) ||\n\t\t\t\t\t\t\t\t   (strcmp(collctype, \"POSIX\") == 0));\n\n\t\tcache_entry->flags_valid = true;\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\treturn cache_entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "OidIsValid(collid)"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "collid"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\npg_locale_t\npg_newlocale_from_collation(Oid collid)\n{\n\tcollation_cache_entry *cache_entry;\n\n\t/* Callers must pass a valid OID */\n\tAssert(OidIsValid(collid));\n\n\t/* Return 0 for \"default\" collation, just in case caller forgets */\n\tif (collid == DEFAULT_COLLATION_OID)\n\t\treturn (pg_locale_t) 0;\n\n\tcache_entry = lookup_collation_cache(collid, false);\n\n\tif (cache_entry->locale == 0)\n\t{\n\t\t/* We haven't computed this yet in this session, so do it */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype pg_attribute_unused();\n\t\tstruct pg_locale_struct result;\n\t\tpg_locale_t resultp;\n\t\tDatum\t\tcollversion;\n\t\tbool\t\tisnull;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\t/* We'll fill in the result struct locally before allocating memory */\n\t\tmemset(&result, 0, sizeof(result));\n\t\tresult.provider = collform->collprovider;\n\n\t\tif (collform->collprovider == COLLPROVIDER_LIBC)\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tlocale_t\tloc;\n\n\t\t\tif (strcmp(collcollate, collctype) == 0)\n\t\t\t{\n\t\t\t\t/* Normal case where they're the same */\n\t\t\t\terrno = 0;\n#ifndef WIN32\n\t\t\t\tloc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,\n\t\t\t\t\t\t\t\tNULL);\n#else\n\t\t\t\tloc = _create_locale(LC_ALL, collcollate);\n#endif\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifndef WIN32\n\t\t\t\t/* We need two newlocale() steps */\n\t\t\t\tlocale_t\tloc1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tloc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);\n\t\t\t\tif (!loc1)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t\terrno = 0;\n\t\t\t\tloc = newlocale(LC_CTYPE_MASK, collctype, loc1);\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collctype);\n#else\n\n\t\t\t\t/*\n\t\t\t\t * XXX The _create_locale() API doesn't appear to support\n\t\t\t\t * this. Could perhaps be worked around by changing\n\t\t\t\t * pg_locale_t to contain two separate fields.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\")));\n#endif\n\t\t\t}\n\n\t\t\tresult.info.lt = loc;\n#else\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t\t/* platform that doesn't support locale_t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\")));\n#endif\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t}\n\t\telse if (collform->collprovider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n\t\t\tUCollator  *collator;\n\t\t\tUErrorCode\tstatus;\n\n\t\t\tif (strcmp(collcollate, collctype) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\")));\n\n\t\t\tstatus = U_ZERO_ERROR;\n\t\t\tcollator = ucol_open(collcollate, &status);\n\t\t\tif (U_FAILURE(status))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\n\t\t\t/* We will leak this string if we get an error below :-( */\n\t\t\tresult.info.icu.locale = MemoryContextStrdup(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t collcollate);\n\t\t\tresult.info.icu.ucol = collator;\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* could get here if a collation was created by a build with ICU */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\")));\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\n\t\tcollversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tchar\t   *actual_versionstr;\n\t\t\tchar\t   *collversionstr;\n\n\t\t\tactual_versionstr = get_collation_actual_version(collform->collprovider, collcollate);\n\t\t\tif (!actual_versionstr)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This could happen when specifying a version in CREATE\n\t\t\t\t * COLLATION for a libc locale, or manually creating a mess in\n\t\t\t\t * the catalogs.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname))));\n\t\t\t}\n\t\t\tcollversionstr = TextDatumGetCString(collversion);\n\n\t\t\tif (strcmp(actual_versionstr, collversionstr) != 0)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname)))));\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\t/* We'll keep the pg_locale_t structures in TopMemoryContext */\n\t\tresultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));\n\t\t*resultp = result;\n\n\t\tcache_entry->locale = resultp;\n\t}\n\n\treturn cache_entry->locale;\n}"
  },
  {
    "function_name": "report_newlocale_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "1286-1313",
    "snippet": "static void\nreport_newlocale_failure(const char *localename)\n{\n\tint\t\t\tsave_errno;\n\n\t/*\n\t * Windows doesn't provide any useful error indication from\n\t * _create_locale(), and BSD-derived platforms don't seem to feel they\n\t * need to set errno either (even though POSIX is pretty clear that\n\t * newlocale should do so).  So, if errno hasn't been set, assume ENOENT\n\t * is what to report.\n\t */\n\tif (errno == 0)\n\t\terrno = ENOENT;\n\n\t/*\n\t * ENOENT means \"no such locale\", not \"no such file\", so clarify that\n\t * errno with an errdetail message.\n\t */\n\tsave_errno = errno;\t\t\t/* auxiliary funcs might change errno */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t errmsg(\"could not create locale \\\"%s\\\": %m\",\n\t\t\t\t\tlocalename),\n\t\t\t (save_errno == ENOENT ?\n\t\t\t  errdetail(\"The operating system could not find any locale data for the locale name \\\"%s\\\".\",\n\t\t\t\t\t\tlocalename) : 0)));\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t errmsg(\"could not create locale \\\"%s\\\": %m\",\n\t\t\t\t\tlocalename),\n\t\t\t (save_errno == ENOENT ?\n\t\t\t  errdetail(\"The operating system could not find any locale data for the locale name \\\"%s\\\".\",\n\t\t\t\t\t\tlocalename) : 0))"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"The operating system could not find any locale data for the locale name \\\"%s\\\".\"",
            "localename"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not create locale \\\"%s\\\": %m\"",
            "localename"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic void\nreport_newlocale_failure(const char *localename)\n{\n\tint\t\t\tsave_errno;\n\n\t/*\n\t * Windows doesn't provide any useful error indication from\n\t * _create_locale(), and BSD-derived platforms don't seem to feel they\n\t * need to set errno either (even though POSIX is pretty clear that\n\t * newlocale should do so).  So, if errno hasn't been set, assume ENOENT\n\t * is what to report.\n\t */\n\tif (errno == 0)\n\t\terrno = ENOENT;\n\n\t/*\n\t * ENOENT means \"no such locale\", not \"no such file\", so clarify that\n\t * errno with an errdetail message.\n\t */\n\tsave_errno = errno;\t\t\t/* auxiliary funcs might change errno */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t errmsg(\"could not create locale \\\"%s\\\": %m\",\n\t\t\t\t\tlocalename),\n\t\t\t (save_errno == ENOENT ?\n\t\t\t  errdetail(\"The operating system could not find any locale data for the locale name \\\"%s\\\".\",\n\t\t\t\t\t\tlocalename) : 0)));\n}"
  },
  {
    "function_name": "lc_ctype_is_c",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "1236-1281",
    "snippet": "bool\nlc_ctype_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_CTYPE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_CTYPE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->ctype_is_c;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lookup_collation_cache",
          "args": [
            "collation",
            "true"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_collation_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1121-1180",
          "snippet": "static collation_cache_entry *\nlookup_collation_cache(Oid collation, bool set_flags)\n{\n\tcollation_cache_entry *cache_entry;\n\tbool\t\tfound;\n\n\tAssert(OidIsValid(collation));\n\tAssert(collation != DEFAULT_COLLATION_OID);\n\n\tif (collation_cache == NULL)\n\t{\n\t\t/* First time through, initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tmemset(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(collation_cache_entry);\n\t\tcollation_cache = hash_create(\"Collation cache\", 100, &ctl,\n\t\t\t\t\t\t\t\t\t  HASH_ELEM | HASH_BLOBS);\n\t}\n\n\tcache_entry = hash_search(collation_cache, &collation, HASH_ENTER, &found);\n\tif (!found)\n\t{\n\t\t/*\n\t\t * Make sure cache entry is marked invalid, in case we fail before\n\t\t * setting things.\n\t\t */\n\t\tcache_entry->flags_valid = false;\n\t\tcache_entry->locale = 0;\n\t}\n\n\tif (set_flags && !cache_entry->flags_valid)\n\t{\n\t\t/* Attempt to set the flags */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collation));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collation);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\tcache_entry->collate_is_c = ((strcmp(collcollate, \"C\") == 0) ||\n\t\t\t\t\t\t\t\t\t (strcmp(collcollate, \"POSIX\") == 0));\n\t\tcache_entry->ctype_is_c = ((strcmp(collctype, \"C\") == 0) ||\n\t\t\t\t\t\t\t\t   (strcmp(collctype, \"POSIX\") == 0));\n\n\t\tcache_entry->flags_valid = true;\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\treturn cache_entry;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *collation_cache = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic HTAB *collation_cache = NULL;\n\nstatic collation_cache_entry *\nlookup_collation_cache(Oid collation, bool set_flags)\n{\n\tcollation_cache_entry *cache_entry;\n\tbool\t\tfound;\n\n\tAssert(OidIsValid(collation));\n\tAssert(collation != DEFAULT_COLLATION_OID);\n\n\tif (collation_cache == NULL)\n\t{\n\t\t/* First time through, initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tmemset(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(collation_cache_entry);\n\t\tcollation_cache = hash_create(\"Collation cache\", 100, &ctl,\n\t\t\t\t\t\t\t\t\t  HASH_ELEM | HASH_BLOBS);\n\t}\n\n\tcache_entry = hash_search(collation_cache, &collation, HASH_ENTER, &found);\n\tif (!found)\n\t{\n\t\t/*\n\t\t * Make sure cache entry is marked invalid, in case we fail before\n\t\t * setting things.\n\t\t */\n\t\tcache_entry->flags_valid = false;\n\t\tcache_entry->locale = 0;\n\t}\n\n\tif (set_flags && !cache_entry->flags_valid)\n\t{\n\t\t/* Attempt to set the flags */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collation));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collation);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\tcache_entry->collate_is_c = ((strcmp(collcollate, \"C\") == 0) ||\n\t\t\t\t\t\t\t\t\t (strcmp(collcollate, \"POSIX\") == 0));\n\t\tcache_entry->ctype_is_c = ((strcmp(collctype, \"C\") == 0) ||\n\t\t\t\t\t\t\t\t   (strcmp(collctype, \"POSIX\") == 0));\n\n\t\tcache_entry->flags_valid = true;\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\treturn cache_entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "localeptr",
            "\"POSIX\""
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid LC_CTYPE setting\""
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setlocale",
          "args": [
            "LC_CTYPE",
            "NULL"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "pg_perm_setlocale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "151-251",
          "snippet": "char *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)"
          ],
          "globals_used": [
            "static char lc_collate_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_ctype_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_monetary_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_numeric_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_time_envbuf[LC_ENV_BUFSIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\n#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)\n\nstatic char lc_collate_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_ctype_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_monetary_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_numeric_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_time_envbuf[LC_ENV_BUFSIZE];\n\nchar *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "collation"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\nlc_ctype_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_CTYPE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_CTYPE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->ctype_is_c;\n}"
  },
  {
    "function_name": "lc_collate_is_c",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "1186-1231",
    "snippet": "bool\nlc_collate_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_COLLATE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_COLLATE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->collate_is_c;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lookup_collation_cache",
          "args": [
            "collation",
            "true"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_collation_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1121-1180",
          "snippet": "static collation_cache_entry *\nlookup_collation_cache(Oid collation, bool set_flags)\n{\n\tcollation_cache_entry *cache_entry;\n\tbool\t\tfound;\n\n\tAssert(OidIsValid(collation));\n\tAssert(collation != DEFAULT_COLLATION_OID);\n\n\tif (collation_cache == NULL)\n\t{\n\t\t/* First time through, initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tmemset(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(collation_cache_entry);\n\t\tcollation_cache = hash_create(\"Collation cache\", 100, &ctl,\n\t\t\t\t\t\t\t\t\t  HASH_ELEM | HASH_BLOBS);\n\t}\n\n\tcache_entry = hash_search(collation_cache, &collation, HASH_ENTER, &found);\n\tif (!found)\n\t{\n\t\t/*\n\t\t * Make sure cache entry is marked invalid, in case we fail before\n\t\t * setting things.\n\t\t */\n\t\tcache_entry->flags_valid = false;\n\t\tcache_entry->locale = 0;\n\t}\n\n\tif (set_flags && !cache_entry->flags_valid)\n\t{\n\t\t/* Attempt to set the flags */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collation));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collation);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\tcache_entry->collate_is_c = ((strcmp(collcollate, \"C\") == 0) ||\n\t\t\t\t\t\t\t\t\t (strcmp(collcollate, \"POSIX\") == 0));\n\t\tcache_entry->ctype_is_c = ((strcmp(collctype, \"C\") == 0) ||\n\t\t\t\t\t\t\t\t   (strcmp(collctype, \"POSIX\") == 0));\n\n\t\tcache_entry->flags_valid = true;\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\treturn cache_entry;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *collation_cache = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic HTAB *collation_cache = NULL;\n\nstatic collation_cache_entry *\nlookup_collation_cache(Oid collation, bool set_flags)\n{\n\tcollation_cache_entry *cache_entry;\n\tbool\t\tfound;\n\n\tAssert(OidIsValid(collation));\n\tAssert(collation != DEFAULT_COLLATION_OID);\n\n\tif (collation_cache == NULL)\n\t{\n\t\t/* First time through, initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tmemset(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(collation_cache_entry);\n\t\tcollation_cache = hash_create(\"Collation cache\", 100, &ctl,\n\t\t\t\t\t\t\t\t\t  HASH_ELEM | HASH_BLOBS);\n\t}\n\n\tcache_entry = hash_search(collation_cache, &collation, HASH_ENTER, &found);\n\tif (!found)\n\t{\n\t\t/*\n\t\t * Make sure cache entry is marked invalid, in case we fail before\n\t\t * setting things.\n\t\t */\n\t\tcache_entry->flags_valid = false;\n\t\tcache_entry->locale = 0;\n\t}\n\n\tif (set_flags && !cache_entry->flags_valid)\n\t{\n\t\t/* Attempt to set the flags */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collation));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collation);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\tcache_entry->collate_is_c = ((strcmp(collcollate, \"C\") == 0) ||\n\t\t\t\t\t\t\t\t\t (strcmp(collcollate, \"POSIX\") == 0));\n\t\tcache_entry->ctype_is_c = ((strcmp(collctype, \"C\") == 0) ||\n\t\t\t\t\t\t\t\t   (strcmp(collctype, \"POSIX\") == 0));\n\n\t\tcache_entry->flags_valid = true;\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\treturn cache_entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "localeptr",
            "\"POSIX\""
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid LC_COLLATE setting\""
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setlocale",
          "args": [
            "LC_COLLATE",
            "NULL"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "pg_perm_setlocale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "151-251",
          "snippet": "char *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)"
          ],
          "globals_used": [
            "static char lc_collate_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_ctype_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_monetary_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_numeric_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_time_envbuf[LC_ENV_BUFSIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\n#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)\n\nstatic char lc_collate_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_ctype_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_monetary_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_numeric_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_time_envbuf[LC_ENV_BUFSIZE];\n\nchar *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "collation"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\nlc_collate_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_COLLATE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_COLLATE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->collate_is_c;\n}"
  },
  {
    "function_name": "lookup_collation_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "1121-1180",
    "snippet": "static collation_cache_entry *\nlookup_collation_cache(Oid collation, bool set_flags)\n{\n\tcollation_cache_entry *cache_entry;\n\tbool\t\tfound;\n\n\tAssert(OidIsValid(collation));\n\tAssert(collation != DEFAULT_COLLATION_OID);\n\n\tif (collation_cache == NULL)\n\t{\n\t\t/* First time through, initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tmemset(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(collation_cache_entry);\n\t\tcollation_cache = hash_create(\"Collation cache\", 100, &ctl,\n\t\t\t\t\t\t\t\t\t  HASH_ELEM | HASH_BLOBS);\n\t}\n\n\tcache_entry = hash_search(collation_cache, &collation, HASH_ENTER, &found);\n\tif (!found)\n\t{\n\t\t/*\n\t\t * Make sure cache entry is marked invalid, in case we fail before\n\t\t * setting things.\n\t\t */\n\t\tcache_entry->flags_valid = false;\n\t\tcache_entry->locale = 0;\n\t}\n\n\tif (set_flags && !cache_entry->flags_valid)\n\t{\n\t\t/* Attempt to set the flags */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collation));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collation);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\tcache_entry->collate_is_c = ((strcmp(collcollate, \"C\") == 0) ||\n\t\t\t\t\t\t\t\t\t (strcmp(collcollate, \"POSIX\") == 0));\n\t\tcache_entry->ctype_is_c = ((strcmp(collctype, \"C\") == 0) ||\n\t\t\t\t\t\t\t\t   (strcmp(collctype, \"POSIX\") == 0));\n\n\t\tcache_entry->flags_valid = true;\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\treturn cache_entry;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *collation_cache = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tp"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "collctype",
            "\"POSIX\""
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "collform->collctype"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "collform->collcollate"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tp"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for collation %u\"",
            "collation"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tp"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "COLLOID",
            "ObjectIdGetDatum(collation)"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "collation"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "collation_cache",
            "&collation",
            "HASH_ENTER",
            "&found"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_create",
          "args": [
            "\"Collation cache\"",
            "100",
            "&ctl",
            "HASH_ELEM | HASH_BLOBS"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "hash_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "315-564",
          "snippet": "HTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_FREELISTS\t\t\t32"
          ],
          "globals_used": [
            "static void *DynaHashAlloc(Size size);",
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static int\tchoose_nelem_alloc(Size entrysize);",
            "static bool init_htab(HTAB *hashp, long nelem);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);",
            "static MemoryContext CurrentDynaHashCxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define NUM_FREELISTS\t\t\t32\n\nstatic void *DynaHashAlloc(Size size);\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic int\tchoose_nelem_alloc(Size entrysize);\nstatic bool init_htab(HTAB *hashp, long nelem);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\nstatic MemoryContext CurrentDynaHashCxt = NULL;\n\nHTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctl",
            "0",
            "sizeof(ctl)"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "collation != DEFAULT_COLLATION_OID"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "OidIsValid(collation)"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "collation"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic HTAB *collation_cache = NULL;\n\nstatic collation_cache_entry *\nlookup_collation_cache(Oid collation, bool set_flags)\n{\n\tcollation_cache_entry *cache_entry;\n\tbool\t\tfound;\n\n\tAssert(OidIsValid(collation));\n\tAssert(collation != DEFAULT_COLLATION_OID);\n\n\tif (collation_cache == NULL)\n\t{\n\t\t/* First time through, initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tmemset(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(collation_cache_entry);\n\t\tcollation_cache = hash_create(\"Collation cache\", 100, &ctl,\n\t\t\t\t\t\t\t\t\t  HASH_ELEM | HASH_BLOBS);\n\t}\n\n\tcache_entry = hash_search(collation_cache, &collation, HASH_ENTER, &found);\n\tif (!found)\n\t{\n\t\t/*\n\t\t * Make sure cache entry is marked invalid, in case we fail before\n\t\t * setting things.\n\t\t */\n\t\tcache_entry->flags_valid = false;\n\t\tcache_entry->locale = 0;\n\t}\n\n\tif (set_flags && !cache_entry->flags_valid)\n\t{\n\t\t/* Attempt to set the flags */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collation));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collation);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\tcache_entry->collate_is_c = ((strcmp(collcollate, \"C\") == 0) ||\n\t\t\t\t\t\t\t\t\t (strcmp(collcollate, \"POSIX\") == 0));\n\t\tcache_entry->ctype_is_c = ((strcmp(collctype, \"C\") == 0) ||\n\t\t\t\t\t\t\t\t   (strcmp(collctype, \"POSIX\") == 0));\n\n\t\tcache_entry->flags_valid = true;\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\treturn cache_entry;\n}"
  },
  {
    "function_name": "check_strxfrm_bug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "1051-1094",
    "snippet": "void\ncheck_strxfrm_bug(void)\n{\n\tchar\t\tbuf[32];\n\tconst int\tcanary = 0x7F;\n\tbool\t\tok = true;\n\n\t/*\n\t * Given a two-byte ASCII string and length limit 7, 8 or 9, Solaris 10\n\t * 05/08 returns 18 and modifies 10 bytes.  It respects limits above or\n\t * below that range.\n\t *\n\t * The bug is present in Solaris 8 as well; it is absent in Solaris 10\n\t * 01/13 and Solaris 11.2.  Affected locales include is_IS.ISO8859-1,\n\t * en_US.UTF-8, en_US.ISO8859-1, and ru_RU.KOI8-R.  Unaffected locales\n\t * include de_DE.UTF-8, de_DE.ISO8859-1, zh_TW.UTF-8, and C.\n\t */\n\tbuf[7] = canary;\n\t(void) strxfrm(buf, \"ab\", 7);\n\tif (buf[7] != canary)\n\t\tok = false;\n\n\t/*\n\t * illumos bug #1594 was present in the source tree from 2010-10-11 to\n\t * 2012-02-01.  Given an ASCII string of any length and length limit 1,\n\t * affected systems ignore the length limit and modify a number of bytes\n\t * one less than the return value.  The problem inputs for this bug do not\n\t * overlap those for the Solaris bug, hence a distinct test.\n\t *\n\t * Affected systems include smartos-20110926T021612Z.  Affected locales\n\t * include en_US.ISO8859-1 and en_US.UTF-8.  Unaffected locales include C.\n\t */\n\tbuf[1] = canary;\n\t(void) strxfrm(buf, \"a\", 1);\n\tif (buf[1] != canary)\n\t\tok = false;\n\n\tif (!ok)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYSTEM_ERROR),\n\t\t\t\t errmsg_internal(\"strxfrm(), in locale \\\"%s\\\", writes past the specified array length\",\n\t\t\t\t\t\t\t\t setlocale(LC_COLLATE, NULL)),\n\t\t\t\t errhint(\"Apply system library package updates.\")));\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYSTEM_ERROR),\n\t\t\t\t errmsg_internal(\"strxfrm(), in locale \\\"%s\\\", writes past the specified array length\",\n\t\t\t\t\t\t\t\t setlocale(LC_COLLATE, NULL)),\n\t\t\t\t errhint(\"Apply system library package updates.\"))"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Apply system library package updates.\""
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg_internal",
          "args": [
            "\"strxfrm(), in locale \\\"%s\\\", writes past the specified array length\"",
            "setlocale(LC_COLLATE, NULL)"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "setlocale",
          "args": [
            "LC_COLLATE",
            "NULL"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "pg_perm_setlocale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "151-251",
          "snippet": "char *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)"
          ],
          "globals_used": [
            "static char lc_collate_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_ctype_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_monetary_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_numeric_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_time_envbuf[LC_ENV_BUFSIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\n#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)\n\nstatic char lc_collate_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_ctype_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_monetary_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_numeric_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_time_envbuf[LC_ENV_BUFSIZE];\n\nchar *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_SYSTEM_ERROR"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strxfrm",
          "args": [
            "buf",
            "\"a\"",
            "1"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strxfrm",
          "args": [
            "buf",
            "\"ab\"",
            "7"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nvoid\ncheck_strxfrm_bug(void)\n{\n\tchar\t\tbuf[32];\n\tconst int\tcanary = 0x7F;\n\tbool\t\tok = true;\n\n\t/*\n\t * Given a two-byte ASCII string and length limit 7, 8 or 9, Solaris 10\n\t * 05/08 returns 18 and modifies 10 bytes.  It respects limits above or\n\t * below that range.\n\t *\n\t * The bug is present in Solaris 8 as well; it is absent in Solaris 10\n\t * 01/13 and Solaris 11.2.  Affected locales include is_IS.ISO8859-1,\n\t * en_US.UTF-8, en_US.ISO8859-1, and ru_RU.KOI8-R.  Unaffected locales\n\t * include de_DE.UTF-8, de_DE.ISO8859-1, zh_TW.UTF-8, and C.\n\t */\n\tbuf[7] = canary;\n\t(void) strxfrm(buf, \"ab\", 7);\n\tif (buf[7] != canary)\n\t\tok = false;\n\n\t/*\n\t * illumos bug #1594 was present in the source tree from 2010-10-11 to\n\t * 2012-02-01.  Given an ASCII string of any length and length limit 1,\n\t * affected systems ignore the length limit and modify a number of bytes\n\t * one less than the return value.  The problem inputs for this bug do not\n\t * overlap those for the Solaris bug, hence a distinct test.\n\t *\n\t * Affected systems include smartos-20110926T021612Z.  Affected locales\n\t * include en_US.ISO8859-1 and en_US.UTF-8.  Unaffected locales include C.\n\t */\n\tbuf[1] = canary;\n\t(void) strxfrm(buf, \"a\", 1);\n\tif (buf[1] != canary)\n\t\tok = false;\n\n\tif (!ok)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYSTEM_ERROR),\n\t\t\t\t errmsg_internal(\"strxfrm(), in locale \\\"%s\\\", writes past the specified array length\",\n\t\t\t\t\t\t\t\t setlocale(LC_COLLATE, NULL)),\n\t\t\t\t errhint(\"Apply system library package updates.\")));\n}"
  },
  {
    "function_name": "IsoLocaleName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "969-1035",
    "snippet": "static char *\nIsoLocaleName(const char *winlocname)\n{\n#if (_MSC_VER >= 1400)\t\t\t/* VC8.0 or later */\n\tstatic char iso_lc_messages[32];\n\t_locale_t\tloct = NULL;\n\n\tif (pg_strcasecmp(\"c\", winlocname) == 0 ||\n\t\tpg_strcasecmp(\"posix\", winlocname) == 0)\n\t{\n\t\tstrcpy(iso_lc_messages, \"C\");\n\t\treturn iso_lc_messages;\n\t}\n\n\tloct = _create_locale(LC_CTYPE, winlocname);\n\tif (loct != NULL)\n\t{\n#if (_MSC_VER >= 1700)\t\t\t/* Visual Studio 2012 or later */\n\t\tsize_t\t\trc;\n\t\tchar\t   *hyphen;\n\n\t\t/* Locale names use only ASCII, any conversion locale suffices. */\n\t\trc = wchar2char(iso_lc_messages, loct->locinfo->locale_name[LC_CTYPE],\n\t\t\t\t\t\tsizeof(iso_lc_messages), NULL);\n\t\t_free_locale(loct);\n\t\tif (rc == -1 || rc == sizeof(iso_lc_messages))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Since the message catalogs sit on a case-insensitive filesystem, we\n\t\t * need not standardize letter case here.  So long as we do not ship\n\t\t * message catalogs for which it would matter, we also need not\n\t\t * translate the script/variant portion, e.g. uz-Cyrl-UZ to\n\t\t * uz_UZ@cyrillic.  Simply replace the hyphen with an underscore.\n\t\t *\n\t\t * Note that the locale name can be less-specific than the value we\n\t\t * would derive under earlier Visual Studio releases.  For example,\n\t\t * French_France.1252 yields just \"fr\".  This does not affect any of\n\t\t * the country-specific message catalogs available as of this writing\n\t\t * (pt_BR, zh_CN, zh_TW).\n\t\t */\n\t\thyphen = strchr(iso_lc_messages, '-');\n\t\tif (hyphen)\n\t\t\t*hyphen = '_';\n#else\n\t\tchar\t\tisolang[32],\n\t\t\t\t\tisocrty[32];\n\t\tLCID\t\tlcid;\n\n\t\tlcid = loct->locinfo->lc_handle[LC_CTYPE];\n\t\tif (lcid == 0)\n\t\t\tlcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);\n\t\t_free_locale(loct);\n\n\t\tif (!GetLocaleInfoA(lcid, LOCALE_SISO639LANGNAME, isolang, sizeof(isolang)))\n\t\t\treturn NULL;\n\t\tif (!GetLocaleInfoA(lcid, LOCALE_SISO3166CTRYNAME, isocrty, sizeof(isocrty)))\n\t\t\treturn NULL;\n\t\tsnprintf(iso_lc_messages, sizeof(iso_lc_messages) - 1, \"%s_%s\", isolang, isocrty);\n#endif\n\t\treturn iso_lc_messages;\n\t}\n\treturn NULL;\n#else\n\treturn NULL;\t\t\t\t/* Not supported on this version of msvc/mingw */\n#endif\t\t\t\t\t\t\t/* _MSC_VER >= 1400 */\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "iso_lc_messages",
            "sizeof(iso_lc_messages) - 1",
            "\"%s_%s\"",
            "isolang",
            "isocrty"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLocaleInfoA",
          "args": [
            "lcid",
            "LOCALE_SISO3166CTRYNAME",
            "isocrty",
            "sizeof(isocrty)"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLocaleInfoA",
          "args": [
            "lcid",
            "LOCALE_SISO639LANGNAME",
            "isolang",
            "sizeof(isolang)"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_free_locale",
          "args": [
            "loct"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKELCID",
          "args": [
            "MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)",
            "SORT_DEFAULT"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKELANGID",
          "args": [
            "LANG_ENGLISH",
            "SUBLANG_ENGLISH_US"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "iso_lc_messages",
            "'-'"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_free_locale",
          "args": [
            "loct"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wchar2char",
          "args": [
            "iso_lc_messages",
            "loct->locinfo->locale_name[LC_CTYPE]",
            "sizeof(iso_lc_messages)",
            "NULL"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "wchar2char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1664-1724",
          "snippet": "size_t\nwchar2char(char *to, const wchar_t *from, size_t tolen, pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\n\t/*\n\t * On Windows, the \"Unicode\" locales assume UTF16 not UTF8 encoding, and\n\t * for some reason mbstowcs and wcstombs won't do this for us, so we use\n\t * MultiByteToWideChar().\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\tresult = WideCharToMultiByte(CP_UTF8, 0, from, -1, to, tolen,\n\t\t\t\t\t\t\t\t\t NULL, NULL);\n\t\t/* A zero return is failure */\n\t\tif (result <= 0)\n\t\t\tresult = -1;\n\t\telse\n\t\t{\n\t\t\tAssert(result <= tolen);\n\t\t\t/* Microsoft counts the zero terminator in the result */\n\t\t\tresult--;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\tif (locale == (pg_locale_t) 0)\n\t{\n\t\t/* Use wcstombs directly for the default locale */\n\t\tresult = wcstombs(to, from, tolen);\n\t}\n\telse\n\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_WCSTOMBS_L\n\t\t/* Use wcstombs_l for nondefault locales */\n\t\tresult = wcstombs_l(to, from, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_WCSTOMBS_L */\n\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\tresult = wcstombs(to, from, tolen);\n\n\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_WCSTOMBS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\telog(ERROR, \"wcstombs_l is not available\");\n\t\tresult = 0;\t\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nsize_t\nwchar2char(char *to, const wchar_t *from, size_t tolen, pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\n\t/*\n\t * On Windows, the \"Unicode\" locales assume UTF16 not UTF8 encoding, and\n\t * for some reason mbstowcs and wcstombs won't do this for us, so we use\n\t * MultiByteToWideChar().\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\tresult = WideCharToMultiByte(CP_UTF8, 0, from, -1, to, tolen,\n\t\t\t\t\t\t\t\t\t NULL, NULL);\n\t\t/* A zero return is failure */\n\t\tif (result <= 0)\n\t\t\tresult = -1;\n\t\telse\n\t\t{\n\t\t\tAssert(result <= tolen);\n\t\t\t/* Microsoft counts the zero terminator in the result */\n\t\t\tresult--;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\tif (locale == (pg_locale_t) 0)\n\t{\n\t\t/* Use wcstombs directly for the default locale */\n\t\tresult = wcstombs(to, from, tolen);\n\t}\n\telse\n\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_WCSTOMBS_L\n\t\t/* Use wcstombs_l for nondefault locales */\n\t\tresult = wcstombs_l(to, from, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_WCSTOMBS_L */\n\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\tresult = wcstombs(to, from, tolen);\n\n\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_WCSTOMBS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\telog(ERROR, \"wcstombs_l is not available\");\n\t\tresult = 0;\t\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_create_locale",
          "args": [
            "LC_CTYPE",
            "winlocname"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "iso_lc_messages",
            "\"C\""
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_strcasecmp",
          "args": [
            "\"posix\"",
            "winlocname"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strcasecmp",
          "args": [
            "\"c\"",
            "winlocname"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic char *\nIsoLocaleName(const char *winlocname)\n{\n#if (_MSC_VER >= 1400)\t\t\t/* VC8.0 or later */\n\tstatic char iso_lc_messages[32];\n\t_locale_t\tloct = NULL;\n\n\tif (pg_strcasecmp(\"c\", winlocname) == 0 ||\n\t\tpg_strcasecmp(\"posix\", winlocname) == 0)\n\t{\n\t\tstrcpy(iso_lc_messages, \"C\");\n\t\treturn iso_lc_messages;\n\t}\n\n\tloct = _create_locale(LC_CTYPE, winlocname);\n\tif (loct != NULL)\n\t{\n#if (_MSC_VER >= 1700)\t\t\t/* Visual Studio 2012 or later */\n\t\tsize_t\t\trc;\n\t\tchar\t   *hyphen;\n\n\t\t/* Locale names use only ASCII, any conversion locale suffices. */\n\t\trc = wchar2char(iso_lc_messages, loct->locinfo->locale_name[LC_CTYPE],\n\t\t\t\t\t\tsizeof(iso_lc_messages), NULL);\n\t\t_free_locale(loct);\n\t\tif (rc == -1 || rc == sizeof(iso_lc_messages))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Since the message catalogs sit on a case-insensitive filesystem, we\n\t\t * need not standardize letter case here.  So long as we do not ship\n\t\t * message catalogs for which it would matter, we also need not\n\t\t * translate the script/variant portion, e.g. uz-Cyrl-UZ to\n\t\t * uz_UZ@cyrillic.  Simply replace the hyphen with an underscore.\n\t\t *\n\t\t * Note that the locale name can be less-specific than the value we\n\t\t * would derive under earlier Visual Studio releases.  For example,\n\t\t * French_France.1252 yields just \"fr\".  This does not affect any of\n\t\t * the country-specific message catalogs available as of this writing\n\t\t * (pt_BR, zh_CN, zh_TW).\n\t\t */\n\t\thyphen = strchr(iso_lc_messages, '-');\n\t\tif (hyphen)\n\t\t\t*hyphen = '_';\n#else\n\t\tchar\t\tisolang[32],\n\t\t\t\t\tisocrty[32];\n\t\tLCID\t\tlcid;\n\n\t\tlcid = loct->locinfo->lc_handle[LC_CTYPE];\n\t\tif (lcid == 0)\n\t\t\tlcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);\n\t\t_free_locale(loct);\n\n\t\tif (!GetLocaleInfoA(lcid, LOCALE_SISO639LANGNAME, isolang, sizeof(isolang)))\n\t\t\treturn NULL;\n\t\tif (!GetLocaleInfoA(lcid, LOCALE_SISO3166CTRYNAME, isocrty, sizeof(isocrty)))\n\t\t\treturn NULL;\n\t\tsnprintf(iso_lc_messages, sizeof(iso_lc_messages) - 1, \"%s_%s\", isolang, isocrty);\n#endif\n\t\treturn iso_lc_messages;\n\t}\n\treturn NULL;\n#else\n\treturn NULL;\t\t\t\t/* Not supported on this version of msvc/mingw */\n#endif\t\t\t\t\t\t\t/* _MSC_VER >= 1400 */\n}"
  },
  {
    "function_name": "cache_locale_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "765-928",
    "snippet": "void\ncache_locale_time(void)\n{\n\tchar\t\tbuf[(2 * 7 + 2 * 12) * MAX_L10N_DATA];\n\tchar\t   *bufptr;\n\ttime_t\t\ttimenow;\n\tstruct tm  *timeinfo;\n\tbool\t\tstrftimefail = false;\n\tint\t\t\tencoding;\n\tint\t\t\ti;\n\tchar\t   *save_lc_time;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* did we do this already? */\n\tif (CurrentLCTimeValid)\n\t\treturn;\n\n\telog(DEBUG3, \"cache_locale_time() executed; locale: \\\"%s\\\"\", locale_time);\n\n\t/*\n\t * As in PGLC_localeconv(), it's critical that we not throw error while\n\t * libc's locale settings have nondefault values.  Hence, we just call\n\t * strftime() within the critical section, and then convert and save its\n\t * results afterwards.\n\t */\n\n\t/* Save prevailing value of time locale */\n\tsave_lc_time = setlocale(LC_TIME, NULL);\n\tif (!save_lc_time)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_time = pstrdup(save_lc_time);\n\n#ifdef WIN32\n\n\t/*\n\t * On Windows, it appears that wcsftime() internally uses LC_CTYPE, so we\n\t * must set it here.  This code looks the same as what PGLC_localeconv()\n\t * does, but the underlying reason is different: this does NOT determine\n\t * the encoding we'll get back from strftime_win32().\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* use lc_time to set the ctype */\n\tsetlocale(LC_CTYPE, locale_time);\n#endif\n\n\tsetlocale(LC_TIME, locale_time);\n\n\t/* We use times close to current time as data for strftime(). */\n\ttimenow = time(NULL);\n\ttimeinfo = localtime(&timenow);\n\n\t/* Store the strftime results in MAX_L10N_DATA-sized portions of buf[] */\n\tbufptr = buf;\n\n\t/*\n\t * MAX_L10N_DATA is sufficient buffer space for every known locale, and\n\t * POSIX defines no strftime() errors.  (Buffer space exhaustion is not an\n\t * error.)  An implementation might report errors (e.g. ENOMEM) by\n\t * returning 0 (or, less plausibly, a negative value) and setting errno.\n\t * Report errno just in case the implementation did that, but clear it in\n\t * advance of the calls so we don't emit a stale, unrelated errno.\n\t */\n\terrno = 0;\n\n\t/* localized days */\n\tfor (i = 0; i < 7; i++)\n\t{\n\t\ttimeinfo->tm_wday = i;\n\t\tif (strftime(bufptr, MAX_L10N_DATA, \"%a\", timeinfo) <= 0)\n\t\t\tstrftimefail = true;\n\t\tbufptr += MAX_L10N_DATA;\n\t\tif (strftime(bufptr, MAX_L10N_DATA, \"%A\", timeinfo) <= 0)\n\t\t\tstrftimefail = true;\n\t\tbufptr += MAX_L10N_DATA;\n\t}\n\n\t/* localized months */\n\tfor (i = 0; i < 12; i++)\n\t{\n\t\ttimeinfo->tm_mon = i;\n\t\ttimeinfo->tm_mday = 1;\t/* make sure we don't have invalid date */\n\t\tif (strftime(bufptr, MAX_L10N_DATA, \"%b\", timeinfo) <= 0)\n\t\t\tstrftimefail = true;\n\t\tbufptr += MAX_L10N_DATA;\n\t\tif (strftime(bufptr, MAX_L10N_DATA, \"%B\", timeinfo) <= 0)\n\t\t\tstrftimefail = true;\n\t\tbufptr += MAX_L10N_DATA;\n\t}\n\n\t/*\n\t * Restore the prevailing locale settings; as in PGLC_localeconv(),\n\t * failure to do so is fatal.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_TIME, save_lc_time))\n\t\telog(FATAL, \"failed to restore LC_TIME to \\\"%s\\\"\", save_lc_time);\n\n\t/*\n\t * At this point we've done our best to clean up, and can throw errors, or\n\t * call functions that might throw errors, with a clean conscience.\n\t */\n\tif (strftimefail)\n\t\telog(ERROR, \"strftime() failed: %m\");\n\n\t/* Release the pstrdup'd locale names */\n\tpfree(save_lc_time);\n#ifdef WIN32\n\tpfree(save_lc_ctype);\n#endif\n\n#ifndef WIN32\n\n\t/*\n\t * As in PGLC_localeconv(), we must convert strftime()'s output from the\n\t * encoding implied by LC_TIME to the database encoding.  If we can't\n\t * identify the LC_TIME encoding, just perform encoding validation.\n\t */\n\tencoding = pg_get_encoding_from_locale(locale_time, true);\n\tif (encoding < 0)\n\t\tencoding = PG_SQL_ASCII;\n\n#else\n\n\t/*\n\t * On Windows, strftime_win32() always returns UTF8 data, so convert from\n\t * that if necessary.\n\t */\n\tencoding = PG_UTF8;\n\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tbufptr = buf;\n\n\t/* localized days */\n\tfor (i = 0; i < 7; i++)\n\t{\n\t\tcache_single_string(&localized_abbrev_days[i], bufptr, encoding);\n\t\tbufptr += MAX_L10N_DATA;\n\t\tcache_single_string(&localized_full_days[i], bufptr, encoding);\n\t\tbufptr += MAX_L10N_DATA;\n\t}\n\n\t/* localized months */\n\tfor (i = 0; i < 12; i++)\n\t{\n\t\tcache_single_string(&localized_abbrev_months[i], bufptr, encoding);\n\t\tbufptr += MAX_L10N_DATA;\n\t\tcache_single_string(&localized_full_months[i], bufptr, encoding);\n\t\tbufptr += MAX_L10N_DATA;\n\t}\n\n\tCurrentLCTimeValid = true;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define\t\tMAX_L10N_DATA\t\t80"
    ],
    "globals_used": [
      "char\t   *locale_time;",
      "char\t   *localized_abbrev_days[7];",
      "char\t   *localized_full_days[7];",
      "char\t   *localized_abbrev_months[12];",
      "char\t   *localized_full_months[12];",
      "static bool CurrentLCTimeValid = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_single_string",
          "args": [
            "&localized_full_months[i]",
            "bufptr",
            "encoding"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "cache_single_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "742-760",
          "snippet": "static void\ncache_single_string(char **dst, const char *src, int encoding)\n{\n\tchar\t   *ptr;\n\tchar\t   *olddst;\n\n\t/* Convert the string to the database encoding, or validate it's OK */\n\tptr = pg_any_to_server(src, strlen(src), encoding);\n\n\t/* Store the string in long-lived storage, replacing any previous value */\n\tolddst = *dst;\n\t*dst = MemoryContextStrdup(TopMemoryContext, ptr);\n\tif (olddst)\n\t\tpfree(olddst);\n\n\t/* Might as well clean up any palloc'd conversion result, too */\n\tif (ptr != src)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic void\ncache_single_string(char **dst, const char *src, int encoding)\n{\n\tchar\t   *ptr;\n\tchar\t   *olddst;\n\n\t/* Convert the string to the database encoding, or validate it's OK */\n\tptr = pg_any_to_server(src, strlen(src), encoding);\n\n\t/* Store the string in long-lived storage, replacing any previous value */\n\tolddst = *dst;\n\t*dst = MemoryContextStrdup(TopMemoryContext, ptr);\n\tif (olddst)\n\t\tpfree(olddst);\n\n\t/* Might as well clean up any palloc'd conversion result, too */\n\tif (ptr != src)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_get_encoding_from_locale",
          "args": [
            "locale_time",
            "true"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "save_lc_ctype"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"strftime() failed: %m\""
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setlocale",
          "args": [
            "LC_TIME",
            "save_lc_time"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "pg_perm_setlocale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "151-251",
          "snippet": "char *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)"
          ],
          "globals_used": [
            "static char lc_collate_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_ctype_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_monetary_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_numeric_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_time_envbuf[LC_ENV_BUFSIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\n#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)\n\nstatic char lc_collate_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_ctype_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_monetary_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_numeric_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_time_envbuf[LC_ENV_BUFSIZE];\n\nchar *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strftime",
          "args": [
            "bufptr",
            "MAX_L10N_DATA",
            "\"%B\"",
            "timeinfo"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "strftime_win32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "694-731",
          "snippet": "static size_t\nstrftime_win32(char *dst, size_t dstlen,\n\t\t\t   const char *format, const struct tm *tm)\n{\n\tsize_t\t\tlen;\n\twchar_t\t\twformat[8];\t\t/* formats used below need 3 chars */\n\twchar_t\t\twbuf[MAX_L10N_DATA];\n\n\t/*\n\t * Get a wchar_t version of the format string.  We only actually use\n\t * plain-ASCII formats in this file, so we can say that they're UTF8.\n\t */\n\tlen = MultiByteToWideChar(CP_UTF8, 0, format, -1,\n\t\t\t\t\t\t\t  wformat, lengthof(wformat));\n\tif (len == 0)\n\t\telog(ERROR, \"could not convert format string from UTF-8: error code %lu\",\n\t\t\t GetLastError());\n\n\tlen = wcsftime(wbuf, MAX_L10N_DATA, wformat, tm);\n\tif (len == 0)\n\t{\n\t\t/*\n\t\t * wcsftime failed, possibly because the result would not fit in\n\t\t * MAX_L10N_DATA.  Return 0 with the contents of dst unspecified.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tlen = WideCharToMultiByte(CP_UTF8, 0, wbuf, len, dst, dstlen - 1,\n\t\t\t\t\t\t\t  NULL, NULL);\n\tif (len == 0)\n\t\telog(ERROR, \"could not convert string to UTF-8: error code %lu\",\n\t\t\t GetLastError());\n\n\tdst[len] = '\\0';\n\n\treturn len;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define\t\tMAX_L10N_DATA\t\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\n#define\t\tMAX_L10N_DATA\t\t80\n\nstatic size_t\nstrftime_win32(char *dst, size_t dstlen,\n\t\t\t   const char *format, const struct tm *tm)\n{\n\tsize_t\t\tlen;\n\twchar_t\t\twformat[8];\t\t/* formats used below need 3 chars */\n\twchar_t\t\twbuf[MAX_L10N_DATA];\n\n\t/*\n\t * Get a wchar_t version of the format string.  We only actually use\n\t * plain-ASCII formats in this file, so we can say that they're UTF8.\n\t */\n\tlen = MultiByteToWideChar(CP_UTF8, 0, format, -1,\n\t\t\t\t\t\t\t  wformat, lengthof(wformat));\n\tif (len == 0)\n\t\telog(ERROR, \"could not convert format string from UTF-8: error code %lu\",\n\t\t\t GetLastError());\n\n\tlen = wcsftime(wbuf, MAX_L10N_DATA, wformat, tm);\n\tif (len == 0)\n\t{\n\t\t/*\n\t\t * wcsftime failed, possibly because the result would not fit in\n\t\t * MAX_L10N_DATA.  Return 0 with the contents of dst unspecified.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tlen = WideCharToMultiByte(CP_UTF8, 0, wbuf, len, dst, dstlen - 1,\n\t\t\t\t\t\t\t  NULL, NULL);\n\tif (len == 0)\n\t\telog(ERROR, \"could not convert string to UTF-8: error code %lu\",\n\t\t\t GetLastError());\n\n\tdst[len] = '\\0';\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "localtime",
          "args": [
            "&timenow"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "pg_timezone_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "4766-4876",
          "snippet": "Datum\npg_timezone_names(PG_FUNCTION_ARGS)\n{\n\tMemoryContext oldcontext;\n\tFuncCallContext *funcctx;\n\tpg_tzenum  *tzenum;\n\tpg_tz\t   *tz;\n\tDatum\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\tvalues[4];\n\tbool\t\tnulls[4];\n\tint\t\t\ttzoff;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\tconst char *tzn;\n\tInterval   *resInterval;\n\tstruct pg_tm itm;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTupleDesc\ttupdesc;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* initialize timezone scanning code */\n\t\ttzenum = pg_tzenumerate_start();\n\t\tfuncctx->user_fctx = (void *) tzenum;\n\n\t\t/*\n\t\t * build tupdesc for result tuples. This must match this function's\n\t\t * pg_proc entry!\n\t\t */\n\t\ttupdesc = CreateTemplateTupleDesc(4, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"abbrev\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"utc_offset\",\n\t\t\t\t\t\t   INTERVALOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 4, \"is_dst\",\n\t\t\t\t\t\t   BOOLOID, -1, 0);\n\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\ttzenum = (pg_tzenum *) funcctx->user_fctx;\n\n\t/* search for another zone to display */\n\tfor (;;)\n\t{\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\t\ttz = pg_tzenumerate_next(tzenum);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\tif (!tz)\n\t\t{\n\t\t\tpg_tzenumerate_end(tzenum);\n\t\t\tfuncctx->user_fctx = NULL;\n\t\t\tSRF_RETURN_DONE(funcctx);\n\t\t}\n\n\t\t/* Convert now() to local time in this zone */\n\t\tif (timestamp2tm(GetCurrentTransactionStartTimestamp(),\n\t\t\t\t\t\t &tzoff, &tm, &fsec, &tzn, tz) != 0)\n\t\t\tcontinue;\t\t\t/* ignore if conversion fails */\n\n\t\t/*\n\t\t * Ignore zic's rather silly \"Factory\" time zone.  The long string\n\t\t * about \"see zic manual page\" is used in tzdata versions before\n\t\t * 2016g; we can drop it someday when we're pretty sure no such data\n\t\t * exists in the wild on platforms using --with-system-tzdata.  In\n\t\t * 2016g and later, the time zone abbreviation \"-00\" is used for\n\t\t * \"Factory\" as well as some invalid cases, all of which we can\n\t\t * reasonably omit from the pg_timezone_names view.\n\t\t */\n\t\tif (tzn && (strcmp(tzn, \"-00\") == 0 ||\n\t\t\t\t\tstrcmp(tzn, \"Local time zone must be set--see zic manual page\") == 0))\n\t\t\tcontinue;\n\n\t\t/* Found a displayable zone */\n\t\tbreak;\n\t}\n\n\tMemSet(nulls, 0, sizeof(nulls));\n\n\tvalues[0] = CStringGetTextDatum(pg_get_timezone_name(tz));\n\tvalues[1] = CStringGetTextDatum(tzn ? tzn : \"\");\n\n\tMemSet(&itm, 0, sizeof(struct pg_tm));\n\titm.tm_sec = -tzoff;\n\tresInterval = (Interval *) palloc(sizeof(Interval));\n\ttm2interval(&itm, 0, resInterval);\n\tvalues[2] = IntervalPGetDatum(resInterval);\n\n\tvalues[3] = BoolGetDatum(tm.tm_isdst > 0);\n\n\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\tresult = HeapTupleGetDatum(tuple);\n\n\tSRF_RETURN_NEXT(funcctx, result);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nDatum\npg_timezone_names(PG_FUNCTION_ARGS)\n{\n\tMemoryContext oldcontext;\n\tFuncCallContext *funcctx;\n\tpg_tzenum  *tzenum;\n\tpg_tz\t   *tz;\n\tDatum\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\tvalues[4];\n\tbool\t\tnulls[4];\n\tint\t\t\ttzoff;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\tconst char *tzn;\n\tInterval   *resInterval;\n\tstruct pg_tm itm;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTupleDesc\ttupdesc;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* initialize timezone scanning code */\n\t\ttzenum = pg_tzenumerate_start();\n\t\tfuncctx->user_fctx = (void *) tzenum;\n\n\t\t/*\n\t\t * build tupdesc for result tuples. This must match this function's\n\t\t * pg_proc entry!\n\t\t */\n\t\ttupdesc = CreateTemplateTupleDesc(4, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"abbrev\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"utc_offset\",\n\t\t\t\t\t\t   INTERVALOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 4, \"is_dst\",\n\t\t\t\t\t\t   BOOLOID, -1, 0);\n\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\ttzenum = (pg_tzenum *) funcctx->user_fctx;\n\n\t/* search for another zone to display */\n\tfor (;;)\n\t{\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\t\ttz = pg_tzenumerate_next(tzenum);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\tif (!tz)\n\t\t{\n\t\t\tpg_tzenumerate_end(tzenum);\n\t\t\tfuncctx->user_fctx = NULL;\n\t\t\tSRF_RETURN_DONE(funcctx);\n\t\t}\n\n\t\t/* Convert now() to local time in this zone */\n\t\tif (timestamp2tm(GetCurrentTransactionStartTimestamp(),\n\t\t\t\t\t\t &tzoff, &tm, &fsec, &tzn, tz) != 0)\n\t\t\tcontinue;\t\t\t/* ignore if conversion fails */\n\n\t\t/*\n\t\t * Ignore zic's rather silly \"Factory\" time zone.  The long string\n\t\t * about \"see zic manual page\" is used in tzdata versions before\n\t\t * 2016g; we can drop it someday when we're pretty sure no such data\n\t\t * exists in the wild on platforms using --with-system-tzdata.  In\n\t\t * 2016g and later, the time zone abbreviation \"-00\" is used for\n\t\t * \"Factory\" as well as some invalid cases, all of which we can\n\t\t * reasonably omit from the pg_timezone_names view.\n\t\t */\n\t\tif (tzn && (strcmp(tzn, \"-00\") == 0 ||\n\t\t\t\t\tstrcmp(tzn, \"Local time zone must be set--see zic manual page\") == 0))\n\t\t\tcontinue;\n\n\t\t/* Found a displayable zone */\n\t\tbreak;\n\t}\n\n\tMemSet(nulls, 0, sizeof(nulls));\n\n\tvalues[0] = CStringGetTextDatum(pg_get_timezone_name(tz));\n\tvalues[1] = CStringGetTextDatum(tzn ? tzn : \"\");\n\n\tMemSet(&itm, 0, sizeof(struct pg_tm));\n\titm.tm_sec = -tzoff;\n\tresInterval = (Interval *) palloc(sizeof(Interval));\n\ttm2interval(&itm, 0, resInterval);\n\tvalues[2] = IntervalPGetDatum(resInterval);\n\n\tvalues[3] = BoolGetDatum(tm.tm_isdst > 0);\n\n\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\tresult = HeapTupleGetDatum(tuple);\n\n\tSRF_RETURN_NEXT(funcctx, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "save_lc_ctype"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\n#define\t\tMAX_L10N_DATA\t\t80\n\nchar\t   *locale_time;\nchar\t   *localized_abbrev_days[7];\nchar\t   *localized_full_days[7];\nchar\t   *localized_abbrev_months[12];\nchar\t   *localized_full_months[12];\nstatic bool CurrentLCTimeValid = false;\n\nvoid\ncache_locale_time(void)\n{\n\tchar\t\tbuf[(2 * 7 + 2 * 12) * MAX_L10N_DATA];\n\tchar\t   *bufptr;\n\ttime_t\t\ttimenow;\n\tstruct tm  *timeinfo;\n\tbool\t\tstrftimefail = false;\n\tint\t\t\tencoding;\n\tint\t\t\ti;\n\tchar\t   *save_lc_time;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* did we do this already? */\n\tif (CurrentLCTimeValid)\n\t\treturn;\n\n\telog(DEBUG3, \"cache_locale_time() executed; locale: \\\"%s\\\"\", locale_time);\n\n\t/*\n\t * As in PGLC_localeconv(), it's critical that we not throw error while\n\t * libc's locale settings have nondefault values.  Hence, we just call\n\t * strftime() within the critical section, and then convert and save its\n\t * results afterwards.\n\t */\n\n\t/* Save prevailing value of time locale */\n\tsave_lc_time = setlocale(LC_TIME, NULL);\n\tif (!save_lc_time)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_time = pstrdup(save_lc_time);\n\n#ifdef WIN32\n\n\t/*\n\t * On Windows, it appears that wcsftime() internally uses LC_CTYPE, so we\n\t * must set it here.  This code looks the same as what PGLC_localeconv()\n\t * does, but the underlying reason is different: this does NOT determine\n\t * the encoding we'll get back from strftime_win32().\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* use lc_time to set the ctype */\n\tsetlocale(LC_CTYPE, locale_time);\n#endif\n\n\tsetlocale(LC_TIME, locale_time);\n\n\t/* We use times close to current time as data for strftime(). */\n\ttimenow = time(NULL);\n\ttimeinfo = localtime(&timenow);\n\n\t/* Store the strftime results in MAX_L10N_DATA-sized portions of buf[] */\n\tbufptr = buf;\n\n\t/*\n\t * MAX_L10N_DATA is sufficient buffer space for every known locale, and\n\t * POSIX defines no strftime() errors.  (Buffer space exhaustion is not an\n\t * error.)  An implementation might report errors (e.g. ENOMEM) by\n\t * returning 0 (or, less plausibly, a negative value) and setting errno.\n\t * Report errno just in case the implementation did that, but clear it in\n\t * advance of the calls so we don't emit a stale, unrelated errno.\n\t */\n\terrno = 0;\n\n\t/* localized days */\n\tfor (i = 0; i < 7; i++)\n\t{\n\t\ttimeinfo->tm_wday = i;\n\t\tif (strftime(bufptr, MAX_L10N_DATA, \"%a\", timeinfo) <= 0)\n\t\t\tstrftimefail = true;\n\t\tbufptr += MAX_L10N_DATA;\n\t\tif (strftime(bufptr, MAX_L10N_DATA, \"%A\", timeinfo) <= 0)\n\t\t\tstrftimefail = true;\n\t\tbufptr += MAX_L10N_DATA;\n\t}\n\n\t/* localized months */\n\tfor (i = 0; i < 12; i++)\n\t{\n\t\ttimeinfo->tm_mon = i;\n\t\ttimeinfo->tm_mday = 1;\t/* make sure we don't have invalid date */\n\t\tif (strftime(bufptr, MAX_L10N_DATA, \"%b\", timeinfo) <= 0)\n\t\t\tstrftimefail = true;\n\t\tbufptr += MAX_L10N_DATA;\n\t\tif (strftime(bufptr, MAX_L10N_DATA, \"%B\", timeinfo) <= 0)\n\t\t\tstrftimefail = true;\n\t\tbufptr += MAX_L10N_DATA;\n\t}\n\n\t/*\n\t * Restore the prevailing locale settings; as in PGLC_localeconv(),\n\t * failure to do so is fatal.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_TIME, save_lc_time))\n\t\telog(FATAL, \"failed to restore LC_TIME to \\\"%s\\\"\", save_lc_time);\n\n\t/*\n\t * At this point we've done our best to clean up, and can throw errors, or\n\t * call functions that might throw errors, with a clean conscience.\n\t */\n\tif (strftimefail)\n\t\telog(ERROR, \"strftime() failed: %m\");\n\n\t/* Release the pstrdup'd locale names */\n\tpfree(save_lc_time);\n#ifdef WIN32\n\tpfree(save_lc_ctype);\n#endif\n\n#ifndef WIN32\n\n\t/*\n\t * As in PGLC_localeconv(), we must convert strftime()'s output from the\n\t * encoding implied by LC_TIME to the database encoding.  If we can't\n\t * identify the LC_TIME encoding, just perform encoding validation.\n\t */\n\tencoding = pg_get_encoding_from_locale(locale_time, true);\n\tif (encoding < 0)\n\t\tencoding = PG_SQL_ASCII;\n\n#else\n\n\t/*\n\t * On Windows, strftime_win32() always returns UTF8 data, so convert from\n\t * that if necessary.\n\t */\n\tencoding = PG_UTF8;\n\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tbufptr = buf;\n\n\t/* localized days */\n\tfor (i = 0; i < 7; i++)\n\t{\n\t\tcache_single_string(&localized_abbrev_days[i], bufptr, encoding);\n\t\tbufptr += MAX_L10N_DATA;\n\t\tcache_single_string(&localized_full_days[i], bufptr, encoding);\n\t\tbufptr += MAX_L10N_DATA;\n\t}\n\n\t/* localized months */\n\tfor (i = 0; i < 12; i++)\n\t{\n\t\tcache_single_string(&localized_abbrev_months[i], bufptr, encoding);\n\t\tbufptr += MAX_L10N_DATA;\n\t\tcache_single_string(&localized_full_months[i], bufptr, encoding);\n\t\tbufptr += MAX_L10N_DATA;\n\t}\n\n\tCurrentLCTimeValid = true;\n}"
  },
  {
    "function_name": "cache_single_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "742-760",
    "snippet": "static void\ncache_single_string(char **dst, const char *src, int encoding)\n{\n\tchar\t   *ptr;\n\tchar\t   *olddst;\n\n\t/* Convert the string to the database encoding, or validate it's OK */\n\tptr = pg_any_to_server(src, strlen(src), encoding);\n\n\t/* Store the string in long-lived storage, replacing any previous value */\n\tolddst = *dst;\n\t*dst = MemoryContextStrdup(TopMemoryContext, ptr);\n\tif (olddst)\n\t\tpfree(olddst);\n\n\t/* Might as well clean up any palloc'd conversion result, too */\n\tif (ptr != src)\n\t\tpfree(ptr);\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "ptr"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextStrdup",
          "args": [
            "TopMemoryContext",
            "ptr"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextStrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1147-1158",
          "snippet": "char *\nMemoryContextStrdup(MemoryContext context, const char *string)\n{\n\tchar\t   *nstr;\n\tSize\t\tlen = strlen(string) + 1;\n\n\tnstr = (char *) MemoryContextAlloc(context, len);\n\n\tmemcpy(nstr, string, len);\n\n\treturn nstr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nchar *\nMemoryContextStrdup(MemoryContext context, const char *string)\n{\n\tchar\t   *nstr;\n\tSize\t\tlen = strlen(string) + 1;\n\n\tnstr = (char *) MemoryContextAlloc(context, len);\n\n\tmemcpy(nstr, string, len);\n\n\treturn nstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_any_to_server",
          "args": [
            "src",
            "strlen(src)",
            "encoding"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "pg_any_to_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "560-615",
          "snippet": "char *\npg_any_to_server(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is needed, but we must still validate the data.\n\t\t */\n\t\t(void) pg_verify_mbstr(DatabaseEncoding->encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is possible, but we must still validate the data,\n\t\t * because the client-side code might have done string escaping using\n\t\t * the selected client_encoding.  If the client encoding is ASCII-safe\n\t\t * then we just do a straight validation under that encoding.  For an\n\t\t * ASCII-unsafe encoding we have a problem: we dare not pass such data\n\t\t * to the parser but we have no way to convert it.  We compromise by\n\t\t * rejecting the data if it contains any non-ASCII characters.\n\t\t */\n\t\tif (PG_VALID_BE_ENCODING(encoding))\n\t\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\telse\n\t\t{\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tif (s[i] == '\\0' || IS_HIGHBIT_SET(s[i]))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t\t\t\t errmsg(\"invalid byte value for encoding \\\"%s\\\": 0x%02x\",\n\t\t\t\t\t\t\t\t\tpg_enc2name_tbl[PG_SQL_ASCII].name,\n\t\t\t\t\t\t\t\t\t(unsigned char) s[i])));\n\t\t\t}\n\t\t}\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, true);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  encoding,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nchar *\npg_any_to_server(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is needed, but we must still validate the data.\n\t\t */\n\t\t(void) pg_verify_mbstr(DatabaseEncoding->encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is possible, but we must still validate the data,\n\t\t * because the client-side code might have done string escaping using\n\t\t * the selected client_encoding.  If the client encoding is ASCII-safe\n\t\t * then we just do a straight validation under that encoding.  For an\n\t\t * ASCII-unsafe encoding we have a problem: we dare not pass such data\n\t\t * to the parser but we have no way to convert it.  We compromise by\n\t\t * rejecting the data if it contains any non-ASCII characters.\n\t\t */\n\t\tif (PG_VALID_BE_ENCODING(encoding))\n\t\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\telse\n\t\t{\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tif (s[i] == '\\0' || IS_HIGHBIT_SET(s[i]))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t\t\t\t errmsg(\"invalid byte value for encoding \\\"%s\\\": 0x%02x\",\n\t\t\t\t\t\t\t\t\tpg_enc2name_tbl[PG_SQL_ASCII].name,\n\t\t\t\t\t\t\t\t\t(unsigned char) s[i])));\n\t\t\t}\n\t\t}\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, true);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  encoding,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "src"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic void\ncache_single_string(char **dst, const char *src, int encoding)\n{\n\tchar\t   *ptr;\n\tchar\t   *olddst;\n\n\t/* Convert the string to the database encoding, or validate it's OK */\n\tptr = pg_any_to_server(src, strlen(src), encoding);\n\n\t/* Store the string in long-lived storage, replacing any previous value */\n\tolddst = *dst;\n\t*dst = MemoryContextStrdup(TopMemoryContext, ptr);\n\tif (olddst)\n\t\tpfree(olddst);\n\n\t/* Might as well clean up any palloc'd conversion result, too */\n\tif (ptr != src)\n\t\tpfree(ptr);\n}"
  },
  {
    "function_name": "strftime_win32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "694-731",
    "snippet": "static size_t\nstrftime_win32(char *dst, size_t dstlen,\n\t\t\t   const char *format, const struct tm *tm)\n{\n\tsize_t\t\tlen;\n\twchar_t\t\twformat[8];\t\t/* formats used below need 3 chars */\n\twchar_t\t\twbuf[MAX_L10N_DATA];\n\n\t/*\n\t * Get a wchar_t version of the format string.  We only actually use\n\t * plain-ASCII formats in this file, so we can say that they're UTF8.\n\t */\n\tlen = MultiByteToWideChar(CP_UTF8, 0, format, -1,\n\t\t\t\t\t\t\t  wformat, lengthof(wformat));\n\tif (len == 0)\n\t\telog(ERROR, \"could not convert format string from UTF-8: error code %lu\",\n\t\t\t GetLastError());\n\n\tlen = wcsftime(wbuf, MAX_L10N_DATA, wformat, tm);\n\tif (len == 0)\n\t{\n\t\t/*\n\t\t * wcsftime failed, possibly because the result would not fit in\n\t\t * MAX_L10N_DATA.  Return 0 with the contents of dst unspecified.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tlen = WideCharToMultiByte(CP_UTF8, 0, wbuf, len, dst, dstlen - 1,\n\t\t\t\t\t\t\t  NULL, NULL);\n\tif (len == 0)\n\t\telog(ERROR, \"could not convert string to UTF-8: error code %lu\",\n\t\t\t GetLastError());\n\n\tdst[len] = '\\0';\n\n\treturn len;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define\t\tMAX_L10N_DATA\t\t80"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not convert string to UTF-8: error code %lu\"",
            "GetLastError()"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WideCharToMultiByte",
          "args": [
            "CP_UTF8",
            "0",
            "wbuf",
            "len",
            "dst",
            "dstlen - 1",
            "NULL",
            "NULL"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcsftime",
          "args": [
            "wbuf",
            "MAX_L10N_DATA",
            "wformat",
            "tm"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiByteToWideChar",
          "args": [
            "CP_UTF8",
            "0",
            "format",
            "-1",
            "wformat",
            "lengthof(wformat)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthof",
          "args": [
            "wformat"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\n#define\t\tMAX_L10N_DATA\t\t80\n\nstatic size_t\nstrftime_win32(char *dst, size_t dstlen,\n\t\t\t   const char *format, const struct tm *tm)\n{\n\tsize_t\t\tlen;\n\twchar_t\t\twformat[8];\t\t/* formats used below need 3 chars */\n\twchar_t\t\twbuf[MAX_L10N_DATA];\n\n\t/*\n\t * Get a wchar_t version of the format string.  We only actually use\n\t * plain-ASCII formats in this file, so we can say that they're UTF8.\n\t */\n\tlen = MultiByteToWideChar(CP_UTF8, 0, format, -1,\n\t\t\t\t\t\t\t  wformat, lengthof(wformat));\n\tif (len == 0)\n\t\telog(ERROR, \"could not convert format string from UTF-8: error code %lu\",\n\t\t\t GetLastError());\n\n\tlen = wcsftime(wbuf, MAX_L10N_DATA, wformat, tm);\n\tif (len == 0)\n\t{\n\t\t/*\n\t\t * wcsftime failed, possibly because the result would not fit in\n\t\t * MAX_L10N_DATA.  Return 0 with the contents of dst unspecified.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tlen = WideCharToMultiByte(CP_UTF8, 0, wbuf, len, dst, dstlen - 1,\n\t\t\t\t\t\t\t  NULL, NULL);\n\tif (len == 0)\n\t\telog(ERROR, \"could not convert string to UTF-8: error code %lu\",\n\t\t\t GetLastError());\n\n\tdst[len] = '\\0';\n\n\treturn len;\n}"
  },
  {
    "function_name": "PGLC_localeconv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "483-676",
    "snippet": "struct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char\t   *locale_monetary;",
      "char\t   *locale_numeric;",
      "static bool CurrentLocaleConvValid = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_END_TRY",
          "args": [],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_struct_lconv",
          "args": [
            "&worklconv"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "free_struct_lconv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "393-416",
          "snippet": "static void\nfree_struct_lconv(struct lconv *s)\n{\n\tif (s->decimal_point)\n\t\tfree(s->decimal_point);\n\tif (s->thousands_sep)\n\t\tfree(s->thousands_sep);\n\tif (s->grouping)\n\t\tfree(s->grouping);\n\tif (s->int_curr_symbol)\n\t\tfree(s->int_curr_symbol);\n\tif (s->currency_symbol)\n\t\tfree(s->currency_symbol);\n\tif (s->mon_decimal_point)\n\t\tfree(s->mon_decimal_point);\n\tif (s->mon_thousands_sep)\n\t\tfree(s->mon_thousands_sep);\n\tif (s->mon_grouping)\n\t\tfree(s->mon_grouping);\n\tif (s->positive_sign)\n\t\tfree(s->positive_sign);\n\tif (s->negative_sign)\n\t\tfree(s->negative_sign);\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic void\nfree_struct_lconv(struct lconv *s)\n{\n\tif (s->decimal_point)\n\t\tfree(s->decimal_point);\n\tif (s->thousands_sep)\n\t\tfree(s->thousands_sep);\n\tif (s->grouping)\n\t\tfree(s->grouping);\n\tif (s->int_curr_symbol)\n\t\tfree(s->int_curr_symbol);\n\tif (s->currency_symbol)\n\t\tfree(s->currency_symbol);\n\tif (s->mon_decimal_point)\n\t\tfree(s->mon_decimal_point);\n\tif (s->mon_thousands_sep)\n\t\tfree(s->mon_thousands_sep);\n\tif (s->mon_grouping)\n\t\tfree(s->mon_grouping);\n\tif (s->positive_sign)\n\t\tfree(s->positive_sign);\n\tif (s->negative_sign)\n\t\tfree(s->negative_sign);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_CATCH",
          "args": [],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_encoding_convert",
          "args": [
            "encoding",
            "&worklconv.negative_sign"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "db_encoding_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "453-476",
          "snippet": "static void\ndb_encoding_convert(int encoding, char **str)\n{\n\tchar\t   *pstr;\n\tchar\t   *mstr;\n\n\t/* convert the string to the database encoding */\n\tpstr = pg_any_to_server(*str, strlen(*str), encoding);\n\tif (pstr == *str)\n\t\treturn;\t\t\t\t\t/* no conversion happened */\n\n\t/* need it malloc'd not palloc'd */\n\tmstr = strdup(pstr);\n\tif (mstr == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\n\t/* replace old string */\n\tfree(*str);\n\t*str = mstr;\n\n\tpfree(pstr);\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic void\ndb_encoding_convert(int encoding, char **str)\n{\n\tchar\t   *pstr;\n\tchar\t   *mstr;\n\n\t/* convert the string to the database encoding */\n\tpstr = pg_any_to_server(*str, strlen(*str), encoding);\n\tif (pstr == *str)\n\t\treturn;\t\t\t\t\t/* no conversion happened */\n\n\t/* need it malloc'd not palloc'd */\n\tmstr = strdup(pstr);\n\tif (mstr == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\n\t/* replace old string */\n\tfree(*str);\n\t*str = mstr;\n\n\tpfree(pstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_get_encoding_from_locale",
          "args": [
            "locale_monetary",
            "true"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_get_encoding_from_locale",
          "args": [
            "locale_numeric",
            "true"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\"))"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"out of memory\""
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OUT_OF_MEMORY"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "struct_lconv_is_valid",
          "args": [
            "&worklconv"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "struct_lconv_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "422-446",
          "snippet": "static bool\nstruct_lconv_is_valid(struct lconv *s)\n{\n\tif (s->decimal_point == NULL)\n\t\treturn false;\n\tif (s->thousands_sep == NULL)\n\t\treturn false;\n\tif (s->grouping == NULL)\n\t\treturn false;\n\tif (s->int_curr_symbol == NULL)\n\t\treturn false;\n\tif (s->currency_symbol == NULL)\n\t\treturn false;\n\tif (s->mon_decimal_point == NULL)\n\t\treturn false;\n\tif (s->mon_thousands_sep == NULL)\n\t\treturn false;\n\tif (s->mon_grouping == NULL)\n\t\treturn false;\n\tif (s->positive_sign == NULL)\n\t\treturn false;\n\tif (s->negative_sign == NULL)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic bool\nstruct_lconv_is_valid(struct lconv *s)\n{\n\tif (s->decimal_point == NULL)\n\t\treturn false;\n\tif (s->thousands_sep == NULL)\n\t\treturn false;\n\tif (s->grouping == NULL)\n\t\treturn false;\n\tif (s->int_curr_symbol == NULL)\n\t\treturn false;\n\tif (s->currency_symbol == NULL)\n\t\treturn false;\n\tif (s->mon_decimal_point == NULL)\n\t\treturn false;\n\tif (s->mon_thousands_sep == NULL)\n\t\treturn false;\n\tif (s->mon_grouping == NULL)\n\t\treturn false;\n\tif (s->positive_sign == NULL)\n\t\treturn false;\n\tif (s->negative_sign == NULL)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "save_lc_ctype"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_TRY",
          "args": [],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"failed to restore LC_NUMERIC to \\\"%s\\\"\"",
            "save_lc_numeric"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setlocale",
          "args": [
            "LC_NUMERIC",
            "save_lc_numeric"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "pg_perm_setlocale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "151-251",
          "snippet": "char *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)"
          ],
          "globals_used": [
            "static char lc_collate_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_ctype_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_monetary_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_numeric_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_time_envbuf[LC_ENV_BUFSIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\n#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)\n\nstatic char lc_collate_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_ctype_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_monetary_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_numeric_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_time_envbuf[LC_ENV_BUFSIZE];\n\nchar *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "extlconv->negative_sign"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "_SPI_strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2371-2379",
          "snippet": "static char *\n_SPI_strdup(const char *s)\n{\n\tsize_t\t\tlen = strlen(s) + 1;\n\tchar\t   *ret = SPI_palloc(len);\n\n\tmemcpy(ret, s, len);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\n_SPI_strdup(const char *s)\n{\n\tsize_t\t\tlen = strlen(s) + 1;\n\tchar\t   *ret = SPI_palloc(len);\n\n\tmemcpy(ret, s, len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "localeconv",
          "args": [],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "PGLC_localeconv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "483-676",
          "snippet": "struct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "save_lc_ctype"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&worklconv",
            "0",
            "sizeof(worklconv)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nchar\t   *locale_monetary;\nchar\t   *locale_numeric;\nstatic bool CurrentLocaleConvValid = false;\n\nstruct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}"
  },
  {
    "function_name": "db_encoding_convert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "453-476",
    "snippet": "static void\ndb_encoding_convert(int encoding, char **str)\n{\n\tchar\t   *pstr;\n\tchar\t   *mstr;\n\n\t/* convert the string to the database encoding */\n\tpstr = pg_any_to_server(*str, strlen(*str), encoding);\n\tif (pstr == *str)\n\t\treturn;\t\t\t\t\t/* no conversion happened */\n\n\t/* need it malloc'd not palloc'd */\n\tmstr = strdup(pstr);\n\tif (mstr == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\n\t/* replace old string */\n\tfree(*str);\n\t*str = mstr;\n\n\tpfree(pstr);\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "pstr"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*str"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "free_struct_lconv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "393-416",
          "snippet": "static void\nfree_struct_lconv(struct lconv *s)\n{\n\tif (s->decimal_point)\n\t\tfree(s->decimal_point);\n\tif (s->thousands_sep)\n\t\tfree(s->thousands_sep);\n\tif (s->grouping)\n\t\tfree(s->grouping);\n\tif (s->int_curr_symbol)\n\t\tfree(s->int_curr_symbol);\n\tif (s->currency_symbol)\n\t\tfree(s->currency_symbol);\n\tif (s->mon_decimal_point)\n\t\tfree(s->mon_decimal_point);\n\tif (s->mon_thousands_sep)\n\t\tfree(s->mon_thousands_sep);\n\tif (s->mon_grouping)\n\t\tfree(s->mon_grouping);\n\tif (s->positive_sign)\n\t\tfree(s->positive_sign);\n\tif (s->negative_sign)\n\t\tfree(s->negative_sign);\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic void\nfree_struct_lconv(struct lconv *s)\n{\n\tif (s->decimal_point)\n\t\tfree(s->decimal_point);\n\tif (s->thousands_sep)\n\t\tfree(s->thousands_sep);\n\tif (s->grouping)\n\t\tfree(s->grouping);\n\tif (s->int_curr_symbol)\n\t\tfree(s->int_curr_symbol);\n\tif (s->currency_symbol)\n\t\tfree(s->currency_symbol);\n\tif (s->mon_decimal_point)\n\t\tfree(s->mon_decimal_point);\n\tif (s->mon_thousands_sep)\n\t\tfree(s->mon_thousands_sep);\n\tif (s->mon_grouping)\n\t\tfree(s->mon_grouping);\n\tif (s->positive_sign)\n\t\tfree(s->positive_sign);\n\tif (s->negative_sign)\n\t\tfree(s->negative_sign);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"))"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"out of memory\""
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OUT_OF_MEMORY"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "pstr"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "_SPI_strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2371-2379",
          "snippet": "static char *\n_SPI_strdup(const char *s)\n{\n\tsize_t\t\tlen = strlen(s) + 1;\n\tchar\t   *ret = SPI_palloc(len);\n\n\tmemcpy(ret, s, len);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\n_SPI_strdup(const char *s)\n{\n\tsize_t\t\tlen = strlen(s) + 1;\n\tchar\t   *ret = SPI_palloc(len);\n\n\tmemcpy(ret, s, len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_any_to_server",
          "args": [
            "*str",
            "strlen(*str)",
            "encoding"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "pg_any_to_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "560-615",
          "snippet": "char *\npg_any_to_server(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is needed, but we must still validate the data.\n\t\t */\n\t\t(void) pg_verify_mbstr(DatabaseEncoding->encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is possible, but we must still validate the data,\n\t\t * because the client-side code might have done string escaping using\n\t\t * the selected client_encoding.  If the client encoding is ASCII-safe\n\t\t * then we just do a straight validation under that encoding.  For an\n\t\t * ASCII-unsafe encoding we have a problem: we dare not pass such data\n\t\t * to the parser but we have no way to convert it.  We compromise by\n\t\t * rejecting the data if it contains any non-ASCII characters.\n\t\t */\n\t\tif (PG_VALID_BE_ENCODING(encoding))\n\t\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\telse\n\t\t{\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tif (s[i] == '\\0' || IS_HIGHBIT_SET(s[i]))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t\t\t\t errmsg(\"invalid byte value for encoding \\\"%s\\\": 0x%02x\",\n\t\t\t\t\t\t\t\t\tpg_enc2name_tbl[PG_SQL_ASCII].name,\n\t\t\t\t\t\t\t\t\t(unsigned char) s[i])));\n\t\t\t}\n\t\t}\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, true);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  encoding,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nchar *\npg_any_to_server(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is needed, but we must still validate the data.\n\t\t */\n\t\t(void) pg_verify_mbstr(DatabaseEncoding->encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is possible, but we must still validate the data,\n\t\t * because the client-side code might have done string escaping using\n\t\t * the selected client_encoding.  If the client encoding is ASCII-safe\n\t\t * then we just do a straight validation under that encoding.  For an\n\t\t * ASCII-unsafe encoding we have a problem: we dare not pass such data\n\t\t * to the parser but we have no way to convert it.  We compromise by\n\t\t * rejecting the data if it contains any non-ASCII characters.\n\t\t */\n\t\tif (PG_VALID_BE_ENCODING(encoding))\n\t\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\telse\n\t\t{\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tif (s[i] == '\\0' || IS_HIGHBIT_SET(s[i]))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t\t\t\t errmsg(\"invalid byte value for encoding \\\"%s\\\": 0x%02x\",\n\t\t\t\t\t\t\t\t\tpg_enc2name_tbl[PG_SQL_ASCII].name,\n\t\t\t\t\t\t\t\t\t(unsigned char) s[i])));\n\t\t\t}\n\t\t}\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, true);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  encoding,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*str"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic void\ndb_encoding_convert(int encoding, char **str)\n{\n\tchar\t   *pstr;\n\tchar\t   *mstr;\n\n\t/* convert the string to the database encoding */\n\tpstr = pg_any_to_server(*str, strlen(*str), encoding);\n\tif (pstr == *str)\n\t\treturn;\t\t\t\t\t/* no conversion happened */\n\n\t/* need it malloc'd not palloc'd */\n\tmstr = strdup(pstr);\n\tif (mstr == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\n\t/* replace old string */\n\tfree(*str);\n\t*str = mstr;\n\n\tpfree(pstr);\n}"
  },
  {
    "function_name": "struct_lconv_is_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "422-446",
    "snippet": "static bool\nstruct_lconv_is_valid(struct lconv *s)\n{\n\tif (s->decimal_point == NULL)\n\t\treturn false;\n\tif (s->thousands_sep == NULL)\n\t\treturn false;\n\tif (s->grouping == NULL)\n\t\treturn false;\n\tif (s->int_curr_symbol == NULL)\n\t\treturn false;\n\tif (s->currency_symbol == NULL)\n\t\treturn false;\n\tif (s->mon_decimal_point == NULL)\n\t\treturn false;\n\tif (s->mon_thousands_sep == NULL)\n\t\treturn false;\n\tif (s->mon_grouping == NULL)\n\t\treturn false;\n\tif (s->positive_sign == NULL)\n\t\treturn false;\n\tif (s->negative_sign == NULL)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic bool\nstruct_lconv_is_valid(struct lconv *s)\n{\n\tif (s->decimal_point == NULL)\n\t\treturn false;\n\tif (s->thousands_sep == NULL)\n\t\treturn false;\n\tif (s->grouping == NULL)\n\t\treturn false;\n\tif (s->int_curr_symbol == NULL)\n\t\treturn false;\n\tif (s->currency_symbol == NULL)\n\t\treturn false;\n\tif (s->mon_decimal_point == NULL)\n\t\treturn false;\n\tif (s->mon_thousands_sep == NULL)\n\t\treturn false;\n\tif (s->mon_grouping == NULL)\n\t\treturn false;\n\tif (s->positive_sign == NULL)\n\t\treturn false;\n\tif (s->negative_sign == NULL)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "free_struct_lconv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "393-416",
    "snippet": "static void\nfree_struct_lconv(struct lconv *s)\n{\n\tif (s->decimal_point)\n\t\tfree(s->decimal_point);\n\tif (s->thousands_sep)\n\t\tfree(s->thousands_sep);\n\tif (s->grouping)\n\t\tfree(s->grouping);\n\tif (s->int_curr_symbol)\n\t\tfree(s->int_curr_symbol);\n\tif (s->currency_symbol)\n\t\tfree(s->currency_symbol);\n\tif (s->mon_decimal_point)\n\t\tfree(s->mon_decimal_point);\n\tif (s->mon_thousands_sep)\n\t\tfree(s->mon_thousands_sep);\n\tif (s->mon_grouping)\n\t\tfree(s->mon_grouping);\n\tif (s->positive_sign)\n\t\tfree(s->positive_sign);\n\tif (s->negative_sign)\n\t\tfree(s->negative_sign);\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s->negative_sign"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "free_struct_lconv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "393-416",
          "snippet": "static void\nfree_struct_lconv(struct lconv *s)\n{\n\tif (s->decimal_point)\n\t\tfree(s->decimal_point);\n\tif (s->thousands_sep)\n\t\tfree(s->thousands_sep);\n\tif (s->grouping)\n\t\tfree(s->grouping);\n\tif (s->int_curr_symbol)\n\t\tfree(s->int_curr_symbol);\n\tif (s->currency_symbol)\n\t\tfree(s->currency_symbol);\n\tif (s->mon_decimal_point)\n\t\tfree(s->mon_decimal_point);\n\tif (s->mon_thousands_sep)\n\t\tfree(s->mon_thousands_sep);\n\tif (s->mon_grouping)\n\t\tfree(s->mon_grouping);\n\tif (s->positive_sign)\n\t\tfree(s->positive_sign);\n\tif (s->negative_sign)\n\t\tfree(s->negative_sign);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic void\nfree_struct_lconv(struct lconv *s)\n{\n\tif (s->decimal_point)\n\t\tfree(s->decimal_point);\n\tif (s->thousands_sep)\n\t\tfree(s->thousands_sep);\n\tif (s->grouping)\n\t\tfree(s->grouping);\n\tif (s->int_curr_symbol)\n\t\tfree(s->int_curr_symbol);\n\tif (s->currency_symbol)\n\t\tfree(s->currency_symbol);\n\tif (s->mon_decimal_point)\n\t\tfree(s->mon_decimal_point);\n\tif (s->mon_thousands_sep)\n\t\tfree(s->mon_thousands_sep);\n\tif (s->mon_grouping)\n\t\tfree(s->mon_grouping);\n\tif (s->positive_sign)\n\t\tfree(s->positive_sign);\n\tif (s->negative_sign)\n\t\tfree(s->negative_sign);\n}"
  },
  {
    "function_name": "assign_locale_messages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "376-386",
    "snippet": "void\nassign_locale_messages(const char *newval, void *extra)\n{\n\t/*\n\t * LC_MESSAGES category does not exist everywhere, but accept it anyway.\n\t * We ignore failure, as per comment above.\n\t */\n#ifdef LC_MESSAGES\n\t(void) pg_perm_setlocale(LC_MESSAGES, newval);\n#endif\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_perm_setlocale",
          "args": [
            "LC_MESSAGES",
            "newval"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "pg_perm_setlocale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "151-251",
          "snippet": "char *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)"
          ],
          "globals_used": [
            "static char lc_collate_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_ctype_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_monetary_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_numeric_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_time_envbuf[LC_ENV_BUFSIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\n#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)\n\nstatic char lc_collate_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_ctype_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_monetary_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_numeric_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_time_envbuf[LC_ENV_BUFSIZE];\n\nchar *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nvoid\nassign_locale_messages(const char *newval, void *extra)\n{\n\t/*\n\t * LC_MESSAGES category does not exist everywhere, but accept it anyway.\n\t * We ignore failure, as per comment above.\n\t */\n#ifdef LC_MESSAGES\n\t(void) pg_perm_setlocale(LC_MESSAGES, newval);\n#endif\n}"
  },
  {
    "function_name": "check_locale_messages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "353-374",
    "snippet": "bool\ncheck_locale_messages(char **newval, void **extra, GucSource source)\n{\n\tif (**newval == '\\0')\n\t{\n\t\tif (source == PGC_S_DEFAULT)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * LC_MESSAGES category does not exist everywhere, but accept it anyway\n\t *\n\t * On Windows, we can't even check the value, so accept blindly\n\t */\n#if defined(LC_MESSAGES) && !defined(WIN32)\n\treturn check_locale(LC_MESSAGES, *newval, NULL);\n#else\n\treturn true;\n#endif\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_locale",
          "args": [
            "LC_MESSAGES",
            "*newval",
            "NULL"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "check_locale_messages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "353-374",
          "snippet": "bool\ncheck_locale_messages(char **newval, void **extra, GucSource source)\n{\n\tif (**newval == '\\0')\n\t{\n\t\tif (source == PGC_S_DEFAULT)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * LC_MESSAGES category does not exist everywhere, but accept it anyway\n\t *\n\t * On Windows, we can't even check the value, so accept blindly\n\t */\n#if defined(LC_MESSAGES) && !defined(WIN32)\n\treturn check_locale(LC_MESSAGES, *newval, NULL);\n#else\n\treturn true;\n#endif\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\ncheck_locale_messages(char **newval, void **extra, GucSource source)\n{\n\tif (**newval == '\\0')\n\t{\n\t\tif (source == PGC_S_DEFAULT)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * LC_MESSAGES category does not exist everywhere, but accept it anyway\n\t *\n\t * On Windows, we can't even check the value, so accept blindly\n\t */\n#if defined(LC_MESSAGES) && !defined(WIN32)\n\treturn check_locale(LC_MESSAGES, *newval, NULL);\n#else\n\treturn true;\n#endif\n}"
  },
  {
    "function_name": "assign_locale_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "337-341",
    "snippet": "void\nassign_locale_time(const char *newval, void *extra)\n{\n\tCurrentLCTimeValid = false;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool CurrentLCTimeValid = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic bool CurrentLCTimeValid = false;\n\nvoid\nassign_locale_time(const char *newval, void *extra)\n{\n\tCurrentLCTimeValid = false;\n}"
  },
  {
    "function_name": "check_locale_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "331-335",
    "snippet": "bool\ncheck_locale_time(char **newval, void **extra, GucSource source)\n{\n\treturn check_locale(LC_TIME, *newval, NULL);\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_locale",
          "args": [
            "LC_TIME",
            "*newval",
            "NULL"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "check_locale_messages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "353-374",
          "snippet": "bool\ncheck_locale_messages(char **newval, void **extra, GucSource source)\n{\n\tif (**newval == '\\0')\n\t{\n\t\tif (source == PGC_S_DEFAULT)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * LC_MESSAGES category does not exist everywhere, but accept it anyway\n\t *\n\t * On Windows, we can't even check the value, so accept blindly\n\t */\n#if defined(LC_MESSAGES) && !defined(WIN32)\n\treturn check_locale(LC_MESSAGES, *newval, NULL);\n#else\n\treturn true;\n#endif\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\ncheck_locale_messages(char **newval, void **extra, GucSource source)\n{\n\tif (**newval == '\\0')\n\t{\n\t\tif (source == PGC_S_DEFAULT)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * LC_MESSAGES category does not exist everywhere, but accept it anyway\n\t *\n\t * On Windows, we can't even check the value, so accept blindly\n\t */\n#if defined(LC_MESSAGES) && !defined(WIN32)\n\treturn check_locale(LC_MESSAGES, *newval, NULL);\n#else\n\treturn true;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\ncheck_locale_time(char **newval, void **extra, GucSource source)\n{\n\treturn check_locale(LC_TIME, *newval, NULL);\n}"
  },
  {
    "function_name": "assign_locale_numeric",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "325-329",
    "snippet": "void\nassign_locale_numeric(const char *newval, void *extra)\n{\n\tCurrentLocaleConvValid = false;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool CurrentLocaleConvValid = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic bool CurrentLocaleConvValid = false;\n\nvoid\nassign_locale_numeric(const char *newval, void *extra)\n{\n\tCurrentLocaleConvValid = false;\n}"
  },
  {
    "function_name": "check_locale_numeric",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "319-323",
    "snippet": "bool\ncheck_locale_numeric(char **newval, void **extra, GucSource source)\n{\n\treturn check_locale(LC_NUMERIC, *newval, NULL);\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_locale",
          "args": [
            "LC_NUMERIC",
            "*newval",
            "NULL"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "check_locale_messages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "353-374",
          "snippet": "bool\ncheck_locale_messages(char **newval, void **extra, GucSource source)\n{\n\tif (**newval == '\\0')\n\t{\n\t\tif (source == PGC_S_DEFAULT)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * LC_MESSAGES category does not exist everywhere, but accept it anyway\n\t *\n\t * On Windows, we can't even check the value, so accept blindly\n\t */\n#if defined(LC_MESSAGES) && !defined(WIN32)\n\treturn check_locale(LC_MESSAGES, *newval, NULL);\n#else\n\treturn true;\n#endif\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\ncheck_locale_messages(char **newval, void **extra, GucSource source)\n{\n\tif (**newval == '\\0')\n\t{\n\t\tif (source == PGC_S_DEFAULT)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * LC_MESSAGES category does not exist everywhere, but accept it anyway\n\t *\n\t * On Windows, we can't even check the value, so accept blindly\n\t */\n#if defined(LC_MESSAGES) && !defined(WIN32)\n\treturn check_locale(LC_MESSAGES, *newval, NULL);\n#else\n\treturn true;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\ncheck_locale_numeric(char **newval, void **extra, GucSource source)\n{\n\treturn check_locale(LC_NUMERIC, *newval, NULL);\n}"
  },
  {
    "function_name": "assign_locale_monetary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "313-317",
    "snippet": "void\nassign_locale_monetary(const char *newval, void *extra)\n{\n\tCurrentLocaleConvValid = false;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool CurrentLocaleConvValid = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic bool CurrentLocaleConvValid = false;\n\nvoid\nassign_locale_monetary(const char *newval, void *extra)\n{\n\tCurrentLocaleConvValid = false;\n}"
  },
  {
    "function_name": "check_locale_monetary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "307-311",
    "snippet": "bool\ncheck_locale_monetary(char **newval, void **extra, GucSource source)\n{\n\treturn check_locale(LC_MONETARY, *newval, NULL);\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_locale",
          "args": [
            "LC_MONETARY",
            "*newval",
            "NULL"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "check_locale_messages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "353-374",
          "snippet": "bool\ncheck_locale_messages(char **newval, void **extra, GucSource source)\n{\n\tif (**newval == '\\0')\n\t{\n\t\tif (source == PGC_S_DEFAULT)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * LC_MESSAGES category does not exist everywhere, but accept it anyway\n\t *\n\t * On Windows, we can't even check the value, so accept blindly\n\t */\n#if defined(LC_MESSAGES) && !defined(WIN32)\n\treturn check_locale(LC_MESSAGES, *newval, NULL);\n#else\n\treturn true;\n#endif\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\ncheck_locale_messages(char **newval, void **extra, GucSource source)\n{\n\tif (**newval == '\\0')\n\t{\n\t\tif (source == PGC_S_DEFAULT)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * LC_MESSAGES category does not exist everywhere, but accept it anyway\n\t *\n\t * On Windows, we can't even check the value, so accept blindly\n\t */\n#if defined(LC_MESSAGES) && !defined(WIN32)\n\treturn check_locale(LC_MESSAGES, *newval, NULL);\n#else\n\treturn true;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\ncheck_locale_monetary(char **newval, void **extra, GucSource source)\n{\n\treturn check_locale(LC_MONETARY, *newval, NULL);\n}"
  },
  {
    "function_name": "check_locale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "264-293",
    "snippet": "bool\ncheck_locale(int category, const char *locale, char **canonname)\n{\n\tchar\t   *save;\n\tchar\t   *res;\n\n\tif (canonname)\n\t\t*canonname = NULL;\t\t/* in case of failure */\n\n\tsave = setlocale(category, NULL);\n\tif (!save)\n\t\treturn false;\t\t\t/* won't happen, we hope */\n\n\t/* save may be pointing at a modifiable scratch variable, see above. */\n\tsave = pstrdup(save);\n\n\t/* set the locale with setlocale, to see if it accepts it. */\n\tres = setlocale(category, locale);\n\n\t/* save canonical name if requested. */\n\tif (res && canonname)\n\t\t*canonname = pstrdup(res);\n\n\t/* restore old value. */\n\tif (!setlocale(category, save))\n\t\telog(WARNING, \"failed to restore old locale \\\"%s\\\"\", save);\n\tpfree(save);\n\n\treturn (res != NULL);\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "save"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"failed to restore old locale \\\"%s\\\"\"",
            "save"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setlocale",
          "args": [
            "category",
            "save"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "pg_perm_setlocale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "151-251",
          "snippet": "char *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)"
          ],
          "globals_used": [
            "static char lc_collate_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_ctype_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_monetary_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_numeric_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_time_envbuf[LC_ENV_BUFSIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\n#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)\n\nstatic char lc_collate_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_ctype_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_monetary_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_numeric_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_time_envbuf[LC_ENV_BUFSIZE];\n\nchar *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "res"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\ncheck_locale(int category, const char *locale, char **canonname)\n{\n\tchar\t   *save;\n\tchar\t   *res;\n\n\tif (canonname)\n\t\t*canonname = NULL;\t\t/* in case of failure */\n\n\tsave = setlocale(category, NULL);\n\tif (!save)\n\t\treturn false;\t\t\t/* won't happen, we hope */\n\n\t/* save may be pointing at a modifiable scratch variable, see above. */\n\tsave = pstrdup(save);\n\n\t/* set the locale with setlocale, to see if it accepts it. */\n\tres = setlocale(category, locale);\n\n\t/* save canonical name if requested. */\n\tif (res && canonname)\n\t\t*canonname = pstrdup(res);\n\n\t/* restore old value. */\n\tif (!setlocale(category, save))\n\t\telog(WARNING, \"failed to restore old locale \\\"%s\\\"\", save);\n\tpfree(save);\n\n\treturn (res != NULL);\n}"
  },
  {
    "function_name": "pg_perm_setlocale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
    "lines": "151-251",
    "snippet": "char *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}",
    "includes": [
      "#include <shlwapi.h>",
      "#include <unicode/ucnv.h>",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_control.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)"
    ],
    "globals_used": [
      "static char lc_collate_envbuf[LC_ENV_BUFSIZE];",
      "static char lc_ctype_envbuf[LC_ENV_BUFSIZE];",
      "static char lc_monetary_envbuf[LC_ENV_BUFSIZE];",
      "static char lc_numeric_envbuf[LC_ENV_BUFSIZE];",
      "static char lc_time_envbuf[LC_ENV_BUFSIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "putenv",
          "args": [
            "envbuf"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "envbuf",
            "LC_ENV_BUFSIZE - 1",
            "\"%s=%s\"",
            "envvar",
            "result"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"unrecognized LC category: %d\"",
            "category"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsoLocaleName",
          "args": [
            "locale"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "IsoLocaleName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "969-1035",
          "snippet": "static char *\nIsoLocaleName(const char *winlocname)\n{\n#if (_MSC_VER >= 1400)\t\t\t/* VC8.0 or later */\n\tstatic char iso_lc_messages[32];\n\t_locale_t\tloct = NULL;\n\n\tif (pg_strcasecmp(\"c\", winlocname) == 0 ||\n\t\tpg_strcasecmp(\"posix\", winlocname) == 0)\n\t{\n\t\tstrcpy(iso_lc_messages, \"C\");\n\t\treturn iso_lc_messages;\n\t}\n\n\tloct = _create_locale(LC_CTYPE, winlocname);\n\tif (loct != NULL)\n\t{\n#if (_MSC_VER >= 1700)\t\t\t/* Visual Studio 2012 or later */\n\t\tsize_t\t\trc;\n\t\tchar\t   *hyphen;\n\n\t\t/* Locale names use only ASCII, any conversion locale suffices. */\n\t\trc = wchar2char(iso_lc_messages, loct->locinfo->locale_name[LC_CTYPE],\n\t\t\t\t\t\tsizeof(iso_lc_messages), NULL);\n\t\t_free_locale(loct);\n\t\tif (rc == -1 || rc == sizeof(iso_lc_messages))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Since the message catalogs sit on a case-insensitive filesystem, we\n\t\t * need not standardize letter case here.  So long as we do not ship\n\t\t * message catalogs for which it would matter, we also need not\n\t\t * translate the script/variant portion, e.g. uz-Cyrl-UZ to\n\t\t * uz_UZ@cyrillic.  Simply replace the hyphen with an underscore.\n\t\t *\n\t\t * Note that the locale name can be less-specific than the value we\n\t\t * would derive under earlier Visual Studio releases.  For example,\n\t\t * French_France.1252 yields just \"fr\".  This does not affect any of\n\t\t * the country-specific message catalogs available as of this writing\n\t\t * (pt_BR, zh_CN, zh_TW).\n\t\t */\n\t\thyphen = strchr(iso_lc_messages, '-');\n\t\tif (hyphen)\n\t\t\t*hyphen = '_';\n#else\n\t\tchar\t\tisolang[32],\n\t\t\t\t\tisocrty[32];\n\t\tLCID\t\tlcid;\n\n\t\tlcid = loct->locinfo->lc_handle[LC_CTYPE];\n\t\tif (lcid == 0)\n\t\t\tlcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);\n\t\t_free_locale(loct);\n\n\t\tif (!GetLocaleInfoA(lcid, LOCALE_SISO639LANGNAME, isolang, sizeof(isolang)))\n\t\t\treturn NULL;\n\t\tif (!GetLocaleInfoA(lcid, LOCALE_SISO3166CTRYNAME, isocrty, sizeof(isocrty)))\n\t\t\treturn NULL;\n\t\tsnprintf(iso_lc_messages, sizeof(iso_lc_messages) - 1, \"%s_%s\", isolang, isocrty);\n#endif\n\t\treturn iso_lc_messages;\n\t}\n\treturn NULL;\n#else\n\treturn NULL;\t\t\t\t/* Not supported on this version of msvc/mingw */\n#endif\t\t\t\t\t\t\t/* _MSC_VER >= 1400 */\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nstatic char *\nIsoLocaleName(const char *winlocname)\n{\n#if (_MSC_VER >= 1400)\t\t\t/* VC8.0 or later */\n\tstatic char iso_lc_messages[32];\n\t_locale_t\tloct = NULL;\n\n\tif (pg_strcasecmp(\"c\", winlocname) == 0 ||\n\t\tpg_strcasecmp(\"posix\", winlocname) == 0)\n\t{\n\t\tstrcpy(iso_lc_messages, \"C\");\n\t\treturn iso_lc_messages;\n\t}\n\n\tloct = _create_locale(LC_CTYPE, winlocname);\n\tif (loct != NULL)\n\t{\n#if (_MSC_VER >= 1700)\t\t\t/* Visual Studio 2012 or later */\n\t\tsize_t\t\trc;\n\t\tchar\t   *hyphen;\n\n\t\t/* Locale names use only ASCII, any conversion locale suffices. */\n\t\trc = wchar2char(iso_lc_messages, loct->locinfo->locale_name[LC_CTYPE],\n\t\t\t\t\t\tsizeof(iso_lc_messages), NULL);\n\t\t_free_locale(loct);\n\t\tif (rc == -1 || rc == sizeof(iso_lc_messages))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Since the message catalogs sit on a case-insensitive filesystem, we\n\t\t * need not standardize letter case here.  So long as we do not ship\n\t\t * message catalogs for which it would matter, we also need not\n\t\t * translate the script/variant portion, e.g. uz-Cyrl-UZ to\n\t\t * uz_UZ@cyrillic.  Simply replace the hyphen with an underscore.\n\t\t *\n\t\t * Note that the locale name can be less-specific than the value we\n\t\t * would derive under earlier Visual Studio releases.  For example,\n\t\t * French_France.1252 yields just \"fr\".  This does not affect any of\n\t\t * the country-specific message catalogs available as of this writing\n\t\t * (pt_BR, zh_CN, zh_TW).\n\t\t */\n\t\thyphen = strchr(iso_lc_messages, '-');\n\t\tif (hyphen)\n\t\t\t*hyphen = '_';\n#else\n\t\tchar\t\tisolang[32],\n\t\t\t\t\tisocrty[32];\n\t\tLCID\t\tlcid;\n\n\t\tlcid = loct->locinfo->lc_handle[LC_CTYPE];\n\t\tif (lcid == 0)\n\t\t\tlcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);\n\t\t_free_locale(loct);\n\n\t\tif (!GetLocaleInfoA(lcid, LOCALE_SISO639LANGNAME, isolang, sizeof(isolang)))\n\t\t\treturn NULL;\n\t\tif (!GetLocaleInfoA(lcid, LOCALE_SISO3166CTRYNAME, isocrty, sizeof(isocrty)))\n\t\t\treturn NULL;\n\t\tsnprintf(iso_lc_messages, sizeof(iso_lc_messages) - 1, \"%s_%s\", isolang, isocrty);\n#endif\n\t\treturn iso_lc_messages;\n\t}\n\treturn NULL;\n#else\n\treturn NULL;\t\t\t\t/* Not supported on this version of msvc/mingw */\n#endif\t\t\t\t\t\t\t/* _MSC_VER >= 1400 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetMessageEncoding",
          "args": [
            "GetDatabaseEncoding()"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "SetMessageEncoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "907-915",
          "snippet": "void\nSetMessageEncoding(int encoding)\n{\n\t/* Some calls happen before we can elog()! */\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\tMessageEncoding = &pg_enc2name_tbl[encoding];\n\tAssert(MessageEncoding->encoding == encoding);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *MessageEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *MessageEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nvoid\nSetMessageEncoding(int encoding)\n{\n\t/* Some calls happen before we can elog()! */\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\tMessageEncoding = &pg_enc2name_tbl[encoding];\n\tAssert(MessageEncoding->encoding == encoding);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_bind_textdomain_codeset",
          "args": [
            "textdomain(NULL)"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "pg_bind_textdomain_codeset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "968-995",
          "snippet": "int\npg_bind_textdomain_codeset(const char *domainname)\n{\n\tbool\t\telog_ok = (CurrentMemoryContext != NULL);\n\tint\t\t\tencoding = GetDatabaseEncoding();\n\tint\t\t\tnew_msgenc;\n\n#ifndef WIN32\n\tconst char *ctype = setlocale(LC_CTYPE, NULL);\n\n\tif (pg_strcasecmp(ctype, \"C\") == 0 || pg_strcasecmp(ctype, \"POSIX\") == 0)\n#endif\n\t\tif (encoding != PG_SQL_ASCII &&\n\t\t\traw_pg_bind_textdomain_codeset(domainname, encoding))\n\t\t\treturn encoding;\n\n\tnew_msgenc = pg_get_encoding_from_locale(NULL, elog_ok);\n\tif (new_msgenc < 0)\n\t\tnew_msgenc = PG_SQL_ASCII;\n\n#ifdef WIN32\n\tif (!raw_pg_bind_textdomain_codeset(domainname, new_msgenc))\n\t\t/* On failure, the old message encoding remains valid. */\n\t\treturn GetMessageEncoding();\n#endif\n\n\treturn new_msgenc;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nint\npg_bind_textdomain_codeset(const char *domainname)\n{\n\tbool\t\telog_ok = (CurrentMemoryContext != NULL);\n\tint\t\t\tencoding = GetDatabaseEncoding();\n\tint\t\t\tnew_msgenc;\n\n#ifndef WIN32\n\tconst char *ctype = setlocale(LC_CTYPE, NULL);\n\n\tif (pg_strcasecmp(ctype, \"C\") == 0 || pg_strcasecmp(ctype, \"POSIX\") == 0)\n#endif\n\t\tif (encoding != PG_SQL_ASCII &&\n\t\t\traw_pg_bind_textdomain_codeset(domainname, encoding))\n\t\t\treturn encoding;\n\n\tnew_msgenc = pg_get_encoding_from_locale(NULL, elog_ok);\n\tif (new_msgenc < 0)\n\t\tnew_msgenc = PG_SQL_ASCII;\n\n#ifdef WIN32\n\tif (!raw_pg_bind_textdomain_codeset(domainname, new_msgenc))\n\t\t/* On failure, the old message encoding remains valid. */\n\t\treturn GetMessageEncoding();\n#endif\n\n\treturn new_msgenc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "textdomain",
          "args": [
            "NULL"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "pg_bindtextdomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "1606-1619",
          "snippet": "void\npg_bindtextdomain(const char *domain)\n{\n#ifdef ENABLE_NLS\n\tif (my_exec_path[0] != '\\0')\n\t{\n\t\tchar\t\tlocale_path[MAXPGPATH];\n\n\t\tget_locale_path(my_exec_path, locale_path);\n\t\tbindtextdomain(domain, locale_path);\n\t\tpg_bind_textdomain_codeset(domain);\n\t}\n#endif\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nvoid\npg_bindtextdomain(const char *domain)\n{\n#ifdef ENABLE_NLS\n\tif (my_exec_path[0] != '\\0')\n\t{\n\t\tchar\t\tlocale_path[MAXPGPATH];\n\n\t\tget_locale_path(my_exec_path, locale_path);\n\t\tbindtextdomain(domain, locale_path);\n\t\tpg_bind_textdomain_codeset(domain);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "save_lc_ctype",
            "result",
            "sizeof(save_lc_ctype)"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_safe_strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ascii.c",
          "lines": "172-198",
          "snippet": "void\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/ascii.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/ascii.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "setlocale",
          "args": [
            "category",
            "locale"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "pg_perm_setlocale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "151-251",
          "snippet": "char *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\n#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)\n\nstatic char lc_collate_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_ctype_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_monetary_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_numeric_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_time_envbuf[LC_ENV_BUFSIZE];\n\nchar *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}"
  }
]